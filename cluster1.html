<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA // VOID CHROME // CLUSTER NETWORK MAKER (BRUTAL CHIC)</title>
<style>
:root{
  --bg:#000;
  --fg:rgba(255,255,255,.86);
  --muted:rgba(255,255,255,.54);
  --hair:rgba(255,255,255,.14);
  --hair2:rgba(255,255,255,.22);
  --panel:rgba(0,0,0,.82);

  --font: Arial, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;

  --fs:12px;      /* uniform text size */
  --lh:1.25;
  --r:0px;

  --nodeW:260px;

  --edge:rgba(255,255,255,.62);
  --edgeHot:rgba(255,255,255,.92);
  --edgeMute:rgba(255,255,255,.18);
}
*{box-sizing:border-box}
html,body{height:100%; margin:0}
body{
  background:var(--bg);
  color:var(--fg);
  font-family:var(--font);
  font-size:var(--fs);
  line-height:var(--lh);
  overflow:hidden;
  user-select:none;
}
#root{position:fixed; inset:0; overflow:hidden}

/* brutal chic void = pure black. no grid, no gradients, no garnish. */
#edges{position:absolute; inset:0; width:100%; height:100%; pointer-events:none}
.edgeLine{stroke:var(--edge); stroke-width:1.2; fill:none}
.edgeLine.hot{stroke:var(--edgeHot)}
.edgeLine.muted{stroke:var(--edgeMute)}
.edgeArrow{fill:var(--edge)}
.edgeArrow.hot{fill:var(--edgeHot)}
.edgeLabel{
  font-family:var(--font);
  font-size:var(--fs);
  fill:var(--fg);
  opacity:.78;
}
.edgeLabel.hot{opacity:.96}
.edgeLabelBox{
  fill:rgba(0,0,0,.92);
  stroke:var(--hair);
  stroke-width:1;
}

#stage{position:absolute; inset:0; overflow:hidden}

/* nodes */
.node{
  position:absolute;
  width:var(--nodeW);
  background:var(--panel);
  border:1px solid var(--hair);
  border-radius:var(--r);
}
.node.hot{border-color:var(--hair2)}
.nodeHeader{
  display:flex; align-items:center; gap:6px;
  padding:6px;
  border-bottom:1px solid var(--hair);
  background:transparent;
  cursor:grab;
}
.nodeHeader:active{cursor:grabbing}
.nodeTitle{
  flex:1;
  font-weight:700;
  color:var(--fg);
  outline:none;
  min-width:0;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.nodeMeta{
  display:flex; align-items:center; gap:6px;
  color:var(--muted);
  font-family:var(--mono);
  font-size:var(--fs);
}
.pill{
  padding:2px 6px;
  border:1px solid var(--hair);
  background:transparent;
  border-radius:var(--r);
}
.nodeBody{padding:6px; display:block}
.nodeBody.collapsed{display:none}
.nodeText{
  width:100%;
  min-height:92px;
  resize:vertical;
  border:1px solid var(--hair);
  background:#000;
  color:var(--fg);
  font-family:var(--font);
  font-size:var(--fs);
  line-height:var(--lh);
  outline:none;
  padding:6px;
  border-radius:var(--r);
}
.row{display:flex; gap:6px; align-items:center; margin-top:6px}
.btn,.btnSq,.input,.select{
  border:1px solid var(--hair);
  background:#000;
  color:var(--fg);
  font-family:var(--font);
  font-size:var(--fs);
  line-height:var(--lh);
  padding:4px 6px;
  border-radius:var(--r);
  outline:none;
}
.btn:hover,.btnSq:hover{border-color:var(--hair2)}
.btn:active,.btnSq:active{transform:translateY(1px)}
.btnSq{
  width:26px; height:26px;
  padding:0;
  display:inline-flex; align-items:center; justify-content:center;
  font-family:var(--mono);
}
.btnWide{padding:4px 10px}
.input{flex:1; min-width:0}
.select{padding:4px 6px}
.small{color:var(--muted); font-family:var(--mono); font-size:var(--fs)}
.kbd{font-family:var(--mono); padding:1px 4px; border:1px solid var(--hair); background:transparent}

/* void chrome panels */
.panel{
  position:absolute;
  min-width:260px;
  background:transparent;
  border:1px solid var(--hair);
  border-radius:var(--r);
}
.panelHeader{
  display:flex; align-items:center; gap:6px;
  padding:6px;
  border-bottom:1px solid var(--hair);
  background:transparent;
  cursor:grab;
}
.panelHeader:active{cursor:grabbing}
.panelTitle{flex:1; font-weight:700}
.panelBody{padding:6px; display:block}
.panelBody.collapsed{display:none}

.list{
  max-height:240px;
  overflow:auto;
  border:1px solid var(--hair);
  background:transparent;
}
.item{
  padding:6px;
  border-bottom:1px solid rgba(255,255,255,.08);
  display:flex;
  gap:6px;
  align-items:flex-start;
}
.item:last-child{border-bottom:none}
.item .name{flex:1; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap}
.item .meta{color:var(--muted); font-family:var(--mono)}
.item:hover{background:rgba(255,255,255,.03)}

/* invert */
.invert{filter:invert(1) hue-rotate(180deg)}

/* chrome off */
.chromeOff .panel{opacity:0; pointer-events:none}
.chromeOff #toast{opacity:0 !important}

/* link mode cursor */
.modeLink #stage{cursor:crosshair}

/* toast */
#toast{
  position:absolute; left:12px; bottom:12px;
  padding:6px 8px;
  border:1px solid var(--hair);
  background:transparent;
  color:var(--fg);
  font-family:var(--mono);
  font-size:var(--fs);
  pointer-events:none;
  opacity:0;
  transform:translateY(6px);
  transition:opacity .14s ease, transform .14s ease;
}
#toast.on{opacity:1; transform:translateY(0)}

#file{display:none}
</style>
</head>
<body>
<div id="root">
  <svg id="edges" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true">
    <defs>
      <marker id="arrow" markerWidth="8" markerHeight="8" refX="7" refY="4" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L8,4 L0,8 z" class="edgeArrow"></path>
      </marker>
      <marker id="arrowHot" markerWidth="8" markerHeight="8" refX="7" refY="4" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L8,4 L0,8 z" class="edgeArrow hot"></path>
      </marker>
    </defs>
  </svg>

  <div id="stage"></div>

  <!-- HUD -->
  <div class="panel" id="hud" style="left:12px; top:12px; width:320px;">
    <div class="panelHeader" data-drag="panel">
      <div class="panelTitle">VOID CHROME</div>
      <button class="btnSq" id="hudCollapse" title="collapse">–</button>
      <button class="btnSq" id="hudHideChrome" title="toggle chrome (CTRL+.)">C</button>
    </div>
    <div class="panelBody" id="hudBody">
      <div class="row">
        <button class="btn btnWide" id="addNode">ADD NODE</button>
        <button class="btn btnWide" id="addCluster">ADD CLUSTER</button>
      </div>
      <div class="row">
        <button class="btn btnWide" id="modeMove" title="move mode (M)">MOVE</button>
        <button class="btn btnWide" id="modeLink" title="link mode (L)">LINK</button>
        <button class="btn btnWide" id="modeSelect" title="select mode (S)">SELECT</button>
      </div>
      <div class="row">
        <button class="btn btnWide" id="invertBtn" title="invert (SHIFT+I)">INVERT</button>
        <button class="btn btnWide" id="labelsBtn" title="toggle labels">LABELS</button>
        <button class="btn btnWide" id="muteEdgesBtn" title="dim non-selected edges">MUTE</button>
      </div>
      <div class="row">
        <button class="btn btnWide" id="exportBtn" title="export JSON file">EXPORT</button>
        <button class="btn btnWide" id="importBtn" title="import JSON file">IMPORT</button>
        <button class="btn btnWide" id="resetBtn" title="new empty graph">NEW</button>
      </div>
      <div class="row">
        <input class="input" id="search" placeholder="find node by title/text"/>
        <button class="btnSq" id="searchGo" title="find">↵</button>
        <button class="btnSq" id="searchClr" title="clear">×</button>
      </div>
      <div class="small">
        LINK: click source then target (ESC cancels). DEL deletes selected.
        <span class="kbd">SHIFT+I</span> invert · <span class="kbd">CTRL+.</span> chrome
      </div>
    </div>
  </div>

  <!-- INSPECTOR -->
  <div class="panel" id="inspect" style="right:12px; top:12px; width:360px;">
    <div class="panelHeader" data-drag="panel">
      <div class="panelTitle">INSPECTOR</div>
      <button class="btnSq" id="inspectCollapse" title="collapse">–</button>
    </div>
    <div class="panelBody" id="inspectBody">
      <div class="row">
        <div class="pill small" id="statNodes">NODES: 0</div>
        <div class="pill small" id="statEdges">EDGES: 0</div>
        <div class="pill small" id="statComp">COMP: 0</div>
      </div>
      <div class="row">
        <select class="select" id="listMode">
          <option value="nodes">NODES</option>
          <option value="edges">EDGES</option>
          <option value="analysis">ANALYSIS</option>
        </select>
        <button class="btn btnWide" id="focusSel">FOCUS</button>
        <button class="btn btnWide" id="deleteSel">DELETE</button>
      </div>
      <div class="list" id="list"></div>
      <div class="small" id="selHint">selected: none</div>
    </div>
  </div>

  <div id="toast"></div>
  <input id="file" type="file" accept="application/json"/>
</div>

<script>
/* =========================
   KETADATA // VOID CHROME (BRUTAL CHIC BLACK VOID)
   cluster network maker / constellation mindmap
   single-file, local-only, import/export file I/O
========================= */

const FILE_ID="KETADATA_VOID_CHROME_CLUSTER_NETWORK_MAKER";
const ROOM_ID="void_chrome";
const VERSION="v1.0.1_brutal_void";
const LS_KEY="KETADATA_VOID_CHROME__STATE__v1";

const $=(id)=>document.getElementById(id);
const stage=$("stage"), svg=$("edges"), toast=$("toast");

let RAF=0;

const STATE={
  ui:{
    invert:false,
    chromeOff:false,
    labelsOn:true,
    muteNonSelected:false,
    hud:{x:12,y:12,w:320,collapsed:false},
    inspect:{x:null,y:null,w:360,collapsed:false},
    listMode:"nodes"
  },
  graph:{ nodes:{}, edges:{} },
  sel:{ nodeId:null, edgeId:null, linkFrom:null, mode:"move" },
  meta:{ updatedAt:null }
};

function uid(p="id"){ return p+"_"+Math.random().toString(16).slice(2)+"_"+Date.now().toString(16); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function save(){
  try{
    STATE.meta.updatedAt=new Date().toISOString();
    localStorage.setItem(LS_KEY, JSON.stringify(STATE));
  }catch(e){}
}
function load(){
  try{
    const raw=localStorage.getItem(LS_KEY);
    if(!raw) return false;
    const data=JSON.parse(raw);
    if(!data || !data.graph) return false;
    Object.assign(STATE.ui, data.ui||{});
    STATE.graph = data.graph || STATE.graph;
    STATE.sel = Object.assign(STATE.sel, data.sel||{});
    STATE.meta = Object.assign(STATE.meta, data.meta||{});
    return true;
  }catch(e){ return false; }
}
function schedule(){
  if(RAF) return;
  RAF=requestAnimationFrame(()=>{ RAF=0; render(); });
}
function setToast(msg,on=true){
  toast.textContent=msg||"";
  toast.classList.toggle("on", !!on);
}

/* ---------- panels ---------- */
function setPanelElPos(el,x,y,w){
  if(Number.isFinite(x)) el.style.left=x+"px";
  if(Number.isFinite(y)) el.style.top=y+"px";
  if(Number.isFinite(w)) el.style.width=w+"px";
}
function makePanelDraggable(panelEl,onMove){
  const header=panelEl.querySelector("[data-drag='panel']");
  let dragging=false, ox=0, oy=0;
  header.addEventListener("pointerdown",(ev)=>{
    if(ev.button!==0) return;
    if(ev.target && (ev.target.tagName==="BUTTON" || ev.target.closest("button"))) return;
    dragging=true;
    panelEl.setPointerCapture(ev.pointerId);
    const r=panelEl.getBoundingClientRect();
    ox=ev.clientX-r.left; oy=ev.clientY-r.top;
  });
  header.addEventListener("pointermove",(ev)=>{
    if(!dragging) return;
    const x=clamp(ev.clientX-ox, 6, window.innerWidth-60);
    const y=clamp(ev.clientY-oy, 6, window.innerHeight-40);
    panelEl.style.left=x+"px";
    panelEl.style.top=y+"px";
    panelEl.style.right="auto";
    onMove && onMove(x,y);
  });
  header.addEventListener("pointerup",()=>{ dragging=false; });
  header.addEventListener("pointercancel",()=>{ dragging=false; });
}
function initPanels(){
  const hud=$("hud"), inspect=$("inspect");

  setPanelElPos(hud, STATE.ui.hud.x, STATE.ui.hud.y, STATE.ui.hud.w);

  if(STATE.ui.inspect.x==null){
    const rect=inspect.getBoundingClientRect();
    STATE.ui.inspect.x = window.innerWidth - rect.width - 12;
    STATE.ui.inspect.y = 12;
  }
  setPanelElPos(inspect, STATE.ui.inspect.x, STATE.ui.inspect.y, STATE.ui.inspect.w);

  $("hudBody").classList.toggle("collapsed", !!STATE.ui.hud.collapsed);
  $("inspectBody").classList.toggle("collapsed", !!STATE.ui.inspect.collapsed);

  $("hudCollapse").onclick=()=>{
    STATE.ui.hud.collapsed=!STATE.ui.hud.collapsed;
    $("hudBody").classList.toggle("collapsed", !!STATE.ui.hud.collapsed);
    save();
  };
  $("inspectCollapse").onclick=()=>{
    STATE.ui.inspect.collapsed=!STATE.ui.inspect.collapsed;
    $("inspectBody").classList.toggle("collapsed", !!STATE.ui.inspect.collapsed);
    save();
  };
  $("hudHideChrome").onclick=toggleChrome;

  makePanelDraggable(hud,(x,y)=>{ STATE.ui.hud.x=x; STATE.ui.hud.y=y; save(); });
  makePanelDraggable(inspect,(x,y)=>{ STATE.ui.inspect.x=x; STATE.ui.inspect.y=y; save(); });
}

/* ---------- nodes ---------- */
function createNode({title="NODE",text="",x=120,y=120,w=null,collapsed=false,cluster=""}={}){
  const id=uid("n");
  STATE.graph.nodes[id]={
    id,title,text,
    x,y,
    w:w || 260,
    collapsed:!!collapsed,
    cluster:cluster||""
  };
  save(); schedule();
  return id;
}
function deleteNode(id){
  if(!STATE.graph.nodes[id]) return;
  for(const eid of Object.keys(STATE.graph.edges)){
    const e=STATE.graph.edges[eid];
    if(e.from===id || e.to===id) delete STATE.graph.edges[eid];
  }
  delete STATE.graph.nodes[id];
  if(STATE.sel.nodeId===id) STATE.sel.nodeId=null;
  if(STATE.sel.linkFrom===id) STATE.sel.linkFrom=null;
  save(); schedule();
}
function nodeCenter(id){
  const el=$("node_"+id);
  const n=STATE.graph.nodes[id];
  if(!n) return {x:0,y:0};
  if(!el) return {x:n.x+(n.w||260)/2, y:n.y+18};
  const r=el.getBoundingClientRect();
  return {x:r.left+r.width/2, y:r.top+18};
}
function focusNode(id){
  STATE.sel.nodeId=id; STATE.sel.edgeId=null;
  setToast("selected node: "+(STATE.graph.nodes[id]?.title||id), true);
  save(); schedule();
}

/* ---------- edges ---------- */
function createEdge(fromId,toId,label=""){
  if(!STATE.graph.nodes[fromId] || !STATE.graph.nodes[toId]) return null;
  const id=uid("e");
  STATE.graph.edges[id]={id,from:fromId,to:toId,label:(label||""),dir:true};
  save(); schedule();
  return id;
}
function deleteEdge(eid){
  if(!STATE.graph.edges[eid]) return;
  delete STATE.graph.edges[eid];
  if(STATE.sel.edgeId===eid) STATE.sel.edgeId=null;
  save(); schedule();
}
function focusEdge(eid){
  STATE.sel.edgeId=eid; STATE.sel.nodeId=null;
  setToast("selected edge: "+(STATE.graph.edges[eid]?.label||"(unlabeled)"), true);
  save(); schedule();
}

/* ---------- render ---------- */
function svgSize(){
  svg.setAttribute("viewBox", `0 0 ${window.innerWidth} ${window.innerHeight}`);
}
function clearSvg(){
  while(svg.childNodes.length>1) svg.removeChild(svg.lastChild);
}
function renderEdges(){
  svgSize(); clearSvg();

  const selectedNode=STATE.sel.nodeId;
  const selectedEdge=STATE.sel.edgeId;

  let incident=null;
  if(STATE.ui.muteNonSelected && (selectedNode || selectedEdge)){
    incident=new Set();
    if(selectedNode){
      for(const eid of Object.keys(STATE.graph.edges)){
        const e=STATE.graph.edges[eid];
        if(e.from===selectedNode || e.to===selectedNode) incident.add(eid);
      }
    }else{
      incident.add(selectedEdge);
    }
  }

  for(const eid of Object.keys(STATE.graph.edges)){
    const e=STATE.graph.edges[eid];
    const a=nodeCenter(e.from), b=nodeCenter(e.to);

    const isHot=(selectedEdge===eid) || (selectedNode && (e.from===selectedNode || e.to===selectedNode));
    const isMuted=(incident && !incident.has(eid));

    const dx=b.x-a.x, dy=b.y-a.y;
    const dist=Math.max(1, Math.hypot(dx,dy));
    const nx=-dy/dist, ny=dx/dist;
    const bend=clamp(dist*0.08, 10, 42);
    const cx=(a.x+b.x)/2 + nx*bend;
    const cy=(a.y+b.y)/2 + ny*bend;

    const line=document.createElementNS("http://www.w3.org/2000/svg","path");
    line.setAttribute("d", `M ${a.x} ${a.y} Q ${cx} ${cy} ${b.x} ${b.y}`);
    line.setAttribute("class", "edgeLine"+(isHot?" hot":"")+(isMuted?" muted":""));
    line.setAttribute("marker-end", isHot ? "url(#arrowHot)" : "url(#arrow)");
    svg.appendChild(line);

    if(STATE.ui.labelsOn){
      const t=(e.label||"").trim();
      if(t){
        const mx=cx, my=cy;
        const pad=4;
        const w=Math.min(260, Math.max(60, t.length*6.4 + pad*2));
        const h=18;

        const box=document.createElementNS("http://www.w3.org/2000/svg","rect");
        box.setAttribute("x", String(mx-w/2));
        box.setAttribute("y", String(my-h/2));
        box.setAttribute("width", String(w));
        box.setAttribute("height", String(h));
        box.setAttribute("rx","0");
        box.setAttribute("class","edgeLabelBox");
        svg.appendChild(box);

        const txt=document.createElementNS("http://www.w3.org/2000/svg","text");
        txt.setAttribute("x", String(mx));
        txt.setAttribute("y", String(my+4));
        txt.setAttribute("text-anchor","middle");
        txt.setAttribute("class","edgeLabel"+(isHot?" hot":""));
        txt.textContent=t;
        svg.appendChild(txt);
      }
    }
  }
}

function renderNode(n){
  const el=document.createElement("div");
  el.className="node"+(STATE.sel.nodeId===n.id?" hot":"");
  el.id="node_"+n.id;
  el.style.left=n.x+"px";
  el.style.top=n.y+"px";
  el.style.width=(n.w||260)+"px";

  const header=document.createElement("div");
  header.className="nodeHeader";
  header.dataset.drag="node";

  const title=document.createElement("div");
  title.className="nodeTitle";
  title.contentEditable="true";
  title.spellcheck=false;
  title.textContent=n.title||"NODE";
  title.addEventListener("input", ()=>{
    n.title = title.textContent.trim() || "NODE";
    save(); schedule();
  });
  title.addEventListener("pointerdown",(ev)=>ev.stopPropagation());

  const meta=document.createElement("div");
  meta.className="nodeMeta";

  const cluster=document.createElement("span");
  cluster.className="pill";
  cluster.textContent=(n.cluster && n.cluster.trim()) ? n.cluster.trim() : "—";
  cluster.title="cluster";
  cluster.addEventListener("click",(ev)=>{
    ev.stopPropagation();
    const v=prompt("cluster label", n.cluster||"");
    if(v==null) return;
    n.cluster=v.trim();
    save(); schedule();
  });

  const collapseBtn=document.createElement("button");
  collapseBtn.className="btnSq";
  collapseBtn.textContent=n.collapsed?"+":"–";
  collapseBtn.title="collapse";
  collapseBtn.addEventListener("click",(ev)=>{
    ev.stopPropagation();
    n.collapsed=!n.collapsed;
    save(); schedule();
  });

  meta.appendChild(cluster);
  meta.appendChild(collapseBtn);

  header.appendChild(title);
  header.appendChild(meta);

  const body=document.createElement("div");
  body.className="nodeBody"+(n.collapsed?" collapsed":"");

  const ta=document.createElement("textarea");
  ta.className="nodeText";
  ta.value=n.text||"";
  ta.spellcheck=false;
  ta.addEventListener("input", ()=>{ n.text=ta.value; save(); schedule(); });
  ta.addEventListener("pointerdown",(ev)=>ev.stopPropagation());

  const row=document.createElement("div");
  row.className="row";

  const btnLink=document.createElement("button");
  btnLink.className="btn";
  btnLink.textContent="LINK FROM";
  btnLink.onclick=(ev)=>{
    ev.stopPropagation();
    STATE.sel.mode="link";
    STATE.sel.linkFrom=n.id;
    STATE.sel.nodeId=n.id;
    STATE.sel.edgeId=null;
    setToast("LINK: choose target (source="+(n.title||n.id)+")", true);
    save(); schedule();
  };

  const btnClone=document.createElement("button");
  btnClone.className="btn";
  btnClone.textContent="CLONE";
  btnClone.onclick=(ev)=>{
    ev.stopPropagation();
    const id2=createNode({
      title:(n.title||"NODE")+" (copy)",
      text:n.text||"",
      x:n.x+24, y:n.y+24,
      w:n.w||260,
      collapsed:n.collapsed,
      cluster:n.cluster||""
    });
    focusNode(id2);
  };

  const btnDel=document.createElement("button");
  btnDel.className="btn";
  btnDel.textContent="DELETE";
  btnDel.onclick=(ev)=>{
    ev.stopPropagation();
    if(confirm("delete node + incident edges?")) deleteNode(n.id);
  };

  row.appendChild(btnLink);
  row.appendChild(btnClone);
  row.appendChild(btnDel);

  body.appendChild(ta);
  body.appendChild(row);

  el.appendChild(header);
  el.appendChild(body);

  el.addEventListener("pointerdown",(ev)=>{
    ev.stopPropagation();
    if(STATE.sel.mode==="link"){ linkClickNode(n.id); }
    else{ focusNode(n.id); }
  });

  makeNodeDraggable(el, header, n);
  return el;
}

function makeNodeDraggable(nodeEl, handleEl, n){
  let dragging=false, ox=0, oy=0;
  handleEl.addEventListener("pointerdown",(ev)=>{
    if(ev.button!==0) return;
    ev.stopPropagation();

    if(STATE.sel.mode==="link"){ linkClickNode(n.id); return; }
    // ignore drag if contenteditable active
    if(document.activeElement && document.activeElement.isContentEditable) return;

    dragging=true;
    nodeEl.setPointerCapture(ev.pointerId);
    const r=nodeEl.getBoundingClientRect();
    ox=ev.clientX-r.left; oy=ev.clientY-r.top;

    STATE.sel.nodeId=n.id; STATE.sel.edgeId=null;
    save(); schedule();
  });
  handleEl.addEventListener("pointermove",(ev)=>{
    if(!dragging) return;
    const x=clamp(ev.clientX-ox, 0, window.innerWidth-20);
    const y=clamp(ev.clientY-oy, 0, window.innerHeight-20);
    n.x=x; n.y=y;
    nodeEl.style.left=x+"px";
    nodeEl.style.top=y+"px";
    renderEdges();
  });
  handleEl.addEventListener("pointerup",()=>{
    if(dragging){
      dragging=false;
      save(); schedule();
    }
  });
  handleEl.addEventListener("pointercancel",()=>{ dragging=false; });
}

function render(){
  document.body.classList.toggle("invert", !!STATE.ui.invert);
  document.body.classList.toggle("chromeOff", !!STATE.ui.chromeOff);
  document.body.classList.toggle("modeLink", STATE.sel.mode==="link");

  $("listMode").value = STATE.ui.listMode || "nodes";

  stage.innerHTML="";
  for(const id of Object.keys(STATE.graph.nodes)){
    stage.appendChild(renderNode(STATE.graph.nodes[id]));
  }
  renderEdges();
  updateStats();
  renderInspectorList();

  $("modeMove").style.borderColor = (STATE.sel.mode==="move") ? "var(--hair2)" : "var(--hair)";
  $("modeLink").style.borderColor = (STATE.sel.mode==="link") ? "var(--hair2)" : "var(--hair)";
  $("modeSelect").style.borderColor = (STATE.sel.mode==="select") ? "var(--hair2)" : "var(--hair)";

  const sh=$("selHint");
  if(STATE.sel.nodeId) sh.textContent="selected: node | "+(STATE.graph.nodes[STATE.sel.nodeId]?.title||STATE.sel.nodeId);
  else if(STATE.sel.edgeId) sh.textContent="selected: edge | "+(STATE.graph.edges[STATE.sel.edgeId]?.label||"(unlabeled)");
  else sh.textContent="selected: none";
}

/* ---------- linking ---------- */
function linkClickNode(targetId){
  const src=STATE.sel.linkFrom;
  if(!src){
    STATE.sel.linkFrom=targetId;
    setToast("LINK: choose target", true);
    save(); schedule();
    return;
  }
  if(src===targetId){
    setToast("LINK: cancelled (same node)", true);
    STATE.sel.linkFrom=null;
    save(); schedule();
    return;
  }
  const label=prompt("edge label (optional)", "");
  if(label===null){
    setToast("LINK: cancelled", true);
    STATE.sel.linkFrom=null;
    save(); schedule();
    return;
  }
  const eid=createEdge(src, targetId, (label||"").trim());
  STATE.sel.edgeId=eid; STATE.sel.nodeId=null; STATE.sel.linkFrom=null;
  setToast("edge created", true);
  save(); schedule();
}

/* ---------- analysis + inspector ---------- */
function computeGraph(){
  const nodes=Object.keys(STATE.graph.nodes);
  const edges=Object.values(STATE.graph.edges);

  const adj=new Map();
  for(const id of nodes) adj.set(id, new Set());
  for(const e of edges){
    if(adj.has(e.from)) adj.get(e.from).add(e.to);
    if(adj.has(e.to)) adj.get(e.to).add(e.from);
  }
  const seen=new Set(), comps=[];
  for(const id of nodes){
    if(seen.has(id)) continue;
    const q=[id]; seen.add(id);
    const comp=[];
    while(q.length){
      const v=q.pop(); comp.push(v);
      for(const u of (adj.get(v)||[])){
        if(!seen.has(u)){ seen.add(u); q.push(u); }
      }
    }
    comps.push(comp);
  }
  const deg={};
  for(const id of nodes) deg[id]=(adj.get(id)||new Set()).size;
  return {nodes,edges,adj,comps,deg};
}
function updateStats(){
  const g=computeGraph();
  $("statNodes").textContent="NODES: "+g.nodes.length;
  $("statEdges").textContent="EDGES: "+g.edges.length;
  $("statComp").textContent="COMP: "+g.comps.length;
}
function emptyLine(text){
  const it=document.createElement("div");
  it.className="item";
  const t=document.createElement("div");
  t.className="name";
  t.style.color="var(--muted)";
  t.textContent=text;
  it.appendChild(t);
  return it;
}
function renderInspectorList(){
  const list=$("list"); list.innerHTML="";
  const mode=STATE.ui.listMode||"nodes";
  const g=computeGraph();

  if(mode==="nodes"){
    const ids=Object.keys(STATE.graph.nodes);
    ids.sort((a,b)=>{
      const A=STATE.graph.nodes[a], B=STATE.graph.nodes[b];
      const ca=(A.cluster||"").toLowerCase(), cb=(B.cluster||"").toLowerCase();
      if(ca<cb) return -1; if(ca>cb) return 1;
      const da=g.deg[a]||0, db=g.deg[b]||0;
      if(db!==da) return db-da;
      const ta=(A.title||"").toLowerCase(), tb=(B.title||"").toLowerCase();
      return ta<tb?-1:ta>tb?1:0;
    });
    for(const id of ids){
      const n=STATE.graph.nodes[id];
      const it=document.createElement("div");
      it.className="item";
      it.style.cursor="pointer";
      it.onclick=()=>focusNode(id);

      const name=document.createElement("div");
      name.className="name";
      name.textContent=n.title||"NODE";
      name.title=(n.text||"").slice(0,220);

      const meta=document.createElement("div");
      meta.className="meta";
      meta.textContent=(n.cluster?n.cluster:"—")+" | d="+(g.deg[id]||0);

      it.appendChild(name);
      it.appendChild(meta);
      list.appendChild(it);
    }
    if(!ids.length) list.appendChild(emptyLine("no nodes"));
  }

  if(mode==="edges"){
    const eids=Object.keys(STATE.graph.edges);
    eids.sort((a,b)=>{
      const A=STATE.graph.edges[a], B=STATE.graph.edges[b];
      const la=(A.label||"").toLowerCase(), lb=(B.label||"").toLowerCase();
      return la<lb?-1:la>lb?1:0;
    });
    for(const eid of eids){
      const e=STATE.graph.edges[eid];
      const it=document.createElement("div");
      it.className="item";
      it.style.cursor="pointer";
      it.onclick=()=>focusEdge(eid);

      const name=document.createElement("div");
      name.className="name";
      const a=STATE.graph.nodes[e.from]?.title||e.from;
      const b=STATE.graph.nodes[e.to]?.title||e.to;
      name.textContent=(e.label&&e.label.trim())?e.label.trim():"(unlabeled)";
      name.title=a+" → "+b;

      const meta=document.createElement("div");
      meta.className="meta";
      meta.textContent=(STATE.graph.nodes[e.from]?.title||e.from)+"→"+(STATE.graph.nodes[e.to]?.title||e.to);

      const edit=document.createElement("button");
      edit.className="btnSq";
      edit.textContent="E";
      edit.title="edit label";
      edit.onclick=(ev)=>{
        ev.stopPropagation();
        const v=prompt("edge label", e.label||"");
        if(v==null) return;
        e.label=v.trim();
        save(); schedule();
      };

      it.appendChild(name);
      it.appendChild(meta);
      it.appendChild(edit);
      list.appendChild(it);
    }
    if(!eids.length) list.appendChild(emptyLine("no edges"));
  }

  if(mode==="analysis"){
    const comps=g.comps.slice().sort((a,b)=>b.length-a.length);
    list.appendChild(emptyLine("components: "+comps.length));
    for(const comp of comps){
      const top=comp.slice().sort((a,b)=>(g.deg[b]||0)-(g.deg[a]||0)).slice(0,3)
        .map(id=>(STATE.graph.nodes[id]?.title||id)+"("+(g.deg[id]||0)+")")
        .join(", ");
      const it=document.createElement("div");
      it.className="item";
      const name=document.createElement("div");
      name.className="name";
      name.textContent="size "+comp.length;
      const meta=document.createElement("div");
      meta.className="meta";
      meta.textContent=top||"—";
      it.appendChild(name);
      it.appendChild(meta);
      list.appendChild(it);
    }
    if(!Object.keys(STATE.graph.nodes).length) list.appendChild(emptyLine("no data"));
  }
}

/* ---------- controls ---------- */
$("addNode").onclick=()=>{
  const id=createNode({title:"NODE",text:"",x:140+Math.random()*260,y:120+Math.random()*200});
  focusNode(id);
};
$("addCluster").onclick=()=>{
  const name=prompt("cluster label", "CLUSTER");
  if(name==null) return;
  const id=createNode({title:(name.trim()||"CLUSTER"),text:"",x:140+Math.random()*260,y:120+Math.random()*200,cluster:(name.trim()||"CLUSTER")});
  focusNode(id);
};

$("modeMove").onclick=()=>{ STATE.sel.mode="move"; STATE.sel.linkFrom=null; setToast("mode: MOVE", true); save(); schedule(); };
$("modeLink").onclick=()=>{ STATE.sel.mode="link"; STATE.sel.linkFrom=null; setToast("mode: LINK (click source then target)", true); save(); schedule(); };
$("modeSelect").onclick=()=>{ STATE.sel.mode="select"; STATE.sel.linkFrom=null; setToast("mode: SELECT", true); save(); schedule(); };

$("invertBtn").onclick=toggleInvert;
$("labelsBtn").onclick=toggleLabels;
$("muteEdgesBtn").onclick=toggleMute;
$("resetBtn").onclick=newGraph;

$("exportBtn").onclick=exportFile;
$("importBtn").onclick=()=>$("file").click();
$("file").addEventListener("change", importFile);

$("listMode").addEventListener("change", ()=>{
  STATE.ui.listMode=$("listMode").value;
  save(); schedule();
});
$("focusSel").onclick=()=>{
  if(STATE.sel.nodeId) nudgeIntoView(STATE.sel.nodeId);
  if(STATE.sel.edgeId){
    const e=STATE.graph.edges[STATE.sel.edgeId];
    if(e){ nudgeIntoView(e.from); nudgeIntoView(e.to); }
  }
};
$("deleteSel").onclick=()=>{
  if(STATE.sel.nodeId){
    if(confirm("delete selected node + incident edges?")) deleteNode(STATE.sel.nodeId);
  }else if(STATE.sel.edgeId){
    if(confirm("delete selected edge?")) deleteEdge(STATE.sel.edgeId);
  }
};

$("searchGo").onclick=searchNext;
$("searchClr").onclick=()=>{ $("search").value=""; setToast("search cleared", true); };
$("search").addEventListener("keydown",(ev)=>{
  if(ev.key==="Enter"){ ev.preventDefault(); searchNext(); }
});

function toggleInvert(){
  STATE.ui.invert=!STATE.ui.invert;
  setToast("invert: "+(STATE.ui.invert?"ON":"OFF"), true);
  save(); schedule();
}
function toggleChrome(){
  STATE.ui.chromeOff=!STATE.ui.chromeOff;
  setToast("chrome: "+(STATE.ui.chromeOff?"OFF":"ON"), true);
  save(); schedule();
}
function toggleLabels(){
  STATE.ui.labelsOn=!STATE.ui.labelsOn;
  setToast("labels: "+(STATE.ui.labelsOn?"ON":"OFF"), true);
  save(); schedule();
}
function toggleMute(){
  STATE.ui.muteNonSelected=!STATE.ui.muteNonSelected;
  setToast("mute: "+(STATE.ui.muteNonSelected?"ON":"OFF"), true);
  save(); schedule();
}
function newGraph(){
  if(!confirm("new empty graph?")) return;
  const keep={...STATE.ui};
  STATE.graph={nodes:{},edges:{}};
  STATE.sel={nodeId:null,edgeId:null,linkFrom:null,mode:"move"};
  // keep ui (including invert/chrome)
  STATE.ui=keep;
  save(); schedule();
}

/* ---------- stage interaction ---------- */
stage.addEventListener("pointerdown",(ev)=>{
  if(STATE.sel.mode==="link") return; // linking requires node clicks
  STATE.sel.nodeId=null; STATE.sel.edgeId=null;
  save(); schedule();
});

window.addEventListener("resize", ()=>{
  svgSize();
  STATE.ui.hud.x=clamp(STATE.ui.hud.x, 6, window.innerWidth-60);
  STATE.ui.hud.y=clamp(STATE.ui.hud.y, 6, window.innerHeight-40);
  STATE.ui.inspect.x=clamp(STATE.ui.inspect.x, 6, window.innerWidth-60);
  STATE.ui.inspect.y=clamp(STATE.ui.inspect.y, 6, window.innerHeight-40);
  setPanelElPos($("hud"), STATE.ui.hud.x, STATE.ui.hud.y, STATE.ui.hud.w);
  setPanelElPos($("inspect"), STATE.ui.inspect.x, STATE.ui.inspect.y, STATE.ui.inspect.w);
  save(); schedule();
});

/* ---------- search ---------- */
let searchHits=[], searchIdx=0;
function searchNext(){
  const q=($("search").value||"").trim().toLowerCase();
  if(!q){ setToast("search empty", true); return; }
  const ids=Object.keys(STATE.graph.nodes);
  searchHits=ids.filter(id=>{
    const n=STATE.graph.nodes[id];
    return (n.title||"").toLowerCase().includes(q) || (n.text||"").toLowerCase().includes(q);
  });
  if(!searchHits.length){ setToast("no matches", true); return; }
  const id=searchHits[searchIdx % searchHits.length];
  searchIdx++;
  focusNode(id);
  nudgeIntoView(id);
}
function nudgeIntoView(nodeId){
  const el=$("node_"+nodeId);
  const n=STATE.graph.nodes[nodeId];
  if(!el || !n) return;
  const r=el.getBoundingClientRect();
  const pad=24;
  let dx=0, dy=0;
  if(r.left < pad) dx = pad - r.left;
  if(r.top < pad) dy = pad - r.top;
  if(r.right > window.innerWidth - pad) dx = (window.innerWidth - pad) - r.right;
  if(r.bottom > window.innerHeight - pad) dy = (window.innerHeight - pad) - r.bottom;
  if(dx||dy){
    n.x=clamp(n.x+dx, 0, window.innerWidth-40);
    n.y=clamp(n.y+dy, 0, window.innerHeight-40);
    save(); schedule();
  }
}

/* ---------- import/export (real file I/O) ---------- */
function exportFile(){
  const data=JSON.stringify(STATE, null, 2);
  const blob=new Blob([data], {type:"application/json"});
  const a=document.createElement("a");
  const ts=new Date().toISOString().replaceAll(":","-");
  a.download=`KETADATA_VOID_CHROME_GRAPH__${ts}.json`;
  a.href=URL.createObjectURL(blob);
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 200);
  setToast("exported JSON file", true);
}
function importFile(ev){
  const f=ev.target.files && ev.target.files[0];
  if(!f) return;
  const reader=new FileReader();
  reader.onload=()=>{
    try{
      const data=JSON.parse(String(reader.result||""));
      if(!data || !data.graph || !data.graph.nodes || !data.graph.edges) throw new Error("bad format");
      Object.assign(STATE.ui, data.ui||{});
      STATE.graph=data.graph;
      STATE.sel=Object.assign(STATE.sel, data.sel||{});
      STATE.meta=Object.assign(STATE.meta, data.meta||{});

      for(const id of Object.keys(STATE.graph.nodes)){
        const n=STATE.graph.nodes[id];
        n.x = Number.isFinite(n.x) ? clamp(n.x, 0, window.innerWidth-40) : 120;
        n.y = Number.isFinite(n.y) ? clamp(n.y, 0, window.innerHeight-40) : 120;
        n.w = Number.isFinite(n.w) ? clamp(n.w, 180, 540) : 260;
        n.title = (n.title||"NODE");
        n.text = (n.text||"");
        n.cluster = (n.cluster||"");
        n.collapsed = !!n.collapsed;
      }
      for(const eid of Object.keys(STATE.graph.edges)){
        const e=STATE.graph.edges[eid];
        if(!STATE.graph.nodes[e.from] || !STATE.graph.nodes[e.to]) delete STATE.graph.edges[eid];
        e.label = e.label || "";
      }
      save();
      setToast("imported", true);
      schedule();
    }catch(e){
      alert("import failed: "+(e?.message||e));
    }finally{
      $("file").value="";
    }
  };
  reader.readAsText(f);
}

/* ---------- keyboard ---------- */
window.addEventListener("keydown",(ev)=>{
  if(ev.key==="I" && ev.shiftKey){ ev.preventDefault(); toggleInvert(); return; }
  if(ev.key==="." && ev.ctrlKey){ ev.preventDefault(); toggleChrome(); return; }

  if(ev.key==="Escape"){
    if(STATE.sel.mode==="link" && STATE.sel.linkFrom){
      STATE.sel.linkFrom=null;
      setToast("link cancelled", true);
      save(); schedule();
      return;
    }
    STATE.sel.nodeId=null; STATE.sel.edgeId=null;
    save(); schedule();
    return;
  }

  const ae=document.activeElement;
  const typing=ae && (ae.tagName==="TEXTAREA" || ae.tagName==="INPUT" || ae.isContentEditable);

  if((ev.key==="Delete" || ev.key==="Backspace") && !typing){
    if(STATE.sel.nodeId){ ev.preventDefault(); deleteNode(STATE.sel.nodeId); return; }
    if(STATE.sel.edgeId){ ev.preventDefault(); deleteEdge(STATE.sel.edgeId); return; }
  }

  if(!typing && (ev.key==="m"||ev.key==="M")){ STATE.sel.mode="move"; STATE.sel.linkFrom=null; setToast("mode: MOVE", true); save(); schedule(); }
  if(!typing && (ev.key==="l"||ev.key==="L")){ STATE.sel.mode="link"; STATE.sel.linkFrom=null; setToast("mode: LINK", true); save(); schedule(); }
  if(!typing && (ev.key==="s"||ev.key==="S")){ STATE.sel.mode="select"; STATE.sel.linkFrom=null; setToast("mode: SELECT", true); save(); schedule(); }
});

/* ---------- boot ---------- */
function boot(){
  const ok=load();
  initPanels();

  const hasNodes=Object.keys(STATE.graph.nodes).length>0;
  if(!ok || !hasNodes){
    const a=createNode({title:"VOID", text:"brutal chic black void\nnodes + edges\n\nLINK mode: click source then target\ncluster pill: click to edit", x:140, y:140, cluster:"CORE"});
    const b=createNode({title:"THREAD", text:"write the thesis / the claim", x:460, y:210, cluster:"CORE"});
    const c=createNode({title:"EVIDENCE", text:"attach fragments / incidents", x:760, y:140, cluster:"CORE"});
    createEdge(a,b,"frames");
    createEdge(b,c,"tests");
    STATE.sel.nodeId=a;
    save();
  }

  STATE.ui.listMode = STATE.ui.listMode || "nodes";
  $("listMode").value = STATE.ui.listMode;

  schedule();
  setToast("ready", true);
  setTimeout(()=>setToast("", false), 600);
}
boot();

/* =========================
   KETADATA SERIALIZATION STAMP (MANDATORY)
   AE / EE / WB + FILE_ID / ROOM_ID / VERSION / UPDATED_AT / CHANGELOG
=========================

AE:
- brutal chic black void: pure #000, transparent chrome, hairline borders, no gradients, uniform text size.

EE:
- draggable nodes + movable panels, collapsible node bodies + panels, link mode (source->target), edge labels, inspector list,
  basic network analysis (components/degree), invert toggle, chrome toggle, import/export with real file download/upload,
  localStorage persistence.

WB:
- event wiring, render loop, state IO, keyboard shortcuts, edge SVG layer.

FILE_ID: KETADATA_VOID_CHROME_CLUSTER_NETWORK_MAKER
ROOM_ID: void_chrome
VERSION: v1.0.1_brutal_void
UPDATED_AT: (runtime) STATE.meta.updatedAt
CHANGELOG:
- v1.0.1 brutal-void AE: removed grid/gradients; transparent chrome; true black surfaces.
*/
</script>
</body>
</html>
