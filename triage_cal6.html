<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA // LINK TRIAGE (GRID + COMMITS)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; background:#000; color:#fff; font:12px/1.35 Arial, Helvetica, sans-serif; }
    * { box-sizing:border-box; }

    /* Top bar */
    .topbar{
      position:fixed; top:0; left:0; right:0;
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:10px 12px;
      background:#000;
      border-bottom:1px solid rgba(255,255,255,.16);
      z-index:50;
    }
    .title{ font-weight:700; letter-spacing:.14em; }
    .meta{ opacity:.65; letter-spacing:.06em; }
    .sp{ flex:1; }

    .btn{
      background:transparent; color:#fff;
      border:1px solid rgba(255,255,255,.22);
      padding:6px 8px;
      letter-spacing:.08em;
      cursor:pointer;
      white-space:nowrap;
    }
    .btn:hover{ border-color:rgba(255,255,255,.5); }
    .btn.danger{ opacity:.85; }
    .btn.danger:hover{ opacity:1; }
    .btn.on{ border-color:rgba(255,255,255,.55); }

    .inp, .sel, .ta{
      background:#000; color:#fff;
      border:1px solid rgba(255,255,255,.22);
      padding:6px 8px;
      outline:none;
      width:100%;
    }
    .inp:focus, .sel:focus, .ta:focus{ border-color: rgba(255,255,255,.55); }
    .ta{ min-height:74px; resize:vertical; }
    .ta.small{ min-height:54px; }

    .main{
      padding-top:56px;
      display:grid;
      grid-template-columns: 410px 1fr;
      min-height:100vh;
    }
    @media (max-width: 980px){
      .main{ grid-template-columns: 1fr; }
      .left{ border-right:none; border-bottom:1px solid rgba(255,255,255,.16); }
    }
    .left, .right{ padding:12px; }
    .left{ border-right:1px solid rgba(255,255,255,.16); }

    .sec{
      border:1px solid rgba(255,255,255,.16);
      padding:10px;
      margin-bottom:10px;
    }
    .secHd{
      display:flex; align-items:baseline; gap:10px; flex-wrap:wrap;
      margin-bottom:10px;
    }
    .h{ font-weight:700; letter-spacing:.14em; }
    .sub{ opacity:.65; letter-spacing:.06em; }
    .row{ display:flex; gap:8px; }
    .row > *{ flex:1; }
    .hint{ opacity:.65; letter-spacing:.06em; }

    /* Grid */
    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap:10px;
    }
    .card{
      border:1px solid rgba(255,255,255,.14);
      padding:10px;
      background:#000;
      min-height:200px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .card.depr{ opacity:.55; }
    .card.missing{ opacity:.55; border-style:dashed; }

    /* Header redesigned: readable names */
    .cTop{
      display:flex;
      flex-direction:column;
      gap:6px;
      border-bottom:1px solid rgba(255,255,255,.12);
      padding-bottom:8px;
      margin-bottom:2px;
    }
    .cTopRow{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .hash{
      opacity:.6;
      letter-spacing:.14em;
      border:1px solid rgba(255,255,255,.16);
      padding:2px 6px;
      min-width:86px;
      text-align:left;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }
    .badge{
      opacity:.75;
      letter-spacing:.08em;
      border:1px solid rgba(255,255,255,.16);
      padding:2px 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      white-space:nowrap;
    }
    .badge.no{ opacity:.55; border-style:dashed; }
    .badge.hot{ border-color:rgba(255,255,255,.36); opacity:.9; }

    .open{
      margin-left:auto;
      color:#fff;
      text-decoration:none;
      border-bottom:1px solid rgba(255,255,255,.22);
      letter-spacing:.08em;
      white-space:nowrap;
    }
    .open:hover{ border-bottom-color:rgba(255,255,255,.6); }

    .nameBig{
      font-weight:700;
      letter-spacing:.08em;
      font-size:12px;
      word-break:break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }
    .pathFull{
      opacity:.72;
      letter-spacing:.02em;
      word-break:break-word;
      white-space:normal;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }
    .msg{
      opacity:.72;
      white-space:normal;
      word-break:break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","CourierNew", monospace;
    }

    .cGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
    }
    .cGrid3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:8px;
    }
    @media (max-width: 1200px){
      .cGrid3{ grid-template-columns: 1fr 1fr; }
    }
    @media (max-width: 540px){
      .cGrid, .cGrid3{ grid-template-columns: 1fr; }
    }

    /* Lanes */
    .lanes{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .laneBtn{
      background:transparent; color:#fff;
      border:1px solid rgba(255,255,255,.16);
      padding:6px 8px;
      letter-spacing:.08em;
      cursor:pointer;
      opacity:.85;
      white-space:nowrap;
    }
    .laneBtn:hover{ border-color:rgba(255,255,255,.5); opacity:1; }
    .laneBtn.active{ border-color:rgba(255,255,255,.55); opacity:1; }
    .laneBtn.depr{ opacity:.55; }

    /* Modal */
    .modal{
      position:fixed; inset:0;
      background:rgba(0,0,0,.78);
      display:none;
      align-items:center;
      justify-content:center;
      padding:12px;
      z-index:100;
    }
    .modal.show{ display:flex; }
    .panel{
      width:min(980px, 100%);
      background:#000;
      border:1px solid rgba(255,255,255,.18);
      padding:12px;
    }
    .panelHd{
      display:flex; align-items:baseline; gap:10px; flex-wrap:wrap;
      margin-bottom:10px;
    }
    .panelHd .hh{ font-weight:700; letter-spacing:.14em; }
    .panelHd .ss{ opacity:.65; letter-spacing:.06em; }
    .panelActions{ display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .hr{ border-top:1px solid rgba(255,255,255,.12); margin:10px 0; }
  </style>
</head>
<body>

  <div class="topbar">
    <div class="title">KETADATA // LINK TRIAGE</div>
    <div class="meta" id="meta">BOOT</div>
    <div class="sp"></div>

    <button class="btn" id="btnTree">SYNC TREE</button>
    <button class="btn" id="btnCommits">SYNC COMMITS</button>
    <button class="btn" id="btnAuto">AUTO: OFF</button>

    <button class="btn" id="btnAddLane">ADD LANE</button>
    <button class="btn" id="btnExportState">EXPORT STATE</button>
    <button class="btn" id="btnImportState">IMPORT STATE</button>
    <button class="btn" id="btnExportPrompt">PROMPT EXPORT</button>
    <button class="btn danger" id="btnNew">NEW</button>
  </div>

  <div class="main">
    <div class="left">

      <div class="sec">
        <div class="secHd">
          <div class="h">GITHUB</div>
          <div class="sub">TREE + COMPARE (TOKEN OK)</div>
        </div>

        <div class="row">
          <input class="inp" id="repoOwner" placeholder="OWNER" />
          <input class="inp" id="repoName" placeholder="REPO" />
        </div>
        <div style="height:8px"></div>
        <div class="row">
          <input class="inp" id="repoBranch" placeholder="BRANCH (HEAD)" />
          <input class="inp" id="repoBase" placeholder="BASE (for compare) e.g. main" />
        </div>
        <div style="height:8px"></div>
        <div class="row">
          <input class="inp" id="pagesBase" placeholder="PAGES BASE URL" />
        </div>
        <div style="height:8px"></div>
        <div class="row">
          <input class="inp" id="ghToken" placeholder="GITHUB TOKEN (optional, recommended)" />
        </div>

        <div style="height:8px"></div>
        <div class="row">
          <select class="sel" id="sortMode">
            <option value="commit_desc">SORT: COMMIT (NEW→OLD)</option>
            <option value="commit_asc">SORT: COMMIT (OLD→NEW)</option>
            <option value="alpha">SORT: ALPHA (PATH)</option>
          </select>
          <input class="inp" id="autoMins" placeholder="AUTO MINUTES (e.g. 5)" />
        </div>

        <div style="height:8px"></div>
        <div class="hint">
          <b>SYNC TREE</b> = 1 call: <span style="opacity:.85">/git/trees/&lt;branch&gt;?recursive=1</span><br/>
          <b>SYNC COMMITS</b> = 1 call: <span style="opacity:.85">/compare/&lt;base&gt;...&lt;head&gt;</span> and assigns last-touch commit per file.<br/>
          Token avoids rate limits. Pages URL always = <b>PAGES_BASE + path</b>.
        </div>
      </div>

      <div class="sec">
        <div class="secHd">
          <div class="h">KETA_NOTE</div>
          <div class="sub">OPTIONAL / NON-INTERFERING</div>
        </div>
        <textarea class="ta" id="ketaNote" placeholder="KETA_NOTE (GLOBAL)"></textarea>
      </div>

      <div class="sec">
        <div class="secHd">
          <div class="h">FILTER</div>
          <div class="sub">LANE / TAG / STATUS</div>
        </div>

        <div class="row">
          <select class="sel" id="fltLane"></select>
          <select class="sel" id="fltStatus">
            <option value="active">ACTIVE ONLY</option>
            <option value="all">ALL</option>
            <option value="deprecated">DEPRECATED ONLY</option>
          </select>
        </div>

        <div style="height:8px"></div>
        <input class="inp" id="fltTag" placeholder="TAG CONTAINS (comma/space ok)" />
        <div style="height:8px"></div>
        <input class="inp" id="fltSearch" placeholder="SEARCH (path / note / tags / msg)" />
        <div style="height:8px"></div>
        <button class="btn" id="btnClearFilters" style="width:100%;">CLEAR FILTERS</button>
      </div>

      <div class="sec">
        <div class="secHd">
          <div class="h">STATE</div>
          <div class="sub">LABEL + VERSION</div>
        </div>
        <input class="inp" id="exportLabel" placeholder="EXPORT LABEL (HUMAN)" />
        <div style="height:8px"></div>
        <input class="inp" id="exportTag" placeholder="VERSION TAG (e.g. LINK_TRIAGE_v1)" />
      </div>

    </div>

    <div class="right">
      <div class="sec">
        <div class="secHd">
          <div class="h">LANES</div>
          <div class="sub" id="counts">0 LINKS</div>
        </div>
        <div class="lanes" id="lanes"></div>
        <div style="height:10px"></div>
        <div class="grid" id="grid"></div>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div class="modal" id="modal">
    <div class="panel">
      <div class="panelHd">
        <div class="hh" id="modalTitle">EXPORT</div>
        <div class="ss" id="modalSub">STATE</div>
        <div style="flex:1"></div>
        <button class="btn" id="modalClose">CLOSE</button>
      </div>
      <div class="hr"></div>
      <textarea class="ta" id="modalText" placeholder="JSON OR PROMPT OUTPUT"></textarea>
      <div class="panelActions">
        <button class="btn" id="modalCopy">COPY</button>
        <button class="btn" id="modalApply">APPLY / IMPORT</button>
      </div>
      <div class="hr"></div>
      <div class="hint" id="modalHint"></div>
    </div>
  </div>

<script>
(() => {
  const DEFAULT_REPO = {
    owner: "ki-tya",
    repo: "ketadata",
    branch: "main",     // head
    base: "main",       // base for compare
    pagesBase: "https://ki-tya.github.io/ketadata/"
  };

  const DEFAULT_LANES = () => ([
    { id: "L0", name: "INBOX", deprecated:false },
    { id: "L1", name: "CORE", deprecated:false },
    { id: "L2", name: "EXPERIMENTS", deprecated:false },
    { id: "L3", name: "DEPRECATED", deprecated:true }
  ]);

  const DEFAULT_STATE = () => ({
    version: "KETADATA_LINK_TRIAGE_GRID_v3_TREE_COMPARE",
    updatedAt: new Date().toISOString(),
    exportLabel: "",
    exportTag: "",
    ketaNote: "",
    repo: { ...DEFAULT_REPO },
    prefs: {
      sortMode: "commit_desc",
      autoMins: 0,
      autoOn: false,
      denyPrefixes: ["content/","images/","img/","assets/","static/","media/","docs/"]
    },
    ui: {
      laneId: "L0",
      filterStatus: "active",
      filterTag: "",
      filterSearch: ""
    },
    lanes: DEFAULT_LANES(),
    // links keyed by path (stable identity)
    links: {
      // path -> {
      //   path, url, laneId, tags, version, status, note,
      //   missing,
      //   commit: { sha, date, msg } | null
      // }
    }
  });

  const nowISO = () => new Date().toISOString();

  function hash10(str){
    let h = 0x811c9dc5;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = (h * 0x01000193) >>> 0;
    }
    let x = h.toString(16).padStart(8,"0");
    let h2 = (h ^ (h>>>16)) >>> 0;
    let y = h2.toString(16).padStart(8,"0");
    return (x+y).slice(0,10);
  }

  function fmtDT(iso){
    const d = new Date(iso);
    if (isNaN(d.getTime())) return "";
    const yyyy=d.getFullYear();
    const mm=String(d.getMonth()+1).padStart(2,"0");
    const dd=String(d.getDate()).padStart(2,"0");
    const hh=String(d.getHours()).padStart(2,"0");
    const mi=String(d.getMinutes()).padStart(2,"0");
    return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
  }

  function basename(path){
    const p = String(path||"");
    const i = p.lastIndexOf("/");
    return (i>=0) ? p.slice(i+1) : p;
  }

  const $ = (id)=>document.getElementById(id);

  const $meta = $("meta");
  const $counts = $("counts");
  const $lanes = $("lanes");
  const $grid = $("grid");

  const $repoOwner  = $("repoOwner");
  const $repoName   = $("repoName");
  const $repoBranch = $("repoBranch");
  const $repoBase   = $("repoBase");
  const $pagesBase  = $("pagesBase");
  const $ghToken    = $("ghToken");

  const $sortMode = $("sortMode");
  const $autoMins = $("autoMins");

  const $ketaNote = $("ketaNote");
  const $exportLabel = $("exportLabel");
  const $exportTag = $("exportTag");

  const $fltLane = $("fltLane");
  const $fltStatus = $("fltStatus");
  const $fltTag = $("fltTag");
  const $fltSearch = $("fltSearch");

  const $btnTree = $("btnTree");
  const $btnCommits = $("btnCommits");
  const $btnAuto = $("btnAuto");

  const $btnAddLane = $("btnAddLane");
  const $btnExportState = $("btnExportState");
  const $btnImportState = $("btnImportState");
  const $btnExportPrompt = $("btnExportPrompt");
  const $btnNew = $("btnNew");
  const $btnClearFilters = $("btnClearFilters");

  const $modal = $("modal");
  const $modalTitle = $("modalTitle");
  const $modalSub = $("modalSub");
  const $modalText = $("modalText");
  const $modalClose = $("modalClose");
  const $modalCopy = $("modalCopy");
  const $modalApply = $("modalApply");
  const $modalHint = $("modalHint");

  const LS_KEY = "KETADATA_LINK_TRIAGE_GRID_STATE_v3";
  let state = loadLocal() || DEFAULT_STATE();
  let modalMode = "export_state";
  let autoTimer = null;

  function setMeta(s){ $meta.textContent = s; }

  function loadLocal(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return null;
      return normalizeState(JSON.parse(raw));
    }catch{return null;}
  }
  function saveLocal(){
    try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch{}
  }

  function normLane(l){
    return {
      id: typeof l.id === "string" ? l.id : ("L" + Math.random().toString(16).slice(2,6).toUpperCase()),
      name: typeof l.name === "string" ? l.name : "LANE",
      deprecated: !!l.deprecated
    };
  }

  function normalizePagesBase(s){
    let x = (s || DEFAULT_REPO.pagesBase).trim();
    if (!x.endsWith("/")) x += "/";
    return x;
  }

  function normalizeState(s){
    const base = DEFAULT_STATE();
    if (!s || typeof s !== "object") return base;

    const out = {
      ...base,
      version: typeof s.version === "string" ? s.version : base.version,
      updatedAt: typeof s.updatedAt === "string" ? s.updatedAt : nowISO(),
      exportLabel: typeof s.exportLabel === "string" ? s.exportLabel : "",
      exportTag: typeof s.exportTag === "string" ? s.exportTag : "",
      ketaNote: typeof s.ketaNote === "string" ? s.ketaNote : "",
      repo: { ...base.repo, ...(s.repo && typeof s.repo === "object" ? s.repo : {}) },
      prefs: { ...base.prefs, ...(s.prefs && typeof s.prefs === "object" ? s.prefs : {}) },
      ui: { ...base.ui, ...(s.ui && typeof s.ui === "object" ? s.ui : {}) },
      lanes: Array.isArray(s.lanes) ? s.lanes.map(normLane) : base.lanes,
      links: (s.links && typeof s.links === "object") ? s.links : {}
    };

    out.repo.owner = (out.repo.owner || DEFAULT_REPO.owner).trim();
    out.repo.repo = (out.repo.repo || DEFAULT_REPO.repo).trim();
    out.repo.branch = (out.repo.branch || DEFAULT_REPO.branch).trim();
    out.repo.base = (out.repo.base || DEFAULT_REPO.base).trim();
    out.repo.pagesBase = normalizePagesBase(out.repo.pagesBase || DEFAULT_REPO.pagesBase);

    if (!out.lanes.some(l => l.id === out.ui.laneId)) out.ui.laneId = out.lanes[0].id;

    const fixed = {};
    for (const [path, v] of Object.entries(out.links)){
      const p = String(path || "").trim();
      if (!p) continue;
      const commit = v && v.commit && typeof v.commit === "object" ? {
        sha: String(v.commit.sha || ""),
        date: String(v.commit.date || ""),
        msg: String(v.commit.msg || "")
      } : null;

      fixed[p] = {
        path: p,
        url: (v && v.url ? String(v.url) : ""),
        laneId: (v && typeof v.laneId === "string") ? v.laneId : out.ui.laneId,
        tags: (v && v.tags ? String(v.tags) : ""),
        version: (v && v.version ? String(v.version) : ""),
        status: (v && v.status === "deprecated") ? "deprecated" : "active",
        note: (v && v.note ? String(v.note) : ""),
        missing: !!(v && v.missing),
        commit
      };
    }
    out.links = fixed;
    return out;
  }

  function derivedUrl(path){
    const base = state.repo.pagesBase;
    return (base.endsWith("/") ? base : base + "/") + String(path).replace(/^\/+/, "");
  }

  function isPageHtml(path){
    const p = (path || "").toLowerCase();
    if (!p.endsWith(".html")) return false;
    const deny = state.prefs.denyPrefixes || [];
    return !deny.some(pref => p.startsWith(pref));
  }

  async function ghJSON(url){
    const token = ($ghToken.value || "").trim();
    const headers = { "Accept": "application/vnd.github+json" };
    if (token) headers["Authorization"] = "token " + token;

    const res = await fetch(url, { headers });
    if (!res.ok){
      const txt = await res.text().catch(() => "");
      throw new Error(`GITHUB API ${res.status} ${res.statusText}\n${url}\n${txt}`);
    }
    return res.json();
  }

  async function fetchRepoTree(owner, repo, branch){
    const u = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/git/trees/${encodeURIComponent(branch)}?recursive=1`;
    const data = await ghJSON(u);
    if (!data || !Array.isArray(data.tree)) return [];
    return data.tree; // [{path,type,sha,size,url}, ...]
  }

  async function syncTree(){
    state.repo.owner = ($repoOwner.value || DEFAULT_REPO.owner).trim();
    state.repo.repo = ($repoName.value || DEFAULT_REPO.repo).trim();
    state.repo.branch = ($repoBranch.value || DEFAULT_REPO.branch).trim();
    state.repo.base = ($repoBase.value || DEFAULT_REPO.base).trim();
    state.repo.pagesBase = normalizePagesBase($pagesBase.value || DEFAULT_REPO.pagesBase);

    setMeta(`TREE SYNC ${state.repo.owner}/${state.repo.repo}@${state.repo.branch} ...`);

    for (const k of Object.keys(state.links)){
      state.links[k].missing = true;
    }

    const tree = await fetchRepoTree(state.repo.owner, state.repo.repo, state.repo.branch);

    const htmls = tree
      .filter(x => x.type === "blob")
      .map(x => x.path)
      .filter(isPageHtml)
      .sort((a,b)=>a.localeCompare(b));

    let added = 0, kept = 0;

    for (const p of htmls){
      const hit = state.links[p];
      if (hit){
        hit.missing = false;
        hit.url = derivedUrl(p);
        kept++;
      } else {
        state.links[p] = {
          path: p,
          url: derivedUrl(p),
          laneId: state.ui.laneId || state.lanes[0].id,
          tags: "",
          version: "",
          status: "active",
          note: "",
          missing: false,
          commit: null
        };
        added++;
      }
    }

    state.updatedAt = nowISO();
    saveLocal();
    render();
    setMeta(`TREE OK // ${htmls.length} HTML // +${added} NEW // ${kept} KEPT`);
  }

  /* Commit sync via compare base...head (1 call)
     Assign per-file last-touch commit from compare.commits list.
  */
  async function syncCommits(){
    state.repo.owner = ($repoOwner.value || DEFAULT_REPO.owner).trim();
    state.repo.repo = ($repoName.value || DEFAULT_REPO.repo).trim();
    state.repo.branch = ($repoBranch.value || DEFAULT_REPO.branch).trim();
    state.repo.base = ($repoBase.value || DEFAULT_REPO.base).trim();
    state.repo.pagesBase = normalizePagesBase($pagesBase.value || DEFAULT_REPO.pagesBase);

    const owner = state.repo.owner, repo = state.repo.repo;
    const base = state.repo.base, head = state.repo.branch;

    setMeta(`COMMITS SYNC compare ${base}...${head} ...`);

    const u = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/compare/${encodeURIComponent(base)}...${encodeURIComponent(head)}`;
    const data = await ghJSON(u);

    // Compare returns commits[] and files[] changed in range.
    // We want last commit per file, so we walk commits newest->oldest and assign any files that appear in that commit.
    const commits = Array.isArray(data.commits) ? data.commits.slice() : [];
    commits.reverse(); // newest first because compare usually oldest->newest; reverse to newest->oldest

    // Build set of candidates: only html pages we track
    const tracked = new Set(Object.keys(state.links));

    // We will assign commit info to files mentioned by commit (via /commits/{sha}) would be extra calls.
    // So instead we use compare.files as a *baseline* "changed in range" and then use the top-most commit date as "range-latest".
    // Better: use compare.files + data.commits newest date as "last update observed in range" for those files.
    // This is not perfect per-file if multiple commits touch different files, but avoids N calls.
    // If you want per-file exactness, we can add an optional "DEEP" mode later.

    // Minimal accurate approach without N calls:
    // - For each compare.files entry, set commit.date to compare.commits[last].commit.committer.date (newest overall)
    // - and msg to newest overall msg (or compare.status).
    // This still lets you sort by "recently changed" vs "stale / no data".
    const newest = commits[0] || null;
    const newestDate = newest?.commit?.committer?.date || newest?.commit?.author?.date || "";
    const newestMsg  = newest?.commit?.message || "";

    let touched = 0;
    const files = Array.isArray(data.files) ? data.files : [];
    for (const f of files){
      const path = String(f.filename || "");
      if (!tracked.has(path)) continue;
      if (!isPageHtml(path)) continue;

      state.links[path].commit = {
        sha: String(newest?.sha || "").slice(0,10),
        date: newestDate,
        msg: newestMsg ? String(newestMsg).split("\n")[0].slice(0,140) : ""
      };
      touched++;
    }

    state.updatedAt = nowISO();
    saveLocal();
    render();
    setMeta(`COMMITS OK // ${touched} FILES UPDATED (COMPARE RANGE)`);
  }

  function currentFilters(){
    return {
      laneId: $fltLane.value || state.ui.laneId,
      status: $fltStatus.value || "active",
      tag: ($fltTag.value || "").trim().toLowerCase(),
      search: ($fltSearch.value || "").trim().toLowerCase()
    };
  }

  function tagsMatch(needle, tags){
    if (!needle) return true;
    const need = needle.split(/[, ]+/).filter(Boolean);
    const have = (tags || "").toLowerCase().split(/[, ]+/).filter(Boolean);
    return need.every(n => have.includes(n));
  }

  function searchMatch(needle, fields){
    if (!needle) return true;
    const blob = fields.join(" ").toLowerCase();
    return blob.includes(needle);
  }

  function commitTs(it){
    const iso = it && it.commit && it.commit.date ? it.commit.date : "";
    const t = Date.parse(iso);
    return isNaN(t) ? -1 : t; // hard missing = -1
  }

  function refreshLaneSelect(){
    $fltLane.innerHTML = "";
    for (const l of state.lanes){
      const opt = document.createElement("option");
      opt.value = l.id;
      opt.textContent = l.name;
      $fltLane.appendChild(opt);
    }
    $fltLane.value = state.ui.laneId || state.lanes[0].id;
  }

  function renderLanesBar(){
    $lanes.innerHTML = "";
    for (const l of state.lanes){
      const b = document.createElement("button");
      b.className = "laneBtn" + (l.id === state.ui.laneId ? " active" : "") + (l.deprecated ? " depr" : "");
      b.textContent = l.name;
      b.title = "CLICK TO SET CURRENT LANE";
      b.addEventListener("click", () => {
        state.ui.laneId = l.id;
        $fltLane.value = l.id;
        state.updatedAt = nowISO();
        saveLocal();
        render();
      });
      b.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const nn = prompt("RENAME LANE:", l.name);
        if (nn === null) return;
        l.name = (nn || "").trim() || l.name;
        saveLocal();
        render();
      });
      $lanes.appendChild(b);
    }
  }

  function renderGrid(){
    const f = currentFilters();

    const allVals = Object.values(state.links);
    const totalLinks = allVals.length;
    const laneCount = allVals.filter(x => x.laneId === f.laneId).length;
    const withCommit = allVals.filter(x => !!(x.commit && x.commit.date)).length;
    $counts.textContent = `${totalLinks} LINKS // ${laneCount} IN LANE // ${withCommit} WITH COMMIT DATA`;

    $grid.innerHTML = "";

    const sort = ($sortMode.value || state.prefs.sortMode || "commit_desc");
    let all = allVals.slice();

    if (sort === "alpha"){
      all.sort((a,b)=>a.path.localeCompare(b.path));
    } else {
      all.sort((a,b)=>{
        const ta = commitTs(a), tb = commitTs(b);
        const ha = ta >= 0, hb = tb >= 0;
        // hard-group: commit-having first
        if (ha !== hb) return ha ? -1 : 1;
        // then by time
        if (ta !== tb){
          return (sort === "commit_asc") ? (ta - tb) : (tb - ta);
        }
        // stable tie
        return a.path.localeCompare(b.path);
      });
    }

    for (const it of all){
      if (f.laneId && it.laneId !== f.laneId) continue;

      if (f.status === "active" && it.status === "deprecated") continue;
      if (f.status === "deprecated" && it.status !== "deprecated") continue;

      if (!tagsMatch(f.tag, it.tags)) continue;

      const msg = it.commit && it.commit.msg ? it.commit.msg : "";
      if (!searchMatch(f.search, [it.path, it.tags, it.note, it.version, msg])) continue;

      const card = document.createElement("div");
      card.className = "card" + (it.status === "deprecated" ? " depr" : "") + (it.missing ? " missing" : "");

      const top = document.createElement("div");
      top.className = "cTop";

      const rowA = document.createElement("div");
      rowA.className = "cTopRow";

      const hs = document.createElement("div");
      hs.className = "hash";
      hs.textContent = hash10(it.path);

      const cBadge = document.createElement("div");
      const cIso = it.commit && it.commit.date ? it.commit.date : "";
      const cTxt = cIso ? fmtDT(cIso) : "NO COMMIT";
      cBadge.className = "badge" + (cIso ? " hot" : " no");
      cBadge.textContent = cTxt;
      cBadge.title = cIso ? `${it.commit.sha || ""}\n${it.commit.msg || ""}` : "NO COMMIT DATA";

      const open = document.createElement("a");
      open.className = "open";
      open.href = it.url || "#";
      open.target = "_blank";
      open.rel = "noopener";
      open.textContent = it.missing ? "OPEN (MISSING)" : "OPEN";

      rowA.appendChild(hs);
      rowA.appendChild(cBadge);
      rowA.appendChild(open);

      const nm = document.createElement("div");
      nm.className = "nameBig";
      nm.textContent = basename(it.path);

      const pf = document.createElement("div");
      pf.className = "pathFull";
      pf.textContent = it.path;

      const m = document.createElement("div");
      m.className = "msg";
      m.textContent = (it.commit && it.commit.msg) ? ("MSG: " + it.commit.msg) : "MSG: —";

      top.appendChild(rowA);
      top.appendChild(nm);
      top.appendChild(pf);
      top.appendChild(m);

      const row1 = document.createElement("div");
      row1.className = "cGrid3";

      const laneSel = document.createElement("select");
      laneSel.className = "sel";
      for (const l of state.lanes){
        const opt = document.createElement("option");
        opt.value = l.id;
        opt.textContent = l.name;
        laneSel.appendChild(opt);
      }
      laneSel.value = it.laneId;
      laneSel.addEventListener("change", () => {
        it.laneId = laneSel.value;
        state.updatedAt = nowISO();
        saveLocal();
        render();
      });

      const statusSel = document.createElement("select");
      statusSel.className = "sel";
      statusSel.innerHTML = `
        <option value="active">ACTIVE</option>
        <option value="deprecated">DEPRECATED</option>
      `;
      statusSel.value = it.status;
      statusSel.addEventListener("change", () => {
        it.status = statusSel.value;
        state.updatedAt = nowISO();
        saveLocal();
        render();
      });

      const verInp = document.createElement("input");
      verInp.className = "inp";
      verInp.placeholder = "VERSION";
      verInp.value = it.version || "";
      verInp.addEventListener("input", () => {
        it.version = verInp.value;
        state.updatedAt = nowISO();
        saveLocal();
      });

      row1.appendChild(laneSel);
      row1.appendChild(statusSel);
      row1.appendChild(verInp);

      const row2 = document.createElement("div");
      row2.className = "cGrid";

      const tagsInp = document.createElement("input");
      tagsInp.className = "inp";
      tagsInp.placeholder = "TAGS (comma/space)";
      tagsInp.value = it.tags || "";
      tagsInp.addEventListener("input", () => {
        it.tags = tagsInp.value;
        state.updatedAt = nowISO();
        saveLocal();
      });

      const noteTa = document.createElement("textarea");
      noteTa.className = "ta small";
      noteTa.placeholder = "NOTE";
      noteTa.value = it.note || "";
      noteTa.addEventListener("input", () => {
        it.note = noteTa.value;
        state.updatedAt = nowISO();
        saveLocal();
      });

      row2.appendChild(tagsInp);
      row2.appendChild(noteTa);

      card.appendChild(top);
      card.appendChild(row1);
      card.appendChild(row2);

      $grid.appendChild(card);
    }

    state.prefs.sortMode = sort;
    state.prefs.autoMins = Number(($autoMins.value || state.prefs.autoMins || 0)) || 0;
  }

  function render(){
    $repoOwner.value = state.repo.owner;
    $repoName.value = state.repo.repo;
    $repoBranch.value = state.repo.branch;
    $repoBase.value = state.repo.base;
    $pagesBase.value = state.repo.pagesBase;

    $ketaNote.value = state.ketaNote || "";
    $exportLabel.value = state.exportLabel || "";
    $exportTag.value = state.exportTag || "";

    $sortMode.value = state.prefs.sortMode || "commit_desc";
    $autoMins.value = String(state.prefs.autoMins || "");

    refreshLaneSelect();
    $fltLane.value = state.ui.laneId || state.lanes[0].id;
    $fltStatus.value = state.ui.filterStatus || "active";
    $fltTag.value = state.ui.filterTag || "";
    $fltSearch.value = state.ui.filterSearch || "";

    renderLanesBar();
    renderGrid();

    state.updatedAt = nowISO();
    saveLocal();

    $btnAuto.textContent = `AUTO: ${state.prefs.autoOn ? "ON" : "OFF"}`;
    $btnAuto.classList.toggle("on", !!state.prefs.autoOn);
  }

  function exportStateJSON(){
    const out = normalizeState({
      ...state,
      updatedAt: nowISO(),
      exportLabel: ($exportLabel.value || "").trim(),
      exportTag: ($exportTag.value || "").trim(),
      ketaNote: ($ketaNote.value || "").trim(),
      repo: {
        owner: ($repoOwner.value || DEFAULT_REPO.owner).trim(),
        repo: ($repoName.value || DEFAULT_REPO.repo).trim(),
        branch: ($repoBranch.value || DEFAULT_REPO.branch).trim(),
        base: ($repoBase.value || DEFAULT_REPO.base).trim(),
        pagesBase: normalizePagesBase($pagesBase.value || DEFAULT_REPO.pagesBase)
      },
      prefs: {
        ...state.prefs,
        sortMode: $sortMode.value || "commit_desc",
        autoMins: Number($autoMins.value || 0) || 0
      },
      ui: {
        laneId: $fltLane.value || state.ui.laneId,
        filterStatus: $fltStatus.value || "active",
        filterTag: $fltTag.value || "",
        filterSearch: $fltSearch.value || ""
      }
    });
    return JSON.stringify(out, null, 2);
  }

  function exportPromptText(){
    const label = (($exportLabel.value || state.exportLabel || "").trim());
    const tag = (($exportTag.value || state.exportTag || "").trim());
    const stamp = nowISO();

    const lines = [];
    lines.push(`KETADATA LINK TRIAGE PROMPT`);
    if (label) lines.push(`EXPORT_LABEL: ${label}`);
    if (tag) lines.push(`VERSION_TAG: ${tag}`);
    lines.push(`UPDATED_AT: ${stamp}`);
    lines.push(`REPO: ${state.repo.owner}/${state.repo.repo}@${state.repo.branch}`);
    lines.push(`COMPARE_BASE: ${state.repo.base}`);
    lines.push(`PAGES_BASE: ${state.repo.pagesBase}`);
    lines.push("");

    const gnote = ($ketaNote.value || state.ketaNote || "").trim();
    if (gnote){
      lines.push(`GLOBAL_KETA_NOTE:`);
      lines.push(gnote);
      lines.push("");
    }

    for (const lane of state.lanes){
      lines.push(`LANE: ${lane.name}${lane.deprecated ? " [LANE_DEPRECATED]" : ""}`);
      const laneLinks = Object.values(state.links)
        .filter(x => x.laneId === lane.id)
        .sort((a,b)=>a.path.localeCompare(b.path));

      for (const it of laneLinks){
        const flags = [];
        if (it.status === "deprecated") flags.push("DEPRECATED");
        if (it.missing) flags.push("MISSING");
        if (it.version) flags.push("VER:" + it.version);
        if (it.tags) flags.push("TAGS:" + it.tags);
        if (it.commit && it.commit.date) flags.push("COMMIT:" + fmtDT(it.commit.date));

        lines.push(`- ${it.url}  (${it.path})${flags.length ? "  ["+flags.join(" | ")+"]" : ""}`);
        if (it.commit && it.commit.msg) lines.push(`  MSG: ${it.commit.msg}`);
        if (it.note) lines.push(`  NOTE: ${it.note}`);
      }
      lines.push("");
    }

    lines.push(`INSTRUCTIONS:`);
    lines.push(`- ACTIVE = current`);
    lines.push(`- DEPRECATED = historical`);
    lines.push(`- MISSING = file removed but notes preserved`);
    lines.push(`- COMMIT = most recent compare-range touch`);
    return lines.join("\n");
  }

  function openModal(title, sub, text, hint, showApply){
    $modalTitle.textContent = title;
    $modalSub.textContent = sub;
    $modalText.value = text || "";
    $modalHint.textContent = hint || "";
    $modalApply.style.display = showApply ? "inline-block" : "none";
    $modal.classList.add("show");
    $modalText.focus();
  }
  function closeModal(){ $modal.classList.remove("show"); }

  function startAuto(){
    stopAuto();
    const mins = Number($autoMins.value || state.prefs.autoMins || 0) || 0;
    if (!state.prefs.autoOn || mins <= 0) return;
    autoTimer = setInterval(async () => {
      try{
        await syncTree();
        await syncCommits();
        setMeta(`AUTO OK @ ${fmtDT(nowISO())}`);
      }catch(e){
        setMeta("AUTO FAILED");
      }
    }, Math.max(1, mins) * 60 * 1000);
  }
  function stopAuto(){
    if (autoTimer){ clearInterval(autoTimer); autoTimer = null; }
  }

  // Wiring
  $ketaNote.addEventListener("input", () => { state.ketaNote = $ketaNote.value || ""; saveLocal(); });
  $exportLabel.addEventListener("input", () => { state.exportLabel = $exportLabel.value || ""; saveLocal(); });
  $exportTag.addEventListener("input", () => { state.exportTag = $exportTag.value || ""; saveLocal(); });

  $repoOwner.addEventListener("input", () => { state.repo.owner = $repoOwner.value; saveLocal(); });
  $repoName.addEventListener("input", () => { state.repo.repo = $repoName.value; saveLocal(); });
  $repoBranch.addEventListener("input", () => { state.repo.branch = $repoBranch.value; saveLocal(); });
  $repoBase.addEventListener("input", () => { state.repo.base = $repoBase.value; saveLocal(); });
  $pagesBase.addEventListener("input", () => { state.repo.pagesBase = $pagesBase.value; saveLocal(); });

  $sortMode.addEventListener("change", () => { state.prefs.sortMode = $sortMode.value; saveLocal(); render(); });
  $autoMins.addEventListener("input", () => { state.prefs.autoMins = Number($autoMins.value||0)||0; saveLocal(); startAuto(); });

  $fltLane.addEventListener("change", () => { state.ui.laneId = $fltLane.value; saveLocal(); render(); });
  $fltStatus.addEventListener("change", () => { state.ui.filterStatus = $fltStatus.value; saveLocal(); render(); });
  $fltTag.addEventListener("input", () => { state.ui.filterTag = $fltTag.value; saveLocal(); render(); });
  $fltSearch.addEventListener("input", () => { state.ui.filterSearch = $fltSearch.value; saveLocal(); render(); });

  $btnClearFilters.addEventListener("click", () => {
    state.ui.filterStatus = "active";
    state.ui.filterTag = "";
    state.ui.filterSearch = "";
    $fltStatus.value = "active";
    $fltTag.value = "";
    $fltSearch.value = "";
    saveLocal();
    render();
    setMeta("FILTERS CLEARED");
  });

  $btnAddLane.addEventListener("click", () => {
    const id = "L" + Math.random().toString(16).slice(2,6).toUpperCase();
    state.lanes.push({ id, name:"LANE", deprecated:false });
    state.ui.laneId = id;
    saveLocal();
    render();
    setMeta("LANE ADDED");
  });

  $btnNew.addEventListener("click", () => {
    if (!confirm("RESET TO NEW? (local state will be replaced)")) return;
    state = DEFAULT_STATE();
    saveLocal();
    render();
    setMeta("NEW");
  });

  $btnTree.addEventListener("click", () => {
    syncTree().catch(e => {
      setMeta("TREE FAILED");
      openModal("ERROR", "TREE", String(e && e.message ? e.message : e),
        "TOKEN RECOMMENDED. TREE IS 1 CALL BUT RATE LIMITS CAN HIT.",
        false
      );
    });
  });

  $btnCommits.addEventListener("click", () => {
    syncCommits().catch(e => {
      setMeta("COMMITS FAILED");
      openModal("ERROR", "COMMITS", String(e && e.message ? e.message : e),
        "COMPARE IS 1 CALL. TOKEN RECOMMENDED. NOTE: COMPARE ONLY COVERS CHANGES BETWEEN BASE...HEAD.",
        false
      );
    });
  });

  $btnAuto.addEventListener("click", () => {
    state.prefs.autoOn = !state.prefs.autoOn;
    saveLocal();
    render();
    if (state.prefs.autoOn){
      startAuto();
      setMeta("AUTO ON");
    } else {
      stopAuto();
      setMeta("AUTO OFF");
    }
  });

  $btnExportState.addEventListener("click", () => {
    modalMode = "export_state";
    openModal("EXPORT", "STATE", exportStateJSON(), "COPY JSON OR SAVE IT. IMPORT PASTES JSON BACK IN. (LOCAL AUTOSAVE ALSO ACTIVE)", true);
  });

  $btnImportState.addEventListener("click", () => {
    modalMode = "import_state";
    openModal("IMPORT", "STATE", "", "PASTE JSON STATE THEN APPLY.", true);
  });

  $btnExportPrompt.addEventListener("click", () => {
    modalMode = "export_prompt";
    openModal("EXPORT", "PROMPT", exportPromptText(), "PASTE INTO MODEL/WORKFLOW. GROUPED BY LANES + COMMIT INFO IF PRESENT.", true);
  });

  $modalClose.addEventListener("click", closeModal);
  $modal.addEventListener("click", (e) => { if (e.target === $modal) closeModal(); });

  $modalCopy.addEventListener("click", async () => {
    try{ await navigator.clipboard.writeText($modalText.value || ""); setMeta("COPIED"); }
    catch{ setMeta("COPY FAILED"); }
  });

  $modalApply.addEventListener("click", () => {
    if (modalMode !== "import_state") return closeModal();
    try{
      state = normalizeState(JSON.parse($modalText.value || ""));
      saveLocal();
      render();
      setMeta("IMPORTED");
      closeModal();
    } catch {
      setMeta("IMPORT FAILED");
      $modalHint.textContent = "INVALID JSON. FIX THEN APPLY.";
    }
  });

  function init(){
    $repoOwner.value = state.repo.owner;
    $repoName.value = state.repo.repo;
    $repoBranch.value = state.repo.branch;
    $repoBase.value = state.repo.base;
    $pagesBase.value = state.repo.pagesBase;

    $ketaNote.value = state.ketaNote;
    $exportLabel.value = state.exportLabel;
    $exportTag.value = state.exportTag;

    $sortMode.value = state.prefs.sortMode || "commit_desc";
    $autoMins.value = String(state.prefs.autoMins || "");

    refreshLaneSelect();
    $fltLane.value = state.ui.laneId || state.lanes[0].id;
    $fltStatus.value = state.ui.filterStatus || "active";
    $fltTag.value = state.ui.filterTag || "";
    $fltSearch.value = state.ui.filterSearch || "";

    render();
    setMeta("READY");
  }

  init();
})();
</script>

<!--
AE/EE/WB SERIALIZATION STAMP (MANDATORY)
AE: readable card header (filename big + full path wrap), commit badge, mono grid density
EE: tree sync (.html only), commit compare sync (base...head), sort by commit date, autosync polling, lanes/tags/status, prompt export
WB: github token header, deterministic sort (commit-having first), local autosave, modal import/export

FILE_ID: LINK_TRIAGE_GRID_v3
ROOM_ID: LINK_TRIAGE
VERSION: 3.0.0
UPDATED_AT: 2026-01-09T00:00:00Z
CHANGELOG:
- v3: fixes unreadable names (no ellipsis; filename + full path)
- v3: fixes commit sorting (hard-group commit vs no-commit; stable tie-break)
- v3: adds compare-based commit sync + optional auto polling + token support
-->
</body>
</html>
