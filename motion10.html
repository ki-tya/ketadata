<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA // CAM SUBSTANCE (ACCUMULATION)</title>

<style>
:root{
  --bg:#000;
  --fg:rgba(255,255,255,.86);
  --muted:rgba(255,255,255,.52);
  --line:rgba(255,255,255,.14);
  --line2:rgba(255,255,255,.22);
  --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  --sans: Arial,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  --top:44px;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);overflow:hidden;font-family:var(--sans)}
#top{
  position:fixed;left:0;right:0;top:0;height:var(--top);
  display:flex;align-items:center;gap:8px;padding:6px 8px;
  background:rgba(0,0,0,.78);border-bottom:1px solid var(--line);
  z-index:60;
}
.btn,.chip{
  height:30px;display:inline-flex;align-items:center;gap:8px;
  padding:0 10px;border:1px solid var(--line2);
  background:rgba(0,0,0,.30);color:var(--fg);
  font:12px/1 var(--sans);white-space:nowrap;user-select:none;
}
.btn{cursor:pointer}
.btn:active{transform:translateY(1px)}
.k{font-family:var(--mono);opacity:.9}
.sep{flex:1}
input[type="range"]{width:110px;accent-color:#fff}

#stage{
  position:fixed;left:0;top:var(--top);
  width:100vw;height:calc(100vh - var(--top));
}
video{position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0}

/* VIZ modes */
#vizSmall{
  position:fixed;right:8px;bottom:8px;width:260px;height:160px;
  border:1px solid var(--line);background:#000;z-index:50;display:none;
}
#vizBig{
  position:fixed;left:0;top:var(--top);right:0;bottom:0;
  z-index:40;display:none;
}
#vizBig canvas{position:absolute;inset:0;width:100%;height:100%;background:#000}
#vizBig .label{
  position:absolute;left:8px;bottom:8px;
  border:1px solid var(--line);
  background:rgba(0,0,0,.55);
  padding:6px 8px;
  font:12px/1.2 var(--sans);
  color:var(--muted);
}
body.vizSmall #vizSmall{display:block}
body.vizBig #vizBig{display:block}

body.invert{filter:invert(1)}
</style>
</head>

<body>
<div id="top">
  <div class="chip k">KETADATA // CAM SUBSTANCE</div>

  <div class="btn" id="start">START CAM</div>
  <div class="btn" id="stopCam">STOP CAM</div>
  <div class="btn" id="run">STOP</div>
  <div class="btn" id="invert">INVERT</div>
  <div class="btn" id="vizToggle">VIZ: OFF</div>

  <div class="chip">FLOW <input id="flow" type="range" min="0" max="100" value="76"></div>
  <div class="chip">REACT <input id="react" type="range" min="0" max="100" value="92"></div>
  <div class="chip">TRAIL <input id="trail" type="range" min="0" max="100" value="92"></div>
  <div class="chip">THR <input id="thr" type="range" min="1" max="80" value="10"></div>
  <div class="chip">DENS <input id="dens" type="range" min="30000" max="220000" value="120000"></div>

  <div class="sep"></div>
  <div class="chip k" id="status">LOCAL</div>
</div>

<canvas id="stage"></canvas>

<canvas id="vizSmall" width="260" height="160"></canvas>
<div id="vizBig">
  <canvas id="vizBigCanvas"></canvas>
  <div class="label">
    <div class="k">VIZ BIG</div>
    <div>V = cycle viz • Esc = close big viz</div>
  </div>
</div>

<video id="video" playsinline muted autoplay></video>

<script>
(() => {
  const $ = id => document.getElementById(id);

  const stage = $("stage");
  const sctx = stage.getContext("2d",{alpha:false});

  const vizSmall = $("vizSmall");
  const vsctx = vizSmall.getContext("2d");

  const vizBigCanvas = $("vizBigCanvas");
  const vbctx = vizBigCanvas.getContext("2d");

  let W=0,H=0,DPR=1;
  const TOP=44;

  function resizeStage(){
    DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
    W = Math.max(1, Math.floor((stage.offsetWidth||1) * DPR));
    H = Math.max(1, Math.floor((stage.offsetHeight||1) * DPR));
    stage.width=W; stage.height=H;
  }
  function resizeVizBig(){
    const w = Math.max(1, Math.floor(innerWidth * DPR));
    const h = Math.max(1, Math.floor((innerHeight - TOP) * DPR));
    vizBigCanvas.width=w; vizBigCanvas.height=h;
  }
  function resizeAll(){ resizeStage(); resizeVizBig(); }
  addEventListener("resize", resizeAll);
  addEventListener("orientationchange", () => setTimeout(resizeAll, 60));
  setTimeout(resizeAll, 0);

  const STATE={
    running:true,
    flow:0.76,
    react:0.92,
    trail:0.92,
    thr:10,
    dens:120000,
    camOn:false,
    vizMode:0 // 0 off, 1 small, 2 big
  };

  const setStatus = s => ($("status").textContent = s);

  $("invert").onclick = () => document.body.classList.toggle("invert");

  function applyVizMode(){
    document.body.classList.toggle("vizSmall", STATE.vizMode===1);
    document.body.classList.toggle("vizBig", STATE.vizMode===2);
    $("vizToggle").textContent = STATE.vizMode===0 ? "VIZ: OFF" : (STATE.vizMode===1 ? "VIZ: SMALL" : "VIZ: BIG");
    if(STATE.vizMode===2) setTimeout(resizeVizBig, 40);
  }
  $("vizToggle").onclick = () => { STATE.vizMode=(STATE.vizMode+1)%3; applyVizMode(); };

  $("flow").oninput  = e => STATE.flow=(+e.target.value)/100;
  $("react").oninput = e => STATE.react=(+e.target.value)/100;
  $("trail").oninput = e => STATE.trail=(+e.target.value)/100;
  $("thr").oninput   = e => STATE.thr=(+e.target.value)|0;
  $("dens").oninput  = e => STATE.dens=(+e.target.value)|0;

  $("run").onclick = () => { STATE.running=!STATE.running; $("run").textContent=STATE.running?"STOP":"RUN"; };

  addEventListener("keydown",(e)=>{
    if(e.repeat) return;
    const k=e.key.toLowerCase();
    if(k==="v"){ STATE.vizMode=(STATE.vizMode+1)%3; applyVizMode(); }
    if(k==="escape" && STATE.vizMode===2){ STATE.vizMode=0; applyVizMode(); }
  });

  // ===== CAM + FIELD + MOTION HEATMAP =====
  const video=$("video");
  let stream=null;

  const DET_W=200, DET_H=112; // more detail => clearer accumulation
  const det=document.createElement("canvas");
  det.width=DET_W; det.height=DET_H;
  const dctx=det.getContext("2d",{willReadFrequently:true});

  // velocity field
  let VX=new Float32Array(DET_W*DET_H);
  let VY=new Float32Array(DET_W*DET_H);

  // motion “heat” field (where movement happens). drives accumulation.
  let HEAT=new Float32Array(DET_W*DET_H);

  let prevLuma=null;

  let energy=0, energySmooth=0;

  function stopCam(){
    if(stream){ try{ for(const t of stream.getTracks()) t.stop(); }catch(_){} }
    stream=null; STATE.camOn=false;
    prevLuma=null;
    VX.fill(0); VY.fill(0); HEAT.fill(0);
    energy=0; energySmooth=0;
    setStatus("LOCAL");
  }

  async function startCam(){
    if(STATE.camOn) return;
    setStatus("CAM REQUEST");
    try{
      stream=await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:"user", width:{ideal:1280}, height:{ideal:720} },
        audio:false
      });
      video.srcObject=stream;
      await video.play();
      STATE.camOn=true;
      prevLuma=null;
      setStatus("CAM ON");
    }catch(e){
      setStatus("CAM BLOCKED");
    }
  }

  $("start").onclick=startCam;
  $("stopCam").onclick=stopCam;

  function updateField(){
    if(!STATE.camOn){ energy=0; return null; }

    // mirrored feed
    dctx.save();
    dctx.scale(-1,1);
    dctx.drawImage(video, -DET_W, 0, DET_W, DET_H);
    dctx.restore();

    const data=dctx.getImageData(0,0,DET_W,DET_H).data;

    const cur=new Uint8Array(DET_W*DET_H);
    let p=0;
    for(let i=0;i<data.length;i+=4){
      const r=data[i], g=data[i+1], b=data[i+2];
      cur[p++]=(r*0.2126+g*0.7152+b*0.0722)|0;
    }

    if(!prevLuma){ prevLuma=cur; energy=0; return null; }

    const thr=STATE.thr|0;

    // persistence for velocity + heat
    const vDecay = 0.82 + 0.16*STATE.flow;          // substance inertia
    const hDecay = 0.90 + 0.08*STATE.trail;         // accumulation persistence
    for(let i=0;i<VX.length;i++){ VX[i]*=vDecay; VY[i]*=vDecay; HEAT[i]*=hDecay; }

    const diff=new Uint8Array(DET_W*DET_H);
    let total=0;

    for(let i=0;i<diff.length;i++){
      const d=Math.abs(cur[i]-prevLuma[i]);
      prevLuma[i]=cur[i];
      diff[i]=d;
      if(d>thr) total += (d-thr);
    }

    // global energy for reactivity
    const norm=(DET_W*DET_H)*8.0;
    energy=Math.max(0, Math.min(2.0, total/norm));
    energySmooth = energySmooth*0.88 + energy*0.12;

    // injection strengths
    const baseInject = 0.0024 + 0.012*STATE.flow;
    const inject = baseInject * (1.0 + 4.5*(STATE.react*energySmooth));

    // HEAT inject (accumulation): motion directly deposits “ink” into HEAT
    const heatInject = (0.003 + 0.020*STATE.react) * (0.6 + 1.8*energySmooth);

    for(let y=1;y<DET_H-1;y++){
      const row=y*DET_W;
      for(let x=1;x<DET_W-1;x++){
        const i=row+x;
        const d=diff[i];
        if(d<thr) continue;

        // deposit heat where motion is detected
        const w = (d - thr) / (80 - thr + 1e-6); // 0..1-ish
        HEAT[i] = Math.min(1.0, HEAT[i] + heatInject * (0.25 + 1.8*w));

        // gradient-based velocity (substance flow around edges)
        const gx = (diff[i+1] - diff[i-1]);
        const gy = (diff[i+DET_W] - diff[i-DET_W]);
        const mag = Math.hypot(gx,gy) + 1e-6;

        // swirl perpendicular component for liquid-like circulation
        const ux = gx/mag, uy = gy/mag;
        const px = -uy, py = ux; // perpendicular

        const swirl = ((x+y)&1) ? 1 : -1;

        const s = inject * (0.35 + 3.8*w);

        // blend gradient + perpendicular swirl
        VX[i] += (0.55*ux + 0.45*px*swirl) * s;
        VY[i] += (0.55*uy + 0.45*py*swirl) * s;
      }
    }

    // optional mild blur of HEAT to make “blobs” instead of pixel dust
    // (cheap 1-pass box blur on a sparse grid)
    if(energySmooth > 0.08){
      const tmp = new Float32Array(HEAT.length);
      for(let y=1;y<DET_H-1;y++){
        const row=y*DET_W;
        for(let x=1;x<DET_W-1;x++){
          const i=row+x;
          tmp[i] = (HEAT[i] + HEAT[i-1] + HEAT[i+1] + HEAT[i-DET_W] + HEAT[i+DET_W]) * 0.2;
        }
      }
      HEAT.set(tmp);
    }

    return diff;
  }

  function drawViz(diff){
    if(STATE.vizMode===0 || !diff) return;

    const ctx = (STATE.vizMode===1) ? vsctx : vbctx;
    const outW = (STATE.vizMode===1) ? vizSmall.width : vizBigCanvas.width;
    const outH = (STATE.vizMode===1) ? vizSmall.height : vizBigCanvas.height;

    ctx.fillStyle="#000";
    ctx.fillRect(0,0,outW,outH);

    // show HEAT as main layer (accumulation)
    const img = ctx.createImageData(DET_W, DET_H);
    for(let i=0;i<HEAT.length;i++){
      const h = Math.max(0, Math.min(1, HEAT[i]));
      const a = Math.floor(h*255);
      const o=i*4;
      img.data[o]=255; img.data[o+1]=255; img.data[o+2]=255;
      img.data[o+3]=a;
    }
    const tmp=document.createElement("canvas");
    tmp.width=DET_W; tmp.height=DET_H;
    tmp.getContext("2d").putImageData(img,0,0);

    ctx.imageSmoothingEnabled=false;
    ctx.drawImage(tmp,0,0,DET_W,DET_H,0,0,outW,outH);

    // overlay current diff faintly (so you see live edges)
    ctx.globalAlpha=0.35;
    const img2 = ctx.createImageData(DET_W, DET_H);
    for(let i=0;i<diff.length;i++){
      const v = diff[i];
      const a = Math.max(0, Math.min(255, (v-STATE.thr)*8));
      const o=i*4;
      img2.data[o]=255; img2.data[o+1]=255; img2.data[o+2]=255;
      img2.data[o+3]=a;
    }
    const tmp2=document.createElement("canvas");
    tmp2.width=DET_W; tmp2.height=DET_H;
    tmp2.getContext("2d").putImageData(img2,0,0);
    ctx.drawImage(tmp2,0,0,DET_W,DET_H,0,0,outW,outH);
    ctx.globalAlpha=1;

    // energy bar
    const e=Math.max(0, Math.min(1, energySmooth/1.2));
    ctx.fillStyle="rgba(255,255,255,.18)";
    ctx.fillRect(8,outH-12,outW-16,4);
    ctx.fillStyle="rgba(255,255,255,.86)";
    ctx.fillRect(8,outH-12,(outW-16)*e,4);

    ctx.strokeStyle="rgba(255,255,255,.22)";
    ctx.strokeRect(0.5,0.5,outW-1,outH-1);
  }

  // ===== PARTICLES (ACCUMULATE INTO HEAT REGIONS) =====
  let P=[];
  function reseed(n){
    P.length=0;
    for(let i=0;i<n;i++){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()-.5)*0.08,
        vy:(Math.random()-.5)*0.08,
        // per-particle “stickiness” so some accumulate harder
        stick: 0.25 + Math.random()*0.75
      });
    }
  }
  reseed(STATE.dens);

  function ensureDensity(){
    const n=STATE.dens|0;
    if(P.length===n) return;
    if(P.length>n){ P.length=n; return; }
    while(P.length<n){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()-.5)*0.08,
        vy:(Math.random()-.5)*0.08,
        stick: 0.25 + Math.random()*0.75
      });
    }
  }

  function sampleField(x,y){
    const fx=(x/W)*(DET_W-1);
    const fy=(y/H)*(DET_H-1);
    const x0=fx|0, y0=fy|0;
    const x1=Math.min(DET_W-1,x0+1);
    const y1=Math.min(DET_H-1,y0+1);
    const tx=fx-x0, ty=fy-y0;

    const i00=y0*DET_W+x0;
    const i10=y0*DET_W+x1;
    const i01=y1*DET_W+x0;
    const i11=y1*DET_W+x1;

    const vx0=VX[i00]*(1-tx)+VX[i10]*tx;
    const vx1=VX[i01]*(1-tx)+VX[i11]*tx;
    const vy0=VY[i00]*(1-tx)+VY[i10]*tx;
    const vy1=VY[i01]*(1-tx)+VY[i11]*tx;

    const heat0=HEAT[i00]*(1-tx)+HEAT[i10]*tx;
    const heat1=HEAT[i01]*(1-tx)+HEAT[i11]*tx;
    const heat = heat0*(1-ty)+heat1*ty;

    return {
      vx: vx0*(1-ty)+vx1*ty,
      vy: vy0*(1-ty)+vy1*ty,
      heat
    };
  }

  function clamp(v,min,max){ return v<min?min:(v>max?max:v); }

  // ===== LOOP =====
  let last=performance.now();
  function frame(t){
    requestAnimationFrame(frame);
    if(!STATE.running) return;

    resizeAll();
    ensureDensity();

    const dt=Math.min(32, t-last); last=t;

    const diff=updateField();
    drawViz(diff);

    // CLEAR: keep trails strong so accumulation is visible
    const baseClear = 0.10 - 0.095*STATE.trail; // 0.005..0.10
    // motion makes it even less clear (ink builds)
    const clearA = Math.max(0.004, baseClear - (STATE.react*energySmooth*0.05));
    sctx.globalCompositeOperation="source-over";
    sctx.fillStyle=`rgba(0,0,0,${clearA})`;
    sctx.fillRect(0,0,W,H);

    // DRAW: brightness increases with heat (so blobs appear clearly)
    sctx.globalCompositeOperation="lighter";

    // stable alpha floor + heat-driven boost
    const alphaFloor = 0.28;
    const alphaBoost = 0.55*(STATE.react*energySmooth);
    const alphaBase  = 0.20 + 0.12*STATE.flow;

    // Controlled speed so points linger where heat is
    const fieldScale = (900 + 2800*STATE.flow) * (1.0 + 3.8*(STATE.react*energySmooth));
    const jitter = (0.004 + 0.030*STATE.flow) * (1.0 + 6.0*(STATE.react*energySmooth));

    // Heat attraction: particles drift toward higher HEAT regions (accumulation)
    // We approximate gradient by sampling nearby heat values.
    const heatPull = (0.40 + 2.2*STATE.react) * (0.35 + 1.4*energySmooth); // strong
    const maxSpeed = 1.2 + 3.5*STATE.flow;

    const px = (energySmooth > 0.22) ? 2 : 1;

    for(const p of P){
      const s = sampleField(p.x,p.y);

      // heat gradient sample (cheap)
      const eps = 6*DPR;
      const sR = sampleField((p.x+eps+W)%W, p.y);
      const sL = sampleField((p.x-eps+W)%W, p.y);
      const sU = sampleField(p.x, (p.y-eps+H)%H);
      const sD = sampleField(p.x, (p.y+eps+H)%H);

      const gx = (sR.heat - sL.heat);
      const gy = (sD.heat - sU.heat);

      // if particle is in hot region, it "sticks" (damping increases) => accumulation
      const stick = p.stick;
      const sticky = Math.min(1, s.heat * stick);
      const damp = 0.94 - 0.22*sticky; // hotter => more damping

      // combine velocity field + heat gradient pull
      p.vx = p.vx*damp + s.vx*fieldScale + gx*heatPull + (Math.random()-0.5)*jitter;
      p.vy = p.vy*damp + s.vy*fieldScale + gy*heatPull + (Math.random()-0.5)*jitter;

      p.vx = clamp(p.vx, -maxSpeed, maxSpeed);
      p.vy = clamp(p.vy, -maxSpeed, maxSpeed);

      p.x += p.vx*dt;
      p.y += p.vy*dt;

      if(p.x<0) p.x+=W; else if(p.x>=W) p.x-=W;
      if(p.y<0) p.y+=H; else if(p.y>=H) p.y-=H;

      // brightness scales with local heat so accumulation becomes obvious
      const a = Math.max(alphaFloor, alphaBase + alphaBoost + 0.55*s.heat);
      sctx.fillStyle = `rgba(255,255,255,${Math.min(0.98,a)})`;
      sctx.fillRect(p.x, p.y, px, px);
    }

    sctx.globalCompositeOperation="source-over";

    if(STATE.camOn) setStatus(energySmooth>0.05 ? "CAM + ACCUMULATE" : "CAM (LOW MOTION)");
    else setStatus("LOCAL");
  }

  requestAnimationFrame(frame);
  addEventListener("beforeunload", () => { try{ stopCam(); }catch(_){} });

  applyVizMode();
})();
</script>

<!--
AE: KETADATA
EE: CAM_SUBSTANCE_ACCUMULATION
WB: SINGLE_FILE_HTML
FILE_ID: KETA_CAM_SUBSTANCE_ACCUM_v1
ROOM_ID: BASE
VERSION: 1
UPDATED_AT: 2026-01-08
CHANGELOG:
- v1: adds motion HEAT field that accumulates where movement occurs; particles are attracted to HEAT gradients and become "sticky" in hot zones for visible clustering; VIZ shows HEAT live
-->
</body>
</html>
