<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE TRAP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
        }

        #container {
            position: relative;
            width: 1000px;
            height: 1000px;
        }

        #yinyang {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
            opacity: 0;
            background: #fff;
            border-radius: 50%;
            overflow: hidden;
        }

        .yang-half {
            position: absolute;
            width: 150px;
            height: 300px;
            background: #000;
            right: 0;
        }

        .white-circle {
            position: absolute;
            width: 150px;
            height: 150px;
            background: #fff;
            border-radius: 50%;
            bottom: 0;
            left: 75px;
            transform: translateX(-50%);
        }

        .black-circle {
            position: absolute;
            width: 150px;
            height: 150px;
            background: #000;
            border-radius: 50%;
            top: 0;
            left: 75px;
            transform: translateX(-50%);
        }

        .white-dot {
            position: absolute;
            top: 75px;
            left: 225px;
            width: 50px;
            height: 50px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
        }

        .black-dot {
            position: absolute;
            top: 225px;
            left: 75px;
            width: 50px;
            height: 50px;
            background: #000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
        }

        .element {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
        }

        .ring {
            border-radius: 50%;
            border-width: 1px;
            border-style: solid;
        }

        .spoke {
            width: 1px;
            transform-origin: center top;
        }

        .particle {
            width: 3px;
            height: 3px;
            border-radius: 50%;
        }

        .mandala-point {
            width: 2px;
            height: 2px;
            background: #fff;
            border-radius: 50%;
        }

        .web-line {
            width: 1px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.3), transparent);
            transform-origin: center top;
        }

        .orbit-ring {
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.1);
        }

        #flash-white, #flash-black {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            opacity: 0;
            pointer-events: none;
        }

        #flash-white { background: #fff; }
        #flash-black { background: #000; }

        #phase {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #555;
            font-size: 11px;
            z-index: 1000;
            letter-spacing: 3px;
        }

        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .phase-button {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #888;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s;
        }

        .phase-button:hover {
            background: #2a2a2a;
            color: #fff;
            border-color: #666;
        }

        .phase-button.active {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        #stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #444;
            font-size: 9px;
            z-index: 1000;
            line-height: 1.8;
        }

        .fractal-ring {
            border-radius: 50%;
            border: 1px solid;
        }
    </style>
</head>
<body>
    <div id="phase">AWAKENING...</div>
    <div id="controls">
        <button class="phase-button" data-phase="1">PHASE 1: LURE</button>
        <button class="phase-button" data-phase="2">PHASE 2: SYNC</button>
        <button class="phase-button" data-phase="3">PHASE 3: BREAK</button>
        <button class="phase-button" data-phase="4">PHASE 4: DOMINATE</button>
    </div>
    <div id="stats"></div>
    <div id="flash-white"></div>
    <div id="flash-black"></div>
    <div id="container">
        <div id="yinyang">
            <div class="yang-half"></div>
            <div class="black-circle"></div>
            <div class="white-circle"></div>
            <div class="white-dot"></div>
            <div class="black-dot"></div>
        </div>
    </div>

    <script>
        const container = document.getElementById('container');
        const yinyang = document.getElementById('yinyang');
        const flashWhite = document.getElementById('flash-white');
        const flashBlack = document.getElementById('flash-black');
        const phaseText = document.getElementById('phase');
        const statsText = document.getElementById('stats');

        let frame = 0;
        const breathCycle = 10000;
        let phase = 1;
        let elements = [];
        let manualPhase = false;

        // Get phase buttons
        const phaseButtons = document.querySelectorAll('.phase-button');
        
        // Add click handlers to phase buttons
        phaseButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetPhase = parseInt(button.dataset.phase);
                phase = targetPhase;
                manualPhase = true;
                
                // Set frame to start of that phase
                if (phase === 1) frame = 0;
                else if (phase === 2) frame = 600;
                else if (phase === 3) frame = 1200;
                else if (phase === 4) frame = 1800;
                
                // Update active button
                phaseButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
            });
        });

        // Layers of complexity
        const layers = {
            rings: [],
            spokes: [],
            particles: [],
            mandalaPoints: [],
            webLines: [],
            orbitRings: [],
            fractalRings: []
        };

        // Create 24 rings (ultra slow reveal)
        for (let i = 0; i < 24; i++) {
            const ring = document.createElement('div');
            ring.className = 'element ring';
            ring.style.borderColor = i % 2 === 0 ? '#fff' : '#000';
            container.appendChild(ring);
            layers.rings.push({ el: ring, index: i, revealed: false });
        }

        // Create 16 primary spokes
        for (let i = 0; i < 16; i++) {
            const spoke = document.createElement('div');
            spoke.className = 'element spoke';
            spoke.style.background = i % 2 === 0 ? 
                'linear-gradient(to bottom, #fff, transparent)' : 
                'linear-gradient(to bottom, #000, rgba(255,255,255,0.1))';
            container.appendChild(spoke);
            layers.spokes.push({ el: spoke, index: i, revealed: false });
        }

        // Create 64 mandala points (sacred geometry)
        for (let i = 0; i < 64; i++) {
            const point = document.createElement('div');
            point.className = 'element mandala-point';
            container.appendChild(point);
            layers.mandalaPoints.push({ el: point, index: i, angle: (360 / 64) * i, revealed: false });
        }

        // Create 80 particles
        for (let i = 0; i < 80; i++) {
            const particle = document.createElement('div');
            particle.className = 'element particle';
            particle.style.background = i % 2 === 0 ? '#fff' : '#000';
            particle.style.boxShadow = i % 2 === 0 ? '0 0 4px #fff' : 'none';
            particle.style.border = i % 2 === 1 ? '1px solid #fff' : 'none';
            container.appendChild(particle);
            layers.particles.push({ 
                el: particle, 
                index: i, 
                angle: Math.random() * Math.PI * 2,
                speed: 0.3 + Math.random() * 0.7,
                distance: 150 + Math.random() * 250,
                revealed: false
            });
        }

        // Create 32 web lines
        for (let i = 0; i < 32; i++) {
            const line = document.createElement('div');
            line.className = 'element web-line';
            container.appendChild(line);
            layers.webLines.push({ el: line, index: i, revealed: false });
        }

        // Create 12 orbit rings
        for (let i = 0; i < 12; i++) {
            const orbit = document.createElement('div');
            orbit.className = 'element orbit-ring';
            container.appendChild(orbit);
            layers.orbitRings.push({ el: orbit, index: i, revealed: false });
        }

        // Create 48 fractal rings
        for (let i = 0; i < 48; i++) {
            const fractal = document.createElement('div');
            fractal.className = 'element fractal-ring';
            fractal.style.borderColor = `rgba(255,255,255,${0.1 + (i % 8) * 0.05})`;
            container.appendChild(fractal);
            layers.fractalRings.push({ el: fractal, index: i, revealed: false });
        }

        function updatePhase() {
            // Only auto-progress if not in manual mode
            if (!manualPhase) {
                // Phases are much longer - 600 frames each = 2400 total
                if (frame < 600) {
                    phase = 1;
                } else if (frame < 1200) {
                    phase = 2;
                } else if (frame < 1800) {
                    phase = 3;
                } else {
                    phase = 4;
                }
            }
            
            // Update phase text
            if (phase === 1) {
                phaseText.textContent = 'PHASE 1: LURE — The Slow Awakening';
            } else if (phase === 2) {
                phaseText.textContent = 'PHASE 2: SYNC — Breathing in Unison';
            } else if (phase === 3) {
                phaseText.textContent = 'PHASE 3: BREAK — The Pattern Fractures';
            } else {
                phaseText.textContent = 'PHASE 4: DOMINATE — Infinite Recursion';
            }
            
            // Update active button
            phaseButtons.forEach(btn => {
                if (parseInt(btn.dataset.phase) === phase) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            const revealed = {
                rings: layers.rings.filter(r => r.revealed).length,
                spokes: layers.spokes.filter(s => s.revealed).length,
                mandala: layers.mandalaPoints.filter(m => m.revealed).length,
                particles: layers.particles.filter(p => p.revealed).length,
                webs: layers.webLines.filter(w => w.revealed).length,
                orbits: layers.orbitRings.filter(o => o.revealed).length,
                fractals: layers.fractalRings.filter(f => f.revealed).length
            };

            statsText.innerHTML = `
                TIME: ${(frame / 60).toFixed(1)}s / 40s<br>
                PHASE: ${phase}/4 ${manualPhase ? '(MANUAL)' : '(AUTO)'}<br>
                RINGS: ${revealed.rings}/24<br>
                SPOKES: ${revealed.spokes}/16<br>
                MANDALA: ${revealed.mandala}/64<br>
                PARTICLES: ${revealed.particles}/80<br>
                WEBS: ${revealed.webs}/32<br>
                ORBITS: ${revealed.orbits}/12<br>
                FRACTALS: ${revealed.fractals}/48
            `;
        }

        function breathPulse(t) {
            return (Math.sin(t * Math.PI * 2 / breathCycle) + 1) / 2;
        }

        function revealElement(layer, index, phase) {
            const element = layer[index];
            if (!element || element.revealed) return;
            element.revealed = true;
        }

        function animate() {
            frame++;
            updatePhase();

            const t = Date.now();
            const breath = breathPulse(t);

            // PHASE 1: Ultra slow reveal - everything builds gradually
            if (phase === 1) {
                // Yin Yang fades in over 200 frames
                yinyang.style.opacity = Math.min(1, frame / 200);
                yinyang.style.transform = `translate(-50%, -50%) scale(${0.4 + breath * 0.1}) rotate(${frame * 0.1}deg)`;

                // Reveal 1 ring every 25 frames
                if (frame % 25 === 0) {
                    const nextRing = layers.rings.find(r => !r.revealed);
                    if (nextRing) nextRing.revealed = true;
                }

                // Reveal 1 spoke every 37 frames
                if (frame % 37 === 0) {
                    const nextSpoke = layers.spokes.find(s => !s.revealed);
                    if (nextSpoke) nextSpoke.revealed = true;
                }

                // Reveal mandala points slowly
                if (frame % 9 === 0) {
                    const nextPoint = layers.mandalaPoints.find(m => !m.revealed);
                    if (nextPoint) nextPoint.revealed = true;
                }

                // Animate revealed elements
                layers.rings.forEach((ring, i) => {
                    if (!ring.revealed) return;
                    const size = 100 + i * 35 + breath * 15;
                    const opacity = (1 - i / 24) * 0.3;
                    ring.el.style.width = size + 'px';
                    ring.el.style.height = size + 'px';
                    ring.el.style.opacity = opacity;
                });

                layers.spokes.forEach((spoke, i) => {
                    if (!spoke.revealed) return;
                    const angle = (360 / 16) * i + frame * 0.1;
                    spoke.el.style.height = '200px';
                    spoke.el.style.transform = `translate(-50%, 0) rotate(${angle}deg)`;
                    spoke.el.style.opacity = 0.2;
                });

                layers.mandalaPoints.forEach((point, i) => {
                    if (!point.revealed) return;
                    const radius = 180 + (i % 8) * 15;
                    const angle = point.angle + frame * 0.05;
                    const x = 500 + Math.cos(angle * Math.PI / 180) * radius;
                    const y = 500 + Math.sin(angle * Math.PI / 180) * radius;
                    point.el.style.left = x + 'px';
                    point.el.style.top = y + 'px';
                    point.el.style.opacity = 0.4;
                });
            }

            // PHASE 2: Continue building, add particles and orbits
            else if (phase === 2) {
                const phaseFrame = frame - 600;
                
                yinyang.style.opacity = 0.9 + breath * 0.1;
                yinyang.style.transform = `translate(-50%, -50%) scale(${0.5 + breath * 0.15}) rotate(${frame * 0.3}deg)`;

                // Reveal remaining rings
                if (phaseFrame % 20 === 0) {
                    const nextRing = layers.rings.find(r => !r.revealed);
                    if (nextRing) nextRing.revealed = true;
                }

                // Reveal particles slowly
                if (phaseFrame % 8 === 0) {
                    const nextParticle = layers.particles.find(p => !p.revealed);
                    if (nextParticle) nextParticle.revealed = true;
                }

                // Reveal orbit rings
                if (phaseFrame % 50 === 0) {
                    const nextOrbit = layers.orbitRings.find(o => !o.revealed);
                    if (nextOrbit) nextOrbit.revealed = true;
                }

                // Animate with breathing delays
                layers.rings.forEach((ring, i) => {
                    if (!ring.revealed) return;
                    const delayedBreath = breathPulse(t - i * 100);
                    const size = 120 + i * 32 + delayedBreath * 25;
                    const opacity = (1 - i / 24) * 0.4 * delayedBreath;
                    ring.el.style.width = size + 'px';
                    ring.el.style.height = size + 'px';
                    ring.el.style.opacity = opacity;
                    ring.el.style.borderWidth = (1 + delayedBreath * 2) + 'px';
                });

                layers.spokes.forEach((spoke, i) => {
                    if (!spoke.revealed) return;
                    const angle = (360 / 16) * i + frame * 0.4;
                    spoke.el.style.height = (180 + breath * 40) + 'px';
                    spoke.el.style.transform = `translate(-50%, 0) rotate(${angle}deg)`;
                    spoke.el.style.opacity = 0.25 + breath * 0.15;
                });

                layers.particles.forEach((p, i) => {
                    if (!p.revealed) return;
                    p.angle += p.speed * 0.01;
                    const x = 500 + Math.cos(p.angle) * p.distance * (0.9 + breath * 0.2);
                    const y = 500 + Math.sin(p.angle) * p.distance * (0.9 + breath * 0.2);
                    p.el.style.left = x + 'px';
                    p.el.style.top = y + 'px';
                    p.el.style.opacity = 0.3 + breath * 0.2;
                });

                layers.mandalaPoints.forEach((point, i) => {
                    if (!point.revealed) return;
                    const radius = 200 + (i % 8) * 18 + breath * 10;
                    const angle = point.angle + frame * 0.08;
                    const x = 500 + Math.cos(angle * Math.PI / 180) * radius;
                    const y = 500 + Math.sin(angle * Math.PI / 180) * radius;
                    point.el.style.left = x + 'px';
                    point.el.style.top = y + 'px';
                    point.el.style.opacity = 0.5;
                });

                layers.orbitRings.forEach((orbit, i) => {
                    if (!orbit.revealed) return;
                    const size = 250 + i * 50;
                    orbit.el.style.width = size + 'px';
                    orbit.el.style.height = size + 'px';
                    orbit.el.style.opacity = 0.15;
                });

                // Begin subtle flashing
                if (phaseFrame % 80 === 0) {
                    flashWhite.style.opacity = 0.03;
                    setTimeout(() => flashWhite.style.opacity = 0, 40);
                }
            }

            // PHASE 3: Chaos - reveal webs and fractals, break patterns
            else if (phase === 3) {
                const phaseFrame = frame - 1200;

                // Jittery yin yang
                const jitter = (Math.random() - 0.5) * 30;
                yinyang.style.opacity = 0.7 + Math.random() * 0.3;
                yinyang.style.transform = `translate(-50%, -50%) scale(${0.6 + breath * 0.3 + Math.random() * 0.2}) rotate(${frame * (0.5 + Math.random() * 0.5) + jitter}deg)`;

                // Reveal web lines
                if (phaseFrame % 18 === 0) {
                    const nextWeb = layers.webLines.find(w => !w.revealed);
                    if (nextWeb) nextWeb.revealed = true;
                }

                // Reveal fractals
                if (phaseFrame % 12 === 0) {
                    const nextFractal = layers.fractalRings.find(f => !f.revealed);
                    if (nextFractal) nextFractal.revealed = true;
                }

                // Finish revealing all particles
                if (phaseFrame % 5 === 0) {
                    const nextParticle = layers.particles.find(p => !p.revealed);
                    if (nextParticle) nextParticle.revealed = true;
                }

                // Chaotic animations
                layers.rings.forEach((ring, i) => {
                    if (!ring.revealed) return;
                    const randomOffset = Math.random() * 60;
                    const size = 100 + i * 35 + breath * 40 + randomOffset;
                    ring.el.style.width = size + 'px';
                    ring.el.style.height = size + 'px';
                    ring.el.style.opacity = Math.random() * 0.6;
                    ring.el.style.borderWidth = (1 + Math.random() * 4) + 'px';
                });

                layers.spokes.forEach((spoke, i) => {
                    if (!spoke.revealed) return;
                    const symmetry = [12, 14, 16, 18][Math.floor(frame / 40) % 4];
                    const angle = (360 / symmetry) * (i % symmetry) + frame * (0.3 + Math.random() * 0.8);
                    const length = 150 + Math.random() * 120;
                    spoke.el.style.height = length + 'px';
                    spoke.el.style.transform = `translate(-50%, 0) rotate(${angle}deg)`;
                    spoke.el.style.opacity = Math.random() * 0.7;
                    spoke.el.style.width = (1 + Math.random() * 3) + 'px';
                });

                layers.particles.forEach((p, i) => {
                    if (!p.revealed) return;
                    p.angle += p.speed * (0.02 + Math.random() * 0.02);
                    p.distance += (Math.random() - 0.5) * 8;
                    const x = 500 + Math.cos(p.angle) * p.distance;
                    const y = 500 + Math.sin(p.angle) * p.distance;
                    p.el.style.left = x + 'px';
                    p.el.style.top = y + 'px';
                    p.el.style.opacity = Math.random() * 0.8;
                });

                layers.webLines.forEach((line, i) => {
                    if (!line.revealed) return;
                    const angle = (360 / 32) * i + frame * (1 + Math.random());
                    const height = 250 + Math.random() * 200;
                    line.el.style.height = height + 'px';
                    line.el.style.transform = `translate(-50%, 0) rotate(${angle}deg)`;
                    line.el.style.opacity = Math.random() * 0.4;
                });

                layers.fractalRings.forEach((fractal, i) => {
                    if (!fractal.revealed) return;
                    const size = 80 + (i % 12) * 70 + Math.random() * 40;
                    fractal.el.style.width = size + 'px';
                    fractal.el.style.height = size + 'px';
                    fractal.el.style.opacity = Math.random() * 0.3;
                });

                // Random flashing
                if (Math.random() > 0.96) {
                    const flash = Math.random() > 0.5 ? flashWhite : flashBlack;
                    flash.style.opacity = 0.08 + Math.random() * 0.15;
                    setTimeout(() => flash.style.opacity = 0, 20 + Math.random() * 60);
                }
            }

            // PHASE 4: Total domination - everything revealed, maximum intensity
            else {
                // Reveal everything
                Object.values(layers).forEach(layer => {
                    layer.forEach(element => element.revealed = true);
                });

                yinyang.style.opacity = 1;
                yinyang.style.transform = `translate(-50%, -50%) scale(${0.7 + breath * 0.6}) rotate(${frame * 2.5}deg)`;
                yinyang.style.filter = `blur(${Math.sin(t / 80) * 3}px) brightness(${1 + breath * 0.3})`;

                // Everything strobes and pulses violently
                const strobe = (t % 300) < 150;

                layers.rings.forEach((ring, i) => {
                    const size = 120 + i * 35;
                    ring.el.style.width = size + 'px';
                    ring.el.style.height = size + 'px';
                    ring.el.style.opacity = strobe ? 0.8 : 0.1;
                    ring.el.style.borderWidth = '3px';
                });

                layers.spokes.forEach((spoke, i) => {
                    const angle = (360 / 16) * i + frame * 3;
                    spoke.el.style.height = '300px';
                    spoke.el.style.transform = `translate(-50%, 0) rotate(${angle}deg)`;
                    spoke.el.style.opacity = 0.8;
                    spoke.el.style.width = '3px';
                });

                layers.particles.forEach((p, i) => {
                    p.angle += 0.08;
                    const x = 500 + Math.cos(p.angle) * p.distance;
                    const y = 500 + Math.sin(p.angle) * p.distance;
                    p.el.style.left = x + 'px';
                    p.el.style.top = y + 'px';
                    p.el.style.opacity = 0.9;
                });

                layers.webLines.forEach((line, i) => {
                    const angle = (360 / 32) * i + frame * 2;
                    line.el.style.height = '400px';
                    line.el.style.transform = `translate(-50%, 0) rotate(${angle}deg)`;
                    line.el.style.opacity = 0.5;
                });

                layers.fractalRings.forEach((fractal, i) => {
                    const size = 90 + (i % 12) * 65;
                    fractal.el.style.width = size + 'px';
                    fractal.el.style.height = size + 'px';
                    fractal.el.style.opacity = strobe ? 0.4 : 0.05;
                });

                layers.mandalaPoints.forEach((point, i) => {
                    const radius = 220 + (i % 8) * 22;
                    const angle = point.angle + frame * 0.5;
                    const x = 500 + Math.cos(angle * Math.PI / 180) * radius;
                    const y = 500 + Math.sin(angle * Math.PI / 180) * radius;
                    point.el.style.left = x + 'px';
                    point.el.style.top = y + 'px';
                    point.el.style.opacity = 0.9;
                    point.el.style.transform = `scale(${2 + breath})`;
                });

                // Intense alternating strobes
                if (frame % 6 === 0) {
                    const flash = frame % 12 === 0 ? flashWhite : flashBlack;
                    flash.style.opacity = 0.25;
                    setTimeout(() => flash.style.opacity = 0, 35);
                }
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
