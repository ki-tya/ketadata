<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA ROUTER — ORGANISM (LIGAMENTS + ALL LINKS BAR)</title>
  <style>
    :root{
      /* KETADATA LAW: BLACK DEFAULT */
      --bg:#0b0b0b;
      --fg:#f2f2f2;
      --muted:#9a9a9a;
      --line:#2f2f2f;
      --hud:rgba(255,255,255,0.03);
      --hud2:rgba(0,0,0,0.35);
      --font:12px/1.15 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }
    html.invert{
      /* INVERT = WHITE WORLD */
      --bg:#ffffff;
      --fg:#111111;
      --muted:#6f6f6f;
      --line:#cfcfcf;
      --hud:rgba(0,0,0,0.03);
      --hud2:rgba(255,255,255,0.35);
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:var(--font);overflow:hidden;}
    *{box-sizing:border-box;}
    #canvas{position:fixed;inset:0;display:block;}

    html.null #hud, html.null #side, html.null #corner, html.null #allbar{display:none;}

    #hud{
      position:fixed;left:10px;top:10px;z-index:60;
      width:860px;max-width:calc(100vw - 20px);
      background:var(--hud);
      border:1px solid var(--line);
      padding:6px;
      backdrop-filter: blur(4px);
      user-select:none;
    }
    #hud .row{display:flex;gap:6px;flex-wrap:wrap;align-items:center;}
    #hud .row + .row{margin-top:6px;}
    #hud button,#hud select,#hud input{
      font:var(--font);
      padding:4px 6px;
      background:transparent;
      border:1px solid var(--line);
      color:var(--fg);
    }
    #hud button{cursor:pointer;}
    #hud input[type="range"]{padding:0;height:22px;}
    #hud .pill{display:inline-block;padding:3px 6px;border:1px solid var(--line);color:var(--muted);}
    #hud .label{color:var(--muted);}
    #hud .sp{flex:1;}

    #side{
      position:fixed;right:10px;top:10px;z-index:70;
      width:430px;max-height:calc(100vh - 20px);
      background:var(--hud);
      border:1px solid var(--line);
      padding:8px;overflow:auto;display:none;
      backdrop-filter: blur(4px);
    }
    #side .t{color:var(--muted);}
    #side .a{color:var(--fg);word-break:break-all;}
    #side .btns{margin-top:6px;display:flex;gap:6px;flex-wrap:wrap;}
    #side button{font:var(--font);padding:4px 6px;background:transparent;border:1px solid var(--line);cursor:pointer;color:var(--fg);}
    #side .list{margin-top:8px;border-top:1px solid var(--line);padding-top:8px;}
    #side .item{display:flex;gap:6px;align-items:center;padding:4px 0;border-bottom:1px dashed var(--line);}
    #side .item:last-child{border-bottom:none;}
    #side .name{flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
    #side .tag{color:var(--muted);}
    #side .dot{width:8px;height:8px;border:1px solid var(--line);border-radius:999px;display:inline-block;}
    #side .dot.public{background:var(--fg);}
    #side .dot.private{background:var(--muted);}
    #side .dot.unset{background:transparent;}
    #side .mini{padding:2px 6px;}

    #allbar{
      position:fixed;left:10px;right:10px;bottom:10px;z-index:65;
      background:var(--hud);
      border:1px solid var(--line);
      backdrop-filter: blur(4px);
      user-select:none;
      overflow:hidden;
    }
    #allbarHead{
      display:flex;gap:6px;align-items:center;
      padding:6px;
      border-bottom:1px solid var(--line);
    }
    #allbarHead .sp{flex:1;}
    #allbarHead button,#allbarHead select,#allbarHead input{
      font:var(--font);
      padding:4px 6px;
      background:transparent;
      border:1px solid var(--line);
      color:var(--fg);
    }
    #allbarHead button{cursor:pointer;}
    #allbarBody{
      display:none;
      max-height:40vh;
      overflow:auto;
      padding:6px;
    }
    #allbarBody .row{
      display:flex;gap:6px;align-items:center;
      padding:4px 0;border-bottom:1px dashed var(--line);
    }
    #allbarBody .row:last-child{border-bottom:none;}
    #allbarBody .c{color:var(--muted);min-width:110px;max-width:110px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
    #allbarBody .p{flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
    #allbarBody .dot{width:8px;height:8px;border:1px solid var(--line);border-radius:999px;display:inline-block;}
    #allbarBody .dot.public{background:var(--fg);}
    #allbarBody .dot.private{background:var(--muted);}
    #allbarBody .dot.unset{background:transparent;}
    #allbarBody button{font:var(--font);padding:2px 6px;background:transparent;border:1px solid var(--line);cursor:pointer;color:var(--fg);}

    #corner{position:fixed;left:10px;bottom:64px;z-index:40;color:var(--muted);user-select:none;}

    #glass{
      position:fixed;inset:0;pointer-events:none;z-index:20;
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.06),
        inset 0 0 120px rgba(255,255,255,.04),
        inset 0 0 260px rgba(255,255,255,.06);
      opacity:.35;
      mix-blend-mode:screen;
    }
    html.invert #glass{
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,.10),
        inset 0 0 120px rgba(0,0,0,.06),
        inset 0 0 260px rgba(0,0,0,.08);
      opacity:.55;
      mix-blend-mode:multiply;
    }

    #crash{
      position:fixed;inset:10px;z-index:9999;
      background:rgba(0,0,0,0.88);
      color:#fff;border:1px solid rgba(255,255,255,0.25);
      padding:10px;display:none;
      font:12px/1.2 ui-monospace, Menlo, Monaco, Consolas, monospace;
      white-space:pre-wrap;
    }
    html.invert #crash{
      background:rgba(255,255,255,0.92);
      color:#000;border:1px solid rgba(0,0,0,0.25);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="glass"></div>
  <div id="crash"></div>

  <div id="hud">
    <div class="row">
      <span class="pill">ROUTER • ORGANISM LIGAMENTS • CLICK CLUSTER = REVEAL</span>
      <span class="sp"></span>
      <span class="pill" id="pillRun">RUNNING</span>
      <span class="pill" id="pillFocus">FOCUS: NONE</span>
    </div>
    <div class="row">
      <button id="btnPause">PAUSE (SPACE)</button>
      <button id="btnRecenter">RECENTER</button>
      <button id="btnSettle">SETTLE</button>
      <button id="btnClear">CLEAR</button>
      <span class="label">ZOOM</span>
      <button id="btnZoomOut">-</button>
      <button id="btnZoomIn">+</button>
      <span class="label">SPEED</span>
      <input id="speed" type="range" min="0" max="2" step="0.05" value="1.15" />
      <span class="label">TENSION</span>
      <input id="tension" type="range" min="0.3" max="1.9" step="0.05" value="1.00" />
      <span class="label">PLANKTON</span>
      <input id="plank" type="range" min="0" max="1" step="0.01" value="0.70" />
      <span class="label">CHAOS</span>
      <input id="chaos" type="range" min="0" max="1.5" step="0.01" value="0.85" />
    </div>
    <div class="row">
      <span class="label">FILTER</span>
      <input id="q" type="text" placeholder="filter links..." />
      <span class="label">VIS</span>
      <select id="visFilter">
        <option value="ALL">ALL</option>
        <option value="PUBLIC">PUBLIC</option>
        <option value="PRIVATE">PRIVATE</option>
        <option value="UNSET">UNSET</option>
      </select>
      <button id="btnExportPublic">EXPORT PUBLIC</button>
      <button id="btnExportVis">EXPORT VIS</button>
      <button id="btnImport">IMPORT</button>
      <button id="btnResetVis">RESET VIS</button>
      <button id="btnAllbar">ALL LINKS (SHIFT+L)</button>
      <button id="btnNull">NULL (SHIFT+N)</button>
      <button id="btnInvert">INVERT (SHIFT+I)</button>
      <button id="btnFull">FULL (SHIFT+F)</button>
    </div>
  </div>

  <div id="side">
    <div class="t" id="sideTitle">FOCUS</div>
    <div class="a" id="sideMain"></div>

    <div class="t" style="margin-top:6px;">TYPE</div>
    <div class="a" id="sideType"></div>

    <div class="t" style="margin-top:6px;">URL</div>
    <div class="a" id="sideUrl"></div>

    <div class="t" style="margin-top:6px;">VISIBILITY</div>
    <div class="a" id="sideVis"></div>

    <div class="btns" id="sideBtns">
      <button id="openNew">OPEN</button>
      <button id="copyUrl">COPY</button>
      <button id="toggleVis">TOGGLE PUBLIC/PRIVATE</button>
      <button id="closeSide">CLOSE</button>
    </div>

    <div class="list" id="sideListWrap" style="display:none;">
      <div class="t">LINKS IN CLUSTER</div>
      <div class="a" id="sideCount"></div>
      <div style="margin-top:6px;display:flex;gap:6px;flex-wrap:wrap;">
        <button class="mini" id="btnOpenSome">OPEN 10</button>
        <button class="mini" id="btnExportCluster">EXPORT CLUSTER</button>
      </div>
      <div id="sideList"></div>
    </div>
  </div>

  <div id="allbar">
    <div id="allbarHead">
      <span class="pill">ALL LINKS</span>
      <span class="label">FIND</span>
      <input id="allQ" type="text" placeholder="search all..." />
      <span class="label">VIS</span>
      <select id="allVis">
        <option value="ALL">ALL</option>
        <option value="PUBLIC">PUBLIC</option>
        <option value="PRIVATE">PRIVATE</option>
        <option value="UNSET">UNSET</option>
      </select>
      <span class="sp"></span>
      <button id="allCollapse">COLLAPSE</button>
    </div>
    <div id="allbarBody"></div>
  </div>

  <div id="corner">DRAG EMPTY=PAN • DRAG NODE=PULL • WHEEL=ZOOM • CLICK CLUSTER=REVEAL • CLICK LINK SELECT; CLICK AGAIN OPEN</div>
  <input id="filePick" type="file" accept="application/json" style="display:none" />

<script>
(() => {
  const crash = (err) => {
    console.error(err);
    const d = document.getElementById("crash");
    d.style.display = "block";
    d.textContent = "KETADATA ROUTER ERROR\n\n" + (err && (err.stack || err.message) ? (err.stack || err.message) : String(err));
  };

  try {
    const BASE_URL = "https://ki-tya.github.io/ketadata/";
    const STORE_VIS = "KD_ROUTER_VIS_V1";

    // nondeterminism: live PRNG seeded by time + jitter
    const mulberry32 = (a) => () => {
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t ^= t + Math.imul(t ^ t >>> 7, 61 | t);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
    let rng = mulberry32(((Date.now() ^ (Math.random()*1e9)) >>> 0));
    const rand = (min=0, max=1) => min + (max-min)*rng();

    const CLUSTERS = [
      { name:"KETA-CORE", links:["based_diva9.html","elevator3.html","index.html","index013.html","index11.html","map.html","room.html"]},
      { name:"BLEAK-TECH", links:["ball.html","beatball.html","blacklotus2.html","bleak.html","chakra.html","memofesto.html"]},
      { name:"SCREENS", links:["cctv1.html","crunch1.html","darkroom1.html","kdtv1.html","obscura.html"]},
      { name:"EXPERIMENTS", links:[
        "003.html","aniversary1111.html","artaud.html","bataille1.html","borges.html","burroughs.html","capture.html",
        "capturegpt.html","capturegpt2.html","capturegpt3.html","capturegpt4.html","capturegpt5.html","capturegpt6.html",
        "capturegpt7.html","capturegpt8.html","christmas25.html","chroma.html","coffee.html","coffee1.html","cp1.html",
        "cube.html","cube1.html","debord.html","deleuze.html","dmt.html","dmt2.html","dmt3.html","dmt4.html","dmtzoom.html",
        "etal.html","funnel.html","funnel1.html","funnel2.html","funnel3.html","funnel4.html","goffman.html","gptsubject.html",
        "holzer.html","hyperstition.html","hyperstition1.html","hyperstition2.html","hyperstition3.html","hyperstition5.html",
        "index0.html","index001.html","index002.html","index003.html","index004.html","index005.html","index006.html","index007.html",
        "index008.html","index009.html","index01.html","index011.html","index012.html","index014.html","index015.html","index02.html",
        "index03.html","index04.html","index05.html","index06.html","index07.html","index08.html","index09.html","infinity.html","jung.html",
        "kitty.html","kmas.html","land.html","mandala.html","mandala2.html","mandala3.html","mandalagpt.html","mandalagpt2.html",
        "mandalagpt3.html","mandalagpt4.html","matrix.html","matryoshka.html","mcluhan.html","mdma.html","mdma2.html","mdmagpt.html",
        "mdmagpt2.html","misc.html","misc2.html","misc3.html","misc4.html","misc5.html","misc6.html","misc7.html","misc8.html",
        "molecule.html","newtrap.html","newtrap2.html","newtrap3.html","polka1.html","polka2.html","polkadot.html","pool.html","pool3.html",
        "pool4.html","pool5.html","pool6.html","release.html","release2.html","release3.html","release4.html","ripple.html","ripple2.html",
        "ripple3.html","ripplegpt.html","sg.html","sg1.html","slopstream2.html","slopstream3.html","slopstream4.html","slopstream6.html",
        "snakes.html","sovereignty.html","subgpt2.html","subgpt3.html","subgpt4.html","subgpt5.html","sublime.html","substance.html",
        "substrate.html","substrate1.html","substrate3.html","teleo.html","teleo1.html","temple.html","temple1.html"
      ]},
      { name:"CONCEPTUAL ALIGNMENT", links:["2812.html","claude_cl3.html","concept_cl4.html","cp.html","depth.html","drugprotocol.html","fivethirtysix.html","intra.html","reading.html","widefield.html"]},
      { name:"BASE", links:["based_diva3.html","based_diva8.html","based_diva98.html","based_diva98x.html","based_diva9a.html","based_diva9b.html","based_diva9c.html","based_diva9d.html","based_diva9e.html","based_diva9f.html","based_diva9g.html","based_diva9h.html","based_diva9i.html","based_diva9ii.html","based_diva9iii.html","bbd1.html","bbd2.html","bbd3.html","diva.html","divabased4.html","re_diva9.html","systemkill.html"]},
      { name:"SYSTEM", links:["backbone.html","backbone1.html","backbone2.html","backend.html","claude_mockup.html","claude.html","contract.html","memofesto1.html","memofesto2.html","mockups.html","mockups1.html","mockups2.html","nav.html","pads.html","page.html"]},
      { name:"SYS-UTIL", links:["arranger.html","bugtest.html","debug.html","diagnostic.html","inspector.html","inspector1.html","linklist.html","linkorg4.html","main3.html","manifest.html","master2.html","mastergpt.html","monitor.html","primitive.html","primitive1.html","primitive2.html","primitive3.html","pulse.html","quota.html","reg.html","regv3.html","regv4.html","screenplane.html","screenplane1.html","storage.html","storage1.html","storagemanager.html","system8.html","version.html","videomanager.html"]},
      { name:"SYS-PR", links:["cashapp1.html","cashapp3.html","funding.html","shop.html","submit.html"]},
      { name:"TESTERS", links:["anniversary1.html","anniversary11.html","anniversary111.html","concept_cl.html","concept_cl1.html","concept_cl2.html","darkroom.html","doc5.html","index_copy.html","index_prev1.html","index01_tester.html","lib_cl.html","mandala88.html","master.html","master1.html","redroom.html","to-do.html","to-do1.html","vape-drive.html","vault.html","video.html","video2.html"]},
      { name:"SECRET", links:["67.html","page2.html"]},
      { name:"CORE", links:["deprecated.html","design1.html","lab.html","lab1.html","labyrinth.html","lib_gpt.html","linksv3.html","main2.html","sensory3.html","studiofront.html","studiov2.html","studiov3.html","tester3.html","tester31.html"]},
      { name:"CORE-UTIL", links:["acid_doc.html","artifact.html","board.html","board1.html","board2.html","board3.html","calendar1.html","controller.html","controller1.html","controller2.html","controller3.html","display1.html","doc2.html","manifest5.html","modern.html","pdf2jpeg7.html","sheets.html","studio.html","to-do2.html"]},
      { name:"DESIGN-UTIL", links:["color1.html","color3.html","font.html"]},
      { name:"PHOTOG-UTIL", links:["editor.html","studiov1.html"]},
      { name:"DATA-UTIL", links:["pdf2jpeg8.html"]},
      { name:"META-COG", links:["circle.html","libra.html"]},
      { name:"LLM-UTIL", links:["compiler.html","contextifier.html","d2.html","prompt.html","prompt1.html","prompt3.html","prompter.html"]},
      { name:"HTML-UTIL", links:["classifier.html","classifier1.html","forge3.html","forge4.html","forge5.html","forge7.html","html.html","metadata.html","metadata1.html","unifier.html"]},
      { name:"UI-UTIL", links:["color5.html","interfacer.html","interfacer1.html","interfacer2.html","lab3.html","lab9.html","system6.html"]},
    ];

    const makeUrl = (p) => (/^https?:\/\//i.test(p) ? p : (BASE_URL + p.replace(/^\//,'')));
    const makeId  = (cluster, path) => `${cluster}::${path}`;
    const cssVar  = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim() || "#fff";

    // visibility map (local-first)
    let vis = {};
    const loadVis = () => {
      try{
        const raw = localStorage.getItem(STORE_VIS);
        if(!raw) return;
        const parsed = JSON.parse(raw);
        if(parsed && parsed.vis && typeof parsed.vis === "object") vis = parsed.vis;
      }catch{}
    };
    const saveVis = () => {
      try{
        localStorage.setItem(STORE_VIS, JSON.stringify({version:"KD_ROUTER_VIS_V1",updatedAt:new Date().toISOString(),vis}));
      }catch{}
    };
    const getVis = (id) => (vis[id] === "PUBLIC" || vis[id] === "PRIVATE") ? vis[id] : "UNSET";
    const toggleVis = (id) => { vis[id] = (getVis(id) === "PUBLIC") ? "PRIVATE" : "PUBLIC"; saveVis(); };
    const resetVis = () => { vis = {}; saveVis(); };

    // DOM refs
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d", { alpha: false });
    if(!ctx) throw new Error("Canvas 2D context unavailable.");

    const pillRun   = document.getElementById("pillRun");
    const pillFocus = document.getElementById("pillFocus");
    const btnPause  = document.getElementById("btnPause");
    const btnRecenter = document.getElementById("btnRecenter");
    const btnSettle = document.getElementById("btnSettle");
    const btnClear  = document.getElementById("btnClear");
    const btnZoomIn = document.getElementById("btnZoomIn");
    const btnZoomOut= document.getElementById("btnZoomOut");
    const speedEl   = document.getElementById("speed");
    const tensionEl = document.getElementById("tension");
    const plankEl   = document.getElementById("plank");
    const chaosEl   = document.getElementById("chaos");
    const qEl       = document.getElementById("q");
    const visFilterEl = document.getElementById("visFilter");
    const btnExportPublic = document.getElementById("btnExportPublic");
    const btnExportVis    = document.getElementById("btnExportVis");
    const btnImport       = document.getElementById("btnImport");
    const btnResetVis     = document.getElementById("btnResetVis");
    const btnAllbar       = document.getElementById("btnAllbar");
    const btnNull         = document.getElementById("btnNull");
    const btnInvert       = document.getElementById("btnInvert");
    const btnFull         = document.getElementById("btnFull");
    const filePick        = document.getElementById("filePick");

    const side = document.getElementById("side");
    const sideTitle = document.getElementById("sideTitle");
    const sideMain  = document.getElementById("sideMain");
    const sideType  = document.getElementById("sideType");
    const sideUrl   = document.getElementById("sideUrl");
    const sideVisEl = document.getElementById("sideVis");
    const openNew   = document.getElementById("openNew");
    const copyUrl   = document.getElementById("copyUrl");
    const toggleVisBtn = document.getElementById("toggleVis");
    const closeSide = document.getElementById("closeSide");

    const sideListWrap = document.getElementById("sideListWrap");
    const sideCount = document.getElementById("sideCount");
    const sideList  = document.getElementById("sideList");
    const btnOpenSome = document.getElementById("btnOpenSome");
    const btnExportCluster = document.getElementById("btnExportCluster");

    const allbar = document.getElementById("allbar");
    const allbarBody = document.getElementById("allbarBody");
    const allCollapse = document.getElementById("allCollapse");
    const allQ = document.getElementById("allQ");
    const allVis = document.getElementById("allVis");

    const download = (filename, text) => {
      const blob = new Blob([text], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 900);
    };

    // canvas sizing
    const cam = { x: 0, y: 0, z: 1 };
    const resize = () => {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };
    const screenToWorld = (sx, sy) => {
      const cx = window.innerWidth / 2, cy = window.innerHeight / 2;
      return { x: (sx - cx) / cam.z + cam.x, y: (sy - cy) / cam.z + cam.y };
    };
    const worldToScreen = (wx, wy) => {
      const cx = window.innerWidth / 2, cy = window.innerHeight / 2;
      return { x: (wx - cam.x) * cam.z + cx, y: (wy - cam.y) * cam.z + cy };
    };

    // build organism
    const nodes = [];
    const edges = [];
    const nodeByKey = new Map();

    const addNode = (n) => { nodes.push(n); nodeByKey.set(n.key, n); return n; };
    const addEdge = (a, b, rest, kind) => edges.push({ a, b, rest, kind, alive: 1, phase: rand(0, Math.PI*2), wob: rand(0.6, 1.6) });

    const clusterNames = CLUSTERS.map(c => c.name);

    // lizard spine: not centered, long, slightly arcing, but now with randomized initial offsets
    const spine = [];
    const L = clusterNames.length;
    for (let i = 0; i < L; i++) {
      const t = i / Math.max(1, L - 1);
      const x = (t * 2 - 1) * 950 + rand(-120, 120);
      const y = Math.sin(t * Math.PI * 2) * 260 + Math.sin(t * Math.PI * 5) * 90 + rand(-120, 120);
      spine.push({ x, y });
    }

    const clusterKeys = [];
    for (let i = 0; i < clusterNames.length; i++) {
      const name = clusterNames[i];
      const p = spine[i];
      const key = "CLUSTER::" + name;
      clusterKeys.push(key);
      addNode({
        key, type: "CLUSTER", label: name, url: "",
        x: p.x + rand(-180, 180),
        y: p.y + rand(-180, 180),
        vx: 0, vy: 0, r: 16,
        revealed: false,
        pulse: rand(0, Math.PI*2)
      });
    }

    // spine ligaments
    for (let i = 0; i < clusterKeys.length - 1; i++) {
      addEdge(clusterKeys[i], clusterKeys[i+1], 300 + rand(-120, 120), "spine");
    }

    // fascia pool (rewirable)
    const fascia = [];
    const pickOtherClusterKey = (i) => {
      let j = i + (rand() < 0.5 ? -1 : 1) * (3 + Math.floor(rand()*9));
      j = (j % clusterKeys.length + clusterKeys.length) % clusterKeys.length;
      if (Math.abs(j - i) <= 1) j = (i + 5) % clusterKeys.length;
      return clusterKeys[j];
    };

    for (let i = 0; i < clusterKeys.length; i++) {
      const a = clusterKeys[i];
      const b = pickOtherClusterKey(i);
      const e = { a, b, rest: 520 + rand(-180, 260), kind: "fascia", alive: 1, phase: rand(0, Math.PI*2), wob: rand(0.6, 1.6), ttl: 3 + rand()*8 };
      fascia.push(e);
      edges.push(e);
    }

    // link nodes: exist but visible only when cluster focused
    for (const c of CLUSTERS) {
      const ck = "CLUSTER::" + c.name;
      const cn = nodeByKey.get(ck);
      if (!cn) continue;
      for (const path of c.links) {
        const id = makeId(c.name, path);
        const key = "LINK::" + id;

        const ang = rand(-2.7, 2.7);
        const rr = 24 + rand()*55;
        const hx = cn.x + Math.cos(ang) * rr;
        const hy = cn.y + Math.sin(ang) * rr;

        addNode({
          key, type: "LINK", label: path, url: makeUrl(path),
          x: hx, y: hy, vx: 0, vy: 0, r: 10,
          cluster: c.name, id,
          visible: false,
          home: { x: hx, y: hy },
          pulse: rand(0, Math.PI*2)
        });

        addEdge(ck, key, 175 + rand()*140, "branch");
      }
    }

    // plankton field
    const plankton = [];
    const initPlankton = () => {
      plankton.length = 0;
      const area = window.innerWidth * window.innerHeight;
      const N = Math.floor(Math.min(1800, Math.max(620, area / 2200)));
      for (let i = 0; i < N; i++) {
        const s = Math.random();
        plankton.push({
          x: (Math.random() - 0.5) * 3000,
          y: (Math.random() - 0.5) * 2200,
          r: 0.6 + s * 2.0,
          w: 0.4 + s * 1.8,
          p: Math.random() * Math.PI * 2,
          f: 0.5 + s * 2.0,
          a: 0.02 + s * 0.10
        });
      }
    };

    // filters
    const listFiltersPass = (path, clusterName) => {
      const q = (qEl.value || "").trim().toLowerCase();
      const vf = (visFilterEl.value || "ALL");
      if (q && !path.toLowerCase().includes(q)) return false;
      const v = getVis(makeId(clusterName, path));
      if (vf !== "ALL" && v !== vf) return false;
      return true;
    };
    const allFiltersPass = (path, clusterName) => {
      const q = (allQ.value || "").trim().toLowerCase();
      const vf = (allVis.value || "ALL");
      if (q && !(path.toLowerCase().includes(q) || clusterName.toLowerCase().includes(q))) return false;
      const v = getVis(makeId(clusterName, path));
      if (vf !== "ALL" && v !== vf) return false;
      return true;
    };

    const isNodeVisible = (n) => {
      if (n.type === "LINK") {
        if (!n.visible) return false;
        return listFiltersPass(n.label, n.cluster);
      }
      return true;
    };

    // selection + side
    let selected = null;
    let focusedClusterKey = null;

    const dotClass = (v) => (v === "PUBLIC" ? "public" : v === "PRIVATE" ? "private" : "unset");

    const renderClusterList = (clusterName) => {
      const cluster = CLUSTERS.find(c => c.name === clusterName);
      if (!cluster) { sideList.innerHTML = ""; sideCount.textContent = "0"; return; }
      const items = cluster.links.filter(p => listFiltersPass(p, clusterName));
      sideCount.textContent = items.length + " / " + cluster.links.length;
      sideList.innerHTML = "";

      for (const p of items) {
        const id = makeId(clusterName, p);
        const v = getVis(id);

        const row = document.createElement("div");
        row.className = "item";

        const dot = document.createElement("span");
        dot.className = "dot " + dotClass(v);

        const name = document.createElement("div");
        name.className = "name";
        name.textContent = p;

        const tag = document.createElement("div");
        tag.className = "tag";
        tag.textContent = v;

        const bOpen = document.createElement("button");
        bOpen.className = "mini";
        bOpen.textContent = "OPEN";
        bOpen.onclick = () => window.open(makeUrl(p), "_blank", "noopener,noreferrer");

        const bT = document.createElement("button");
        bT.className = "mini";
        bT.textContent = "TOGGLE";
        bT.onclick = () => { toggleVis(id); renderClusterList(clusterName); renderAllBar(); };

        row.appendChild(dot);
        row.appendChild(name);
        row.appendChild(tag);
        row.appendChild(bOpen);
        row.appendChild(bT);

        sideList.appendChild(row);
      }
    };

    const setSelected = (n, showList=false) => {
      selected = n;
      if (!n) { side.style.display = "none"; return; }
      side.style.display = "block";

      sideTitle.textContent = (n.type === "CLUSTER") ? "FOCUS CLUSTER" : "SELECTED";
      sideMain.textContent = n.label;
      sideType.textContent = n.type;
      sideUrl.textContent = n.url || "";

      if (n.type === "LINK") {
        sideVisEl.textContent = getVis(n.id);
        openNew.style.display = "";
        copyUrl.style.display = "";
        toggleVisBtn.style.display = "";
        sideListWrap.style.display = "none";
      } else if (n.type === "CLUSTER") {
        sideVisEl.textContent = "";
        openNew.style.display = "none";
        copyUrl.style.display = "none";
        toggleVisBtn.style.display = "none";
        sideListWrap.style.display = showList ? "" : "none";
        if (showList) renderClusterList(n.label);
      } else {
        sideVisEl.textContent = "";
        sideListWrap.style.display = "none";
      }
    };

    const focusCluster = (clusterKey) => {
      if (!clusterKey || !clusterKey.startsWith("CLUSTER::")) clusterKey = null;
      focusedClusterKey = (focusedClusterKey === clusterKey) ? null : clusterKey;

      for (const n of nodes) if (n.type === "CLUSTER") n.revealed = (focusedClusterKey === n.key);
      for (const n of nodes) {
        if (n.type !== "LINK") continue;
        n.visible = (focusedClusterKey === ("CLUSTER::" + n.cluster));
        if (!n.visible) { n.vx *= 0.12; n.vy *= 0.12; }
      }

      pillFocus.textContent = focusedClusterKey ? ("FOCUS: " + focusedClusterKey.replace("CLUSTER::","")) : "FOCUS: NONE";
      if (focusedClusterKey) setSelected(nodeByKey.get(focusedClusterKey), true);
      else setSelected(null);
    };

    // all links bar (collapsible)
    let allOpen = false;
    const setAllOpen = (v) => {
      allOpen = v;
      allbarBody.style.display = allOpen ? "" : "none";
    };
    const renderAllBar = () => {
      if (!allOpen) return;
      allbarBody.innerHTML = "";
      for (const c of CLUSTERS) {
        for (const p of c.links) {
          if (!allFiltersPass(p, c.name)) continue;
          const id = makeId(c.name, p);
          const v = getVis(id);

          const row = document.createElement("div");
          row.className = "row";

          const dot = document.createElement("span");
          dot.className = "dot " + dotClass(v);

          const cn = document.createElement("div");
          cn.className = "c";
          cn.textContent = c.name;

          const pn = document.createElement("div");
          pn.className = "p";
          pn.textContent = p;

          const bOpen = document.createElement("button");
          bOpen.textContent = "OPEN";
          bOpen.onclick = () => window.open(makeUrl(p), "_blank", "noopener,noreferrer");

          const bT = document.createElement("button");
          bT.textContent = "TOGGLE";
          bT.onclick = () => { toggleVis(id); renderAllBar(); if (selected && selected.type === "LINK" && selected.id === id) sideVisEl.textContent = getVis(id); if (selected && selected.type === "CLUSTER") renderClusterList(selected.label); };

          row.appendChild(dot);
          row.appendChild(cn);
          row.appendChild(pn);
          row.appendChild(bOpen);
          row.appendChild(bT);

          allbarBody.appendChild(row);
        }
      }
    };

    btnAllbar.onclick = () => { setAllOpen(!allOpen); renderAllBar(); };
    allCollapse.onclick = () => setAllOpen(false);
    allQ.addEventListener("input", renderAllBar);
    allVis.addEventListener("change", renderAllBar);

    qEl.addEventListener("input", () => { if (selected && selected.type === "CLUSTER" && focusedClusterKey) renderClusterList(selected.label); });
    visFilterEl.addEventListener("change", () => { if (selected && selected.type === "CLUSTER" && focusedClusterKey) renderClusterList(selected.label); });

    // side actions
    openNew.onclick = () => { if (selected && selected.type === "LINK") window.open(selected.url, "_blank", "noopener,noreferrer"); };
    copyUrl.onclick = async () => { if (!(selected && selected.type === "LINK")) return; try { await navigator.clipboard.writeText(selected.url); } catch {} };
    toggleVisBtn.onclick = () => {
      if (!(selected && selected.type === "LINK")) return;
      toggleVis(selected.id);
      sideVisEl.textContent = getVis(selected.id);
      if (selected.cluster && focusedClusterKey === ("CLUSTER::" + selected.cluster) && selected) renderClusterList(selected.cluster);
      renderAllBar();
    };
    closeSide.onclick = () => setSelected(null);

    btnOpenSome.onclick = () => {
      if (!(selected && selected.type === "CLUSTER")) return;
      const clusterName = selected.label;
      const cluster = CLUSTERS.find(c => c.name === clusterName);
      if (!cluster) return;
      const items = cluster.links.filter(p => listFiltersPass(p, clusterName)).slice(0, 10);
      for (const p of items) window.open(makeUrl(p), "_blank", "noopener,noreferrer");
    };

    btnExportCluster.onclick = () => {
      if (!(selected && selected.type === "CLUSTER")) return;
      const clusterName = selected.label;
      const cluster = CLUSTERS.find(c => c.name === clusterName);
      if (!cluster) return;
      const out = {
        fileId: "KETADATA_CLUSTER_EXPORT_V1",
        updatedAt: new Date().toISOString(),
        baseUrl: BASE_URL,
        cluster: clusterName,
        links: cluster.links.map(p => ({ path: p, url: makeUrl(p), visibility: getVis(makeId(clusterName, p)) }))
      };
      download("KD_cluster_" + clusterName.replace(/\s+/g,"_") + ".json", JSON.stringify(out, null, 2));
    };

    // export/import/reset (global)
    btnExportPublic.onclick = () => {
      const out = { fileId:"KETADATA_PUBLIC_LINKS_V1", updatedAt:new Date().toISOString(), baseUrl:BASE_URL, clusters:{} };
      for (const c of CLUSTERS) {
        out.clusters[c.name] = c.links
          .map(p => ({ path:p, url:makeUrl(p), visibility:getVis(makeId(c.name,p)) }))
          .filter(x => x.visibility === "PUBLIC");
      }
      download("KD_public_links.json", JSON.stringify(out, null, 2));
    };

    btnExportVis.onclick = () => download("KD_visibility_map.json", JSON.stringify({ version:"KD_ROUTER_VIS_V1", updatedAt:new Date().toISOString(), vis }, null, 2));

    const importJSON = (text) => {
      let parsed;
      try { parsed = JSON.parse(text); } catch { return; }
      if (!parsed || typeof parsed !== "object") return;

      if (parsed.vis && typeof parsed.vis === "object") {
        const next = {};
        for (const k in parsed.vis) {
          const v = parsed.vis[k];
          if (v === "PUBLIC" || v === "PRIVATE") next[k] = v;
        }
        vis = next; saveVis();
        if (selected && selected.type === "LINK") sideVisEl.textContent = getVis(selected.id);
        if (selected && selected.type === "CLUSTER" && focusedClusterKey) renderClusterList(selected.label);
        renderAllBar();
        return;
      }
    };

    btnImport.onclick = () => filePick.click();
    filePick.addEventListener("change", async () => {
      const f = filePick.files && filePick.files[0];
      if (!f) return;
      importJSON(await f.text());
      filePick.value = "";
    });

    btnResetVis.onclick = () => { resetVis(); if (selected && selected.type === "LINK") sideVisEl.textContent = getVis(selected.id); if (selected && selected.type === "CLUSTER" && focusedClusterKey) renderClusterList(selected.label); renderAllBar(); };

    // system universals
    const toggleNull = () => document.documentElement.classList.toggle("null");
    const toggleInvert = () => document.documentElement.classList.toggle("invert");
    const toggleFull = () => { if (!document.fullscreenElement) document.documentElement.requestFullscreen?.(); else document.exitFullscreen?.(); };
    btnNull.onclick = toggleNull;
    btnInvert.onclick = toggleInvert;
    btnFull.onclick = toggleFull;

    // running
    let running = true;
    const setRunning = (r) => {
      running = r;
      pillRun.textContent = r ? "RUNNING" : "PAUSED";
      btnPause.textContent = r ? "PAUSE (SPACE)" : "RUN (SPACE)";
    };
    btnPause.onclick = () => setRunning(!running);

    btnRecenter.onclick = () => { cam.x = 0; cam.y = 0; cam.z = 1; };
    btnSettle.onclick = () => { for (const n of nodes) { n.vx *= 0.2; n.vy *= 0.2; } };
    btnClear.onclick = () => focusCluster(null);
    btnZoomIn.onclick = () => { cam.z = Math.min(3.5, cam.z * 1.15); };
    btnZoomOut.onclick = () => { cam.z = Math.max(0.15, cam.z / 1.15); };

    // picking
    let hovered = null;
    const nodeAt = (sx, sy) => {
      const w = screenToWorld(sx, sy);
      let best = null, bestD = Infinity;
      for (const n of nodes) {
        if (!isNodeVisible(n)) continue;
        const dx = w.x - n.x, dy = w.y - n.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        const hit = n.r + (n.type === "LINK" ? 10 : 12);
        if (d < hit && d < bestD) { best = n; bestD = d; }
      }
      return best;
    };

    let draggingCam = false;
    let draggingNode = null;
    let dragOff = { x: 0, y: 0 };
    let lastMouse = { x: 0, y: 0 };

    canvas.addEventListener("mousedown", (e) => {
      const onHud = e.target && e.target.closest && e.target.closest("#hud");
      const onSide = e.target && e.target.closest && e.target.closest("#side");
      const onAll  = e.target && e.target.closest && e.target.closest("#allbar");
      if (onHud || onSide || onAll) return;

      const hit = nodeAt(e.clientX, e.clientY);
      if (hit) {
        draggingNode = hit;
        const w = screenToWorld(e.clientX, e.clientY);
        dragOff.x = w.x - hit.x; dragOff.y = w.y - hit.y;
        setSelected(hit, hit.type === "CLUSTER");
      } else {
        draggingCam = true;
        lastMouse.x = e.clientX; lastMouse.y = e.clientY;
        setSelected(null);
      }
    });

    window.addEventListener("mousemove", (e) => {
      hovered = nodeAt(e.clientX, e.clientY);
      if (draggingNode) {
        const w = screenToWorld(e.clientX, e.clientY);
        draggingNode.x = w.x - dragOff.x;
        draggingNode.y = w.y - dragOff.y;
        draggingNode.vx *= 0.25; draggingNode.vy *= 0.25;

        if (draggingNode.type === "CLUSTER") {
          for (const n of nodes) {
            if (n.type !== "LINK") continue;
            if (n.cluster !== draggingNode.label) continue;
            const ang = rand(-2.7, 2.7);
            const rr = 26 + rand()*58;
            n.home.x = draggingNode.x + Math.cos(ang)*rr;
            n.home.y = draggingNode.y + Math.sin(ang)*rr;
            if (!n.visible) { n.x = n.home.x; n.y = n.home.y; }
          }
        }
      } else if (draggingCam) {
        const dx = (e.clientX - lastMouse.x) / cam.z;
        const dy = (e.clientY - lastMouse.y) / cam.z;
        cam.x -= dx; cam.y -= dy;
        lastMouse.x = e.clientX; lastMouse.y = e.clientY;
      }
    });

    window.addEventListener("mouseup", () => { draggingCam = false; draggingNode = null; });

    canvas.addEventListener("click", (e) => {
      const onHud = e.target && e.target.closest && e.target.closest("#hud");
      const onSide = e.target && e.target.closest && e.target.closest("#side");
      const onAll  = e.target && e.target.closest && e.target.closest("#allbar");
      if (onHud || onSide || onAll) return;

      const hit = nodeAt(e.clientX, e.clientY);
      if (!hit) return;

      if (hit.type === "CLUSTER") { focusCluster(hit.key); return; }
      if (hit.type === "LINK") {
        if (selected && selected.key === hit.key) window.open(hit.url, "_blank", "noopener,noreferrer");
        else setSelected(hit);
      }
    });

    canvas.addEventListener("wheel", (e) => {
      const onHud = e.target && e.target.closest && e.target.closest("#hud");
      const onSide = e.target && e.target.closest && e.target.closest("#side");
      const onAll  = e.target && e.target.closest && e.target.closest("#allbar");
      if (onHud || onSide || onAll) return;

      e.preventDefault();
      const before = screenToWorld(e.clientX, e.clientY);
      const zoom = Math.exp(-e.deltaY * 0.0012);
      cam.z = Math.max(0.15, Math.min(3.5, cam.z * zoom));
      const after = screenToWorld(e.clientX, e.clientY);
      cam.x += (before.x - after.x);
      cam.y += (before.y - after.y);
    }, { passive: false });

    window.addEventListener("keydown", (e) => {
      const tag = document.activeElement && document.activeElement.tagName ? document.activeElement.tagName.toLowerCase() : "";
      const typing = (tag === "input" || tag === "textarea");
      if (e.key === " " && !typing) { e.preventDefault(); setRunning(!running); }
      if (e.shiftKey && (e.key === "I" || e.key === "i")) { e.preventDefault(); toggleInvert(); }
      if (e.shiftKey && (e.key === "N" || e.key === "n")) { e.preventDefault(); toggleNull(); }
      if (e.shiftKey && (e.key === "F" || e.key === "f")) { e.preventDefault(); toggleFull(); }
      if (e.shiftKey && (e.key === "L" || e.key === "l")) { e.preventDefault(); setAllOpen(!allOpen); renderAllBar(); }
      if (e.key === "Escape") { setSelected(null); focusCluster(null); setAllOpen(false); }
    });

    // plankton draw
    const drawPlankton = (t) => {
      const intensity = parseFloat(plankEl.value || "0.7");
      if (intensity <= 0) return;

      const fg = cssVar("--fg");
      const muted = cssVar("--muted");
      const par = 0.18;

      ctx.save();
      ctx.globalCompositeOperation = "screen";

      ctx.globalAlpha = 0.018 * intensity;
      ctx.fillStyle = muted;
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

      ctx.fillStyle = fg;
      for (const p of plankton) {
        const dx = Math.sin(t*0.22 + p.p) * 0.8 + Math.sin(t*0.63 + p.p*2.3) * 0.35;
        const dy = Math.cos(t*0.19 + p.p*1.7) * 0.8 + Math.cos(t*0.58 + p.p*2.1) * 0.35;

        p.x += (0.08 + p.w*0.16) + dx*0.05;
        p.y += (dy*0.07);

        if (p.x > 3200) p.x = -3200;
        if (p.x < -3200) p.x = 3200;
        if (p.y > 2400) p.y = -2400;
        if (p.y < -2400) p.y = 2400;

        const pulse = 0.30 + 0.70 * Math.max(0, Math.sin(t*p.f + p.p));
        const alpha = (p.a * pulse) * intensity;

        const sx = (p.x - cam.x*par) * cam.z + window.innerWidth/2;
        const sy = (p.y - cam.y*par) * cam.z + window.innerHeight/2;

        if (sx < -30 || sx > window.innerWidth+30 || sy < -30 || sy > window.innerHeight+30) continue;

        ctx.globalAlpha = alpha;
        ctx.beginPath(); ctx.arc(sx, sy, p.r, 0, Math.PI*2); ctx.fill();

        ctx.globalAlpha = alpha * 0.20;
        ctx.beginPath(); ctx.arc(sx, sy, p.r * 3.4, 0, Math.PI*2); ctx.fill();
      }

      ctx.restore();
      ctx.globalCompositeOperation = "source-over";
    };

    // live currents (less deterministic)
    let cur = { x: rand(-1,1), y: rand(-1,1) };
    let cur2 = { x: rand(-1,1), y: rand(-1,1) };
    let curT = 0;

    const updateCurrents = (dt) => {
      curT -= dt/1000;
      if (curT <= 0) {
        curT = 2.2 + rand()*4.5;
        cur2 = { x: rand(-1,1), y: rand(-1,1) };
        // reseed slightly so the field keeps evolving (not loop-locked)
        rng = mulberry32(((Date.now() ^ ((Math.random()*1e9)|0) ^ ((rand()*1e9)|0)) >>> 0));
      }
      // ease current towards target
      cur.x += (cur2.x - cur.x) * 0.02;
      cur.y += (cur2.y - cur.y) * 0.02;
    };

    // fascia rewiring (connect/disconnect)
    const rewireOneFascia = () => {
      const e = fascia[Math.floor(rand()*fascia.length)];
      if (!e) return;
      // choose new endpoints
      const a = clusterKeys[Math.floor(rand()*clusterKeys.length)];
      let b = clusterKeys[Math.floor(rand()*clusterKeys.length)];
      if (b === a) b = clusterKeys[(clusterKeys.indexOf(a)+5)%clusterKeys.length];
      e.a = a;
      e.b = b;
      e.rest = 460 + rand()*520;
      e.phase = rand(0, Math.PI*2);
      e.wob = rand(0.6, 1.8);
      e.ttl = 2 + rand()*9;
    };

    // physics
    const step = (dt) => {
      const speed = parseFloat(speedEl.value || "1.15");
      const tension = parseFloat(tensionEl.value || "1.0");
      const chaos = parseFloat(chaosEl.value || "0.85");
      const t = performance.now() * 0.001;

      updateCurrents(dt);

      // occasional rewires (more alive, less fixed)
      if (rand() < 0.008 * chaos) rewireOneFascia();

      const repulse = 1180 + 520*chaos;
      const springK = (0.010 * tension) * (0.75 + 0.55*(1-chaos));
      const damp = 0.91 - 0.02*Math.min(1, chaos);

      // node repulsion
      for (let i = 0; i < nodes.length; i++) {
        const A = nodes[i];
        if (!isNodeVisible(A)) continue;
        for (let j = i + 1; j < nodes.length; j++) {
          const B = nodes[j];
          if (!isNodeVisible(B)) continue;
          const dx = B.x - A.x, dy = B.y - A.y;
          const d2 = dx*dx + dy*dy + 0.001;
          const d = Math.sqrt(d2);
          const minD = (A.r + B.r + 22);
          const squeeze = (d < minD) ? 2.5 : 1.0;
          const f = (repulse / d2) * squeeze;
          const ux = dx / d, uy = dy / d;
          if (draggingNode !== A) { A.vx -= ux * f * 0.002; A.vy -= uy * f * 0.002; }
          if (draggingNode !== B) { B.vx += ux * f * 0.002; B.vy += uy * f * 0.002; }
        }
      }

      // springs
      for (const e of edges) {
        const A = nodeByKey.get(e.a), B = nodeByKey.get(e.b);
        if (!A || !B) continue;
        if (!isNodeVisible(A) || !isNodeVisible(B)) continue;

        const dx = B.x - A.x, dy = B.y - A.y;
        const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
        const diff = d - e.rest;
        const ux = dx / d, uy = dy / d;

        // synaptic thinning / thickening
        let alive = 1;
        if (e.kind !== "branch") {
          const syn = parseFloat(plankEl.value || "0.7");
          const flick = 0.5 + 0.5*Math.sin(t*(0.55*e.wob) + e.phase);
          alive = 0.20 + 0.80 * (1 - syn*0.45 + syn*0.45*flick);
        }
        const kindMult = (e.kind === "spine") ? 1.2 : (e.kind === "fascia" ? 0.75 : 0.95);
        const f = diff * springK * kindMult * alive;

        if (draggingNode !== A) { A.vx += ux * f; A.vy += uy * f; }
        if (draggingNode !== B) { B.vx -= ux * f; B.vy -= uy * f; }
      }

      // ambient movement (less deterministic, more “currents” + random micro-jitter)
      for (const n of nodes) {
        if (!isNodeVisible(n)) continue;
        if (draggingNode === n) continue;

        const drift = (n.type === "CLUSTER") ? 0.16 : 0.08;
        const jitter = (n.type === "CLUSTER") ? 0.11 : 0.06;

        // global current (sea)
        n.vx += cur.x * drift * speed * (0.6 + 0.8*chaos);
        n.vy += cur.y * drift * speed * (0.6 + 0.8*chaos);

        // micro randomness (not periodic)
        if (rand() < 0.45*chaos) {
          n.vx += (rand(-1,1)) * jitter * speed;
          n.vy += (rand(-1,1)) * jitter * speed;
        }

        // subtle pulse
        n.pulse += (0.02 + 0.06*chaos);
      }

      // hidden links return to home
      for (const n of nodes) {
        if (n.type !== "LINK") continue;
        if (n.visible) continue;
        n.vx += (n.home.x - n.x) * 0.03;
        n.vy += (n.home.y - n.y) * 0.03;
        n.vx *= 0.62; n.vy *= 0.62;
      }

      // integrate
      for (const n of nodes) {
        if (!isNodeVisible(n)) continue;
        if (draggingNode === n) continue;
        n.vx *= damp; n.vy *= damp;
        n.x += n.vx * (dt / 16) * speed;
        n.y += n.vy * (dt / 16) * speed;
      }
    };

    const draw = () => {
      const W = window.innerWidth, H = window.innerHeight;
      const t = performance.now() * 0.001;

      const bg = cssVar("--bg");
      const fg = cssVar("--fg");
      const muted = cssVar("--muted");
      const line = cssVar("--line");

      // base fill
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, W, H);

      // waterline texture
      ctx.save();
      ctx.globalAlpha = 0.10;
      ctx.strokeStyle = line;
      ctx.lineWidth = 1;
      for (let i = 0; i < 8; i++) {
        const y = (i / 7) * H;
        ctx.beginPath();
        for (let x = 0; x <= W; x += 32) {
          const yy = y + Math.sin(x*0.01 + i*0.9 + t*0.33) * (7 + i*0.24);
          if (x === 0) ctx.moveTo(x, yy); else ctx.lineTo(x, yy);
        }
        ctx.stroke();
      }
      ctx.restore();

      drawPlankton(t);

      // edges
      ctx.save();
      for (const e of edges) {
        const A = nodeByKey.get(e.a), B = nodeByKey.get(e.b);
        if (!A || !B) continue;
        if (!(isNodeVisible(A) && isNodeVisible(B))) continue;

        const a = worldToScreen(A.x, A.y);
        const b = worldToScreen(B.x, B.y);

        const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
        const nx = -(b.y - a.y), ny = (b.x - a.x);
        const nd = Math.sqrt(nx*nx + ny*ny) + 0.001;
        const ux = nx / nd, uy = ny / nd;

        const bendBase = (e.kind === "spine") ? 10 : (e.kind === "fascia" ? 20 : 12);
        const bend = bendBase * Math.sin(t*(0.6*e.wob) + e.phase);

        let alpha = (e.kind === "branch") ? 0.85 : 0.58;
        let width = (e.kind === "spine") ? 1.7 : (e.kind === "fascia" ? 1.05 : 1.25);

        if (e.kind !== "branch") {
          const syn = parseFloat(plankEl.value || "0.7");
          const flick = 0.5 + 0.5*Math.sin(t*(0.55*e.wob) + e.phase);
          const alive = 0.20 + 0.80 * (1 - syn*0.45 + syn*0.45*flick);
          alpha *= alive;
          width *= (0.6 + alive*0.7);
          if (alive < 0.33) ctx.setLineDash([10, 10]); else ctx.setLineDash([]);
        } else {
          ctx.setLineDash([]);
        }

        ctx.globalAlpha = alpha;
        ctx.strokeStyle = line;
        ctx.lineWidth = width;

        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.quadraticCurveTo(mx + ux*bend, my + uy*bend, b.x, b.y);
        ctx.stroke();
      }
      ctx.setLineDash([]);
      ctx.restore();

      // nodes + labels
      const visibleNodes = nodes.filter(n => isNodeVisible(n));

      // soft halo
      ctx.save();
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = line;
      ctx.filter = "blur(14px)";
      for (const n of visibleNodes) {
        const p = worldToScreen(n.x, n.y);
        const r = (n.type === "CLUSTER") ? 28 : 16;
        ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
      }
      ctx.filter = "none";
      ctx.restore();

      for (const n of visibleNodes) {
        const p = worldToScreen(n.x, n.y);
        const isHover = hovered && hovered.key === n.key;
        const isSel = selected && selected.key === n.key;
        const r = n.r;

        // ring
        ctx.save();
        ctx.globalAlpha = 0.18 + (isSel ? 0.16 : 0) + (isHover ? 0.10 : 0) + (n.type==="CLUSTER" && n.revealed ? 0.10 : 0);
        ctx.fillStyle = line;
        ctx.beginPath(); ctx.arc(p.x, p.y, r+10, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // core
        ctx.save();
        ctx.fillStyle = bg;
        ctx.strokeStyle = line;
        ctx.lineWidth = (isSel || isHover || (n.type==="CLUSTER" && n.revealed)) ? 2 : 1;
        ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.restore();

        // vis dot for links
        if (n.type === "LINK") {
          const v = getVis(n.id);
          ctx.save();
          ctx.globalAlpha = 0.85;
          ctx.fillStyle = (v === "PUBLIC") ? fg : (v === "PRIVATE" ? muted : line);
          ctx.beginPath(); ctx.arc(p.x, p.y, 3.2, 0, Math.PI*2); ctx.fill();
          ctx.restore();
        }

        // label
        ctx.save();
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\",\"Courier New\", monospace";
        ctx.textBaseline = "middle";
        const maxChars = (n.type === "LINK") ? 28 : 18;
        const text = n.label.length > maxChars ? (n.label.slice(0, maxChars-1) + "…") : n.label;

        const tx = p.x + (r + 9), ty = p.y;
        ctx.textAlign = "left";
        const w = ctx.measureText(text).width;
        const pad = 3;

        ctx.globalAlpha = 0.78;
        ctx.fillStyle = bg;
        ctx.fillRect(tx - pad, ty - 8, w + pad*2, 16);

        ctx.globalAlpha = 1;
        ctx.fillStyle = (n.type === "LINK") ? muted : fg;
        ctx.fillText(text, tx, ty);
        ctx.restore();
      }

      // vignette
      ctx.save();
      const g = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.20, W/2, H/2, Math.min(W,H)*0.86);
      const inv = document.documentElement.classList.contains("invert");
      g.addColorStop(0, "rgba(0,0,0,0)");
      g.addColorStop(1, inv ? "rgba(0,0,0,0.08)" : "rgba(0,0,0,0.16)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    };

    // init
    loadVis();
    resize();
    initPlankton();
    window.addEventListener("resize", () => { resize(); initPlankton(); });

    // default: allbar collapsed
    setAllOpen(false);

    // loop
    let last = performance.now();
    const loop = (now) => {
      const dt = Math.min(40, now - last);
      last = now;
      if (running) step(dt);
      draw();
      requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);

  } catch (err) {
    crash(err);
  }
})();
</script>

<!--
AE / EE / WB — KETADATA SERIALIZATION STAMP (MANDATORY)
AE: BLACK-DEFAULT TERRARIUM SEA • ORGANISM LIGAMENTS + REWIRING FASCIA • PLANKTON BIOLUM PULSE • INVERT FLIPS WHOLE WORLD
EE: CLICK CLUSTER TO FOCUS/UNFOCUS → REVEALS ITS LINK NODES • SIDE PANEL SHOWS CLUSTER LINKS • ALL LINKS BAR COLLAPSIBLE (SHIFT+L) • DRAG EMPTY PAN • DRAG NODE PULL • WHEEL ZOOM • SPACE PAUSE
WB: LOCAL-FIRST VISIBILITY MAP (PUBLIC/PRIVATE/UNSET) + EXPORT/IMPORT • NULL/INVERT/FULL HOTKEYS • NO DEPENDENCIES

FILE_ID: "KD_ROUTER_ORGANISM_TERRARIUM_PLANKTON_ALLBAR_V2"
ROOM_ID: "K_ROUTER"
VERSION_ID: "V2"
UPDATED_AT: "2026-01-04T00:00:00.000-05:00"
CHANGELOG:
- V2: MORE MOVEMENT (LIVE CURRENTS + MICRO-JITTER + FASCIA REWIRING) • CHAOS SLIDER • COLLAPSIBLE ALL LINKS BAR (SHIFT+L)
-->
</body>
</html>
