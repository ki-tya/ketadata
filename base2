<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>KETADATA_BASE_SYSTEM.html</title>

<!-- =========================================================
AE ▸ AESTHETIC LAYER
KETADATA BASE — BLACK / WHITE / GREY — SHARP / INDUSTRIAL
========================================================= -->
<style>
:root{
  --bg:#000; --fg:#fff; --muted:#8a8a8a; --line:#222; --line2:#333;
  --top:44px; --bot:34px;

  --mono:
    ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono","Courier New", monospace;

  --serif:
    ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;

  --radius:0px;
  --pad:10px;
}

*{box-sizing:border-box;}
html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:var(--mono);}
a{color:inherit; text-decoration:none;}
button,input,textarea,select{
  font-family:var(--mono);
  background:transparent;
  color:var(--fg);
  border:1px solid var(--line2);
  outline:none;
}
button{cursor:pointer;}
textarea{resize:none;}

#root{
  position:relative;
  height:100%;
  overflow:hidden;
}

#topbar{
  position:absolute; left:0; top:0; right:0; height:var(--top);
  border-bottom:1px solid var(--line);
  display:flex; align-items:center; justify-content:space-between;
  padding:0 12px;
  z-index:40;
  background:rgba(0,0,0,0.86);
  backdrop-filter: blur(2px);
}

#bottombar{
  position:absolute; left:0; bottom:0; right:0; height:var(--bot);
  border-top:1px solid var(--line);
  display:flex; align-items:center; justify-content:space-between;
  padding:0 12px;
  z-index:40;
  background:rgba(0,0,0,0.86);
  backdrop-filter: blur(2px);
}

.brand{
  display:flex; align-items:center; gap:10px;
  letter-spacing:.14em;
  font-size:12px;
}
.brand .tag{
  color:var(--muted);
  letter-spacing:.18em;
  font-size:11px;
}

#stage{
  position:absolute;
  left:0; right:0;
  top:var(--top);
  bottom:var(--bot);
  overflow:hidden;
}

#motion{
  position:absolute; inset:0;
  opacity:.22;
  pointer-events:none;
}
#motion::before{
  content:"";
  position:absolute; inset:-40%;
  background:
    radial-gradient(circle at 50% 50%, rgba(255,255,255,0.10), rgba(0,0,0,0.0) 58%),
    repeating-radial-gradient(circle at 50% 50%, rgba(255,255,255,0.08) 0 1px, rgba(0,0,0,0) 1px 16px);
  animation: drift 18s linear infinite;
  transform: rotate(0deg);
}
@keyframes drift{
  from{transform:translate3d(-2%, -1%, 0) rotate(0deg);}
  to{transform:translate3d(2%, 1%, 0) rotate(20deg);}
}

.panel{
  position:absolute;
  border:1px solid var(--line2);
  background:rgba(0,0,0,0.66);
  backdrop-filter: blur(2px);
}

.panelHeader{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:8px 10px;
  border-bottom:1px solid var(--line2);
  letter-spacing:.12em;
  font-size:11px;
}
.panelHeader .hLeft{display:flex; align-items:center; gap:10px;}
.panelHeader .hRight{display:flex; align-items:center; gap:8px;}
.small{
  font-size:11px;
  color:var(--muted);
  letter-spacing:.14em;
}
.kchip{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:6px 10px;
  border:1px solid var(--line2);
  background:rgba(0,0,0,0.72);
  letter-spacing:.12em;
  font-size:11px;
  user-select:none;
}
.kchip .t{color:var(--muted);}
.kchip .v{color:var(--fg);}
.kchip button{
  border:1px solid var(--line2);
  padding:4px 8px;
  font-size:11px;
  letter-spacing:.12em;
}

.row{display:flex; align-items:center; gap:8px;}
.col{display:flex; flex-direction:column; gap:8px;}

.divLine{height:1px; background:var(--line2); opacity:.7;}

#baseBoard{
  left:18px;
  top:16px;
  width:calc(100% - 36px);
  height:calc(100% - 32px);
  display:flex;
  flex-direction:column;
}

#boardInner{
  position:relative;
  flex:1;
  overflow:hidden;
  padding:12px;
}

#armedBar{
  position:absolute;
  left:12px;
  right:12px;
  top:12px;
  border:1px solid var(--line2);
  background:rgba(0,0,0,0.78);
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:8px 10px;
  letter-spacing:.14em;
  font-size:11px;
  z-index:5;
}
#armedBar .left{display:flex; align-items:center; gap:10px;}
#armedBar .right{display:flex; align-items:center; gap:10px;}
#armedLabel{
  color:var(--muted);
}
#armedTarget{
  color:var(--fg);
}
#armedHint{
  color:var(--muted);
  letter-spacing:.14em;
}
#armedActions button{
  padding:4px 8px;
  font-size:11px;
  letter-spacing:.12em;
}

#pinnedWrap{
  position:absolute;
  left:12px;
  right:12px;
  top:58px;
  bottom:12px;
  overflow:auto;
  padding-right:6px;
}

.module{
  border:1px solid var(--line2);
  background:rgba(0,0,0,0.60);
  margin-bottom:10px;
}

.moduleHead{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:8px 10px;
  border-bottom:1px solid var(--line2);
  letter-spacing:.12em;
  font-size:11px;
  user-select:none;
}
.moduleHead .mLeft{display:flex; align-items:center; gap:10px;}
.moduleHead .mRight{display:flex; align-items:center; gap:8px;}
.moduleBody{
  padding:10px;
  display:grid;
  grid-template-columns: 1fr;
  gap:8px;
}
.moduleGrid{
  display:grid;
  grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
  gap:10px;
}

.card{
  border:1px solid var(--line2);
  background:rgba(0,0,0,0.72);
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.card .title{
  letter-spacing:.14em;
  font-size:11px;
}
.card .meta{
  color:var(--muted);
  font-size:11px;
  letter-spacing:.12em;
}
.card .actions{
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:wrap;
}
.card button{
  padding:4px 8px;
  font-size:11px;
  letter-spacing:.12em;
}

#drawer{
  position:absolute;
  right:12px;
  top:calc(var(--top) + 12px);
  width:340px;
  height:calc(100% - var(--top) - var(--bot) - 24px);
  border:1px solid var(--line2);
  background:rgba(0,0,0,0.84);
  z-index:30;
  display:flex;
  flex-direction:column;
  overflow:hidden;
}

#drawerHead{
  padding:8px 10px;
  border-bottom:1px solid var(--line2);
  display:flex;
  justify-content:space-between;
  align-items:center;
  letter-spacing:.14em;
  font-size:11px;
}
#drawerHead .left{display:flex; align-items:center; gap:10px;}
#drawerHead .right{display:flex; align-items:center; gap:8px;}
#drawerBody{
  overflow:auto;
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:10px;
}

.section{
  border:1px solid var(--line2);
  background:rgba(0,0,0,0.66);
}
.sectionHead{
  padding:8px 10px;
  border-bottom:1px solid var(--line2);
  display:flex;
  justify-content:space-between;
  align-items:center;
  letter-spacing:.14em;
  font-size:11px;
  user-select:none;
}
.sectionBody{
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.sectionBody.collapsed{display:none;}

.krow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.krow label{
  font-size:11px;
  letter-spacing:.12em;
  color:var(--muted);
}
.krow input[type="range"]{width:160px;}
.krow input[type="number"]{width:88px; padding:6px 8px; font-size:11px;}
.krow input[type="text"]{width:100%; padding:6px 8px; font-size:11px; letter-spacing:.10em;}
.krow textarea{width:100%; height:100px; padding:8px 10px; font-size:11px; letter-spacing:.10em; border:1px solid var(--line2);}

.iconBtn{
  border:1px solid var(--line2);
  width:26px; height:26px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-size:11px;
  letter-spacing:.14em;
}

#ketaNoteIcon{
  border:1px solid var(--line2);
  width:26px; height:26px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-size:11px;
  letter-spacing:.14em;
  user-select:none;
}

#ketaNote{
  position:absolute;
  border:1px solid var(--line2);
  background:rgba(0,0,0,0.78);
  z-index:35;
  width:320px;
  height:220px;
  display:none;
}
#ketaNoteHead{
  padding:8px 10px;
  border-bottom:1px solid var(--line2);
  display:flex;
  justify-content:space-between;
  align-items:center;
  letter-spacing:.14em;
  font-size:11px;
  user-select:none;
}
#ketaNoteBody{padding:10px; height:calc(100% - 34px);}
#ketaNoteBody textarea{height:100%;}

.toast{
  position:absolute;
  left:12px;
  bottom:calc(var(--bot) + 12px);
  border:1px solid var(--line2);
  background:rgba(0,0,0,0.78);
  padding:8px 10px;
  letter-spacing:.12em;
  font-size:11px;
  color:var(--muted);
  display:none;
  z-index:41;
}

#persistProbe{
  position:absolute;
  right:12px;
  top:calc(var(--top) + 12px);
  padding:10px 12px;
  border:1px solid var(--line2);
  background:rgba(8,8,8,0.82);
  font-family:var(--mono);
  font-size:11px;
  letter-spacing:.06em;
  color:var(--fg);
  display:none;
  z-index:41;
  max-width:420px;
  pointer-events:none;
}

.hide{display:none !important;}
.dim{color:var(--muted);}

.invert{
  filter: invert(1) hue-rotate(180deg);
}

.fullscreen #topbar,
.fullscreen #bottombar{
  display:none;
}
.fullscreen #stage{
  top:0;
  bottom:0;
}
.fullscreen #drawer{top:12px; height:calc(100% - 24px);}
.fullscreen #motion{opacity:.20;}

.null #topbar,
.null #bottombar,
.null #drawer{
  display:none;
}
.null #stage{top:0; bottom:0;}
.null #motion{opacity:.12;}

.light1 #motion{opacity:.10;}
.light2 #motion{opacity:.18;}
.light3 #motion{opacity:.26;}
.light4 #motion{opacity:.34;}
.light5 #motion{opacity:.42;}
.light6 #motion{opacity:.52;}
</style>
</head>

<body>
<div id="root">
  <div id="topbar">
    <div class="brand">
      <div>[KETADATA]</div>
      <div class="tag">[BASE]</div>
    </div>
    <div class="row">
      <div class="small" id="hotkeyHint">SHIFT+I / 1–6 / SHIFT+N / SHIFT+F / SHIFT+K</div>
      <div id="ketaNoteIcon">■</div>
    </div>
  </div>

  <div id="bottombar">
    <div class="small" id="statusLeft">[READY]</div>
    <div class="small" id="statusRight">[STATE]</div>
  </div>

  <div id="stage">
    <div id="motion"></div>

    <div class="panel" id="baseBoard">
      <div class="panelHeader">
        <div class="hLeft">
          <div>[BASE DIRECTORY]</div>
          <div class="small" id="stateSig"></div>
        </div>
        <div class="hRight">
          <button class="iconBtn" id="drawerToggle">≡</button>
        </div>
      </div>

      <div id="boardInner">
        <div id="armedBar">
          <div class="left">
            <span id="armedLabel">[ARMED]</span>
            <span id="armedTarget">[NONE]</span>
          </div>
          <div class="right">
            <span id="armedHint">CLICK CARD TO ARM · GO COMMITS</span>
            <span id="armedActions">
              <button id="armedGo">GO</button>
              <button id="armedNewTab">NEW TAB</button>
              <button id="armedClear">CLEAR</button>
            </span>
          </div>
        </div>

        <div id="pinnedWrap"></div>
      </div>
    </div>

    <div id="drawer">
      <div id="drawerHead">
        <div class="left">
          <div>[SYSTEM]</div>
          <div class="small" id="drawerSig"></div>
        </div>
        <div class="right">
          <button class="iconBtn" id="drawerClose">×</button>
        </div>
      </div>
      <div id="drawerBody">

        <div class="section" id="secRegistry">
          <div class="sectionHead">
            <div>[REGISTRY]</div>
            <div class="row">
              <button class="iconBtn" data-collapse="secRegistry">–</button>
            </div>
          </div>
          <div class="sectionBody" id="secRegistryBody">
            <div class="krow">
              <label>[IMPORT JSON]</label>
              <button id="importBtn">IMPORT</button>
            </div>
            <div class="krow">
              <label>[EXPORT JSON]</label>
              <button id="exportBtn">EXPORT</button>
            </div>
            <div class="divLine"></div>
            <div class="krow">
              <label>[PROMPT EXPORT]</label>
              <button id="promptBtn">PROMPT</button>
            </div>
            <div class="krow">
              <label class="dim">[HARD RESET]</label>
              <button id="resetBtn">RESET</button>
            </div>
          </div>
        </div>

        <div class="section" id="secUniversals">
          <div class="sectionHead">
            <div>[UNIVERSALS]</div>
            <div class="row">
              <button class="iconBtn" data-collapse="secUniversals">–</button>
            </div>
          </div>
          <div class="sectionBody" id="secUniversalsBody">
            <div class="krow">
              <label>[MOTION]</label>
              <button id="motionToggle">TOGGLE</button>
            </div>
            <div class="krow">
              <label>[TEXT SIZE]</label>
              <div class="row">
                <input id="textSize" type="range" min="10" max="18" step="1" />
                <input id="textSizeNum" type="number" min="10" max="18" step="1" />
              </div>
            </div>
          </div>
        </div>

        <div class="section" id="secDrawer">
          <div class="sectionHead">
            <div>[DRAWER]</div>
            <div class="row">
              <button class="iconBtn" data-collapse="secDrawer">–</button>
            </div>
          </div>
          <div class="sectionBody" id="secDrawerBody">
            <div class="krow">
              <label>[DRAWER HEIGHT]</label>
              <div class="row">
                <input id="drawerH" type="range" min="240" max="820" step="10" />
                <input id="drawerHNum" type="number" min="240" max="820" step="10" />
              </div>
            </div>
          </div>
        </div>

        <div class="section" id="secUnpinned">
          <div class="sectionHead">
            <div>[UNPINNED ROOMS]</div>
            <div class="row">
              <button class="iconBtn" data-collapse="secUnpinned">–</button>
            </div>
          </div>
          <div class="sectionBody" id="secUnpinnedBody">
            <div class="small dim">[UNPINNED ROOMS LIVE HERE]</div>
            <div id="unpinnedRooms"></div>
          </div>
        </div>

        <div class="section" id="secSets">
          <div class="sectionHead">
            <div>[SETS]</div>
            <div class="row">
              <button class="iconBtn" data-collapse="secSets">–</button>
            </div>
          </div>
          <div class="sectionBody" id="secSetsBody">
            <div class="krow">
              <label>[NEW SET NAME]</label>
              <input id="newSetName" type="text" placeholder="[NAME]" />
            </div>
            <button id="addSetBtn">ADD SET</button>
            <div class="divLine"></div>
            <div id="setsList"></div>
          </div>
        </div>

      </div>
    </div>

    <div id="ketaNote">
      <div id="ketaNoteHead">
        <div>[KETA_NOTE]</div>
        <div class="row">
          <button class="iconBtn" id="noteClose">×</button>
        </div>
      </div>
      <div id="ketaNoteBody">
        <textarea id="noteText" placeholder="[NOTE]"></textarea>
      </div>
    </div>

    <div class="toast" id="toast"></div>
    <div id="persistProbe"></div>
  </div>
</div>

<!-- =========================================================
EE ▸ ENGINE + WIRING (NO AESTHETIC DRIFT)
========================================================= -->
<script>
/* =========================================================
WB ▸ URLS (EDIT THESE AS YOU LIKE — AESTHETIC FIXED)
========================================================= */
const URLS = {
  LANDING:"index.html",
  BASE:"system.html",
  CALENDAR:"calendar.html",
  POD:"pod.html",
  WORLD:"world.html",
  KDTV:"kdtv1.html",
  PHOTOBOOTH:"photobooth.html",
  STUDIO:"studio.html",
  MAP:"map.html"
};

/* =========================================================
EE ▸ STORAGE — BASE STATE MUST BE IMMUTABLE UNLESS USER RESETS
FIX:
- Path-scoped Base key so sibling pages cannot clobber Base
- Atomic-ish write MAIN+BACKUP+TMP
- Lifecycle flush (pagehide/visibilitychange/beforeunload)
- Cross-tab sync listens to the actual Base key
========================================================= */
const FILE_ID="KETADATA_SHELL8";
const PAGE_ID="BASE_SYSTEM";
const STORAGE_EPOCH="BASE_CANON";

function nowISO(){return new Date().toISOString();}
const $=(id)=>document.getElementById(id);

const root=$("root");
const stage=$("stage");
const motion=$("motion");

/* =========================================================
EE ▸ DIVA PERSISTENCE KERNEL (LAZY + PROVABLE)
GOAL: Base sovereign state persists across refresh, hotkey return, and tabs.
RULES:
- One canonical state string.
- Always verify write by reading back + comparing hash.
- If localStorage fails or is cleared, fall back to IndexedDB.
- One rehydrate before first render. No “restore paths” stomping state.
- Cross-tab sync via BroadcastChannel.
========================================================= */

/* Canonical keys (constant across file renames) */
const KEY_BASE = "KDT::BASE::SOVEREIGN::STATE";
const KEY_META = "KDT::BASE::SOVEREIGN::META";
const BC_NAME  = "KDT::BASE::SOVEREIGN::BC";

/* IndexedDB fallback */
const IDB_NAME = "KDT_BASE_DB";
const IDB_STORE= "kv";
const IDB_KEY  = "STATE";

/* Probe (hidden unless toggled) */
let PROBE_ON = false;
function probeSet(lines){
  const el=$("persistProbe");
  if(!el) return;
  el.innerHTML = lines.map(s=>`<div>${escapeHTML(s)}</div>`).join("");
  el.style.display = PROBE_ON ? "block" : "none";
}
function escapeHTML(s){
  return String(s||"").replace(/[&<>"]/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;" }[c]));
}

/* Small, fast hash (FNV-1a) */
function fnv1a(str){
  const s=String(str||"");
  let h=2166136261;
  for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619); }
  return (h>>>0).toString(16);
}
function bytes(str){ return new Blob([String(str||"")]).size; }

function originSig(){
  return `${location.origin}${location.pathname}`;
}

/* IDB minimal */
function idbOpen(){
  return new Promise((resolve,reject)=>{
    const req=indexedDB.open(IDB_NAME,1);
    req.onupgradeneeded=()=>{ req.result.createObjectStore(IDB_STORE); };
    req.onsuccess=()=>resolve(req.result);
    req.onerror=()=>reject(req.error);
  });
}
async function idbGet(k){
  const db=await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx=db.transaction(IDB_STORE,"readonly");
    const st=tx.objectStore(IDB_STORE);
    const rq=st.get(k);
    rq.onsuccess=()=>resolve(rq.result||null);
    rq.onerror=()=>reject(rq.error);
  });
}
async function idbSet(k,v){
  const db=await idbOpen();
  return new Promise((resolve,reject)=>{
    const tx=db.transaction(IDB_STORE,"readwrite");
    tx.oncomplete=()=>resolve(true);
    tx.onerror=()=>reject(tx.error);
    tx.objectStore(IDB_STORE).put(v,k);
  });
}

/* Read raw string from storage (LS first, then IDB) */
async function readRawState(){
  try{
    const ls=localStorage.getItem(KEY_BASE);
    if(ls && typeof ls==="string") return { raw: ls, source: "localStorage" };
  }catch(_){}
  try{
    const idb=await idbGet(IDB_KEY);
    if(idb && typeof idb==="string") return { raw: idb, source: "indexedDB" };
  }catch(_){}
  return { raw: null, source: "none" };
}

/* Write raw string with verification + fallback */
async function writeRawState(raw){
  const h=fnv1a(raw);
  const b=bytes(raw);
  const meta = { updatedAt: nowISO(), hash: h, bytes: b, origin: location.origin, page: location.pathname };
  let okLS=false, okIDB=false, verified=false;

  // Attempt localStorage
  try{
    localStorage.setItem(KEY_BASE, raw);
    localStorage.setItem(KEY_META, JSON.stringify(meta));
    okLS=true;
    const back=localStorage.getItem(KEY_BASE);
    verified = (back === raw) && (fnv1a(back) === h);
  }catch(_){
    okLS=false;
    verified=false;
  }

  // If LS failed or verification failed, fall back to IDB
  if(!verified){
    try{
      await idbSet(IDB_KEY, raw);
      okIDB=true;
      // Best-effort meta mirror in LS (not required)
      try{ localStorage.setItem(KEY_META, JSON.stringify(meta)); }catch(_){}
      verified=true;
    }catch(_){
      okIDB=false;
    }
  }

  // Probe output
  probeSet([
    `[PERSIST] ${verified ? "OK" : "FAIL"}`,
    `ORIGIN: ${location.origin}`,
    `PATH: ${location.pathname}`,
    `KEY: ${KEY_BASE}`,
    `HASH: ${h.slice(0,8)}`,
    `BYTES: ${b}`,
    `LS: ${okLS ? "WRITE" : "FAIL"} / ${verified && okLS ? "VERIFIED" : (okLS ? "UNVERIFIED" : "—")}`,
    `IDB: ${okIDB ? "WRITE" : "—"}`,
    `AT: ${meta.updatedAt}`
  ]);

  // Broadcast to other tabs if verified
  if(verified){
    try{
      const bc = new BroadcastChannel(BC_NAME);
      bc.postMessage({ type:"STATE_SAVED", hash:h, bytes:b, at:meta.updatedAt });
      bc.close();
    }catch(_){}
  }

  return verified;
}

function writeRawStateSync(raw){
  const s=String(raw||"");
  const h=fnv1a(s);
  const b=bytes(s);
  const meta = { updatedAt: nowISO(), hash: h, bytes: b, origin: location.origin, page: location.pathname };
  try{
    localStorage.setItem(KEY_BASE, s);
    localStorage.setItem(KEY_META, JSON.stringify(meta));
    const back=localStorage.getItem(KEY_BASE);
    const verified = (back===s) && (fnv1a(back)===h);
    if(verified){
      // Minimal probe update (do not spam unless probe is on)
      probeSet([
        `[PERSIST] OK (SYNC)`,
        `ORIGIN: ${location.origin}`,
        `PATH: ${location.pathname}`,
        `KEY: ${KEY_BASE}`,
        `HASH: ${h.slice(0,8)}`,
        `BYTES: ${b}`,
        `AT: ${meta.updatedAt}`
      ]);
    }
    return verified;
  }catch(_){
    return false;
  }
}

/* JSON helpers */
function safeParseJSON(s){
  try{ return JSON.parse(s); }catch(_){ return null; }
}
function loadLocal(){
  // Sync: localStorage only (fast, deterministic for first render)
  try{
    const raw = localStorage.getItem(KEY_BASE);
    if(!raw) return null;
    const obj = safeParseJSON(raw);
    if(!obj) return null;

    const h=fnv1a(raw), b=bytes(raw);
    probeSet([
      `[LOAD] OK`,
      `SOURCE: localStorage`,
      `ORIGIN: ${location.origin}`,
      `PATH: ${location.pathname}`,
      `KEY: ${KEY_BASE}`,
      `HASH: ${h.slice(0,8)}`,
      `BYTES: ${b}`
    ]);
    return obj;
  }catch(_){
    return null;
  }
}

// Async fallback: IndexedDB (used after first render if LS missing)
async function loadLocalAsync(){
  const { raw, source } = await readRawState();
  if(!raw) return null;
  const obj = safeParseJSON(raw);
  if(!obj) return null;

  const h=fnv1a(raw), b=bytes(raw);
  probeSet([
    `[LOAD] OK`,
    `SOURCE: ${source}`,
    `ORIGIN: ${location.origin}`,
    `PATH: ${location.pathname}`,
    `KEY: ${KEY_BASE}`,
    `HASH: ${h.slice(0,8)}`,
    `BYTES: ${b}`
  ]);
  return obj;
}

/* Save scheduling (debounced) */
let _SAVE_T=null;
let _SAVE_PENDING=false;
function scheduleSave(){
  _SAVE_PENDING=true;
  if(_SAVE_T) clearTimeout(_SAVE_T);
  _SAVE_T=setTimeout(async ()=>{
    _SAVE_T=null;
    if(!_SAVE_PENDING) return;
    _SAVE_PENDING=false;
    await persist(true); // persist() defined later
  }, 140);
}

/* Hard flush on leave / nav (sync) */
function flushSaveSync(){ try{ const raw=JSON.stringify(STATE); writeRawStateSync(raw); }catch(_){ } }

/* Cross-tab: listen for broadcasts and rehydrate */
(function bindCrossTab(){
  try{
    const bc = new BroadcastChannel(BC_NAME);
    bc.onmessage = async (ev)=>{
      if(!ev || !ev.data || ev.data.type!=="STATE_SAVED") return;
      // Rehydrate from canonical storage; do not “merge,” just load.
      const obj = await loadLocalAsync();
      if(!obj) return;
      if(typeof window.__APPLY_REMOTE_STATE__ === "function"){
        window.__APPLY_REMOTE_STATE__(obj);
      }
    };
  }catch(_){}
})();

/* Lifecycle flush */
window.addEventListener("pagehide", ()=>{ flushSaveSync(); }, {capture:true});
window.addEventListener("beforeunload", ()=>{ flushSaveSync(); }, {capture:true});
document.addEventListener("visibilitychange", ()=>{ if(document.visibilityState==="hidden") flushSaveSync(); }, {capture:true});

/* Probe toggle hotkey: SHIFT+? (SHIFT+/) */
window.addEventListener("keydown",(ev)=>{
  if(ev.shiftKey && ev.key==="?"){
    ev.preventDefault();
    PROBE_ON = !PROBE_ON;
    const el=$("persistProbe");
    if(el) el.style.display = PROBE_ON ? "block" : "none";
  }
}, {passive:false});


/* =========================================================
EE ▸ DEFAULT PRESETS (ALWAYS PRESENT)
========================================================= */
const CORE_PRESETS = [
  { room:"CALENDAR",  roomUrl:URLS.CALENDAR },
  { room:"POD",       roomUrl:URLS.POD },
  { room:"WORLD",     roomUrl:URLS.WORLD },
  { room:"KDTV",      roomUrl:URLS.KDTV },
  { room:"PHOTOBOOTH",roomUrl:URLS.PHOTOBOOTH },
  { room:"STUDIO",    roomUrl:URLS.STUDIO },
  { room:"MAP",       roomUrl:URLS.MAP }
];

function ensureCorePresets(){
  if(!STATE.rooms) STATE.rooms=[];
  const byName=new Map(STATE.rooms.map(r=>[r.room,r]));
  for(const p of CORE_PRESETS){
    if(!byName.has(p.room)){
      STATE.rooms.push({room:p.room, roomUrl:p.roomUrl, pinned:true});
    }else{
      const r=byName.get(p.room);
      if(!r.roomUrl) r.roomUrl=p.roomUrl;
    }
  }
  if(!STATE.pinnedSets) STATE.pinnedSets=[];
  if(!STATE.sets) STATE.sets=[];
  if(!STATE.ui) STATE.ui={};
  if(typeof STATE.ui.motion!=="boolean") STATE.ui.motion=true;
  if(!STATE.ui.drawer) STATE.ui.drawer=true;
  if(!STATE.ui.sectionCollapse) STATE.ui.sectionCollapse={};
}

/* =========================================================
EE ▸ DEFAULT STATE
========================================================= */
const DEFAULT = {
  version:"8.0.0",
  updatedAt: nowISO(),
  ui:{
    invert:false,
    fullscreen:false,
    null:false,
    light:0,
    drawer:true,
    drawerH:520,
    textSize:12,
    motion:true,
    sectionCollapse:{
      secRegistry:false,
      secUniversals:false,
      secDrawer:false,
      secUnpinned:false,
      secSets:false
    }
  },
  nav:{
    armed:null
  },
  rooms: structuredClone(CORE_PRESETS).map(r=>({room:r.room, roomUrl:r.roomUrl, pinned:true})),
  sets: [],
  pinnedSets: [],
  ketaNote:{
    open:false,
    text:"",
    rect:{ x:null, y: null, w:320, h:220 }
  },
  payload:{
    exportLabel:"",
    exportTag:"",
  }
};

function mergeDefault(obj){
  const out=structuredClone(DEFAULT);
  Object.assign(out,obj||{});
  out.ui=Object.assign(structuredClone(DEFAULT.ui),(obj&&obj.ui)||{});
  out.payload=Object.assign(structuredClone(DEFAULT.payload),(obj&&obj.payload)||{});

  if(!out.ui.sectionCollapse) out.ui.sectionCollapse=structuredClone(DEFAULT.ui.sectionCollapse);
  else out.ui.sectionCollapse=Object.assign(structuredClone(DEFAULT.ui.sectionCollapse), out.ui.sectionCollapse);

  if(!Array.isArray(out.rooms)) out.rooms=structuredClone(DEFAULT.rooms);
  if(!Array.isArray(out.sets)) out.sets=[];
  if(!Array.isArray(out.pinnedSets)) out.pinnedSets=[];
  if(!out.ketaNote) out.ketaNote=structuredClone(DEFAULT.ketaNote);
  if(!out.ketaNote.rect) out.ketaNote.rect=structuredClone(DEFAULT.ketaNote.rect);

  return out;
}

/* =========================================================
WB ▸ HELPERS
========================================================= */
function toast(msg){
  const t=$("toast");
  t.textContent=msg;
  t.style.display="block";
  clearTimeout(toast._t);
  toast._t=setTimeout(()=>t.style.display="none",1200);
}
function setBodyClass(){
  const c=document.body.classList;
  c.toggle("invert", !!STATE.ui.invert);
  c.toggle("fullscreen", !!STATE.ui.fullscreen);
  c.toggle("null", !!STATE.ui.null);
  for(let i=1;i<=6;i++) c.toggle("light"+i, STATE.ui.light===i);
}
function applyMotion(){
  motion.style.display = STATE.ui.motion ? "block" : "none";
}
function setTextSize(){
  root.style.fontSize = STATE.ui.textSize + "px";
}
function setDrawerHeight(){
  $("drawer").style.height = `calc(100% - var(--top) - var(--bot) - 24px)`;
  $("drawer").style.maxHeight = `calc(100% - var(--top) - var(--bot) - 24px)`;
  $("drawerBody").style.maxHeight = (STATE.ui.drawerH - 44) + "px";
  $("drawerBody").style.height = (STATE.ui.drawerH - 44) + "px";
}
function sig(){
  return `[${FILE_ID}] [${PAGE_ID}] [${STATE.version}]`;
}
function setSigs(){
  $("stateSig").textContent=sig();
  $("drawerSig").textContent=originSig();
  $("statusRight").textContent=`[UPDATED ${STATE.updatedAt}]`;
}

/* =========================================================
EE ▸ PERSIST + IMPORT/EXPORT
========================================================= */
async function persist(silent=false){
  // UI first (no perceived lag), then persist.
  STATE.updatedAt=nowISO();
  ensureCorePresets();
  root.style.setProperty("--drawer-h", String(STATE.ui.drawerH));

  if(!silent) render();

  const raw = JSON.stringify(STATE);
  await writeRawState(raw);
}

function exportState(){
  persist(true);
  const blob=new Blob([JSON.stringify(STATE,null,2)], {type:"application/json"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="KETADATA_BASE_STATE.json";
  a.click();
  URL.revokeObjectURL(a.href);
  toast("[EXPORTED]");
}

function promptExport(){
  persist(true);
  const payload={
    file: "system.html",
    state: STATE,
    note: "[PASTE THIS INTO GPT OR ARCHIVE]"
  };
  const blob=new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="KETADATA_BASE_PROMPT.json";
  a.click();
  URL.revokeObjectURL(a.href);
  toast("[PROMPT EXPORTED]");
}

function importState(){
  const inp=document.createElement("input");
  inp.type="file";
  inp.accept="application/json";
  inp.onchange=async ()=>{
    const f=inp.files && inp.files[0];
    if(!f) return;
    const txt=await f.text();
    const obj=safeParseJSON(txt);
    if(!obj){ toast("[INVALID JSON]"); return; }
    STATE=mergeDefault(obj);
    ensureCorePresets();
    render();
    await persist(true);
    toast("[IMPORTED]");
  };
  inp.click();
}

function hardReset(){
  try{
    localStorage.removeItem(KEY_BASE);
    localStorage.removeItem(KEY_META);
  }catch(_){}
  // IDB best effort clear
  (async()=>{ try{ await idbSet(IDB_KEY, ""); }catch(_){ } })();
  STATE=mergeDefault(DEFAULT);
  ensureCorePresets();
  render();
  persist(true);
  toast("[RESET]");
}

/* =========================================================
EE ▸ NAV
========================================================= */
function arm(target){
  STATE.nav.armed=target;
  scheduleSave();
  renderArmed();
}
function clearArm(){
  STATE.nav.armed=null;
  scheduleSave();
  renderArmed();
}
function finalizeBeforeNav(){ try{ const raw=JSON.stringify(STATE); writeRawStateSync(raw); }catch(_){ } }
function go(url){
  const u=String(url||"").trim();
  if(!u) return;
  finalizeBeforeNav();
  window.location.href=u;
}
function openNewTab(url){
  const u=String(url||"").trim();
  if(!u) return;
  finalizeBeforeNav();
  window.open(u,"_blank","noopener,noreferrer");
}

/* =========================================================
EE ▸ RENDER
========================================================= */
function renderArmed(){
  const t=$("armedTarget");
  const a=STATE.nav.armed;
  if(!a){ t.textContent="[NONE]"; return; }
  t.textContent=`[${a.label}]`;
}
function renderPinned(){
  const wrap=$("pinnedWrap");
  wrap.innerHTML="";

  const pinnedRooms=STATE.rooms.filter(r=>r.pinned);
  const pinnedSets=STATE.sets.filter(s=>STATE.pinnedSets.includes(s.id));

  // Pinned Rooms module
  const modRooms=document.createElement("div");
  modRooms.className="module";
  modRooms.dataset.type="rooms";
  modRooms.innerHTML=`
    <div class="moduleHead">
      <div class="mLeft"><div>[PINNED ROOMS]</div><div class="small dim">[DRAG ORDER]</div></div>
      <div class="mRight"><div class="small dim">[${pinnedRooms.length}]</div></div>
    </div>
    <div class="moduleBody">
      <div class="moduleGrid" id="gridRooms"></div>
    </div>
  `;
  wrap.appendChild(modRooms);

  const gridRooms=modRooms.querySelector("#gridRooms");
  for(const r of pinnedRooms){
    const c=document.createElement("div");
    c.className="card";
    c.draggable=true;
    c.dataset.kind="room";
    c.dataset.id=r.room;
    c.innerHTML=`
      <div class="title">[${r.room}]</div>
      <div class="meta">${r.roomUrl||""}</div>
      <div class="actions">
        <button data-act="arm">ARM</button>
        <button data-act="go">GO</button>
        <button data-act="newtab">NEW TAB</button>
        <button data-act="unpin">UNPIN</button>
      </div>
    `;
    c.querySelector('[data-act="arm"]').onclick=()=>arm({type:"room", id:r.room, url:r.roomUrl, label:r.room});
    c.querySelector('[data-act="go"]').onclick=()=>go(r.roomUrl);
    c.querySelector('[data-act="newtab"]').onclick=()=>openNewTab(r.roomUrl);
    c.querySelector('[data-act="unpin"]').onclick=()=>{ r.pinned=false; scheduleSave(); render(); };
    gridRooms.appendChild(c);
  }

  // Pinned Sets module
  const modSets=document.createElement("div");
  modSets.className="module";
  modSets.dataset.type="sets";
  modSets.innerHTML=`
    <div class="moduleHead">
      <div class="mLeft"><div>[PINNED SETS]</div><div class="small dim">[DRAG ORDER]</div></div>
      <div class="mRight"><div class="small dim">[${pinnedSets.length}]</div></div>
    </div>
    <div class="moduleBody">
      <div class="moduleGrid" id="gridSets"></div>
    </div>
  `;
  wrap.appendChild(modSets);

  const gridSets=modSets.querySelector("#gridSets");
  for(const s of pinnedSets){
    const c=document.createElement("div");
    c.className="card";
    c.draggable=true;
    c.dataset.kind="set";
    c.dataset.id=s.id;
    c.innerHTML=`
      <div class="title">[${s.name}]</div>
      <div class="meta">[${(s.items||[]).length} ROOMS]</div>
      <div class="actions">
        <button data-act="arm">ARM</button>
        <button data-act="unpin">UNPIN</button>
      </div>
    `;
    c.querySelector('[data-act="arm"]').onclick=()=>arm({type:"set", id:s.id, label:s.name});
    c.querySelector('[data-act="unpin"]').onclick=()=>{ STATE.pinnedSets=STATE.pinnedSets.filter(x=>x!==s.id); scheduleSave(); render(); };
    gridSets.appendChild(c);
  }

  bindDnD(modRooms, "room");
  bindDnD(modSets, "set");
}

function renderDrawer(){
  $("drawer").classList.toggle("hide", !STATE.ui.drawer);
  $("drawerBody").style.height = STATE.ui.drawerH + "px";
  $("drawerBody").style.maxHeight = STATE.ui.drawerH + "px";

  // Collapse states
  const map=STATE.ui.sectionCollapse||{};
  setCollapsed("secRegistry", !!map.secRegistry);
  setCollapsed("secUniversals", !!map.secUniversals);
  setCollapsed("secDrawer", !!map.secDrawer);
  setCollapsed("secUnpinned", !!map.secUnpinned);
  setCollapsed("secSets", !!map.secSets);

  // Universals
  $("textSize").value=STATE.ui.textSize;
  $("textSizeNum").value=STATE.ui.textSize;
  $("drawerH").value=STATE.ui.drawerH;
  $("drawerHNum").value=STATE.ui.drawerH;
  $("motionToggle").textContent = STATE.ui.motion ? "ON" : "OFF";

  // Unpinned rooms list
  const unp=$("unpinnedRooms");
  unp.innerHTML="";
  const unpRooms=STATE.rooms.filter(r=>!r.pinned);
  for(const r of unpRooms){
    const row=document.createElement("div");
    row.className="kchip";
    row.innerHTML=`
      <span class="t">[ROOM]</span>
      <span class="v">[${r.room}]</span>
      <button data-act="pin">PIN</button>
      <button data-act="arm">ARM</button>
      <button data-act="go">GO</button>
    `;
    row.querySelector('[data-act="pin"]').onclick=()=>{ r.pinned=true; scheduleSave(); render(); };
    row.querySelector('[data-act="arm"]').onclick=()=>arm({type:"room", id:r.room, url:r.roomUrl, label:r.room});
    row.querySelector('[data-act="go"]').onclick=()=>go(r.roomUrl);
    unp.appendChild(row);
  }

  // Sets list
  const sets=$("setsList");
  sets.innerHTML="";
  for(const s of STATE.sets){
    const box=document.createElement("div");
    box.className="card";
    box.innerHTML=`
      <div class="title">[${s.name}]</div>
      <div class="meta">[${(s.items||[]).length} ROOMS]</div>
      <div class="actions">
        <button data-act="togglePin">${STATE.pinnedSets.includes(s.id)?"UNPIN":"PIN"}</button>
        <button data-act="edit">EDIT</button>
        <button data-act="del">DELETE</button>
      </div>
      <div class="divLine"></div>
      <div class="col" data-edit="wrap" style="display:none;">
        <div class="small dim">[ROOMS IN SET]</div>
        <div class="col" data-edit="items"></div>
        <div class="krow">
          <input type="text" data-edit="add" placeholder="[ADD ROOM URL]" />
          <button data-edit="addBtn">ADD</button>
        </div>
      </div>
    `;
    box.querySelector('[data-act="togglePin"]').onclick=()=>{
      if(STATE.pinnedSets.includes(s.id)) STATE.pinnedSets=STATE.pinnedSets.filter(x=>x!==s.id);
      else STATE.pinnedSets.push(s.id);
      scheduleSave(); render();
    };
    const wrap=box.querySelector('[data-edit="wrap"]');
    box.querySelector('[data-act="edit"]').onclick=()=>{
      wrap.style.display = wrap.style.display==="none" ? "block" : "none";
    };
    box.querySelector('[data-act="del"]').onclick=()=>{
      STATE.sets=STATE.sets.filter(x=>x.id!==s.id);
      STATE.pinnedSets=STATE.pinnedSets.filter(x=>x!==s.id);
      scheduleSave(); render();
    };

    const itemsEl=box.querySelector('[data-edit="items"]');
    function renderItems(){
      itemsEl.innerHTML="";
      for(let i=0;i<(s.items||[]).length;i++){
        const it=s.items[i];
        const row=document.createElement("div");
        row.className="kchip";
        row.innerHTML=`
          <span class="t">[URL]</span>
          <span class="v">${it}</span>
          <button data-act="arm">ARM</button>
          <button data-act="go">GO</button>
          <button data-act="newtab">NEW TAB</button>
          <button data-act="rm">×</button>
        `;
        row.querySelector('[data-act="arm"]').onclick=()=>arm({type:"url", id:it, url:it, label:s.name});
        row.querySelector('[data-act="go"]').onclick=()=>go(it);
        row.querySelector('[data-act="newtab"]').onclick=()=>openNewTab(it);
        row.querySelector('[data-act="rm"]').onclick=()=>{
          s.items.splice(i,1);
          scheduleSave();
          renderItems();
        };
        itemsEl.appendChild(row);
      }
    }
    renderItems();
    box.querySelector('[data-edit="addBtn"]').onclick=()=>{
      const inp=box.querySelector('[data-edit="add"]');
      const v=String(inp.value||"").trim();
      if(!v) return;
      if(!s.items) s.items=[];
      s.items.push(v);
      inp.value="";
      scheduleSave();
      renderItems();
    };

    sets.appendChild(box);
  }
}

function renderKetaNote(){
  const on=!!STATE.ketaNote.open;
  const note=$("ketaNote");
  note.style.display = on ? "block" : "none";
  $("noteText").value = STATE.ketaNote.text || "";

  if(on){
    // Dock under icon on the right unless user has explicit x
    const rect=STATE.ketaNote.rect||{};
    const icon=$("ketaNoteIcon").getBoundingClientRect();
    const stageRect=$("stage").getBoundingClientRect();

    const w=rect.w||320, h=rect.h||220;
    let x = (rect.x==null)
      ? (stageRect.width - w - 12) // right dock
      : rect.x;
    let y = (rect.y==null)
      ? 12
      : rect.y;

    // clamp
    x = Math.max(12, Math.min(stageRect.width - w - 12, x));
    y = Math.max(12, Math.min(stageRect.height - h - 12, y));

    note.style.left = (stageRect.left + x) + "px";
    note.style.top  = (stageRect.top + y) + "px";
    note.style.width = w + "px";
    note.style.height= h + "px";
  }
}

function render(){
  ensureCorePresets();
  setBodyClass();
  applyMotion();
  setTextSize();
  setDrawerHeight();
  setSigs();
  renderArmed();
  renderPinned();
  renderDrawer();
  renderKetaNote();
}

/* =========================================================
WB ▸ COLLAPSE TOGGLES
========================================================= */
function setCollapsed(secId, collapsed){
  const body=$(secId+"Body");
  if(!body) return;
  body.classList.toggle("collapsed", collapsed);
}
function toggleSection(secId){
  if(!STATE.ui.sectionCollapse) STATE.ui.sectionCollapse={};
  const key=secId;
  STATE.ui.sectionCollapse[key]=!STATE.ui.sectionCollapse[key];
  scheduleSave();
  renderDrawer();
}

/* =========================================================
WB ▸ DND (PINNED ORDER)
========================================================= */
function bindDnD(container, kind){
  const grid=container.querySelector(".moduleGrid");
  if(!grid) return;

  let dragId=null;
  grid.querySelectorAll(".card").forEach(card=>{
    card.addEventListener("dragstart",(e)=>{
      dragId=card.dataset.id;
      e.dataTransfer.effectAllowed="move";
    });
    card.addEventListener("dragover",(e)=>{ e.preventDefault(); });
    card.addEventListener("drop",(e)=>{
      e.preventDefault();
      const targetId=card.dataset.id;
      if(!dragId || dragId===targetId) return;
      if(kind==="room"){
        const pinned=STATE.rooms.filter(r=>r.pinned);
        const all=STATE.rooms.slice();
        const order=pinned.map(r=>r.room);
        const from=order.indexOf(dragId);
        const to=order.indexOf(targetId);
        if(from<0||to<0) return;
        order.splice(to,0,order.splice(from,1)[0]);
        // rebuild pinned order in STATE.rooms by stable reinsert
        const pinnedSet=new Set(order);
        const unp=all.filter(r=>!r.pinned);
        const newPinned=[];
        for(const name of order){
          const r=all.find(x=>x.room===name);
          if(r) newPinned.push(r);
        }
        STATE.rooms=[...newPinned, ...unp];
      }else if(kind==="set"){
        const order=STATE.pinnedSets.slice();
        const from=order.indexOf(dragId);
        const to=order.indexOf(targetId);
        if(from<0||to<0) return;
        order.splice(to,0,order.splice(from,1)[0]);
        STATE.pinnedSets=order;
      }
      scheduleSave();
      render();
    });
  });
}

/* =========================================================
WB ▸ WIRING (EVENTS)
========================================================= */
$("drawerToggle").onclick=()=>{ STATE.ui.drawer=!STATE.ui.drawer; scheduleSave(); render(); };
$("drawerClose").onclick=()=>{ STATE.ui.drawer=false; scheduleSave(); render(); };

$("armedGo").onclick=()=>{
  const a=STATE.nav.armed;
  if(!a){ toast("[NO TARGET]"); return; }
  if(a.type==="room" || a.type==="url"){ go(a.url); return; }
  if(a.type==="set"){
    const s=STATE.sets.find(x=>x.id===a.id);
    if(!s){ toast("[SET MISSING]"); return; }
    // open drawer edit? For now: arm only, user chooses item. (No drift.)
    toast("[SET ARMED]");
  }
};
$("armedNewTab").onclick=()=>{
  const a=STATE.nav.armed;
  if(!a){ toast("[NO TARGET]"); return; }
  if(a.type==="room" || a.type==="url"){ openNewTab(a.url); return; }
  toast("[SET ARMED]");
};
$("armedClear").onclick=()=>{ clearArm(); toast("[CLEARED]"); };

$("importBtn").onclick=importState;
$("exportBtn").onclick=exportState;
$("promptBtn").onclick=promptExport;
$("resetBtn").onclick=hardReset;

$("motionToggle").onclick=()=>{ STATE.ui.motion=!STATE.ui.motion; scheduleSave(); render(); };

$("textSize").oninput=(e)=>{ STATE.ui.textSize=+e.target.value; $("textSizeNum").value=STATE.ui.textSize; scheduleSave(); setTextSize(); };
$("textSizeNum").oninput=(e)=>{ STATE.ui.textSize=+e.target.value; $("textSize").value=STATE.ui.textSize; scheduleSave(); setTextSize(); };

$("drawerH").oninput=(e)=>{ STATE.ui.drawerH=+e.target.value; $("drawerHNum").value=STATE.ui.drawerH; scheduleSave(); setDrawerHeight(); };
$("drawerHNum").oninput=(e)=>{ STATE.ui.drawerH=+e.target.value; $("drawerH").value=STATE.ui.drawerH; scheduleSave(); setDrawerHeight(); };

document.querySelectorAll("[data-collapse]").forEach(btn=>{
  btn.onclick=()=>toggleSection(btn.getAttribute("data-collapse"));
});

$("ketaNoteIcon").onclick=()=>{
  STATE.ketaNote.open = !STATE.ketaNote.open;
  if(STATE.ketaNote.open){
    // force dock-right by default unless user has moved it
    if(STATE.ketaNote.rect) STATE.ketaNote.rect.x = null;
  }
  scheduleSave();
  render();
};
$("noteClose").onclick=()=>{ STATE.ketaNote.open=false; scheduleSave(); render(); };
$("noteText").addEventListener("input",(e)=>{
  STATE.ketaNote.text = e.target.value;
  scheduleSave();
});

$("addSetBtn").onclick=()=>{
  const name=String($("newSetName").value||"").trim();
  if(!name){ toast("[NAME REQUIRED]"); return; }
  const id="SET_"+Math.random().toString(16).slice(2,10).toUpperCase();
  STATE.sets.push({id, name, items:[]});
  $("newSetName").value="";
  scheduleSave();
  render();
};

/* =========================================================
WB ▸ HOTKEYS (LOCKED)
========================================================= */
function bindHotkeys(){
  window.addEventListener("keydown",(e)=>{
    const tag=(e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    const typing = (tag==="input" || tag==="textarea" || e.target.isContentEditable);

    // LIGHTS 1-6 continuous (do not interfere with typing unless not typing)
    if(!typing && /^[1-6]$/.test(e.key)){
      STATE.ui.light=+e.key;
      scheduleSave();
      render();
      return;
    }

    if(!e.shiftKey) return;

    if(e.key.toLowerCase()==="i"){
      e.preventDefault();
      STATE.ui.invert=!STATE.ui.invert;
      scheduleSave();
      render();
    }
    if(e.key.toLowerCase()==="n"){
      e.preventDefault();
      STATE.ui.null=!STATE.ui.null;
      scheduleSave();
      render();
    }
    if(e.key.toLowerCase()==="f"){
      e.preventDefault();
      STATE.ui.fullscreen=!STATE.ui.fullscreen;
      scheduleSave();
      render();
    }
    if(e.key.toLowerCase()==="k"){
      e.preventDefault();
      // landing snap (Base uses it as return)
      finalizeBeforeNav();
      window.location.href=URLS.LANDING;
    }
    // Optional: return to BASE via Shift+B (if used from other pages, safe)
    if(e.key.toLowerCase()==="b"){
      e.preventDefault();
      finalizeBeforeNav();
      window.location.href=URLS.BASE;
    }
  }, {passive:false});
}

/* =========================================================
BOOT
========================================================= */
const _BOOT_LOADED = loadLocal();
let STATE = _BOOT_LOADED || structuredClone(DEFAULT);
ensureCorePresets();
bindHotkeys();

render();

// Cross-tab + async restore hook (IDB fallback and BroadcastChannel)
window.__APPLY_REMOTE_STATE__ = function(obj){
  try{
    STATE = mergeDefault(obj||{});
    ensureCorePresets();
    render();
    // Do not auto-save here; the sender already saved.
  }catch(_){}
};

// If localStorage is empty but IDB has a state, rehydrate after first render.
(async function idbFallbackRehydrate(){
  try{
    const hasLS = !!localStorage.getItem(KEY_BASE);
    if(hasLS) return;
  }catch(_){ /* ignore */ }
  const obj = await loadLocalAsync();
  if(!obj) return;
  STATE = mergeDefault(obj||{});
  ensureCorePresets();
  render();
  // Seed localStorage so refresh becomes fully deterministic going forward.
  await persist(true);
})();

/* Do NOT overwrite an existing Base. Only seed if empty. */
(function seedOnce(){
  try{
    if(!localStorage.getItem(KEY_BASE)){
      persist(true);
    }
  }catch(_){}
})();

</script>

<!-- =========================================================
AE/EE/WB SERIALIZATION STAMP (MANDATORY)
FILE_ID: KETADATA_SHELL8
ROOM_ID: BASE_SYSTEM
VERSION: 8.0.0
UPDATED_AT: 2025-12-27T00:00:00.000Z
CHANGELOG:
- EE-CORE: Diva persistence kernel (single sovereign key + verified write + IDB fallback + BroadcastChannel sync)
- EE-NAV: Sync flush before navigation + lifecycle flush
- EE-PROBE: Hidden persistence probe toggle SHIFT+? for truth diagnostics (no surface drift)
========================================================= -->
</body>
</html>
