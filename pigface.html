<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA // PIGFACE</title>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --muted:rgba(255,255,255,.58);
      --hair:rgba(255,255,255,.10);
      --panel:rgba(0,0,0,.35);
      --panel2:rgba(0,0,0,.62);
      --motion:1;

      --breath:0.55;   /* slow life */
      --blink:0.42;    /* blink frequency */
      --snort:0.30;    /* micro puff */
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:var(--bg);
      color:var(--fg);
      font:10px/1.3 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      overflow:hidden;
      user-select:none;
      letter-spacing:0.03em;
    }
    body.invert{ filter: invert(1) hue-rotate(180deg); background:#fff; }
    body.nullmode .chrome{display:none}
    body.nullmode #hud{opacity:0; pointer-events:none}

    #field{
      position:absolute; inset:0;
      background:
        radial-gradient(1800px 1400px at 50% 45%, rgba(255,255,255,.11), rgba(0,0,0,0) 70%),
        radial-gradient(1200px 1100px at 28% 82%, rgba(255,255,255,.05), rgba(0,0,0,0) 66%),
        radial-gradient(1000px 900px at 76% 26%, rgba(255,255,255,.035), rgba(0,0,0,0) 64%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,0) 52%),
        linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.52));
    }
    canvas{position:absolute; inset:0; width:100%; height:100%}

    .chrome{position:absolute; inset:0; pointer-events:none}
    .corner{
      position:absolute; width:40px; height:40px;
      border:1px solid var(--hair); opacity:.38;
    }
    .corner.tl{top:12px; left:12px; border-right:none; border-bottom:none;}
    .corner.tr{top:12px; right:12px; border-left:none; border-bottom:none;}
    .corner.bl{bottom:12px; left:12px; border-right:none; border-top:none;}
    .corner.br{bottom:12px; right:12px; border-left:none; border-top:none;}

    #hud{
      position:absolute;
      top:12px; right:12px;
      border:1px solid var(--hair);
      background:var(--panel);
      backdrop-filter: blur(8px);
      padding:8px 10px;
      opacity:.88;
      pointer-events:auto;
      display:flex;
      gap:10px;
      align-items:center;
      white-space:nowrap;
    }
    .btn{
      border:1px solid var(--hair);
      background:rgba(255,255,255,.03);
      padding:5px 8px;
      cursor:pointer;
      font:inherit;
      color:inherit;
    }
    .btn:hover{background:rgba(255,255,255,.08)}
    .btn:active{transform: translateY(1px)}
    .sep{opacity:.45}

    #info{
      position:absolute;
      bottom:12px; left:12px;
      border:1px solid var(--hair);
      background:rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      padding:8px 10px;
      opacity:.78;
      pointer-events:none;
      max-width:60vw;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    #note{
      position:absolute;
      left:12px; top:12px;
      width:360px; height:220px;
      border:1px solid var(--hair);
      background:var(--panel2);
      pointer-events:auto;
      display:none;
    }
    #note.open{display:block}
    #note .bar{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 8px;
      border-bottom:1px solid var(--hair);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,0));
      cursor:move;
      user-select:none;
    }
    #note textarea{
      width:100%; height: calc(100% - 34px);
      border:0; outline:none; resize:none;
      background:transparent;
      color:var(--fg);
      font:inherit;
      padding:8px;
      user-select:text;
    }
  </style>
</head>
<body>
  <div id="field"><canvas id="c"></canvas></div>

  <div class="chrome">
    <div class="corner tl"></div><div class="corner tr"></div><div class="corner bl"></div><div class="corner br"></div>

    <div id="hud">
      <button class="btn" id="btnInvert">INVERT</button>
      <span class="sep">|</span>
      <button class="btn" id="btnBlink">BLINK</button>
      <button class="btn" id="btnSnort">SNORT</button>
      <button class="btn" id="btnMotion">MOTION ON</button>
      <span class="sep">|</span>
      <button class="btn" id="btnNull">NULL</button>
      <button class="btn" id="btnFull">FULL</button>
      <button class="btn" id="btnNote">NOTE</button>
    </div>

    <div id="note">
      <div class="bar">
        <div>KETA_NOTE</div>
        <div style="opacity:.55">SHIFT+K TO TOGGLE</div>
      </div>
      <textarea id="noteText" spellcheck="false" placeholder="KETA_NOTE — optional, movable, non-interfering."></textarea>
    </div>

    <div id="info">KETADATA // PIGFACE · SHIFT+I INVERT · SPACE BLINK · ENTER SNORT · SHIFT+N NULL · SHIFT+F FULL</div>
  </div>

<script>
/* EE: local-first */
const FILE_ID = "KETADATA_PIGFACE_MONO_V1";
const LS_KEY = "KETADATA::" + FILE_ID + "::STATE";
const $ = (id)=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;

const S = {
  invert:false, nullMode:false, fullscreen:false, motion:true,
  breath:0.55, blinkRate:0.42, snortAmt:0.30,
  noteOpen:false, notePos:{x:null,y:null}, noteText:"",
  blink:0, snort:0, breathPh:0,
  seed:(Math.random()*1e9)>>>0
};

function loadState(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(!s || typeof s !== "object") return;
    Object.assign(S, s);
  }catch(_){}
}
function saveState(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(S)); }catch(_){ } }

function apply(){
  document.body.classList.toggle("invert", !!S.invert);
  document.body.classList.toggle("nullmode", !!S.nullMode);
  $("btnMotion").textContent = S.motion ? "MOTION ON" : "MOTION OFF";
  $("noteText").value = S.noteText || "";
  $("note").classList.toggle("open", !!S.noteOpen);
  if(S.notePos && S.notePos.x!=null && S.notePos.y!=null){
    $("note").style.left = S.notePos.x + "px";
    $("note").style.top  = S.notePos.y + "px";
  }
}

function inv(){ return document.body.classList.contains("invert"); }
function col(a){ return inv() ? `rgba(10,12,15,${a})` : `rgba(255,255,255,${a})`; }

function rand(){
  S.seed = (S.seed * 1664525 + 1013904223) >>> 0;
  return (S.seed >>> 8) / 16777216;
}

/* canvas */
const canvas = $("c");
const ctx = canvas.getContext("2d", { alpha:true });
let W=0,H=0,DPR=1;

function resize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  W = Math.floor(window.innerWidth * DPR);
  H = Math.floor(window.innerHeight * DPR);
  canvas.width = W;
  canvas.height = H;
}
addEventListener("resize", resize);

/* breath vapor (monochrome) */
const vapor = [];
function puff(x,y,n,dir){
  for(let i=0;i<n;i++){
    vapor.push({
      x: x + (rand()*2-1)*6*DPR,
      y: y + (rand()*2-1)*4*DPR,
      vx: (dir + (rand()*2-1)*0.10) * (0.55 + rand()*0.35) * DPR,
      vy: -(0.15 + rand()*0.25) * DPR,
      r: (3 + rand()*12) * DPR,
      a: 0.06 + rand()*0.14,
      ph: rand()*Math.PI*2,
      w: 0.002 + rand()*0.006,
      life: 0,
      max: 140 + rand()*220
    });
  }
}
function drawV(p){
  const f = 1 - (p.life/p.max);
  ctx.fillStyle = inv() ? `rgba(10,12,15,${p.a*f})` : `rgba(255,255,255,${p.a*f})`;
  ctx.beginPath();
  ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
  ctx.fill();
}

/* pig face renderer */
function drawPig(cx, cy, scale, t){
  const Scl = scale;

  // life/breath
  const life = S.motion ? 1 : 0;
  S.breathPh += (0.004 + 0.003*S.breath) * life;
  const breath = Math.sin(S.breathPh) * (0.020 + 0.022*S.breath);
  const breathY = breath * Scl;
  const cheekPulse = (0.010 + 0.012*S.breath) * (0.5 + 0.5*Math.sin(S.breathPh*1.2)) * life;

  // blink
  if(S.blink > 0) S.blink = Math.max(0, S.blink - 0.035*life);
  if(S.blink <= 0 && life){
    const p = 0.0008 + 0.0016*S.blinkRate;
    if(Math.random() < p) S.blink = 1.25;
  }
  const blink = clamp(S.blink, 0, 1);
  const eyeOpen = 1 - blink;

  // snort decay
  if(S.snort > 0) S.snort = Math.max(0, S.snort - 0.030*life);
  const snort = clamp(S.snort, 0, 1);

  ctx.save();
  ctx.translate(cx, cy + breathY);
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  // subtle depth wash
  ctx.fillStyle = "rgba(0,0,0,.16)";
  ctx.beginPath();
  ctx.ellipse(0, Scl*0.12, Scl*0.78, Scl*0.68, 0, 0, Math.PI*2);
  ctx.fill();

  // HEAD MASS (rounder than cat, heavy)
  const headGrad = ctx.createRadialGradient(0, -Scl*0.35, 0, 0, 0, Scl*1.05);
  headGrad.addColorStop(0, col(0.22));
  headGrad.addColorStop(0.35, col(0.14));
  headGrad.addColorStop(0.72, col(0.07));
  headGrad.addColorStop(1, "rgba(0,0,0,0.10)");
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.ellipse(0, 0, Scl*0.76, Scl*0.68, 0, 0, Math.PI*2);
  ctx.fill();

  // head outline
  ctx.strokeStyle = col(0.95);
  ctx.lineWidth = 3.2*DPR;
  ctx.beginPath();
  ctx.ellipse(0, 0, Scl*0.76, Scl*0.68, 0, 0, Math.PI*2);
  ctx.stroke();

  // cheeks (soft pads)
  ctx.fillStyle = col(0.05);
  ctx.beginPath();
  ctx.ellipse(-Scl*0.38, Scl*0.10, Scl*(0.24+cheekPulse), Scl*(0.20+cheekPulse*0.8), -0.10, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(Scl*0.38, Scl*0.10, Scl*(0.24+cheekPulse), Scl*(0.20+cheekPulse*0.8), 0.10, 0, Math.PI*2);
  ctx.fill();

  // ears (floppy-ish triangles with rounded inner)
  function ear(side){
    const ex = side*Scl*0.54;
    const ey = -Scl*0.42;
    const flop = 0.18 + 0.10*Math.sin(S.breathPh*0.7 + side*0.6);
    ctx.fillStyle = "rgba(0,0,0,0.16)";
    ctx.beginPath();
    ctx.moveTo(ex, ey);
    ctx.quadraticCurveTo(ex + side*Scl*0.22, ey - Scl*0.18, ex + side*Scl*0.18, ey + Scl*0.18);
    ctx.quadraticCurveTo(ex + side*Scl*0.05, ey + Scl*0.30, ex - side*Scl*0.06, ey + Scl*0.18);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = col(0.08);
    ctx.strokeStyle = col(0.95);
    ctx.lineWidth = 3*DPR;
    ctx.beginPath();
    ctx.moveTo(ex, ey);
    ctx.quadraticCurveTo(ex + side*Scl*0.24, ey - Scl*(0.16+flop*0.2), ex + side*Scl*0.18, ey + Scl*0.18);
    ctx.quadraticCurveTo(ex + side*Scl*0.06, ey + Scl*0.32, ex - side*Scl*0.06, ey + Scl*0.18);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // inner ear
    ctx.strokeStyle = col(0.18);
    ctx.lineWidth = 1.6*DPR;
    ctx.beginPath();
    ctx.moveTo(ex + side*Scl*0.07, ey + Scl*0.08);
    ctx.quadraticCurveTo(ex + side*Scl*0.14, ey + Scl*0.02, ex + side*Scl*0.12, ey + Scl*0.16);
    ctx.stroke();
  }
  ear(-1); ear(1);

  // eye sockets (set wider)
  function eye(side){
    const ex = side*Scl*0.28;
    const ey = -Scl*0.10;

    // socket shadow
    ctx.fillStyle = "rgba(0,0,0,0.20)";
    ctx.beginPath();
    ctx.ellipse(ex, ey, Scl*0.16, Scl*0.12, 0, 0, Math.PI*2);
    ctx.fill();

    // eye shape
    if(eyeOpen > 0.12){
      const sclera = ctx.createRadialGradient(ex, ey, 0, ex, ey, Scl*0.12);
      sclera.addColorStop(0, col(0.16));
      sclera.addColorStop(1, col(0.08));
      ctx.fillStyle = sclera;
      ctx.beginPath();
      ctx.ellipse(ex, ey, Scl*0.11*eyeOpen, Scl*0.085*eyeOpen, 0, 0, Math.PI*2);
      ctx.fill();

      // iris (round, piggy)
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.beginPath();
      ctx.arc(ex + side*Scl*0.01, ey, Scl*0.030*eyeOpen, 0, Math.PI*2);
      ctx.fill();

      // highlight
      ctx.fillStyle = col(0.35);
      ctx.beginPath();
      ctx.arc(ex - side*Scl*0.03, ey - Scl*0.02, Scl*0.012, 0, Math.PI*2);
      ctx.fill();

      // outline
      ctx.strokeStyle = col(0.95);
      ctx.lineWidth = 2.6*DPR;
      ctx.beginPath();
      ctx.ellipse(ex, ey, Scl*0.11*eyeOpen, Scl*0.085*eyeOpen, 0, 0, Math.PI*2);
      ctx.stroke();

      // lid crease
      ctx.strokeStyle = col(0.12);
      ctx.lineWidth = 1.2*DPR;
      ctx.beginPath();
      ctx.arc(ex, ey - Scl*0.03, Scl*0.13, Math.PI*0.95, Math.PI*0.05);
      ctx.stroke();
    } else {
      // closed lids
      ctx.strokeStyle = col(0.95);
      ctx.lineWidth = 2.8*DPR;
      ctx.beginPath();
      ctx.ellipse(ex, ey, Scl*0.11, Scl*0.018, 0, 0, Math.PI*2);
      ctx.stroke();

      ctx.strokeStyle = col(0.18);
      ctx.lineWidth = 1.2*DPR;
      ctx.beginPath();
      ctx.arc(ex, ey, Scl*0.11, Math.PI*0.12, Math.PI*0.88);
      ctx.stroke();
    }
  }
  eye(-1); eye(1);

  // SNOUT (dominant, sensitive)
  const snx = 0;
  const sny = Scl*0.26;
  const snW = Scl*(0.44 + 0.035*Math.sin(S.breathPh*1.1)*life);
  const snH = Scl*(0.30 + 0.020*Math.sin(S.breathPh*1.1 + 1.2)*life);

  // snout shadow
  ctx.fillStyle = "rgba(0,0,0,0.18)";
  ctx.beginPath();
  ctx.ellipse(snx, sny + Scl*0.07, snW*0.98, snH*0.88, 0, 0, Math.PI*2);
  ctx.fill();

  // snout mass
  const snGrad = ctx.createRadialGradient(snx, sny - Scl*0.05, 0, snx, sny, Scl*0.50);
  snGrad.addColorStop(0, col(0.18));
  snGrad.addColorStop(0.55, col(0.10));
  snGrad.addColorStop(1, col(0.05));
  ctx.fillStyle = snGrad;
  ctx.beginPath();
  ctx.ellipse(snx, sny, snW, snH, 0, 0, Math.PI*2);
  ctx.fill();

  // snout outline
  ctx.strokeStyle = col(0.95);
  ctx.lineWidth = 3.0*DPR;
  ctx.beginPath();
  ctx.ellipse(snx, sny, snW, snH, 0, 0, Math.PI*2);
  ctx.stroke();

  // nostrils (oval cavities)
  const flare = (0.10 + 0.65*snort) * S.snortAmt;
  for(const side of [-1,1]){
    const nx = side*Scl*0.13;
    const ny = sny + Scl*0.02;
    const nrx = Scl*(0.060 + 0.030*flare);
    const nry = Scl*(0.085 + 0.040*flare);
    ctx.fillStyle = "rgba(0,0,0,0.82)";
    ctx.beginPath();
    ctx.ellipse(nx, ny, nrx, nry, side*0.10, 0, Math.PI*2);
    ctx.fill();

    // rim highlight
    ctx.strokeStyle = col(0.18 + 0.10*flare);
    ctx.lineWidth = 1.4*DPR;
    ctx.beginPath();
    ctx.ellipse(nx - side*Scl*0.010, ny - Scl*0.010, nrx*1.05, nry*1.05, side*0.10, Math.PI*1.05, Math.PI*1.90);
    ctx.stroke();
  }

  // philtrum / mouth (tiny)
  ctx.strokeStyle = col(0.22);
  ctx.lineWidth = 1.8*DPR;
  ctx.beginPath();
  ctx.moveTo(0, sny + Scl*0.12);
  ctx.quadraticCurveTo(0, sny + Scl*0.16, -Scl*0.10, sny + Scl*0.18);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, sny + Scl*0.12);
  ctx.quadraticCurveTo(0, sny + Scl*0.16, Scl*0.10, sny + Scl*0.18);
  ctx.stroke();

  // pores / skin texture (subtle, not noisy)
  ctx.strokeStyle = col(0.03);
  ctx.lineWidth = 1*DPR;
  for(let i=0;i<140;i++){
    const a = rand()*Math.PI*2;
    const rr = (0.25 + rand()*0.75) * Scl*0.70;
    const x = Math.cos(a)*rr;
    const y = Math.sin(a)*rr*0.62;
    const k = (rand()*2-1)*Scl*0.010;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + k, y + k*0.6);
    ctx.stroke();
  }

  // snort vapor puffs (from nostrils)
  if(life && snort > 0.02){
    const d = (0.35 + 0.65*snort);
    const leftX = cx + (-Scl*0.13);
    const rightX = cx + (Scl*0.13);
    const y = cy + breathY + (sny + Scl*0.00);
    if(Math.random() < 0.35*d) puff(leftX, y, 1, -0.10 - 0.20*snort);
    if(Math.random() < 0.35*d) puff(rightX, y, 1, 0.10 + 0.20*snort);
  }

  ctx.restore();
}

function render(t){
  // soft persistence
  const a = S.motion ? (0.020 + 0.010*Math.sin(t*0.00025)) : 1.0;
  ctx.fillStyle = `rgba(0,0,0,${a})`;
  ctx.fillRect(0,0,W,H);

  // subtle scan line
  ctx.strokeStyle = col(0.008);
  ctx.lineWidth = 1*DPR;
  const y = ((t*0.10) % H);
  ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();

  const cx = W/2;
  const cy = H/2;
  const scale = Math.min(W,H) * 0.52;

  drawPig(cx, cy, scale, t);

  // vapor drift
  for(let i=vapor.length-1;i>=0;i--){
    const p = vapor[i];
    p.life++;
    p.ph += p.w;
    p.x += p.vx + Math.sin(p.ph)*0.16*DPR;
    p.y += p.vy + Math.cos(p.ph*0.7)*0.10*DPR;
    p.r *= 1.0030;
    drawV(p);
    if(p.life > p.max || p.y < -90*DPR) vapor.splice(i,1);
  }

  // border
  ctx.strokeStyle = col(0.03);
  ctx.lineWidth = 1*DPR;
  ctx.strokeRect(15*DPR, 15*DPR, W-30*DPR, H-30*DPR);

  requestAnimationFrame(render);
}

/* actions */
function toggleInvert(){ S.invert=!S.invert; saveState(); apply(); }
function toggleNull(){ S.nullMode=!S.nullMode; saveState(); apply(); }
async function toggleFullscreen(){
  try{
    if(!document.fullscreenElement){ await document.documentElement.requestFullscreen(); S.fullscreen=true; }
    else { await document.exitFullscreen(); S.fullscreen=false; }
  }catch(_){}
  saveState(); apply();
}
function toggleMotion(){ S.motion=!S.motion; saveState(); apply(); }
function triggerBlink(){ S.blink = 1.25; saveState(); }
function triggerSnort(){
  S.snort = 1.35;
  // immediate vapor burst
  const cx = W/2, cy = H/2, scale = Math.min(W,H)*0.52;
  const snY = cy + (scale*0.26);
  puff(cx - scale*0.13, snY, 3, -0.22);
  puff(cx + scale*0.13, snY, 3, 0.22);
  saveState();
}
function toggleNote(){ S.noteOpen=!S.noteOpen; saveState(); apply(); }

$("btnInvert").addEventListener("click", toggleInvert);
$("btnNull").addEventListener("click", toggleNull);
$("btnFull").addEventListener("click", toggleFullscreen);
$("btnMotion").addEventListener("click", toggleMotion);
$("btnBlink").addEventListener("click", triggerBlink);
$("btnSnort").addEventListener("click", triggerSnort);
$("btnNote").addEventListener("click", toggleNote);

$("noteText").addEventListener("input",(e)=>{ S.noteText = e.target.value || ""; saveState(); });

/* note drag */
(function noteDrag(){
  const el = $("note");
  const bar = el.querySelector(".bar");
  let dragging=false, ox=0, oy=0;

  bar.addEventListener("mousedown",(e)=>{
    dragging=true;
    const r = el.getBoundingClientRect();
    ox = e.clientX - r.left;
    oy = e.clientY - r.top;
    e.preventDefault();
  });
  window.addEventListener("mousemove",(e)=>{
    if(!dragging) return;
    const x = Math.max(10, Math.min(window.innerWidth - 10 - el.offsetWidth, e.clientX - ox));
    const y = Math.max(10, Math.min(window.innerHeight - 10 - el.offsetHeight, e.clientY - oy));
    el.style.left = x + "px";
    el.style.top  = y + "px";
    S.notePos = { x, y };
  });
  window.addEventListener("mouseup",()=>{
    if(!dragging) return;
    dragging=false;
    saveState();
  });
})();

/* hotkeys */
function isTypingTarget(t){
  if(!t) return false;
  const tag = (t.tagName||"").toLowerCase();
  return tag==="textarea" || tag==="input" || t.isContentEditable;
}
window.addEventListener("keydown",(e)=>{
  const typing = isTypingTarget(e.target);

  if(e.shiftKey && e.key.toLowerCase()==="i"){ e.preventDefault(); toggleInvert(); return; }
  if(e.shiftKey && e.key.toLowerCase()==="n"){ e.preventDefault(); toggleNull(); return; }
  if(e.shiftKey && e.key.toLowerCase()==="f"){ e.preventDefault(); toggleFullscreen(); return; }
  if(e.shiftKey && e.key.toLowerCase()==="k"){ e.preventDefault(); toggleNote(); return; }

  if(e.code==="Space" && !typing){ e.preventDefault(); triggerBlink(); return; }
  if(e.key==="Enter" && !typing){ e.preventDefault(); triggerSnort(); return; }
}, {passive:false});

/* boot */
loadState();
resize();
apply();
requestAnimationFrame(render);
</script>

<!--
AE: VISUAL (MONOCHROME PIGFACE CLOSEUP: heavy head mass, floppy ears, wide-set eyes, dominant snout w/ nostrils, pore texture, breath vapor)
EE: ENGINE (LOCAL-FIRST STATE, blink/snort actions, subtle breathing/motion, hotkeys, fullscreen/invert/null, movable KETA_NOTE)
WB: WIRING BRIDGE (apply state to DOM + controls)

FILE_ID: "KETADATA_PIGFACE_MONO_V1"
ROOM_ID: "K_PIGFACE"
VERSION: "V1"
UPDATED_AT: "2026-01-06T00:00:00.000-05:00"
CHANGELOG:
- V1: Pig face closeup still-life portrait, monochrome-only, blink + snort vapor, local-first persistence.
-->
</body>
</html>
