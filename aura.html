<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TEMPLE // AURA GENERATOR</title>
  <style>
    :root{
      --bg:#000;
      --panel:#050505;
      --panel2:#080808;
      --line:#1f1f1f;
      --line2:#2a2a2a;
      --txt:#eaeaea;
      --muted:#a8a8a8;
      --muted2:#7a7a7a;
      --hl:#2f2f2f;
      --uiFont:13px;
      --uiLine:1.45;
      --pad:14px;
      --gap:14px;
    }

    *{ box-sizing:border-box; font-family: Arial, Helvetica, sans-serif; }
    html,body{ height:100%; }
    body{
      margin:0;
      background: var(--bg);
      color: var(--txt);
      overflow:hidden;
    }

    /* App shell */
    .app{
      height:100%;
      display:grid;
      grid-template-rows: 56px 1fr 120px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 0 var(--pad);
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, #0a0a0a, #000);
    }

    .brand{
      letter-spacing: .14em;
      font-weight:700;
      text-transform:uppercase;
      font-size: 12px;
      color: var(--muted);
    }

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
    }

    .btn{
      border:1px solid var(--line2);
      background: #0b0b0b;
      color: var(--txt);
      padding: 8px 10px;
      font-size: 12px;
      letter-spacing:.06em;
      text-transform:uppercase;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{ border-color:#3a3a3a; }
    .btn:active{ transform: translateY(1px); }

    .pill{
      border:1px solid var(--line2);
      color: var(--muted);
      padding: 6px 10px;
      font-size: 12px;
      letter-spacing:.08em;
      text-transform:uppercase;
    }

    /* Stage */
    .stageWrap{
      position:relative;
      display:grid;
      place-items:center;
      padding: var(--gap);
    }

    .stage{
      position:relative;
      width:min(980px, calc(100vw - 2*var(--gap)));
      height:min(620px, calc(100vh - 56px - 120px - 2*var(--gap)));
      border:1px solid var(--line);
      background:
        radial-gradient(1000px 600px at 50% 50%, #0b0b0b 0%, #020202 55%, #000 100%);
      box-shadow: 0 0 0 1px #000 inset;
      overflow:hidden;
    }

    /* photobooth feel: user center, aura blooms around */
    video{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit:cover;
      filter: contrast(1.06) brightness(0.98);
      transform: scaleX(-1); /* mirror like a booth */
    }

    canvas#aura{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      transform: scaleX(-1); /* match video mirror */
      pointer-events:none;
    }

    /* Subtle frame lines */
    .frameLines{
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        linear-gradient(#0000, #0000),
        linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00)),
        linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00));
      mix-blend-mode: screen;
      opacity:.25;
    }

    .stageHud{
      position:absolute;
      left: var(--pad);
      top: var(--pad);
      right: var(--pad);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      pointer-events:none; /* allow clean booth feel */
    }

    .hudBlock{
      pointer-events:auto;
      max-width: 360px;
      border:1px solid var(--line2);
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      padding: 10px 12px;
    }

    .hudTitle{
      font-size: 12px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color: var(--muted);
      margin:0 0 8px 0;
    }

    .hudRow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      font-size: 12px;
      color: var(--muted);
      line-height: var(--uiLine);
    }

    .slider{
      width: 170px;
      accent-color: #666; /* grey only */
    }

    .swatches{
      position:absolute;
      left: var(--pad);
      bottom: var(--pad);
      right: var(--pad);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      pointer-events:none;
    }

    .swatchStrip{
      pointer-events:auto;
      border:1px solid var(--line2);
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      padding: 10px 12px;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width: 420px;
    }

    .swatchRow{
      display:flex;
      gap:8px;
      align-items:center;
    }

    .sw{
      width: 24px;
      height: 24px;
      border:1px solid var(--line2);
      background:#111;
    }

    .small{
      font-size: 11px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color: var(--muted2);
    }

    /* Bottom panel */
    .bottom{
      border-top:1px solid var(--line);
      background: linear-gradient(180deg, #000, #080808);
      padding: 12px var(--pad);
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: var(--gap);
      overflow:hidden;
    }

    .box{
      border:1px solid var(--line2);
      background: rgba(0,0,0,0.5);
      padding: 10px 12px;
      overflow:auto;
    }

    .box h3{
      margin:0 0 8px 0;
      font-size: 12px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color: var(--muted);
    }

    .box p{
      margin:0;
      font-size: 12px;
      line-height: var(--uiLine);
      color: var(--muted);
      white-space: pre-wrap;
    }

    .warn{
      color:#cfcfcf;
    }

    .hidden{
      display:none !important;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="brand">TEMPLE // AURA GENERATOR</div>
      <div class="actions">
        <div class="pill" id="status">idle</div>
        <button class="btn" id="btnStart">start camera</button>
        <button class="btn" id="btnSnap">snapshot</button>
        <button class="btn" id="btnExport">export png</button>
      </div>
    </div>

    <div class="stageWrap">
      <div class="stage" id="stage">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="aura"></canvas>
        <div class="frameLines"></div>

        <div class="stageHud">
          <div class="hudBlock">
            <div class="hudTitle">aura engine</div>
            <div class="hudRow">
              <span>intensity</span>
              <input class="slider" type="range" id="intensity" min="0" max="100" value="78" />
              <span id="intensityV">78</span>
            </div>
            <div class="hudRow">
              <span>complexity</span>
              <input class="slider" type="range" id="complexity" min="0" max="100" value="74" />
              <span id="complexityV">74</span>
            </div>
            <div class="hudRow">
              <span>saturation</span>
              <input class="slider" type="range" id="saturation" min="0" max="100" value="88" />
              <span id="saturationV">88</span>
            </div>
          </div>

          <div class="hudBlock">
            <div class="hudTitle">mode</div>
            <div class="hudRow"><span class="warn">photobooth input â†’ automatic aura</span></div>
            <div class="hudRow"><span>mirror</span><span>on</span></div>
            <div class="hudRow"><span>palette refresh</span><span id="palRate">~900ms</span></div>
          </div>
        </div>

        <div class="swatches">
          <div class="swatchStrip">
            <div class="small">color story (auto-extracted)</div>
            <div class="swatchRow" id="swatchRow"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="bottom">
      <div class="box">
        <h3>notes</h3>
        <p id="notes">- center is the user\n- aura is a dense color narrative derived from the frame\n- export yields the staged image + aura + palette</p>
      </div>
      <div class="box">
        <h3>references</h3>
        <p id="refs">- camera feed (getUserMedia)\n- palette quantization\n- glow compositing (lighter/screen)\n- edge-guided energy field</p>
      </div>
      <div class="box">
        <h3>export packet</h3>
        <p id="packet">- png: stage composite\n- palette: hex list\n- parameters: intensity/complexity/saturation</p>
      </div>
    </div>
  </div>

<script>
(() => {
  const video = document.getElementById('video');
  const canvas = document.getElementById('aura');
  const ctx = canvas.getContext('2d', { alpha: true });

  const statusEl = document.getElementById('status');
  const btnStart = document.getElementById('btnStart');
  const btnSnap = document.getElementById('btnSnap');
  const btnExport = document.getElementById('btnExport');

  const intensity = document.getElementById('intensity');
  const complexity = document.getElementById('complexity');
  const saturation = document.getElementById('saturation');
  const intensityV = document.getElementById('intensityV');
  const complexityV = document.getElementById('complexityV');
  const saturationV = document.getElementById('saturationV');

  const swatchRow = document.getElementById('swatchRow');

  let stream = null;
  let running = false;

  // offscreen buffers for analysis (cheap)
  const aW = 160, aH = 120;
  const aC = document.createElement('canvas');
  aC.width = aW; aC.height = aH;
  const aCtx = aC.getContext('2d', { willReadFrequently: true });

  const eC = document.createElement('canvas');
  eC.width = aW; eC.height = aH;
  const eCtx = eC.getContext('2d', { willReadFrequently: true });

  // state
  let palette = ["#ff4d4d","#ffb84d","#ffe84d","#4dffb5","#4da3ff","#b84dff","#ff4df2","#ff4d8a"];
  let lastPaletteAt = 0;
  let paletteIntervalMs = 900;

  let lastComposite = null; // ImageData snapshot for export (optional)
  let lastExportURL = null;

  function setStatus(txt){ statusEl.textContent = txt; }

  function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }

  function rgbToHex(r,g,b){
    const to = v => v.toString(16).padStart(2,'0');
    return "#" + to(r) + to(g) + to(b);
  }

  function rgbToHsl(r,g,b){
    r/=255; g/=255; b/=255;
    const max = Math.max(r,g,b), min = Math.min(r,g,b);
    let h=0, s=0, l=(max+min)/2;
    const d = max-min;
    if(d !== 0){
      s = d / (1 - Math.abs(2*l - 1));
      switch(max){
        case r: h = ((g-b)/d) % 6; break;
        case g: h = (b-r)/d + 2; break;
        case b: h = (r-g)/d + 4; break;
      }
      h *= 60;
      if(h < 0) h += 360;
    }
    return { h, s, l };
  }

  function hslToRgb(h,s,l){
    // h in [0,360), s,l in [0,1]
    const c = (1 - Math.abs(2*l - 1)) * s;
    const x = c * (1 - Math.abs(((h/60) % 2) - 1));
    const m = l - c/2;
    let r=0,g=0,b=0;
    if(h < 60){ r=c; g=x; b=0; }
    else if(h < 120){ r=x; g=c; b=0; }
    else if(h < 180){ r=0; g=c; b=x; }
    else if(h < 240){ r=0; g=x; b=c; }
    else if(h < 300){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    return {
      r: Math.round((r+m)*255),
      g: Math.round((g+m)*255),
      b: Math.round((b+m)*255)
    };
  }

  function boostColor(hex, satBoost=1.15, lightShift=-0.02){
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    const hsl = rgbToHsl(r,g,b);
    hsl.s = clamp(hsl.s * satBoost, 0, 1);
    hsl.l = clamp(hsl.l + lightShift, 0, 1);
    const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    return rgbToHex(rgb.r,rgb.g,rgb.b);
  }

  function renderSwatches(list){
    swatchRow.innerHTML = "";
    list.slice(0,10).forEach(c=>{
      const d = document.createElement('div');
      d.className = "sw";
      d.style.background = c;
      swatchRow.appendChild(d);
    });
  }

  function quantizePalette(imgData, k=8){
    // fast-ish: histogram binning (no kmeans)
    const data = imgData.data;
    const bins = new Map(); // key -> count
    const step = 4; // sample stride
    for(let i=0; i<data.length; i += 4*step){
      const r = data[i], g = data[i+1], b = data[i+2];
      // ignore very dark pixels to avoid black dominating
      const lum = 0.2126*r + 0.7152*g + 0.0722*b;
      if(lum < 28) continue;

      // binning: 5-bit per channel
      const rb = r >> 3, gb = g >> 3, bb = b >> 3;
      const key = (rb<<10) | (gb<<5) | bb;
      bins.set(key, (bins.get(key) || 0) + 1);
    }

    const sorted = Array.from(bins.entries()).sort((a,b)=>b[1]-a[1]).slice(0, k*6);

    // spread by hue: take top bins but avoid near-duplicates
    const picked = [];
    for(const [key] of sorted){
      const rb = (key>>10)&31, gb = (key>>5)&31, bb = key&31;
      const r = (rb<<3) + 4, g = (gb<<3) + 4, b = (bb<<3) + 4;
      const hex = rgbToHex(r,g,b);
      const {h,s,l} = rgbToHsl(r,g,b);

      // require some chroma; avoid washed-out greys
      if(s < 0.18) continue;
      // avoid near hue duplicates
      if(picked.some(p => Math.abs(p.h - h) < 18 || Math.abs((p.h+360)-h) < 18 || Math.abs(p.h - (h+360)) < 18)) continue;

      picked.push({hex, h, s, l});
      if(picked.length >= k) break;
    }

    let out = picked.map(p => p.hex);

    // If insufficient (dark/low color frames), fall back to last palette
    if(out.length < 5) out = palette.slice(0, k);

    // Boost to KETADATA intensity
    const sat = (parseFloat(saturation.value) / 100);
    const satBoost = 1.0 + sat * 0.45;     // up to +45%
    const lightShift = -0.08 + sat * 0.03; // slightly darker but vivid

    out = out.map(c => boostColor(c, satBoost, lightShift));

    // ensure high contrast by adding a "hot" accent if missing
    if(!out.some(c => c.toLowerCase().includes("ff"))){
      out.push("#ff3b3b");
    }

    return out.slice(0, k);
  }

  function sobelEdges(imgData){
    // return ImageData for edges (alpha in edges)
    const w = imgData.width, h = imgData.height;
    const src = imgData.data;
    const out = eCtx.createImageData(w,h);
    const dst = out.data;

    // grayscale
    const g = new Float32Array(w*h);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = (y*w+x)*4;
        g[y*w+x] = 0.2126*src[i] + 0.7152*src[i+1] + 0.0722*src[i+2];
      }
    }

    // sobel
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const i = y*w+x;
        const gx =
          -g[i-w-1] -2*g[i-1] -g[i+w-1] +
           g[i-w+1] +2*g[i+1] +g[i+w+1];
        const gy =
          -g[i-w-1] -2*g[i-w] -g[i-w+1] +
           g[i+w-1] +2*g[i+w] +g[i+w+1];
        const mag = Math.sqrt(gx*gx + gy*gy);
        const v = clamp(mag * 0.9, 0, 255);

        const di = i*4;
        dst[di] = 255;
        dst[di+1] = 255;
        dst[di+2] = 255;
        dst[di+3] = v > 80 ? clamp((v-80)*2.0, 0, 255) : 0; // edge alpha only
      }
    }
    return out;
  }

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  window.addEventListener('resize', resizeCanvas);

  // Flow field particles (dense aura)
  const P = [];
  let Pn = 1800; // will be scaled by complexity
  function initParticles(){
    P.length = 0;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    for(let i=0;i<Pn;i++){
      P.push({
        x: Math.random()*w,
        y: Math.random()*h,
        vx: 0,
        vy: 0,
        life: Math.random()*120,
        seed: Math.random()*1000
      });
    }
  }

  function fieldAngle(x,y,t,comp){
    // compact, hypnotic, complex: layered trig
    const n1 = Math.sin((x*0.004 + t*0.0009) + Math.cos(y*0.003 - t*0.0012));
    const n2 = Math.cos((y*0.004 - t*0.0011) + Math.sin(x*0.003 + t*0.0008));
    const n3 = Math.sin((x+y)*0.002 + t*0.0016);
    const a = (n1 + n2*0.8 + n3*0.6) * (1.2 + comp*1.6);
    return a * Math.PI;
  }

  function drawAura(t){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    const inten = parseFloat(intensity.value) / 100;
    const comp = parseFloat(complexity.value) / 100;

    // particle count scales with complexity
    const targetPn = Math.floor(900 + comp * 2600);
    if(Math.abs(targetPn - Pn) > 120){
      Pn = targetPn;
      initParticles();
    }

    // soft clear (trail)
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = `rgba(0,0,0,${0.16 - comp*0.06})`;
    ctx.fillRect(0,0,w,h);

    // edge guide from analysis buffer (downscaled video)
    aCtx.drawImage(video, 0, 0, aW, aH);
    const img = aCtx.getImageData(0,0,aW,aH);
    const edges = sobelEdges(img);

    // draw edges as faint mask (not kitsch; just structure)
    // scale edges to stage
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.globalAlpha = 0.10 + inten*0.10;
    // draw edges via temp canvas
    eCtx.putImageData(edges, 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(eC, 0, 0, w, h);
    ctx.restore();

    // aura blooms (radial gradients from palette)
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.globalAlpha = 0.10 + inten*0.22;

    const cx = w*0.50, cy = h*0.44;
    const baseR = Math.min(w,h) * (0.34 + inten*0.18);

    for(let i=0; i<palette.length; i++){
      const col = palette[i];
      const ang = (t*0.0002 + i*0.9) % (Math.PI*2);
      const ox = Math.cos(ang) * (18 + i*8) * (0.4 + comp);
      const oy = Math.sin(ang) * (14 + i*7) * (0.4 + comp);
      const r = baseR * (0.65 + i*0.05);

      const g = ctx.createRadialGradient(cx+ox, cy+oy, r*0.12, cx+ox, cy+oy, r);
      g.addColorStop(0, col + "ff");
      g.addColorStop(0.45, col + "55");
      g.addColorStop(1, "#00000000");

      ctx.shadowColor = col;
      ctx.shadowBlur = 22 + inten*44;
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(cx+ox, cy+oy, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // dense flow particles (rich, bold, complex)
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const speed = 0.55 + inten*1.25;
    const jitter = 0.12 + comp*0.30;

    for(let i=0; i<P.length; i++){
      const p = P[i];

      // map particle to analysis edges to bias around subject
      const ex = Math.floor((p.x / w) * aW);
      const ey = Math.floor((p.y / h) * aH);
      const ei = (ey*aW + ex)*4 + 3;
      const edgeA = edges.data[ei] / 255;

      // if close to edges, amplify energy
      const edgeBoost = 1 + edgeA * (1.2 + inten*1.5);

      const ang = fieldAngle(p.x, p.y, t + p.seed*10, comp);
      const ax = Math.cos(ang) * speed * edgeBoost;
      const ay = Math.sin(ang) * speed * edgeBoost;

      p.vx = p.vx*0.86 + ax*0.14;
      p.vy = p.vy*0.86 + ay*0.14;

      p.x += p.vx + (Math.random()-0.5)*jitter;
      p.y += p.vy + (Math.random()-0.5)*jitter;
      p.life -= 1;

      if(p.x < -20 || p.x > w+20 || p.y < -20 || p.y > h+20 || p.life <= 0){
        p.x = cx + (Math.random()-0.5)*baseR*1.2;
        p.y = cy + (Math.random()-0.5)*baseR*1.2;
        p.vx = p.vy = 0;
        p.life = 40 + Math.random()*140;
      }

      const c = palette[i % palette.length];
      ctx.strokeStyle = c;
      ctx.globalAlpha = (0.06 + inten*0.12) * (0.55 + edgeA*0.9);
      ctx.lineWidth = 1;

      ctx.shadowColor = c;
      ctx.shadowBlur = 10 + inten*18;

      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x - p.vx*2.4, p.y - p.vy*2.4);
      ctx.stroke();
    }
    ctx.restore();

    // subtle chromatic separation (sophisticated, not neon)
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.globalAlpha = 0.10 + inten*0.10;
    ctx.translate(1.2, 0.0);
    ctx.drawImage(canvas, 0, 0);
    ctx.restore();

    // update export packet text
    document.getElementById('packet').textContent =
`- png: stage composite
- palette: ${palette.join(" ")}
- parameters: intensity=${Math.round(inten*100)} complexity=${Math.round(comp*100)} saturation=${Math.round((parseFloat(saturation.value)))} `;
  }

  function compositeToPNG(){
    // render final composite = video frame + aura canvas
    const rect = canvas.getBoundingClientRect();
    const out = document.createElement('canvas');
    out.width = Math.floor(rect.width);
    out.height = Math.floor(rect.height);
    const o = out.getContext('2d');

    // mirror like booth (same as on screen)
    o.save();
    o.translate(out.width, 0);
    o.scale(-1, 1);
    o.drawImage(video, 0, 0, out.width, out.height);
    // aura canvas already mirrored; draw it mirrored again to match the composite
    // easiest: draw aura without further flip by drawing the displayed canvas snapshot:
    o.drawImage(canvas, 0, 0, out.width, out.height);
    o.restore();

    return out.toDataURL('image/png');
  }

  function tick(t){
    if(!running) return;

    // update numbers
    intensityV.textContent = intensity.value;
    complexityV.textContent = complexity.value;
    saturationV.textContent = saturation.value;

    // palette refresh (automatic)
    if(t - lastPaletteAt > paletteIntervalMs){
      try{
        aCtx.drawImage(video, 0, 0, aW, aH);
        const img = aCtx.getImageData(0,0,aW,aH);
        palette = quantizePalette(img, 8);
        renderSwatches(palette);
        lastPaletteAt = t;
      }catch(e){
        // ignore transient camera draw errors
      }
    }

    drawAura(t);
    requestAnimationFrame(tick);
  }

  async function startCamera(){
    if(stream) return;

    setStatus("requesting camera");
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 1280 },
          height: { ideal: 720 },
          facingMode: "user"
        },
        audio: false
      });

      video.srcObject = stream;

      await new Promise(res => {
        video.onloadedmetadata = () => res();
      });

      resizeCanvas();
      initParticles();

      running = true;
      setStatus("running");
      requestAnimationFrame(tick);
    }catch(err){
      console.error(err);
      setStatus("blocked");
      alert("Camera access failed. Use https or localhost and allow camera permissions.");
    }
  }

  function snapshot(){
    // force palette refresh + quick aura punch (moment)
    try{
      aCtx.drawImage(video, 0, 0, aW, aH);
      const img = aCtx.getImageData(0,0,aW,aH);
      palette = quantizePalette(img, 8);
      renderSwatches(palette);
      setStatus("snapshot");
      setTimeout(()=> setStatus("running"), 450);
    }catch(e){}
  }

  function exportPNG(){
    const url = compositeToPNG();
    // download
    const a = document.createElement('a');
    a.href = url;
    a.download = `ketadata_aura_${Date.now()}.png`;
    a.click();
    setStatus("exported");
    setTimeout(()=> setStatus("running"), 600);
  }

  // Wire controls
  btnStart.addEventListener('click', startCamera);
  btnSnap.addEventListener('click', snapshot);
  btnExport.addEventListener('click', exportPNG);

  // Auto start if possible (still needs permission; user click may be required depending on browser policy)
  // startCamera();

  // initial swatches
  renderSwatches(palette);

})();
</script>
</body>
</html>
