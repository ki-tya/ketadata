<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA ROUTER — LIZARD MINDMAP</title>
  <style>
    :root{
      --bg:#ffffff; --fg:#111111; --muted:#7a7a7a; --line:#cfcfcf;
      --panel:#f2f2f2; --panel2:#e8e8e8;
      --font:12px/1.15 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:var(--font);overflow:hidden;}
    *{box-sizing:border-box;}

    /* INVERT MUST AFFECT WHOLE PAGE: class on <html> */
    html.invert{
      --bg:#0b0b0b; --fg:#f2f2f2; --muted:#a0a0a0; --line:#3a3a3a;
      --panel:#111111; --panel2:#161616;
    }

    /* NULL */
    html.null #hud, html.null #side, html.null #corner{display:none;}

    #canvas{position:fixed;inset:0;display:block;}
    #hud{
      position:fixed;left:10px;top:10px;z-index:50;
      width:620px;max-width:calc(100vw - 20px);
      background:var(--panel);border:1px solid var(--line);
      padding:8px;user-select:none;
    }
    #hud .row{display:flex;gap:6px;flex-wrap:wrap;align-items:center;}
    #hud .row + .row{margin-top:6px;}
    #hud button, #hud select, #hud input{
      font:var(--font);
      padding:4px 6px;
      background:var(--bg);
      border:1px solid var(--line);
      color:var(--fg);
    }
    #hud button{cursor:pointer;}
    #hud .pill{display:inline-block;padding:3px 6px;border:1px solid var(--line);background:var(--bg);color:var(--muted);}
    #hud .label{color:var(--muted);}
    #hud .sp{flex:1;}
    #hud input[type="range"]{padding:0;height:22px;}
    #side{
      position:fixed;right:10px;top:10px;z-index:60;
      width:420px;max-height:calc(100vh - 20px);
      background:var(--panel);border:1px solid var(--line);
      padding:8px;overflow:auto;display:none;
    }
    #side .t{color:var(--muted);}
    #side .a{color:var(--fg);word-break:break-all;}
    #side .btns{margin-top:6px;display:flex;gap:6px;flex-wrap:wrap;}
    #side button{font:var(--font);padding:4px 6px;background:var(--bg);border:1px solid var(--line);cursor:pointer;color:var(--fg);}
    #corner{position:fixed;left:10px;bottom:10px;z-index:40;color:var(--muted);user-select:none;}
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="hud">
  <div class="row">
    <span class="pill">ROUTER / LIMINAL CENTER / LIZARD MINDMAP</span>
    <span class="sp"></span>
    <span class="pill" id="pillRun">RUNNING</span>
    <span class="pill" id="pillSaved">LOCAL</span>
  </div>
  <div class="row">
    <button id="btnPause">PAUSE (SPACE)</button>
    <button id="btnRecenter">RECENTER</button>
    <button id="btnSpread">SPREAD</button>
    <span class="label">ZOOM</span>
    <button id="btnZoomOut">-</button>
    <button id="btnZoomIn">+</button>
    <span class="label">SPEED</span>
    <input id="speed" type="range" min="0" max="2" step="0.05" value="1" />
    <span class="label">DENSITY</span>
    <input id="density" type="range" min="0.3" max="1.6" step="0.05" value="1" />
  </div>
  <div class="row">
    <span class="label">FILTER</span>
    <input id="q" type="text" placeholder="search filename..." />
    <span class="label">SHOW</span>
    <select id="visFilter">
      <option value="ALL">ALL</option>
      <option value="PUBLIC">PUBLIC</option>
      <option value="PRIVATE">PRIVATE</option>
      <option value="UNSET">UNSET</option>
    </select>
    <button id="btnExportPublic">EXPORT PUBLIC JSON</button>
    <button id="btnExportAll">EXPORT VIS JSON</button>
    <button id="btnImport">IMPORT JSON</button>
    <button id="btnResetVis">RESET VIS</button>
    <button id="btnNull">NULL (SHIFT+N)</button>
    <button id="btnInvert">INVERT (SHIFT+I)</button>
    <button id="btnFull">FULL (SHIFT+F)</button>
  </div>
</div>

<div id="side">
  <div class="t">SELECTED</div>
  <div class="a" id="selTitle"></div>
  <div class="t" style="margin-top:6px;">TYPE</div>
  <div class="a" id="selType"></div>
  <div class="t" style="margin-top:6px;">URL</div>
  <div class="a" id="selUrl"></div>
  <div class="t" style="margin-top:6px;">VISIBILITY</div>
  <div class="a" id="selVis"></div>
  <div class="btns">
    <button id="openNew">OPEN NEW TAB</button>
    <button id="copyUrl">COPY URL</button>
    <button id="toggleVis">TOGGLE PUBLIC/PRIVATE</button>
    <button id="closeSide">CLOSE</button>
  </div>
</div>

<div id="corner">WHEEL = ZOOM • DRAG EMPTY SPACE = PAN • DRAG NODE = PULL • CLICK NODE = SELECT / OPEN</div>
<input id="filePick" type="file" accept="application/json" style="display:none" />

<script>
(() => {
  const BASE_URL = "https://ki-tya.github.io/ketadata/";

  // ===== EXACT CLUSTERS + LINKS (from your consolidated map) =====
  const CLUSTERS = [
    { name:"KETA-CORE", links:["based_diva9.html","elevator3.html","index.html","index013.html","index11.html","map.html","room.html"]},
    { name:"BLEAK-TECH", links:["ball.html","beatball.html","blacklotus2.html","bleak.html","chakra.html","memofesto.html"]},
    { name:"SCREENS", links:["cctv1.html","crunch1.html","darkroom1.html","kdtv1.html","obscura.html"]},
    { name:"EXPERIMENTS", links:[
      "003.html","aniversary1111.html","artaud.html","bataille1.html","borges.html","burroughs.html","capture.html",
      "capturegpt.html","capturegpt2.html","capturegpt3.html","capturegpt4.html","capturegpt5.html","capturegpt6.html",
      "capturegpt7.html","capturegpt8.html","christmas25.html","chroma.html","coffee.html","coffee1.html","cp1.html",
      "cube.html","cube1.html","debord.html","deleuze.html","dmt.html","dmt2.html","dmt3.html","dmt4.html","dmtzoom.html",
      "etal.html","funnel.html","funnel1.html","funnel2.html","funnel3.html","funnel4.html","goffman.html","gptsubject.html",
      "holzer.html","hyperstition.html","hyperstition1.html","hyperstition2.html","hyperstition3.html","hyperstition5.html",
      "index0.html","index001.html","index002.html","index003.html","index004.html","index005.html","index006.html","index007.html",
      "index008.html","index009.html","index01.html","index011.html","index012.html","index014.html","index015.html","index02.html",
      "index03.html","index04.html","index05.html","index06.html","index07.html","index08.html","index09.html","infinity.html","jung.html",
      "kitty.html","kmas.html","land.html","mandala.html","mandala2.html","mandala3.html","mandalagpt.html","mandalagpt2.html",
      "mandalagpt3.html","mandalagpt4.html","matrix.html","matryoshka.html","mcluhan.html","mdma.html","mdma2.html","mdmagpt.html",
      "mdmagpt2.html","misc.html","misc2.html","misc3.html","misc4.html","misc5.html","misc6.html","misc7.html","misc8.html",
      "molecule.html","newtrap.html","newtrap2.html","newtrap3.html","polka1.html","polka2.html","polkadot.html","pool.html","pool3.html",
      "pool4.html","pool5.html","pool6.html","release.html","release2.html","release3.html","release4.html","ripple.html","ripple2.html",
      "ripple3.html","ripplegpt.html","sg.html","sg1.html","slopstream2.html","slopstream3.html","slopstream4.html","slopstream6.html",
      "snakes.html","sovereignty.html","subgpt2.html","subgpt3.html","subgpt4.html","subgpt5.html","sublime.html","substance.html",
      "substrate.html","substrate1.html","substrate3.html","teleo.html","teleo1.html","temple.html","temple1.html"
    ]},
    { name:"CONCEPTUAL ALIGNMENT", links:["2812.html","claude_cl3.html","concept_cl4.html","cp.html","depth.html","drugprotocol.html","fivethirtysix.html","intra.html","reading.html","widefield.html"]},
    { name:"BASE", links:["based_diva3.html","based_diva8.html","based_diva98.html","based_diva98x.html","based_diva9a.html","based_diva9b.html","based_diva9c.html","based_diva9d.html","based_diva9e.html","based_diva9f.html","based_diva9g.html","based_diva9h.html","based_diva9i.html","based_diva9ii.html","based_diva9iii.html","bbd1.html","bbd2.html","bbd3.html","diva.html","divabased4.html","re_diva9.html","systemkill.html"]},
    { name:"SYSTEM", links:["backbone.html","backbone1.html","backbone2.html","backend.html","claude_mockup.html","claude.html","contract.html","memofesto1.html","memofesto2.html","mockups.html","mockups1.html","mockups2.html","nav.html","pads.html","page.html"]},
    { name:"SYS-UTIL", links:["arranger.html","bugtest.html","debug.html","diagnostic.html","inspector.html","inspector1.html","linklist.html","linkorg4.html","main3.html","manifest.html","master2.html","mastergpt.html","monitor.html","primitive.html","primitive1.html","primitive2.html","primitive3.html","pulse.html","quota.html","reg.html","regv3.html","regv4.html","screenplane.html","screenplane1.html","storage.html","storage1.html","storagemanager.html","system8.html","version.html","videomanager.html"]},
    { name:"SYS-PR", links:["cashapp1.html","cashapp3.html","funding.html","shop.html","submit.html"]},
    { name:"TESTERS", links:["anniversary1.html","anniversary11.html","anniversary111.html","concept_cl.html","concept_cl1.html","concept_cl2.html","darkroom.html","doc5.html","index_copy.html","index_prev1.html","index01_tester.html","lib_cl.html","mandala88.html","master.html","master1.html","redroom.html","to-do.html","to-do1.html","vape-drive.html","vault.html","video.html","video2.html"]},
    { name:"SECRET", links:["67.html","page2.html"]},
    { name:"CORE", links:["deprecated.html","design1.html","lab.html","lab1.html","labyrinth.html","lib_gpt.html","linksv3.html","main2.html","sensory3.html","studiofront.html","studiov2.html","studiov3.html","tester3.html","tester31.html"]},
    { name:"CORE-UTIL", links:["acid_doc.html","artifact.html","board.html","board1.html","board2.html","board3.html","calendar1.html","controller.html","controller1.html","controller2.html","controller3.html","display1.html","doc2.html","manifest5.html","modern.html","pdf2jpeg7.html","sheets.html","studio.html","to-do2.html"]},
    { name:"DESIGN-UTIL", links:["color1.html","color3.html","font.html"]},
    { name:"PHOTOG-UTIL", links:["editor.html","studiov1.html"]},
    { name:"DATA-UTIL", links:["pdf2jpeg8.html"]},
    { name:"META-COG", links:["circle.html","libra.html"]},
    { name:"LLM-UTIL", links:["compiler.html","contextifier.html","d2.html","prompt.html","prompt1.html","prompt3.html","prompter.html"]},
    { name:"HTML-UTIL", links:["classifier.html","classifier1.html","forge3.html","forge4.html","forge5.html","forge7.html","html.html","metadata.html","metadata1.html","unifier.html"]},
    { name:"UI-UTIL", links:["color5.html","interfacer.html","interfacer1.html","interfacer2.html","lab3.html","lab9.html","system6.html"]},
  ];

  // ===== Storage (public/private map) =====
  const STORE_VIS = "KD_ROUTER_VIS_V1";

  function makeUrl(path){ return /^https?:\/\//i.test(path) ? path : (BASE_URL + path.replace(/^\//,'')); }
  function makeId(cluster, path){ return `${cluster}::${path}`; }
  function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  let vis = {};
  function loadVis(){
    try{
      const raw = localStorage.getItem(STORE_VIS);
      if(!raw) return;
      const parsed = JSON.parse(raw);
      if(parsed && parsed.vis && typeof parsed.vis === "object") vis = parsed.vis || {};
    }catch{}
  }
  function saveVis(){
    try{
      localStorage.setItem(STORE_VIS, JSON.stringify({ version:"KD_ROUTER_VIS_V1", updatedAt:new Date().toISOString(), vis }));
      pillSaved.textContent = "SAVED";
      setTimeout(()=>pillSaved.textContent="LOCAL", 650);
    }catch{}
  }
  function getVis(id){
    const v = vis[id];
    if(v==="PUBLIC" || v==="PRIVATE") return v;
    return "UNSET";
  }
  function toggleVis(id){
    const cur = getVis(id);
    vis[id] = (cur==="PUBLIC") ? "PRIVATE" : "PUBLIC";
    saveVis();
  }
  function resetVis(){
    vis = {};
    saveVis();
  }

  // ===== Canvas + Camera =====
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  const cam = { x:0, y:0, z:1 }; // world -> screen: (p - cam) * z + center

  function screenToWorld(sx, sy){
    const cx = window.innerWidth/2, cy = window.innerHeight/2;
    return {
      x: (sx - cx)/cam.z + cam.x,
      y: (sy - cy)/cam.z + cam.y
    };
  }
  function worldToScreen(wx, wy){
    const cx = window.innerWidth/2, cy = window.innerHeight/2;
    return {
      x: (wx - cam.x)*cam.z + cx,
      y: (wy - cam.y)*cam.z + cy
    };
  }

  // ===== Graph =====
  const nodes = [];
  const edges = [];
  const nodeByKey = new Map();

  function addNode(n){
    nodes.push(n);
    nodeByKey.set(n.key, n);
    return n;
  }
  function addEdge(a, b, rest){
    edges.push({ a, b, rest });
  }

  function seeded(s){
    let h=2166136261>>>0;
    s=String(s);
    for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h,16777619)>>>0; }
    return (h % 10000) / 10000;
  }
  function randSigned(seed){ return (seed*2-1); }

  const CENTER_KEY = "CENTER::KETADATA_ROUTER";
  addNode({
    key: CENTER_KEY, type:"CENTER", label:"KETADATA ROUTER", url:"",
    x:0,y:0,vx:0,vy:0,r:22, pinned:true
  });

  // Cluster nodes orbit around center; link nodes attach to clusters.
  CLUSTERS.forEach((c, i) => {
    const s = seeded(c.name);
    const ang = s * Math.PI*2;
    const rad = 240 + seeded(c.name+"_r")*140;
    const cx = Math.cos(ang)*rad;
    const cy = Math.sin(ang)*rad;

    const cKey = `CLUSTER::${c.name}`;
    addNode({
      key:cKey, type:"CLUSTER", label:c.name, url:"",
      x:cx, y:cy, vx:0, vy:0, r:16, seed:s
    });
    addEdge(CENTER_KEY, cKey, 230);

    c.links.forEach((p, j) => {
      const id = makeId(c.name, p);
      const k = `LINK::${id}`;
      const s2 = seeded(id);
      const a2 = (s2*2-1) * 1.7; // small angular variance off the cluster vector
      const rr = 120 + (s2*120);
      const lx = cx + Math.cos(ang + a2)*rr;
      const ly = cy + Math.sin(ang + a2)*rr;

      addNode({
        key:k, type:"LINK", label:p, url:makeUrl(p),
        x:lx,y:ly,vx:0,vy:0,r:10, cluster:c.name, id, seed:s2
      });
      addEdge(cKey, k, 120);
    });
  });

  // ===== Interaction / Selection =====
  let running = true;
  let draggingCam = false;
  let draggingNode = null;
  let dragOff = {x:0,y:0};
  let lastMouse = {x:0,y:0};
  let hovered = null;
  let selected = null;

  const hud = document.getElementById("hud");
  const side = document.getElementById("side");
  const selTitle = document.getElementById("selTitle");
  const selType = document.getElementById("selType");
  const selUrl = document.getElementById("selUrl");
  const selVis = document.getElementById("selVis");

  const pillRun = document.getElementById("pillRun");
  const pillSaved = document.getElementById("pillSaved");
  const btnPause = document.getElementById("btnPause");
  const btnRecenter = document.getElementById("btnRecenter");
  const btnSpread = document.getElementById("btnSpread");
  const btnZoomIn = document.getElementById("btnZoomIn");
  const btnZoomOut = document.getElementById("btnZoomOut");
  const speedEl = document.getElementById("speed");
  const densityEl = document.getElementById("density");
  const qEl = document.getElementById("q");
  const visFilterEl = document.getElementById("visFilter");
  const btnExportPublic = document.getElementById("btnExportPublic");
  const btnExportAll = document.getElementById("btnExportAll");
  const btnImport = document.getElementById("btnImport");
  const btnResetVis = document.getElementById("btnResetVis");
  const btnNull = document.getElementById("btnNull");
  const btnInvert = document.getElementById("btnInvert");
  const btnFull = document.getElementById("btnFull");
  const filePick = document.getElementById("filePick");

  const openNew = document.getElementById("openNew");
  const copyUrl = document.getElementById("copyUrl");
  const toggleVisBtn = document.getElementById("toggleVis");
  const closeSide = document.getElementById("closeSide");

  function setRunning(r){
    running = r;
    pillRun.textContent = r ? "RUNNING" : "PAUSED";
    btnPause.textContent = r ? "PAUSE (SPACE)" : "RUN (SPACE)";
  }

  function setSelected(n){
    selected = n;
    if(!n){ side.style.display="none"; return; }
    side.style.display="block";
    selTitle.textContent = n.label;
    selType.textContent = n.type;
    selUrl.textContent = n.url || "";
    if(n.type === "LINK"){
      selVis.textContent = getVis(n.id);
      toggleVisBtn.style.display = "";
      openNew.style.display = "";
      copyUrl.style.display = "";
    }else{
      selVis.textContent = "";
      toggleVisBtn.style.display = "none";
      openNew.style.display = "none";
      copyUrl.style.display = "none";
    }
  }

  function nodeAt(sx, sy){
    const w = screenToWorld(sx, sy);
    let best = null;
    let bestD = Infinity;
    for(const n of nodes){
      if(!isVisibleByFilter(n)) continue;
      const dx = w.x - n.x, dy = w.y - n.y;
      const d = Math.sqrt(dx*dx+dy*dy);
      const hitR = n.r + (n.type==="LINK" ? 7 : 9);
      if(d < hitR && d < bestD){ best = n; bestD = d; }
    }
    return best;
  }

  function isVisibleByFilter(n){
    const q = qEl.value.trim().toLowerCase();
    const vf = visFilterEl.value;
    if(n.type === "LINK"){
      if(q && !n.label.toLowerCase().includes(q)) return false;
      const v = getVis(n.id);
      if(vf !== "ALL" && v !== vf) return false;
      return true;
    }
    // keep CENTER + CLUSTERS visible unless query+filter would mean "show nothing"
    if(q || vf !== "ALL"){
      // If filters active, show clusters only if they have at least one visible child link
      if(n.type === "CLUSTER"){
        for(const e of edges){
          if(e.a === n.key){
            const child = nodeByKey.get(e.b);
            if(child && child.type==="LINK" && isVisibleByFilter(child)) return true;
          }
        }
        return false;
      }
      if(n.type === "CENTER") return true;
    }
    return true;
  }

  function filteredEdges(){
    return edges.filter(e => {
      const a = nodeByKey.get(e.a);
      const b = nodeByKey.get(e.b);
      if(!a || !b) return false;
      return isVisibleByFilter(a) && isVisibleByFilter(b);
    });
  }

  canvas.addEventListener("mousedown", (e) => {
    const onHud = e.target && (e.target.closest && e.target.closest("#hud"));
    const onSide = e.target && (e.target.closest && e.target.closest("#side"));
    if(onHud || onSide) return;

    const hit = nodeAt(e.clientX, e.clientY);
    if(hit){
      draggingNode = hit;
      const w = screenToWorld(e.clientX, e.clientY);
      dragOff.x = w.x - hit.x;
      dragOff.y = w.y - hit.y;
      setSelected(hit);
    }else{
      draggingCam = true;
      lastMouse.x = e.clientX;
      lastMouse.y = e.clientY;
      setSelected(null);
    }
  });

  window.addEventListener("mousemove", (e) => {
    hovered = nodeAt(e.clientX, e.clientY);

    if(draggingNode){
      const w = screenToWorld(e.clientX, e.clientY);
      draggingNode.x = w.x - dragOff.x;
      draggingNode.y = w.y - dragOff.y;
      draggingNode.vx *= 0.3;
      draggingNode.vy *= 0.3;
    }else if(draggingCam){
      const dx = (e.clientX - lastMouse.x)/cam.z;
      const dy = (e.clientY - lastMouse.y)/cam.z;
      cam.x -= dx;
      cam.y -= dy;
      lastMouse.x = e.clientX;
      lastMouse.y = e.clientY;
    }
  });

  window.addEventListener("mouseup", () => {
    draggingCam = false;
    draggingNode = null;
  });

  canvas.addEventListener("click", (e) => {
    const onHud = e.target && (e.target.closest && e.target.closest("#hud"));
    const onSide = e.target && (e.target.closest && e.target.closest("#side"));
    if(onHud || onSide) return;

    const hit = nodeAt(e.clientX, e.clientY);
    if(hit && hit.type === "LINK"){
      // click again opens
      if(selected && selected.key === hit.key){
        window.open(hit.url, "_blank", "noopener,noreferrer");
      }
    }
  });

  canvas.addEventListener("wheel", (e) => {
    const onHud = e.target && (e.target.closest && e.target.closest("#hud"));
    const onSide = e.target && (e.target.closest && e.target.closest("#side"));
    if(onHud || onSide) return;
    e.preventDefault();

    const mouse = { x:e.clientX, y:e.clientY };
    const before = screenToWorld(mouse.x, mouse.y);

    const zoom = Math.exp(-e.deltaY * 0.0012);
    cam.z = Math.max(0.15, Math.min(3.5, cam.z * zoom));

    const after = screenToWorld(mouse.x, mouse.y);
    cam.x += (before.x - after.x);
    cam.y += (before.y - after.y);
  }, { passive:false });

  // ===== Physics (lizard organism) =====
  function step(dt){
    const speed = parseFloat(speedEl.value || "1");
    const density = parseFloat(densityEl.value || "1");
    const t = performance.now() * 0.001;

    const activeEdges = filteredEdges();

    // forces
    const repulse = 2200 * density;
    const springK = 0.010 * density;
    const damp = 0.92;

    // repel
    for(let i=0;i<nodes.length;i++){
      const A = nodes[i];
      if(!isVisibleByFilter(A)) continue;
      if(A.pinned) { A.vx = 0; A.vy = 0; continue; }
      for(let j=i+1;j<nodes.length;j++){
        const B = nodes[j];
        if(!isVisibleByFilter(B)) continue;
        if(B.pinned) continue;
        const dx = B.x - A.x, dy = B.y - A.y;
        const d2 = dx*dx + dy*dy + 0.001;
        const d = Math.sqrt(d2);
        const minD = (A.r + B.r + 16);
        const f = (repulse / d2) * (d < minD ? 2.2 : 1.0);
        const ux = dx / d, uy = dy / d;
        A.vx -= ux * f * 0.002;
        A.vy -= uy * f * 0.002;
        B.vx += ux * f * 0.002;
        B.vy += uy * f * 0.002;
      }
    }

    // springs
    for(const e of activeEdges){
      const A = nodeByKey.get(e.a);
      const B = nodeByKey.get(e.b);
      const dx = B.x - A.x, dy = B.y - A.y;
      const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
      const diff = d - e.rest;
      const ux = dx / d, uy = dy / d;
      const f = diff * springK;

      if(!A.pinned && draggingNode !== A){
        A.vx += ux * f;
        A.vy += uy * f;
      }
      if(!B.pinned && draggingNode !== B){
        B.vx -= ux * f;
        B.vy -= uy * f;
      }
    }

    // lizard crawl: subtle oscillation in clusters, tiny jitter in links
    for(const n of nodes){
      if(!isVisibleByFilter(n)) continue;
      if(n.pinned) continue;
      if(draggingNode === n) continue;

      if(n.type === "CLUSTER"){
        const s = n.seed || 0.5;
        n.vx += Math.sin(t*0.9 + s*9) * 0.06 * speed;
        n.vy += Math.cos(t*0.8 + s*11) * 0.06 * speed;
      }
      if(n.type === "LINK"){
        const s = n.seed || 0.5;
        n.vx += Math.sin(t*1.7 + s*17) * 0.02 * speed;
        n.vy += Math.cos(t*1.5 + s*19) * 0.02 * speed;
      }
    }

    // integrate
    for(const n of nodes){
      if(!isVisibleByFilter(n)) continue;
      if(n.pinned) continue;
      if(draggingNode === n) continue;

      n.vx *= damp;
      n.vy *= damp;

      n.x += n.vx * (dt/16) * speed;
      n.y += n.vy * (dt/16) * speed;
    }
  }

  // ===== Draw =====
  function draw(){
    const W = window.innerWidth, H = window.innerHeight;
    ctx.clearRect(0,0,W,H);

    const bg = cssVar("--bg");
    const fg = cssVar("--fg");
    const muted = cssVar("--muted");
    const line = cssVar("--line");

    // Background subtle grid
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = line;
    ctx.lineWidth = 1;
    ctx.beginPath();
    const g = 64;
    for(let x=0;x<=W;x+=g){ ctx.moveTo(x,0); ctx.lineTo(x,H); }
    for(let y=0;y<=H;y+=g){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
    ctx.stroke();
    ctx.restore();

    // Edges
    const eList = filteredEdges();
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.strokeStyle = line;
    ctx.lineWidth = 1;
    for(const e of eList){
      const A = nodeByKey.get(e.a);
      const B = nodeByKey.get(e.b);
      const a = worldToScreen(A.x, A.y);
      const b = worldToScreen(B.x, B.y);

      // lizard “tendon”: slight bend
      const mx = (a.x + b.x)/2;
      const my = (a.y + b.y)/2;
      const bend = 10;
      const nx = -(b.y - a.y);
      const ny = (b.x - a.x);
      const nd = Math.sqrt(nx*nx + ny*ny) + 0.001;
      const ux = nx/nd, uy = ny/nd;

      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.quadraticCurveTo(mx + ux*bend, my + uy*bend, b.x, b.y);
      ctx.stroke();
    }
    ctx.restore();

    // Nodes
    for(const n of nodes){
      if(!isVisibleByFilter(n)) continue;

      const p = worldToScreen(n.x, n.y);
      const r = n.r * (n.type==="CENTER" ? 1.0 : 1.0);

      // fill
      ctx.save();
      const isHover = hovered && hovered.key === n.key;
      const isSel = selected && selected.key === n.key;

      ctx.fillStyle = bg;
      ctx.strokeStyle = line;
      ctx.lineWidth = 1;

      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.fill();

      // emphasize
      if(isSel){
        ctx.lineWidth = 2;
      }else if(isHover){
        ctx.lineWidth = 2;
      }else{
        ctx.lineWidth = 1;
      }
      ctx.stroke();

      // inner mark for link visibility
      if(n.type === "LINK"){
        const v = getVis(n.id);
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = (v==="PUBLIC") ? fg : (v==="PRIVATE" ? muted : line);
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3.2, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      ctx.restore();

      // labels (uniform size, minimal)
      ctx.save();
      ctx.fillStyle = (n.type==="LINK") ? muted : fg;
      ctx.font = cssVar("--font").replace(/^\s*12px\/1\.15\s*/,"12px "); // keep same size
      ctx.textBaseline = "middle";

      const text = n.type==="CENTER" ? "KETADATA" : n.label;
      const maxChars = (n.type==="LINK") ? 26 : 18;
      const label = text.length > maxChars ? text.slice(0,maxChars-1) + "…" : text;

      // label position: center label under, others to right
      const offX = (n.type==="CENTER") ? 0 : (r + 8);
      const offY = (n.type==="CENTER") ? (r + 14) : 0;

      if(n.type==="CENTER"){
        ctx.textAlign = "center";
      }else{
        ctx.textAlign = "left";
      }

      // subtle background tag for legibility
      const tx = p.x + offX;
      const ty = p.y + offY;
      const w = ctx.measureText(label).width;
      const pad = 3;
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = bg;
      ctx.fillRect(tx - (n.type==="CENTER" ? w/2 : 0) - pad, ty - 8, w + pad*2, 16);
      ctx.globalAlpha = 1;

      ctx.fillStyle = (n.type==="LINK") ? muted : fg;
      ctx.fillText(label, tx, ty);

      ctx.restore();
    }
  }

  // ===== Controls =====
  btnPause.onclick = () => setRunning(!running);
  btnRecenter.onclick = () => { cam.x = 0; cam.y = 0; cam.z = 1; };
  btnSpread.onclick = () => {
    // shove clusters outward = "lizard stretch"
    for(const n of nodes){
      if(n.type==="CLUSTER" || n.type==="LINK"){
        const dx = n.x, dy = n.y;
        const d = Math.sqrt(dx*dx+dy*dy) + 0.001;
        n.vx += (dx/d) * 14;
        n.vy += (dy/d) * 14;
      }
    }
  };
  btnZoomIn.onclick = () => cam.z = Math.min(3.5, cam.z * 1.15);
  btnZoomOut.onclick = () => cam.z = Math.max(0.15, cam.z / 1.15);

  qEl.addEventListener("input", () => { /* filtering is live */ });
  visFilterEl.addEventListener("change", () => { /* filtering is live */ });

  openNew.onclick = () => {
    if(selected && selected.type==="LINK") window.open(selected.url, "_blank", "noopener,noreferrer");
  };
  copyUrl.onclick = async () => {
    if(!(selected && selected.type==="LINK")) return;
    try{ await navigator.clipboard.writeText(selected.url); }catch{}
  };
  toggleVisBtn.onclick = () => {
    if(!(selected && selected.type==="LINK")) return;
    toggleVis(selected.id);
    selVis.textContent = getVis(selected.id);
  };
  closeSide.onclick = () => setSelected(null);

  btnExportPublic.onclick = () => {
    const out = { fileId:"KETADATA_PUBLIC_LINKS_V1", updatedAt:new Date().toISOString(), baseUrl:BASE_URL, clusters:{} };
    CLUSTERS.forEach(c => {
      out.clusters[c.name] = c.links
        .map(p => ({ path:p, url:makeUrl(p), visibility:getVis(makeId(c.name,p)) }))
        .filter(x => x.visibility === "PUBLIC");
    });
    download("KD_public_links.json", JSON.stringify(out, null, 2));
  };

  btnExportAll.onclick = () => {
    download("KD_visibility_map.json", JSON.stringify({ version:"KD_ROUTER_VIS_V1", updatedAt:new Date().toISOString(), vis }, null, 2));
  };

  btnImport.onclick = () => filePick.click();
  filePick.addEventListener("change", async () => {
    const f = filePick.files && filePick.files[0];
    if(!f) return;
    const text = await f.text();
    importJSON(text);
    filePick.value = "";
  });

  btnResetVis.onclick = () => { resetVis(); };

  function download(filename, text){
    const blob = new Blob([text], { type:"application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 800);
  }

  function importJSON(text){
    let parsed;
    try{ parsed = JSON.parse(text); }catch{ return; }
    if(!parsed || typeof parsed !== "object") return;

    if(parsed.vis && typeof parsed.vis === "object"){
      const next = {};
      for(const k in parsed.vis){
        const v = parsed.vis[k];
        if(v==="PUBLIC" || v==="PRIVATE") next[k]=v;
      }
      vis = next;
      saveVis();
      if(selected && selected.type==="LINK") selVis.textContent = getVis(selected.id);
      return;
    }

    // also accept {clusters:{NAME:[{path,visibility}]}}
    if(parsed.clusters && typeof parsed.clusters === "object"){
      const next = {};
      for(const cname in parsed.clusters){
        const arr = parsed.clusters[cname];
        if(!Array.isArray(arr)) continue;
        arr.forEach(it => {
          const p = it?.path;
          const v = it?.visibility;
          if(typeof p !== "string") return;
          const id = makeId(cname, p);
          if(v==="PUBLIC" || v==="PRIVATE") next[id]=v;
        });
      }
      vis = next;
      saveVis();
      if(selected && selected.type==="LINK") selVis.textContent = getVis(selected.id);
    }
  }

  // System universals
  function toggleNull(){ document.documentElement.classList.toggle("null"); }
  function toggleInvert(){ document.documentElement.classList.toggle("invert"); }
  function toggleFull(){
    if(!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
  }
  btnNull.onclick = toggleNull;
  btnInvert.onclick = toggleInvert;
  btnFull.onclick = toggleFull;

  window.addEventListener("keydown", (e) => {
    const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
    const typing = (tag === "input" || tag === "textarea");

    if(e.key === " " && !typing){ e.preventDefault(); setRunning(!running); return; }
    if(e.shiftKey && (e.key==="I"||e.key==="i")){ e.preventDefault(); toggleInvert(); return; }
    if(e.shiftKey && (e.key==="N"||e.key==="n")){ e.preventDefault(); toggleNull(); return; }
    if(e.shiftKey && (e.key==="F"||e.key==="f")){ e.preventDefault(); toggleFull(); return; }
    if(e.key==="Escape"){ setSelected(null); }
  });

  // ===== Main loop =====
  loadVis();
  let last = performance.now();
  function loop(now){
    const dt = Math.min(40, now - last);
    last = now;
    if(running) step(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>

<!--
AE / EE / WB — KETADATA SERIALIZATION STAMP (MANDATORY)
AE: LIMINAL CENTER ROUTER + CLUSTER NODES + LINK OFFSHOOTS, MONOCHROME, UNIFORM TEXT, SURREAL BRUTALIST FIELD
EE: ZOOM/PAN, DRAG TO PULL NODES, PAUSE/RESUME, SEARCH + VIS FILTER (PUBLIC/PRIVATE/UNSET), CLICK-TO-OPEN, EXPORT/IMPORT VIS MAP
WB: LOCAL-FIRST VISIBILITY MAP (localStorage), WHOLE-PAGE INVERT (HTML CLASS), NULL/FULL HOTKEYS

FILE_ID: "KETADATA_ROUTER_LIZARD_MINDMAP"
ROOM_ID: "K_ROUTER"
VERSION_ID: "V1"
UPDATED_AT: "2026-01-04T00:00:00.000-05:00"
CHANGELOG:
- V1: LIMINAL CENTER MINDMAP ROUTER WITH ALL CLUSTER LINKS + LIZARD MOTION + PAUSE + ZOOM/PAN + LINK VISIBILITY (PUBLIC/PRIVATE)
-->
</body>
</html>
