<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA // CONSTELLATION NOTES</title>
  <style>
    :root{
      --bg:#000;
      --panel:#050607;
      --ink:#eef2f7;
      --muted:#9aa3af;

      --lineSoft:#1b1f25;

      --radius:3px;          /* industrial: slight only */
      --nodeW:240;
      --nodeH:158;
      --centerW:240;
      --centerH:158;

      --shadow: 0 0 0 1px rgba(233,238,247,.16), 0 10px 40px rgba(0,0,0,.65);
      --shadowSoft: 0 0 0 1px rgba(233,238,247,.10), 0 8px 30px rgba(0,0,0,.55);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--ink); font-family:Arial,Helvetica,sans-serif; }

    .topbar{
      position:fixed; inset:0 0 auto 0;
      height:52px;
      display:flex; align-items:center; justify-content:space-between;
      padding:0 14px;
      background:#000;
      border-bottom:1px solid var(--lineSoft);
      z-index:50;
    }
    .brand{ display:flex; flex-direction:column; gap:2px; min-width:340px; }
    .brand .t{ font-size:12px; letter-spacing:1.4px; text-transform:uppercase; }
    .brand .s{ font-size:11px; color:var(--muted); }

    .btns{ display:flex; gap:8px; align-items:center; }
    button{
      background:transparent;
      color:var(--ink);
      border:1px solid var(--lineSoft);
      border-radius:10px;
      padding:7px 10px;
      font-size:11px;
      letter-spacing:.6px;
      text-transform:uppercase;
      cursor:pointer;
    }
    button:hover{ border-color:rgba(233,238,247,.28); }
    button.primary{ border-color:rgba(233,238,247,.28); }

    .pill{
      border:1px solid rgba(233,238,247,.22);
      border-radius:999px;
      padding:6px 10px;
      font-size:11px;
      color:rgba(233,238,247,.85);
      letter-spacing:.6px;
      text-transform:uppercase;
    }

    #stageWrap{
      position:fixed;
      inset:52px 0 0 0;
      overflow:hidden;
      background:#000;
    }
    #stage{
      position:absolute;
      inset:0;
      overflow:hidden;
    }
    #wires{
      position:absolute; inset:0;
      pointer-events:none;
      z-index:1;
    }

    .hint{
      position:absolute;
      left:12px; bottom:10px;
      font-size:11px;
      letter-spacing:1px;
      color:rgba(154,163,175,.65);
      text-transform:uppercase;
      z-index:5;
      user-select:none;
    }

    .node{
      position:absolute;
      width:calc(var(--nodeW) * 1px);
      height:calc(var(--nodeH) * 1px);
      border-radius:var(--radius);
      background:rgba(5,6,7,.98);
      border:1px solid rgba(233,238,247,.14);
      box-shadow:var(--shadowSoft);
      z-index:3;
      user-select:none;
      cursor:grab;
    }
    .node.center{
      width:calc(var(--centerW) * 1px);
      height:calc(var(--centerH) * 1px);
      background:rgba(4,5,6,.98);
      border-color:rgba(233,238,247,.18);
      box-shadow:var(--shadow);
    }
    .node.selected{ border-color:rgba(233,238,247,.35); }
    .node:active{ cursor:grabbing; }

    .bar{
      display:flex; align-items:center; justify-content:space-between;
      padding:9px 10px 7px 10px;
      border-bottom:1px solid var(--lineSoft);
    }
    .bar .name{ font-size:12px; letter-spacing:1.2px; text-transform:uppercase; }
    .bar .tag{
      font-size:10px;
      color:rgba(154,163,175,.8);
      letter-spacing:.6px;
      border:1px solid rgba(233,238,247,.12);
      padding:2px 6px;
      border-radius:9px;
      text-transform:lowercase;
      white-space:nowrap;
    }
    .pin{
      width:7px; height:7px; border-radius:999px;
      border:1px solid rgba(233,238,247,.18);
      background:rgba(233,238,247,.06);
      margin-left:10px;
    }

    .body{
      padding:10px;
      height:calc(100% - 38px);
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    textarea{
      width:100%;
      flex:1;
      resize:none;
      border-radius:2px;
      border:1px solid rgba(233,238,247,.10);
      background:#000;
      color:rgba(233,238,247,.92);
      padding:8px;
      font-size:11px;
      line-height:1.35;
      outline:none;
    }
    textarea:focus{ border-color:rgba(233,238,247,.22); }

    .meta{
      display:flex; align-items:center; justify-content:space-between;
      font-size:11px;
      color:rgba(154,163,175,.85);
    }
    .meta .focus{
      border-radius:2px;
      border:1px solid rgba(233,238,247,.14);
      padding:4px 7px;
      font-size:11px;
      text-transform:lowercase;
      color:rgba(233,238,247,.92);
      background:transparent;
      cursor:pointer;
    }
    .meta .focus:hover{ border-color:rgba(233,238,247,.24); }

    #rightDock{
      position:absolute;
      right:12px; top:12px;
      width:360px;
      display:flex;
      flex-direction:column;
      gap:10px;
      z-index:10;
      pointer-events:none;
    }
    .panel{
      pointer-events:auto;
      border-radius:var(--radius);
      border:1px solid rgba(233,238,247,.14);
      background:rgba(5,6,7,.98);
      box-shadow:var(--shadowSoft);
      padding:10px;
    }
    .panel h3{
      margin:0 0 10px 0;
      font-size:11px;
      color:rgba(154,163,175,.9);
      letter-spacing:1.2px;
      text-transform:uppercase;
    }
    .kv{
      display:grid;
      grid-template-columns:88px 1fr;
      gap:6px 10px;
      font-size:11px;
      color:rgba(233,238,247,.92);
    }
    .kv .k{ color:rgba(154,163,175,.9); text-transform:lowercase; }
    .rules{
      margin-top:10px;
      border-top:1px solid var(--lineSoft);
      padding-top:10px;
      font-size:11px;
      color:rgba(154,163,175,.85);
      line-height:1.4;
    }
    .rules .dash{ display:block; }

    .wire{
      stroke:rgba(233,238,247,.14);
      stroke-width:1;
      fill:none;
      vector-effect: non-scaling-stroke;
    }
    .wire.dashed{
      stroke:rgba(120,150,130,.28);
      stroke-dasharray:3 6;
    }

    .pulseLine{
      stroke:rgba(233,238,247,.92);
      stroke-width:1.2;
      fill:none;
      stroke-dasharray: 2 7;
      animation: dash 900ms linear infinite;
      filter: drop-shadow(0 0 6px rgba(233,238,247,.25));
      vector-effect: non-scaling-stroke;
    }
    @keyframes dash{
      from{ stroke-dashoffset: 0; }
      to{ stroke-dashoffset: -40; }
    }

    .sr{ position:absolute; left:-9999px; }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">
      <div class="t">KETADATA // CONSTELLATION NOTES</div>
      <div class="s">Squares are rooms + system layers. Drag to rearrange. Lines are navigation logic.</div>
    </div>

    <div class="btns">
      <span id="dirty" class="pill">unsaved</span>
      <button class="primary" id="btnCenter">center</button>
      <button id="btnReset">reset layout</button>
      <button id="btnExport">export.json</button>
      <button id="btnImport">import.json</button>
      <button class="primary" id="btnSave">save</button>
      <input id="file" class="sr" type="file" accept="application/json">
    </div>
  </div>

  <div id="stageWrap">
    <div id="stage">
      <svg id="wires"></svg>

      <div id="rightDock">
        <div class="panel" id="selectedPanel">
          <h3>Selected</h3>
          <div class="kv">
            <div class="k">node</div><div id="selNode">—</div>
            <div class="k">type</div><div id="selType">—</div>
            <div class="k">neighbors</div><div id="selNbrs">—</div>
          </div>
          <div class="rules">
            <span class="dash">— click a square to select</span>
            <span class="dash">— drag squares to rearrange</span>
            <span class="dash">— notes persist per square</span>
            <span class="dash">— navigation logic is fixed unless edited in JSON</span>
          </div>
        </div>
      </div>

      <div class="hint">DRAG TO REPOSITION · CLICK TO SELECT</div>
    </div>
  </div>

<script>
(() => {
  const stage = document.getElementById('stage');
  const svg = document.getElementById('wires');

  const dirtyEl = document.getElementById('dirty');
  const btnCenter = document.getElementById('btnCenter');
  const btnReset = document.getElementById('btnReset');
  const btnExport = document.getElementById('btnExport');
  const btnImport = document.getElementById('btnImport');
  const btnSave = document.getElementById('btnSave');
  const file = document.getElementById('file');

  const selNode = document.getElementById('selNode');
  const selType = document.getElementById('selType');
  const selNbrs = document.getElementById('selNbrs');

  const LS_KEY = 'ketadata_constellation_v2_clean';

  const cssNum = (name) => {
    const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    const n = Number(v);
    return Number.isFinite(n) ? n : 0;
  };

  // ---- graph ----
  const nodes = [
    { id:'observatory', label:'Observatory', type:'room/highest' },
    { id:'cinema',      label:'Cinema',      type:'room/lens' },
    { id:'library',     label:'Library',     type:'room/club' },
    { id:'temple',      label:'Temple',      type:'room/adjacent' },
    { id:'lobby',       label:'Lobby',       type:'room/entry' },
    { id:'store',       label:'Store',       type:'room/commerce' },
    { id:'room',        label:'Room',        type:'room/private' },
    { id:'studio',      label:'Studio',      type:'room/work' },
    { id:'lab',         label:'Lab',         type:'room/sensory' },
    { id:'vault',       label:'Vault',       type:'room/sealed' },
    { id:'basement',    label:'Basement',    type:'room/lowest' },
    { id:'elevator',    label:'Elevator',    type:'room/router', center:true },
  ];

  const edges = [
    ['elevator','lobby'],
    ['elevator','temple'],
    ['elevator','store'],
    ['elevator','room'],
    ['elevator','studio'],
    ['elevator','lab'],
    ['elevator','vault'],
    ['elevator','cinema'],
    ['elevator','library'],
    ['elevator','observatory'],
    ['elevator','basement'],
  ];

  const dashedEdges = [
    ['lobby','store'],
    ['temple','store'],
    ['lab','basement'],
    ['vault','lab'],
    ['observatory','cinema'],
    ['cinema','studio'],
    ['library','vault'],
  ];

  const state = {
    selected: 'elevator',
    positions: {},
    notes: {},
    _dirty: true
  };

  // drag/click guard
  let justDragged = false;
  let dragStartAt = 0;

  // ---- DOM ----
  const dom = new Map();

  function makeNode(n){
    const el = document.createElement('div');
    el.className = 'node' + (n.center ? ' center' : '');
    el.dataset.id = n.id;

    const bar = document.createElement('div');
    bar.className = 'bar';

    const left = document.createElement('div');
    left.style.display = 'flex';
    left.style.alignItems = 'center';
    left.style.gap = '8px';

    const name = document.createElement('div');
    name.className = 'name';
    name.textContent = n.label;

    const pin = document.createElement('div');
    pin.className = 'pin';

    left.appendChild(name);
    left.appendChild(pin);

    const tag = document.createElement('div');
    tag.className = 'tag';
    tag.textContent = n.type;

    bar.appendChild(left);
    bar.appendChild(tag);

    const body = document.createElement('div');
    body.className = 'body';

    const ta = document.createElement('textarea');
    ta.placeholder = 'notes...';
    ta.value = state.notes[n.id] || '';
    ta.addEventListener('input', () => {
      state.notes[n.id] = ta.value;
      setDirty(true);
    });

    const meta = document.createElement('div');
    meta.className = 'meta';

    const m1 = document.createElement('span');
    m1.textContent = 'drag to reposition';

    const focus = document.createElement('button');
    focus.className = 'focus';
    focus.type = 'button';
    focus.textContent = 'focus';
    focus.addEventListener('click', (e) => {
      e.stopPropagation();
      selectNode(n.id);
      // focus centers without changing other nodes’ relative spacing
      centerOn(n.id);
    });

    meta.appendChild(m1);
    meta.appendChild(focus);

    body.appendChild(ta);
    body.appendChild(meta);

    el.appendChild(bar);
    el.appendChild(body);

    // click select (no route)
    el.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'TEXTAREA' || e.target.classList.contains('focus')) return;
      selectNode(n.id);
    });

    enableDrag(el);

    stage.appendChild(el);
    dom.set(n.id, el);
  }

  function rebuild(){
    for (const [, el] of dom) el.remove();
    dom.clear();
    nodes.forEach(makeNode);
    layoutAll();
    selectNode(state.selected);
  }

  // ---- selection ----
  function selectNode(id){
    state.selected = id;
    for (const [nid, el] of dom){
      el.classList.toggle('selected', nid === id);
    }
    const n = nodes.find(x => x.id === id);
    const neighbors = edges
      .filter(([a,b]) => a === id || b === id)
      .map(([a,b]) => (a === id ? b : a))
      .map(x => (nodes.find(nn => nn.id === x)?.label || x));

    selNode.textContent = n ? n.label : id;
    selType.textContent = n ? n.type : '—';
    selNbrs.textContent = neighbors.length ? neighbors.join(', ') : '—';

    setDirty(true);
  }

  // ---- geometry ----
  function nodeCenter(id){
    const el = dom.get(id);
    const r = el.getBoundingClientRect();
    const sr = stage.getBoundingClientRect();
    return { x:(r.left - sr.left) + r.width/2, y:(r.top - sr.top) + r.height/2 };
  }

  function layoutAll(){
    for (const n of nodes){
      const el = dom.get(n.id);
      const p = state.positions[n.id];
      if (!el || !p) continue;
      el.style.left = Math.round(p.x) + 'px';
      el.style.top  = Math.round(p.y) + 'px';
    }
    drawWires();
  }

  function drawWires(){
    const r = stage.getBoundingClientRect();
    svg.setAttribute('width', r.width);
    svg.setAttribute('height', r.height);
    svg.innerHTML = '';

    for (const [a,b] of edges){
      const A = nodeCenter(a), B = nodeCenter(b);
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('class','wire');
      p.setAttribute('d', `M ${A.x} ${A.y} L ${B.x} ${B.y}`);
      svg.appendChild(p);
    }
    for (const [a,b] of dashedEdges){
      const A = nodeCenter(a), B = nodeCenter(b);
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('class','wire dashed');
      p.setAttribute('d', `M ${A.x} ${A.y} L ${B.x} ${B.y}`);
      svg.appendChild(p);
    }
  }

  // ---- CLEANER DEFAULT LAYOUT (more “architected”, less mathy drift) ----
  function resetLayout(){
  // === KETADATA // CANON DEFAULT LAYOUT (v2 clean) ===
  // NOTE: This is a fixed relative layout; we only translate it so the elevator lands center-stage.

  const r = stage.getBoundingClientRect();
  const desiredX = r.width * 0.50;
  const desiredY = r.height * 0.50;

  // --- CANON PRESET (your exact payload) ---
  const pos = {
    elevator:     { x: 858,  y: 407 },
    observatory:  { x: 105,  y: 50.60000000000002 },
    cinema:       { x: 106,  y: 239.60000000000002 },
    library:      { x: 104,  y: 424.80000000000007 },
    lobby:        { x: 858,  y: 59.80000000000001 },
    temple:       { x: 1131, y: 238.60000000000002 },
    store:        { x: 603,  y: 240.60000000000002 },
    room:         { x: 1640, y: 413.44000000000005 },
    studio:       { x: 602,  y: 643.6 },
    vault:        { x: 873,  y: 825.6 },
    lab:          { x: 1142, y: 635 },
    basement:     { x: 1643, y: 790.5999999999999 },
  };

  // --- recenter translation (preserves exact relative geometry) ---
  const dx = desiredX - pos.elevator.x;
  const dy = desiredY - pos.elevator.y;

  for (const k in pos){
    pos[k] = { x: pos[k].x + dx, y: pos[k].y + dy };
  }

  state.positions = pos;

  // Keep current notes, but ensure keys exist
  state.notes = state.notes || {};
  if (state.notes.lobby == null) state.notes.lobby = "";

  // Canon selection
  state.selected = "vault";

  // Optional: if your app stores edges/dashedEdges in state and you want reset to reassert them:
  // state.edges = [
  //   ["elevator","lobby"],
  //   ["elevator","temple"],
  //   ["elevator","store"],
  //   ["elevator","room"],
  //   ["elevator","studio"],
  //   ["elevator","lab"],
  //   ["elevator","vault"],
  //   ["elevator","cinema"],
  //   ["elevator","library"],
  //   ["elevator","observatory"],
  //   ["elevator","basement"],
  // ];
  // state.dashedEdges = [
  //   ["lobby","store"],
  //   ["temple","store"],
  //   ["lab","basement"],
  //   ["vault","lab"],
  //   ["observatory","cinema"],
  //   ["cinema","studio"],
  //   ["library","vault"],
  // ];

  setDirty(true);
  persist();
  layoutAll();
  selectNode(state.selected);
}


  function centerOn(id){
    const r = stage.getBoundingClientRect();
    const target = nodeCenter(id);
    const desired = { x: r.width * 0.50, y: r.height * 0.50 };
    const dx = desired.x - target.x;
    const dy = desired.y - target.y;

    for (const k of Object.keys(state.positions)){
      state.positions[k] = { x: state.positions[k].x + dx, y: state.positions[k].y + dy };
    }
    setDirty(true);
    persist();
    layoutAll();
  }

  // ---- drag (stable + click-guard) ----
  function enableDrag(el){
    const id = el.dataset.id;
    let dragging = false;
    let start = null;
    let base = null;

    const onDown = (e) => {
      if (e.button !== 0) return;
      if (e.target.tagName === 'TEXTAREA') return;

      dragging = true;
      justDragged = false;
      dragStartAt = performance.now();

      selectNode(id);

      const sr = stage.getBoundingClientRect();
      const rect = el.getBoundingClientRect();

      start = { x: e.clientX, y: e.clientY };
      base = {
        x: (state.positions[id]?.x ?? (rect.left - sr.left)),
        y: (state.positions[id]?.y ?? (rect.top  - sr.top))
      };

      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
    };

    const onMove = (e) => {
      if (!dragging) return;
      const dx = e.clientX - start.x;
      const dy = e.clientY - start.y;

      // if user has moved more than a few pixels, it’s a drag
      if (Math.abs(dx) + Math.abs(dy) > 4) justDragged = true;

      state.positions[id] = { x: base.x + dx, y: base.y + dy };
      setDirty(true);
      layoutAll();
    };

    const onUp = () => {
      dragging = false;
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);

      // if it was a drag, suppress click routing briefly
      if (justDragged || (performance.now() - dragStartAt) > 180){
        justDragged = true;
        window.setTimeout(() => { justDragged = false; }, 220);
      }

      persist();
    };

    el.addEventListener('mousedown', onDown);
  }

  // ---- pulse route (clean, no camera jump) ----
  let pulseTimeout = null;

  function pulseRoute(toId){
    const existing = svg.querySelector('.pulseLine');
    if (existing) existing.remove();

    const A = nodeCenter('elevator');
    const B = nodeCenter(toId);

    const p = document.createElementNS('http://www.w3.org/2000/svg','path');
    p.setAttribute('class','pulseLine');
    p.setAttribute('d', `M ${A.x} ${A.y} L ${B.x} ${B.y}`);
    svg.appendChild(p);

    clearTimeout(pulseTimeout);
    pulseTimeout = setTimeout(() => p.remove(), 900);
  }

  // click: select + pulse only (no movement)
  stage.addEventListener('click', (e) => {
    if (justDragged) return;

    const nodeEl = e.target.closest('.node');
    if (!nodeEl) return;

    const id = nodeEl.dataset.id;
    if (!id) return;

    selectNode(id);
    if (id !== 'elevator') pulseRoute(id);
  });

  // ---- persistence ----
  function setDirty(v){
    state._dirty = !!v;
    dirtyEl.textContent = state._dirty ? 'unsaved' : 'saved';
    dirtyEl.style.borderColor = state._dirty ? 'rgba(233,238,247,.30)' : 'rgba(120,150,130,.35)';
    dirtyEl.style.color = state._dirty ? 'rgba(233,238,247,.85)' : 'rgba(180,220,190,.85)';
  }

  function persist(){
    try{
      localStorage.setItem(LS_KEY, JSON.stringify({
        selected: state.selected,
        positions: state.positions,
        notes: state.notes
      }));
    }catch{}
  }

  function load(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return false;
      const data = JSON.parse(raw);
      if (data && typeof data === 'object'){
        state.selected = data.selected || state.selected;
        state.positions = data.positions || {};
        state.notes = data.notes || {};
        return true;
      }
    }catch{}
    return false;
  }

  // ---- export/import ----
  function exportJSON(){
    const payload = {
      version: 'ketadata-constellation-v2-clean',
      selected: state.selected,
      positions: state.positions,
      notes: state.notes,
      edges,
      dashedEdges
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'ketadata_constellation.json';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function importJSONFile(f){
    const reader = new FileReader();
    reader.onload = () => {
      try{
        const data = JSON.parse(reader.result);
        if (!data || typeof data !== 'object') return;

        if (data.positions) state.positions = data.positions;
        if (data.notes) state.notes = data.notes;
        if (typeof data.selected === 'string') state.selected = data.selected;

        persist();
        rebuild();
        setDirty(true);
      }catch{}
    };
    reader.readAsText(f);
  }

  // ---- controls ----
  btnReset.addEventListener('click', () => resetLayout());
  btnCenter.addEventListener('click', () => centerOn('elevator'));
  btnSave.addEventListener('click', () => { persist(); setDirty(false); });
  btnExport.addEventListener('click', exportJSON);
  btnImport.addEventListener('click', () => file.click());
  file.addEventListener('change', () => {
    if (file.files && file.files[0]) importJSONFile(file.files[0]);
    file.value = '';
  });

  window.addEventListener('resize', () => drawWires());

  // ---- init ----
  const had = load();
  rebuild();
  if (!had || !Object.keys(state.positions).length){
    resetLayout();
  }else{
    layoutAll();
    selectNode(state.selected);
  }
  setDirty(true);

})();
</script>
</body>
</html>
