<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA — ARTAUD INTERFACE (THEATRE OF CRUELTY / RITUAL ENGINE)</title>
  <style>
    :root{
      --bg:#000;
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.56);
      --hair:rgba(255,255,255,.14);
      --panel:rgba(0,0,0,.58);
      --panel2:rgba(255,255,255,.03);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background:var(--bg);
      color:var(--fg);
      font-family: Arial, Helvetica, sans-serif;
    }
    canvas{ position:fixed; inset:0; width:100vw; height:100vh; display:block; }

    .hud{
      position:fixed; left:18px; top:16px;
      user-select:none; pointer-events:none;
      mix-blend-mode:screen;
    }
    .brand{
      font-weight:900;
      letter-spacing:.18em;
      text-transform:uppercase;
      font-size:15px;
      text-shadow:0 0 18px rgba(255,255,255,.18);
    }
    .sub{
      margin-top:4px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:var(--muted);
      line-height:1.25;
      max-width: 56ch;
    }

    .dock{
      position:fixed; left:18px; bottom:16px;
      display:flex; flex-wrap:wrap;
      gap:10px; align-items:center;
      pointer-events:auto;
    }
    .btn{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.22);
      color:rgba(255,255,255,.86);
      padding:10px 12px;
      border-radius:10px;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{ background:rgba(255,255,255,.10); border-color:rgba(255,255,255,.36); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }

    .panel{
      position:fixed; right:16px; top:16px;
      width:min(760px, calc(100vw - 32px));
      max-height: calc(100vh - 32px);
      overflow:auto;
      border:1px solid rgba(255,255,255,.18);
      background:var(--panel);
      backdrop-filter: blur(10px);
      border-radius:14px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset, 0 16px 50px rgba(0,0,0,.65);
    }
    .panelHeader{
      position:sticky; top:0;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.74);
      backdrop-filter: blur(10px);
      display:flex; justify-content:space-between; align-items:center;
      z-index:10;
    }
    .title{
      font-weight:900;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      color:rgba(255,255,255,.86);
    }
    .hint{
      font-size:11px;
      letter-spacing:.08em;
      color:rgba(255,255,255,.55);
      text-align:right;
      line-height:1.2;
    }
    .panelBody{ padding:10px 12px 14px; display:flex; flex-direction:column; gap:10px; }

    .block{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      overflow:hidden;
      background:var(--panel2);
    }
    .block h3{
      margin:0;
      padding:10px 10px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:rgba(255,255,255,.75);
      border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      display:flex; justify-content:space-between; align-items:center; gap:10px;
    }
    .pill{
      font-size:10px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:rgba(255,255,255,.62);
      border:1px solid rgba(255,255,255,.18);
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.20);
      white-space:nowrap;
    }
    .rows{ padding:10px; display:flex; flex-direction:column; gap:10px; }
    .row{
      display:grid;
      grid-template-columns: 260px 1fr 70px;
      gap:10px;
      align-items:center;
    }
    .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:rgba(255,255,255,.62);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    input[type="range"]{ width:100%; accent-color: rgba(255,255,255,.92); }
    .val{ font-variant-numeric: tabular-nums; font-size:11px; color:rgba(255,255,255,.76); text-align:right; }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 900px){
      .grid2{ grid-template-columns: 1fr; }
    }

    .toggles{
      padding:10px;
      display:flex; flex-wrap:wrap; gap:8px;
      border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
    }
    .toggle{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }
    .toggle span{
      font-size:11px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:rgba(255,255,255,.78);
      white-space:nowrap;
    }

    .status{
      padding:10px;
      border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
      display:flex; flex-direction:column; gap:10px;
    }
    .mono{
      font-variant-numeric: tabular-nums;
      letter-spacing:.10em;
      text-transform:uppercase;
      font-size:10px;
      color:rgba(255,255,255,.74);
      line-height:1.35;
    }
    .bar{
      height:12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.04);
      overflow:hidden;
    }
    .fill{
      height:100%;
      width:0%;
      background:rgba(255,255,255,.60);
    }
    .edict{
      font-size:12px;
      line-height:1.35;
      letter-spacing:.02em;
      color:rgba(255,255,255,.86);
      padding:10px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.45);
      border-radius:12px;
      white-space:pre-wrap;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="brand">KETADATA</div>
    <div class="sub">ARTAUD MODE · STAGE AS WEAPON · PRESSURE RISES UNLESS YOU PERFORM · HOLD / CUT / BREATH / SILENCE</div>
  </div>

  <div class="dock">
    <button class="btn" id="invert">INVERT</button>
    <button class="btn" id="pause">PAUSE</button>
    <button class="btn" id="recast">RECAST RITUAL</button>
    <button class="btn" id="purge">PURGE</button>
    <button class="btn" id="reset">RESET</button>
  </div>

  <div class="panel" id="panel">
    <div class="panelHeader">
      <div class="title">RITUAL ENGINE</div>
      <div class="hint">
        HOLD [SPACE] = SILENCE · DRAG = CUT · CLICK = STAMP<br/>
        SCROLL = ZOOM · DRAG EMPTY = PAN<br/>
        [H] PANEL · [I] INVERT · [P] PAUSE
      </div>
    </div>

    <div class="panelBody">
      <div class="grid2">
        <div class="block">
          <h3>Stage Physics <span class="pill">motion</span></h3>
          <div class="rows">
            <div class="row">
              <div class="label">time scale (slow-mo)</div>
              <input id="timeScale" type="range" min="0.000" max="2.000" step="0.001" value="0.30">
              <div class="val" id="timeScaleV">0.300</div>
            </div>
            <div class="row">
              <div class="label">tremor</div>
              <input id="tremor" type="range" min="0.00" max="2.00" step="0.01" value="0.85">
              <div class="val" id="tremorV">0.85</div>
            </div>
            <div class="row">
              <div class="label">vortex</div>
              <input id="vortex" type="range" min="0.00" max="2.50" step="0.01" value="1.15">
              <div class="val" id="vortexV">1.15</div>
            </div>
            <div class="row">
              <div class="label">density</div>
              <input id="density" type="range" min="0.40" max="2.40" step="0.01" value="1.30">
              <div class="val" id="densityV">1.30</div>
            </div>
            <div class="row">
              <div class="label">trace (residue)</div>
              <input id="trace" type="range" min="0.000" max="0.22" step="0.001" value="0.055">
              <div class="val" id="traceV">0.055</div>
            </div>
          </div>
        </div>

        <div class="block">
          <h3>Pressure System <span class="pill">discipline</span></h3>
          <div class="rows">
            <div class="row">
              <div class="label">pressure rise rate</div>
              <input id="rise" type="range" min="0.00" max="2.00" step="0.01" value="0.85">
              <div class="val" id="riseV">0.85</div>
            </div>
            <div class="row">
              <div class="label">release strength</div>
              <input id="release" type="range" min="0.00" max="2.50" step="0.01" value="1.15">
              <div class="val" id="releaseV">1.15</div>
            </div>
            <div class="row">
              <div class="label">gesture strictness</div>
              <input id="strict" type="range" min="0.00" max="1.50" step="0.01" value="0.65">
              <div class="val" id="strictV">0.65</div>
            </div>
            <div class="row">
              <div class="label">breath tempo</div>
              <input id="breath" type="range" min="0.10" max="2.50" step="0.01" value="0.95">
              <div class="val" id="breathV">0.95</div>
            </div>
            <div class="row">
              <div class="label">safe pulse rate (Hz)</div>
              <input id="pulseHz" type="range" min="0.00" max="3.00" step="0.01" value="1.20">
              <div class="val" id="pulseHzV">1.20</div>
            </div>
          </div>

          <div class="toggles">
            <label class="toggle"><input id="T_ring" type="checkbox" checked><span>ritual ring</span></label>
            <label class="toggle"><input id="T_wire" type="checkbox" checked><span>wireframe skin</span></label>
            <label class="toggle"><input id="T_text" type="checkbox" checked><span>edicts</span></label>
            <label class="toggle"><input id="T_safePulse" type="checkbox" checked><span>pulse (safe)</span></label>
            <label class="toggle"><input id="T_fastPulse" type="checkbox"><span>fast pulse (unsafe)</span></label>
          </div>

          <div class="status">
            <div class="mono" id="statLine">—</div>
            <div class="bar"><div class="fill" id="pFill"></div></div>
            <div class="edict" id="edict">EDICT: HOLD [SPACE] FOR SILENCE. CUT THE STAGE WITH A DRAG. STAMP WITH A CLICK.</div>
            <div class="mono" id="footnote">
              NOTE: "FAST PULSE" can produce rapid flashing; it is OFF by default. Use at your own risk.
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha:false });

      let W=0, H=0, DPR=Math.min(2, window.devicePixelRatio||1);
      function resize(){
        W=innerWidth; H=innerHeight;
        canvas.width = Math.floor(W*DPR);
        canvas.height = Math.floor(H*DPR);
        canvas.style.width = W+'px';
        canvas.style.height = H+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize);
      resize();

      const $ = (id)=>document.getElementById(id);

      const ui = {
        timeScale: $('timeScale'),
        tremor: $('tremor'),
        vortex: $('vortex'),
        density: $('density'),
        trace: $('trace'),
        rise: $('rise'),
        release: $('release'),
        strict: $('strict'),
        breath: $('breath'),
        pulseHz: $('pulseHz'),
        T_ring: $('T_ring'),
        T_wire: $('T_wire'),
        T_text: $('T_text'),
        T_safePulse: $('T_safePulse'),
        T_fastPulse: $('T_fastPulse'),
      };
      const vv = {
        timeScaleV: $('timeScaleV'),
        tremorV: $('tremorV'),
        vortexV: $('vortexV'),
        densityV: $('densityV'),
        traceV: $('traceV'),
        riseV: $('riseV'),
        releaseV: $('releaseV'),
        strictV: $('strictV'),
        breathV: $('breathV'),
        pulseHzV: $('pulseHzV'),
      };

      function syncVals(){
        vv.timeScaleV.textContent = (+ui.timeScale.value).toFixed(3);
        vv.tremorV.textContent   = (+ui.tremor.value).toFixed(2);
        vv.vortexV.textContent   = (+ui.vortex.value).toFixed(2);
        vv.densityV.textContent  = (+ui.density.value).toFixed(2);
        vv.traceV.textContent    = (+ui.trace.value).toFixed(3);
        vv.riseV.textContent     = (+ui.rise.value).toFixed(2);
        vv.releaseV.textContent  = (+ui.release.value).toFixed(2);
        vv.strictV.textContent   = (+ui.strict.value).toFixed(2);
        vv.breathV.textContent   = (+ui.breath.value).toFixed(2);
        vv.pulseHzV.textContent  = (+ui.pulseHz.value).toFixed(2);
      }
      Object.values(ui).forEach(el=>{
        if (!el || !el.addEventListener) return;
        el.addEventListener('input', syncVals);
        el.addEventListener('change', syncVals);
      });
      syncVals();

      function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
      function lerp(a,b,t){ return a + (b-a)*t; }
      function hash32(n){
        n = (n ^ (n >>> 16)) >>> 0;
        n = Math.imul(n, 2246822519) >>> 0;
        n = (n ^ (n >>> 13)) >>> 0;
        n = Math.imul(n, 3266489917) >>> 0;
        n = (n ^ (n >>> 16)) >>> 0;
        return n >>> 0;
      }
      function rnd01(n){ return hash32(n) / 4294967295; }

      const st = {
        t:0,
        invert:false,
        paused:false,
        seed:(Math.random()*1e9)|0,

        // stage transform
        ox:0, oy:0,
        wheel:0,
        zoom:1.0,

        // cursor / gestures
        mx:0, my:0,
        dragging:false,
        dragType:"pan", // "pan" or "cut"
        lastX:0, lastY:0,
        cutEnergy:0.0,
        stampEnergy:0.0,
        holding:false,
        holdTime:0.0,

        // ritual state
        pressure:0.12,     // 0..1
        violence:0.0,      // 0..1 (visual agitation)
        breathPhase:0.0,   // 0..tau
        edict:"",
        edictTimer:0,
        pulsePhase:0.0,    // phase for pulse
      };

      const tau = Math.PI*2;

      // Marks that persist briefly (stage scars)
      const scars = []; // {x,y,dx,dy,life,kind}
      function addScar(x,y,dx,dy,kind){
        scars.push({ x,y, dx,dy, life:1.0, kind });
        if (scars.length > 260) scars.shift();
      }

      // Edicts are short and procedural (Artaud, not poetry).
      const EDICTS = [
        "HOLD [SPACE] UNTIL THE STAGE STOPS RESISTING.",
        "CUT A CLEAN LINE. DO NOT HESITATE.",
        "STAMP THE CENTER. ACCEPT THE CONSEQUENCE.",
        "PAN AWAY FROM THE COMFORT ZONE. RETURN.",
        "CUT TWICE. THEN HOLD. THEN RELEASE.",
        "MAKE ONE DECISIVE GESTURE. NO DECORATION.",
        "LOWER TIME SCALE. WATCH WHAT YOU AVOID.",
        "RAISE STRICTNESS. EARN RELEASE.",
        "PULSE SAFE. BREATHE IN TIME. DO NOT RUSH.",
        "PURGE NOW. THEN RECAST."
      ];
      function newEdict(){
        const i = Math.floor(rnd01(st.seed + ((st.t*1000)|0) + scars.length*31) * EDICTS.length);
        st.edict = "EDICT: " + EDICTS[i];
        st.edictTimer = 3.6;
        $('edict').textContent = st.edict;
      }

      // Stage coords
      function stageToScreen(x,y){
        const S = Math.min(W,H) * 0.60 * st.zoom;
        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;
        return { x: cx + x*S, y: cy + y*S };
      }
      function screenToStage(sx,sy){
        const S = Math.min(W,H) * 0.60 * st.zoom;
        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;
        return { x: (sx-cx)/S, y: (sy-cy)/S };
      }

      // Ritual mechanics: pressure rises by default. You must perform to release it.
      function applyRitual(dt){
        const rise = +ui.rise.value;
        const rel = +ui.release.value;
        const strict = +ui.strict.value;
        const breath = +ui.breath.value;

        // base rise (pressure wants to climb)
        const riseRate = (0.02 + 0.085*rise) * (1 + 0.9*strict);
        st.pressure += riseRate * dt;

        // breath oscillation (a metronome you can obey or ignore)
        st.breathPhase += dt * (0.35 + 0.95*breath);
        if (st.breathPhase > tau) st.breathPhase -= tau;

        // holding = silence ritual; releases pressure if sustained
        if (st.holding){
          st.holdTime += dt;
          // strictness makes it harder to earn release quickly
          const earn = clamp((st.holdTime - (0.10 + 0.35*strict)) * (0.55 + 0.75*rel), 0, 1);
          st.pressure -= earn * dt * (0.22 + 0.35*rel);
          // silence calms violence
          st.violence = lerp(st.violence, 0.0, clamp(dt*(0.9 + 0.8*rel),0,1));
        } else {
          st.holdTime = Math.max(0, st.holdTime - dt*1.2);
        }

        // cutting releases pressure if the cut is decisive
        if (st.cutEnergy > 0){
          const cutThreshold = 0.18 + 0.32*strict;
          const cutPower = clamp((st.cutEnergy - cutThreshold) / (0.85 + 0.65*strict), 0, 1);
          st.pressure -= cutPower * dt * (0.28 + 0.55*rel);
          st.violence = clamp(st.violence + cutPower*0.9, 0, 1);
          st.cutEnergy *= Math.pow(0.02, dt*1.2);
        }

        // stamping (click) is a spike: it can reduce pressure if timed with breath, otherwise raises agitation
        if (st.stampEnergy > 0){
          const phase = st.breathPhase;
          const inWindow = (Math.abs(Math.sin(phase)) < 0.25); // “breath gate”
          if (inWindow){
            st.pressure -= st.stampEnergy * dt * (0.22 + 0.48*rel);
          } else {
            st.pressure += st.stampEnergy * dt * (0.05 + 0.10*strict);
            st.violence = clamp(st.violence + st.stampEnergy*0.35, 0, 1);
          }
          st.stampEnergy *= Math.pow(0.05, dt*1.5);
        }

        // clamp pressure
        st.pressure = clamp(st.pressure, 0, 1);

        // auto-edicts
        st.edictTimer -= dt;
        if (st.edictTimer <= 0) newEdict();

        // UI meter
        $('pFill').style.width = Math.round(st.pressure*100) + "%";
        $('statLine').textContent =
          `PRESSURE ${Math.round(st.pressure*100)}% · VIOLENCE ${Math.round(st.violence*100)}% · SCARS ${scars.length} · ZOOM ${st.zoom.toFixed(2)}`;

        // if pressure hits max: forced rupture (visual) until you perform
        if (st.pressure > 0.985){
          st.violence = clamp(st.violence + dt*0.9, 0, 1);
        } else {
          // decay violence slightly over time if pressure is controlled
          st.violence *= Math.pow(0.12, dt*0.25);
        }
      }

      function draw(){
        const inv = st.invert;
        const bg = inv ? 255 : 0;
        const fg = inv ? 0 : 255;

        const trace = +ui.trace.value;
        if (trace > 0){
          ctx.fillStyle = `rgba(${bg},${bg},${bg},${clamp(trace,0,1)})`;
          ctx.fillRect(0,0,W,H);
        } else {
          ctx.fillStyle = `rgb(${bg},${bg},${bg})`;
          ctx.fillRect(0,0,W,H);
        }

        // In invert mode: keep source-over so lines truly become black.
        ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';

        const tremor = +ui.tremor.value;
        const vortex = +ui.vortex.value;
        const density = +ui.density.value;

        // pulse: safe by default (<= 3Hz); fast pulse is opt-in
        const safeHz = +ui.pulseHz.value;
        const fastEnabled = ui.T_fastPulse.checked;
        const pulseEnabled = ui.T_safePulse.checked || fastEnabled;

        // if fast pulse is enabled, allow up to 12Hz (unsafe); otherwise cap at safeHz
        const hz = fastEnabled ? 12.0 : safeHz;

        let pulse = 0.0;
        if (pulseEnabled && hz > 0){
          // sine pulse, never a full-screen hard strobe unless fast is enabled
          pulse = 0.5 + 0.5*Math.sin(st.pulsePhase);
        }

        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;
        const S  = Math.min(W,H) * 0.60 * st.zoom;

        // tremor offset
        const shake = (0.5 + 0.9*st.violence) * tremor;
        const sx = (Math.sin(st.t*17.0) * 0.9 + Math.sin(st.t*9.0+1.3)*0.6) * 0.9 * shake;
        const sy = (Math.cos(st.t*15.0) * 0.9 + Math.cos(st.t*8.0+2.1)*0.6) * 0.9 * shake;

        // “stage skin”: wireframe torus-like vignette
        if (ui.T_wire.checked){
          const lines = Math.floor(lerp(70, 170, clamp(density/2.4,0,1)));
          const a0 = 0.018 + 0.06*(0.3 + st.violence);
          ctx.lineWidth = 1.1;

          for (let i=0;i<lines;i++){
            const r1 = rnd01(st.seed + i*31);
            const r2 = rnd01(st.seed + i*79);
            const ang = (r1*tau) + st.t*(0.12 + 0.55*vortex);
            const rad = (0.15 + 0.85*Math.sqrt(r2)) * (0.85 + 0.12*Math.sin(st.t*0.7+i));
            const wob = (0.04 + 0.14*st.violence) * (0.4 + 0.6*Math.sin(st.t*0.8+i));
            const x = Math.cos(ang) * (rad + wob*Math.sin(st.t*1.5+i*0.7));
            const y = Math.sin(ang) * (rad + wob*Math.cos(st.t*1.3+i*0.6));

            const p = stageToScreen(x,y);
            const len = (18 + 58*st.pressure) * (0.6 + 0.65*rad);

            const dx = Math.cos(ang + Math.PI/2) * len;
            const dy = Math.sin(ang + Math.PI/2) * len;

            const a = clamp(a0 + 0.06*pulse + 0.10*(1-rad), 0, fastEnabled ? 0.45 : 0.30);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
            ctx.beginPath();
            ctx.moveTo(p.x + sx - dx*0.5, p.y + sy - dy*0.5);
            ctx.lineTo(p.x + sx + dx*0.5, p.y + sy + dy*0.5);
            ctx.stroke();
          }
        }

        // ritual ring (constriction)
        if (ui.T_ring.checked){
          const rBase = Math.min(W,H) * 0.34 * (0.88 + 0.16*Math.sin(st.t*0.5));
          const constrict = lerp(1.05, 0.62, st.pressure); // pressure tightens
          const r = rBase * constrict;

          const a = clamp(0.08 + 0.18*st.pressure + 0.10*pulse, 0, fastEnabled ? 0.65 : 0.45);
          ctx.lineWidth = 1.4;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
          ctx.beginPath();
          ctx.arc(cx+sx, cy+sy, r, 0, tau);
          ctx.stroke();

          // breath gate mark
          const phase = st.breathPhase;
          const gx = (cx+sx) + Math.cos(phase) * r;
          const gy = (cy+sy) + Math.sin(phase) * r;
          ctx.lineWidth = 2.0;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(0.10 + 0.22*(1-Math.abs(Math.sin(phase))) + 0.18*pulse,0,0.55)})`;
          ctx.beginPath();
          ctx.arc(gx, gy, 10 + 10*(1-Math.abs(Math.sin(phase))), 0, tau);
          ctx.stroke();
        }

        // scars (cuts + stamps)
        ctx.lineWidth = 1.4;
        for (let i=scars.length-1;i>=0;i--){
          const s = scars[i];
          s.life -= (0.25 + 0.55*st.pressure) * (1/60);
          if (s.life <= 0){ scars.splice(i,1); continue; }

          const a = clamp(0.06 + 0.26*s.life + 0.10*st.violence, 0, fastEnabled ? 0.75 : 0.55);
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;

          const p1 = stageToScreen(s.x - s.dx*0.5, s.y - s.dy*0.5);
          const p2 = stageToScreen(s.x + s.dx*0.5, s.y + s.dy*0.5);

          if (s.kind === "cut"){
            ctx.beginPath();
            ctx.moveTo(p1.x+sx, p1.y+sy);
            ctx.lineTo(p2.x+sx, p2.y+sy);
            ctx.stroke();
          } else {
            // stamp: cross
            ctx.beginPath();
            ctx.moveTo(p1.x+sx, p1.y+sy);
            ctx.lineTo(p2.x+sx, p2.y+sy);
            ctx.moveTo(p1.x+sx, p2.y+sy);
            ctx.lineTo(p2.x+sx, p1.y+sy);
            ctx.stroke();
          }
        }

        // center “throat” marker (where it hurts)
        const throatA = clamp(0.10 + 0.26*st.pressure + 0.18*pulse, 0, fastEnabled ? 0.80 : 0.60);
        ctx.lineWidth = 1.6;
        ctx.strokeStyle = `rgba(${fg},${fg},${fg},${throatA})`;
        ctx.beginPath();
        ctx.arc(cx+sx, cy+sy, 8 + 18*st.pressure, 0, tau);
        ctx.stroke();

        // “rupture wash” when pressure maxes (not a rapid strobe; it’s a slow crush)
        if (st.pressure > 0.92){
          ctx.globalCompositeOperation = 'source-over';
          const k = clamp((st.pressure - 0.92)/0.08, 0, 1);
          const alpha = (fastEnabled ? 0.28 : 0.18) * k;
          ctx.fillStyle = inv ? `rgba(0,0,0,${alpha})` : `rgba(255,255,255,${alpha})`;
          ctx.fillRect(0,0,W,H);
          ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';
        }

        ctx.globalCompositeOperation = 'source-over';
      }

      // Interaction
      $('invert').onclick = ()=> st.invert = !st.invert;
      $('pause').onclick = ()=> st.paused = !st.paused;

      $('purge').onclick = ()=>{
        // purge = remove scars + reduce violence + partial pressure drop
        scars.length = 0;
        st.violence = 0;
        st.pressure = Math.max(0.10, st.pressure * 0.55);
        st.cutEnergy = 0;
        st.stampEnergy = 0;
        newEdict();
      };

      $('recast').onclick = ()=>{
        // recast = keep controls, reseed aesthetic + edict
        st.seed = (Math.random()*1e9)|0;
        scars.length = 0;
        st.cutEnergy = 0;
        st.stampEnergy = 0;
        st.violence = 0;
        st.pressure = 0.12;
        newEdict();
      };

      $('reset').onclick = ()=>{
        st.t=0; st.invert=false; st.paused=false; st.ox=0; st.oy=0; st.wheel=0; st.zoom=1.0;
        st.pressure=0.12; st.violence=0; st.breathPhase=0; st.pulsePhase=0;
        st.cutEnergy=0; st.stampEnergy=0; st.holding=false; st.holdTime=0;
        scars.length = 0;

        ui.timeScale.value=0.30;
        ui.tremor.value=0.85;
        ui.vortex.value=1.15;
        ui.density.value=1.30;
        ui.trace.value=0.055;
        ui.rise.value=0.85;
        ui.release.value=1.15;
        ui.strict.value=0.65;
        ui.breath.value=0.95;
        ui.pulseHz.value=1.20;
        ui.T_ring.checked=true;
        ui.T_wire.checked=true;
        ui.T_text.checked=true;
        ui.T_safePulse.checked=true;
        ui.T_fastPulse.checked=false;

        syncVals();
        $('recast').click();
      };

      addEventListener('keydown', (e)=>{
        if (e.key==='i' || e.key==='I') st.invert = !st.invert;
        if (e.key==='p' || e.key==='P') st.paused = !st.paused;
        if (e.key==='h' || e.key==='H'){
          const panel = document.getElementById('panel');
          panel.style.display = (panel.style.display === 'none') ? '' : 'none';
        }
        if (e.code === 'Space'){
          e.preventDefault();
          st.holding = true;
        }
      });
      addEventListener('keyup', (e)=>{
        if (e.code === 'Space'){
          st.holding = false;
        }
      });

      addEventListener('wheel', (e)=>{
        const d = Math.max(-160, Math.min(160, e.deltaY));
        st.wheel += (-d/160) * 0.18;
        st.wheel = clamp(st.wheel, -0.85, 0.95);
      }, { passive:true });

      function insideCenter(sx,sy){
        const p = screenToStage(sx,sy);
        const r = Math.sqrt(p.x*p.x + p.y*p.y);
        return r < 0.22;
      }

      addEventListener('pointerdown', (e)=>{
        st.mx=e.clientX; st.my=e.clientY;
        st.dragging=true;
        st.lastX=e.clientX; st.lastY=e.clientY;

        // if near center: interpret as CUT, else PAN unless shift held
        if (insideCenter(e.clientX, e.clientY) || e.shiftKey){
          st.dragType = "cut";
        } else {
          st.dragType = "pan";
        }

        // click = stamp
        const p = screenToStage(e.clientX, e.clientY);
        addScar(p.x, p.y, 0.10, 0.10, "stamp");
        st.stampEnergy = clamp(st.stampEnergy + 0.9, 0, 2.0);
      });

      addEventListener('pointerup', ()=>{
        st.dragging=false;
        st.dragType="pan";
      });
      addEventListener('pointercancel', ()=>{
        st.dragging=false;
        st.dragType="pan";
      });

      addEventListener('pointermove', (e)=>{
        st.mx=e.clientX; st.my=e.clientY;

        if (!st.dragging) return;
        const dx = e.clientX - st.lastX;
        const dy = e.clientY - st.lastY;
        st.lastX = e.clientX; st.lastY = e.clientY;

        if (st.dragType === "pan"){
          st.ox += dx;
          st.oy += dy;
          st.ox = clamp(st.ox, -W*0.60, W*0.60);
          st.oy = clamp(st.oy, -H*0.60, H*0.60);
        } else {
          // CUT: record decisive movement in stage coords
          const p1 = screenToStage(e.clientX - dx, e.clientY - dy);
          const p2 = screenToStage(e.clientX, e.clientY);
          const cdx = (p2.x - p1.x);
          const cdy = (p2.y - p1.y);
          const len = Math.sqrt(cdx*cdx + cdy*cdy);

          if (len > 0.001){
            addScar((p1.x+p2.x)*0.5, (p1.y+p2.y)*0.5, cdx*3.2, cdy*3.2, "cut");
            // cut energy accumulates from speed and strictness demand
            const strict = +ui.strict.value;
            const gain = clamp(len * (2.2 + 1.4*strict), 0, 0.45);
            st.cutEnergy = clamp(st.cutEnergy + gain, 0, 2.5);
          }
        }
      });

      // Loop
      function tick(now){
        // basic dt
        if (!tick.last) tick.last = now;
        const rawDt = Math.min(0.033, (now - tick.last)/1000);
        tick.last = now;

        // zoom smoothing
        st.wheel *= 0.88;
        st.zoom += st.wheel;
        st.zoom = clamp(st.zoom, 0.55, 2.60);

        const dt = rawDt * (+ui.timeScale.value) * (0.55 + 0.55*(+ui.density.value));
        if (!st.paused){
          st.t += dt;

          // pulse phase
          const hz = ui.T_fastPulse.checked ? 12.0 : (+ui.pulseHz.value);
          if ((ui.T_safePulse.checked || ui.T_fastPulse.checked) && hz > 0){
            st.pulsePhase += dt * tau * hz;
            if (st.pulsePhase > 1e9) st.pulsePhase = st.pulsePhase % tau;
          }

          applyRitual(dt);

          // nudge edict changes when user performs well
          if (st.pressure < 0.18 && rnd01(st.seed + ((st.t*1000)|0) + scars.length*19) < 0.01){
            newEdict();
          }
        }

        draw();
        requestAnimationFrame(tick);
      }

      // Init
      newEdict();
      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>
