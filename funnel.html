<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA — ENDLESS FUNNEL (FIXED)</title>
  <style>
    :root{
      --bg:#000;
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.55);
      --hair:rgba(255,255,255,.18);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family: Arial, Helvetica, sans-serif;
      overflow:hidden;
    }
    #stage{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      display:block;
    }

    .hud{
      position:fixed;
      left:24px; top:18px;
      user-select:none;
      mix-blend-mode:screen;
      pointer-events:none;
    }
    .brand{
      letter-spacing:.18em;
      font-weight:800;
      font-size:18px;
      text-transform:uppercase;
      text-shadow: 0 0 18px rgba(255,255,255,.18);
    }
    .sub{
      margin-top:4px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:var(--muted);
    }

    .dock{
      position:fixed;
      left:24px; bottom:20px;
      display:flex; gap:10px;
      pointer-events:auto;
    }
    .btn{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.20);
      color:rgba(255,255,255,.88);
      padding:10px 12px;
      border-radius:10px;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{
      background:rgba(255,255,255,.10);
      border-color:rgba(255,255,255,.34);
      transform: translateY(-1px);
    }

    .panel{
      position:fixed;
      right:22px; top:18px;
      width:min(420px, calc(100vw - 44px));
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.46);
      backdrop-filter: blur(10px);
      border-radius:16px;
      overflow:hidden;
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset, 0 16px 50px rgba(0,0,0,.65);
    }
    .panelHeader{
      display:flex; justify-content:space-between; align-items:center;
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,.12);
    }
    .panelHeader .title{
      font-weight:800;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
    }
    .panelBody{ padding:12px 14px 14px; display:flex; flex-direction:column; gap:10px; }
    .row{ display:grid; grid-template-columns: 130px 1fr 54px; gap:10px; align-items:center; }
    .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:rgba(255,255,255,.62);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    input[type="range"]{ width:100%; accent-color: rgba(255,255,255,.92); }
    .val{
      font-variant-numeric: tabular-nums;
      font-size:11px;
      letter-spacing:.06em;
      color:rgba(255,255,255,.75);
      text-align:right;
    }
    .mini{
      font-size:11px;
      color:rgba(255,255,255,.55);
      line-height:1.35;
      letter-spacing:.02em;
      margin-top:4px;
    }

    #err{
      position:fixed;
      left:50%; top:12px;
      transform:translateX(-50%);
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.22);
      background:rgba(0,0,0,.72);
      border-radius:12px;
      font-size:12px;
      letter-spacing:.06em;
      color:rgba(255,255,255,.85);
      display:none;
      max-width:min(680px, calc(100vw - 24px));
      white-space:pre-wrap;
    }
  </style>
</head>
<body>
  <canvas id="stage"></canvas>

  <div class="hud">
    <div class="brand">KETADATA</div>
    <div class="sub">ENDLESS FUNNEL INTERFACE (LIVE)</div>
  </div>

  <div class="dock">
    <button class="btn" id="btnPulse">PULSE</button>
    <button class="btn" id="btnInvert">INVERT</button>
    <button class="btn" id="btnReset">RESET</button>
  </div>

  <div class="panel">
    <div class="panelHeader">
      <div class="title">FUNNEL PARAMETERS</div>
      <div style="font-size:11px; color:rgba(255,255,255,.55)">SCROLL = THRUST · DRAG = STEER · SPACE = PULSE</div>
    </div>
    <div class="panelBody">
      <div class="row">
        <div class="label">speed</div>
        <input id="speed" type="range" min="0.2" max="4" step="0.01" value="1.55" />
        <div class="val" id="speedV">1.55</div>
      </div>
      <div class="row">
        <div class="label">depth</div>
        <input id="depth" type="range" min="24" max="180" step="1" value="110" />
        <div class="val" id="depthV">110</div>
      </div>
      <div class="row">
        <div class="label">contrast</div>
        <input id="contrast" type="range" min="0.6" max="2.6" step="0.01" value="1.65" />
        <div class="val" id="contrastV">1.65</div>
      </div>
      <div class="row">
        <div class="label">jitter</div>
        <input id="jitter" type="range" min="0" max="1" step="0.01" value="0.30" />
        <div class="val" id="jitterV">0.30</div>
      </div>
      <div class="row">
        <div class="label">strobe</div>
        <input id="strobe" type="range" min="0" max="1" step="0.01" value="0.18" />
        <div class="val" id="strobeV">0.18</div>
      </div>
      <div class="mini">
        If you still see pure black: open DevTools Console and you’ll see the error banner text.
      </div>
    </div>
  </div>

  <div id="err"></div>

  <script>
    (() => {
      const err = (msg) => {
        const el = document.getElementById('err');
        el.style.display = 'block';
        el.textContent = msg;
      };

      const canvas = document.getElementById('stage');
      const ctx = canvas.getContext('2d');
      if (!ctx) { err('Canvas 2D context failed. Your browser is blocking or unsupported.'); return; }

      const $ = (id) => document.getElementById(id);

      const ui = {
        speed: $('speed'), depth: $('depth'), contrast: $('contrast'),
        jitter: $('jitter'), strobe: $('strobe'),
        speedV: $('speedV'), depthV: $('depthV'), contrastV: $('contrastV'),
        jitterV: $('jitterV'), strobeV: $('strobeV')
      };

      function syncUI(){
        ui.speedV.textContent = (+ui.speed.value).toFixed(2);
        ui.depthV.textContent = ui.depth.value;
        ui.contrastV.textContent = (+ui.contrast.value).toFixed(2);
        ui.jitterV.textContent = (+ui.jitter.value).toFixed(2);
        ui.strobeV.textContent = (+ui.strobe.value).toFixed(2);
      }
      Object.values(ui).forEach(v => (v && v.tagName === 'INPUT') ? v.addEventListener('input', syncUI) : null);
      syncUI();

      let W=0,H=0,DPR=Math.min(2, window.devicePixelRatio||1);
      function resize(){
        W = innerWidth; H = innerHeight;
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize);
      resize();

      const state = {
        t: 0,
        invert: false,
        thrust: 0.55,      // AUTO MOTION so it’s never “still black”
        wheel: 0,
        steerX: 0,
        steerY: 0,
        pulse: 0,
        drag:false,
        lastX:0,lastY:0
      };

      const btnPulse = $('btnPulse');
      const btnInvert = $('btnInvert');
      const btnReset = $('btnReset');

      btnPulse.onclick = () => state.pulse = Math.min(1, state.pulse + 0.95);
      btnInvert.onclick = () => state.invert = !state.invert;
      btnReset.onclick = () => { state.t=0; state.thrust=0.55; state.wheel=0; state.steerX=0; state.steerY=0; state.pulse=0; state.invert=false; };

      addEventListener('wheel', (e) => {
        const d = Math.max(-160, Math.min(160, e.deltaY));
        state.wheel += (-d / 160) * 0.55;
        state.wheel = clamp(state.wheel, -1.2, 3.0);
      }, { passive:true });

      addEventListener('keydown', (e) => {
        if (e.code === 'Space'){ e.preventDefault(); state.pulse = Math.min(1, state.pulse + 0.95); }
        if (e.key === 'i' || e.key === 'I') state.invert = !state.invert;
        if (e.key === 'r' || e.key === 'R') btnReset.click();
      });

      addEventListener('pointerdown', (e)=>{ state.drag=true; state.lastX=e.clientX; state.lastY=e.clientY; });
      addEventListener('pointerup', ()=> state.drag=false);
      addEventListener('pointercancel', ()=> state.drag=false);
      addEventListener('pointermove', (e)=>{
        const cx=W*0.5, cy=H*0.5;
        if (state.drag){
          const dx=e.clientX-state.lastX, dy=e.clientY-state.lastY;
          state.lastX=e.clientX; state.lastY=e.clientY;
          state.steerX += dx * 0.0022;
          state.steerY += dy * 0.0022;
        } else {
          state.steerX += ((e.clientX - cx)/cx) * 0.0018;
          state.steerY += ((e.clientY - cy)/cy) * 0.0018;
        }
        state.steerX = clamp(state.steerX, -1.6, 1.6);
        state.steerY = clamp(state.steerY, -1.6, 1.6);
      });

      let last = performance.now();
      function tick(now){
        const dt = Math.min(0.033, (now-last)/1000);
        last = now;

        // dynamics
        state.wheel *= 0.90;
        state.thrust += state.wheel * 0.35;
        state.thrust *= 0.965;
        state.thrust = clamp(state.thrust, 0.12, 3.2);

        state.pulse *= 0.90;
        if (state.pulse < 0.0008) state.pulse = 0;

        const speed = +ui.speed.value;
        state.t += dt * (0.65 + speed * 1.15) * (1 + state.thrust * 0.85);

        render();

        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);

      function render(){
        const inv = state.invert;
        const bg = inv ? 255 : 0;
        const fg = inv ? 0 : 255;

        const depth = +ui.depth.value;
        const contrast = +ui.contrast.value;
        const jitter = +ui.jitter.value;
        const strobe = +ui.strobe.value;

        // background
        ctx.fillStyle = `rgb(${bg},${bg},${bg})`;
        ctx.fillRect(0,0,W,H);

        const cx=W*0.5, cy=H*0.5;

        // strobe/exposure
        const stro = strobe * (0.5 + 0.5*Math.sin(state.t*11.0));
        const exposure = (1.05 + stro*0.85 + state.pulse*0.70) * contrast;

        // drift
        const driftX = state.steerX * 140;
        const driftY = state.steerY * 140;

        // scanlines (visible)
        ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.08*contrast})`;
        ctx.lineWidth = 1;
        const step = 7;
        const yOff = (state.t*75) % step;
        for (let y=-step; y<H+step; y+=step){
          ctx.beginPath();
          ctx.moveTo(0, y+yOff);
          ctx.lineTo(W, y+yOff);
          ctx.stroke();
        }

        ctx.save();
        ctx.translate(cx+driftX, cy+driftY);
        ctx.globalCompositeOperation = 'lighter';

        const maxR = Math.min(W,H) * 0.70;
        const minR = 10;

        // rings
        for (let i=0; i<depth; i++){
          const z = i / depth;            // 0 far, 1 near
          const k = Math.pow(z, 2.1);     // non-linear perspective
          const r = lerp(maxR, minR, k);

          const wobX = (noise1(i*0.17 + state.t*0.9)*2-1) * jitter * (10 + 30*k) + state.pulse * (noise1(i*0.31 + state.t*2.2)*2-1) * 22;
          const wobY = (noise1(i*0.19 + state.t*1.1)*2-1) * jitter * (10 + 30*k) + state.pulse * (noise1(i*0.29 + state.t*2.4)*2-1) * 22;

          const rot = state.t*0.14 + i*0.018 + state.steerX*0.28 - state.steerY*0.20;

          const a = clamp((0.18 + (1-k)*0.55) * exposure, 0, 1);
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
          ctx.lineWidth = 1.4 + (1-k)*2.1 + state.pulse*2.0;

          ctx.save();
          ctx.rotate(rot);
          ctx.translate(wobX, wobY);

          // superellipse ring (diamond-ish, system-ish)
          drawSuperellipse(ctx, 0, 0, r, r, 2.7);

          // ribs
          const ribs = 10;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(a*0.55,0,1)})`;
          ctx.lineWidth = Math.max(1, (1.2 + (1-k)*1.2));
          for (let j=0;j<ribs;j++){
            const ang = (Math.PI*2/ribs)*j + rot*0.6;
            ctx.beginPath();
            ctx.moveTo(Math.cos(ang)*r*0.18, Math.sin(ang)*r*0.18);
            ctx.lineTo(Math.cos(ang)*r*0.98, Math.sin(ang)*r*0.98);
            ctx.stroke();
          }

          ctx.restore();
        }

        ctx.restore();
        ctx.globalCompositeOperation = 'source-over';

        // mouth / sink (always visible)
        const mouthR = 14 + state.pulse*16;
        const g = ctx.createRadialGradient(cx+driftX, cy+driftY, 0, cx+driftX, cy+driftY, mouthR*10);
        g.addColorStop(0, `rgba(${fg},${fg},${fg},${clamp(0.55*exposure,0,1)})`);
        g.addColorStop(1, `rgba(${fg},${fg},${fg},0)`);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(cx+driftX, cy+driftY, mouthR*10, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(0.75*exposure,0,1)})`;
        ctx.lineWidth = 2.2;
        ctx.beginPath();
        ctx.arc(cx+driftX, cy+driftY, mouthR*1.8, 0, Math.PI*2);
        ctx.stroke();
      }

      function drawSuperellipse(ctx, x, y, rx, ry, n){
        const steps = 180;
        ctx.beginPath();
        for (let i=0;i<=steps;i++){
          const t = (i/steps) * Math.PI*2;
          const ct = Math.cos(t), st = Math.sin(t);
          const px = x + Math.sign(ct) * Math.pow(Math.abs(ct), 2/n) * rx;
          const py = y + Math.sign(st) * Math.pow(Math.abs(st), 2/n) * ry;
          if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.closePath();
        ctx.stroke();
      }

      function noise1(x){
        const s = Math.sin(x*12.9898) * 43758.5453;
        return s - Math.floor(s);
      }

      function lerp(a,b,t){ return a + (b-a)*t; }
      function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    })();
  </script>
</body>
</html>
