<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KETADATA WALL</title>
  <style>
    :root{
      --bg:#000;
      --ink:rgba(255,255,255,.86);
      --muted:rgba(255,255,255,.45);
      --line:rgba(255,255,255,.12);
      --gap:10px;
      --ui:#000;
      --uiLine:rgba(255,255,255,.16);
      --uiFill:rgba(255,255,255,.06);
      --mono: ui-sans-serif, system-ui, -apple-system, Arial, Helvetica, sans-serif;
    }
    *{ box-sizing:border-box; font-family:var(--mono); }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      overflow:hidden;
    }

    /* Top control rail (minimal, collapsible) */
    .top{
      position:fixed;
      top:0; left:0; right:0;
      z-index:50;
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background:rgba(0,0,0,.92);
      backdrop-filter: blur(6px);
    }
    .brand{
      font-size:12px;
      letter-spacing:2px;
      text-transform:uppercase;
      color:var(--muted);
      white-space:nowrap;
    }
    .controls{
      display:flex;
      align-items:center;
      gap:10px;
      flex:1;
      flex-wrap:wrap;
    }
    label{
      font-size:11px;
      letter-spacing:1px;
      text-transform:uppercase;
      color:var(--muted);
    }
    select, input[type="range"], button{
      background:var(--ui);
      border:1px solid var(--uiLine);
      color:var(--ink);
      padding:7px 9px;
      border-radius:0;
      outline:none;
      font-size:12px;
    }
    button{
      cursor:pointer;
      background:rgba(255,255,255,.02);
    }
    button:hover{ border-color:rgba(255,255,255,.32); }
    .sep{ width:1px; height:26px; background:var(--line); }

    .rangeWrap{
      display:flex; align-items:center; gap:8px;
    }
    input[type="range"]{
      padding:0;
      height:26px;
      width:140px;
      background:transparent;
      border:1px solid var(--uiLine);
    }

    /* Grid */
    .stage{
      position:absolute;
      top:52px; left:0; right:0; bottom:0;
      padding:var(--gap);
    }
    .grid{
      width:100%;
      height:100%;
      display:grid;
      gap:var(--gap);
      align-content:stretch;
      justify-content:stretch;
    }

    /* Tile */
    .tile{
      position:relative;
      background:#000;
      border:1px solid var(--line);
      border-radius:0;
      overflow:hidden;
      min-height:120px;
    }
    .screen{
      position:absolute;
      inset:0;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
      background:#000;
    }

    /* YouTube iframe */
    .screen iframe{
      width:100%;
      height:100%;
      border:0;
      display:block;
      background:#000;
    }

    /* Visual processing layer */
    .fx{
      pointer-events:none;
      position:absolute;
      inset:0;
      opacity:1;
      mix-blend-mode:normal;
      /* we will apply CSS filter dynamically */
    }
    /* very subtle noise, non-theatrical */
    .fx::before{
      content:"";
      position:absolute; inset:0;
      opacity:0; /* controlled by grain */
      background-image:
        radial-gradient(rgba(255,255,255,.06) 1px, transparent 1px),
        radial-gradient(rgba(255,255,255,.04) 1px, transparent 1px);
      background-size: 26px 26px, 34px 34px;
      background-position: 0 0, 7px 11px;
      mix-blend-mode: overlay;
    }
    .fx::after{
      content:"";
      position:absolute; inset:0;
      opacity:0; /* controlled by exposure */
      background: rgba(0,0,0,.0);
      mix-blend-mode: multiply;
    }

    /* Per-tile controls: hidden until hover/focus */
    .hud{
      position:absolute;
      left:0; right:0; bottom:0;
      padding:10px;
      background:linear-gradient(0deg, rgba(0,0,0,.88), rgba(0,0,0,0));
      opacity:0;
      transition:opacity .15s linear;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .tile:hover .hud, .tile:focus-within .hud{ opacity:1; }

    .hudTop{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .cam{
      font-size:11px;
      letter-spacing:2px;
      text-transform:uppercase;
      color:var(--muted);
      border:1px solid var(--uiLine);
      padding:6px 8px;
      white-space:nowrap;
    }
    .url{
      flex:1;
      width:100%;
      background:rgba(0,0,0,.0);
      border:1px solid var(--uiLine);
      padding:7px 9px;
      color:var(--ink);
      font-size:12px;
      border-radius:0;
      outline:none;
    }
    .hudGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .ctrl{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:8px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.02);
    }
    .ctrl .row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .val{
      font-size:11px;
      color:var(--muted);
      letter-spacing:1px;
      text-transform:uppercase;
      white-space:nowrap;
    }
    .ctrl input[type="range"]{ width:100%; }

    /* Focus outline minimal */
    .tile:focus-within{ outline:1px solid rgba(255,255,255,.22); outline-offset:0; }

    /* Small screens: stack */
    @media (max-width: 760px){
      .stage{ top:98px; }
      .hudGrid{ grid-template-columns: 1fr; }
      input[type="range"]{ width:160px; }
    }
  </style>
</head>

<body>
  <div class="top">
    <div class="brand">KETADATA WALL</div>

    <div class="controls">
      <div class="rangeWrap">
        <label for="count">Screens</label>
        <select id="count"></select>
      </div>

      <div class="rangeWrap">
        <label for="gap">Gap</label>
        <input id="gap" type="range" min="0" max="24" step="1" value="10" />
      </div>

      <div class="sep"></div>

      <div class="rangeWrap">
        <label for="duck">Duck</label>
        <input id="duck" type="range" min="0" max="90" step="1" value="55" />
      </div>

      <button id="muteAll">Mute All</button>
      <button id="bgAll">Background All</button>
      <button id="save">Save</button>
      <button id="load">Load</button>
      <button id="clear">Clear</button>
    </div>
  </div>

  <div class="stage">
    <div id="grid" class="grid"></div>
  </div>

  <!-- YouTube IFrame API -->
  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    /*
      KETADATA WALL — minimal CCTV logic
      - 1–12 screens
      - per-tile video load, volume, and visual processing controls
      - "Promote" via Shift+Click on a tile (foreground); others auto-duck
      - no kitsch overlays (no timestamps/REC/scanlines)
    */

    const STORAGE_KEY = "ketadata_wall_v1";

    const gridEl = document.getElementById("grid");
    const countEl = document.getElementById("count");
    const gapEl = document.getElementById("gap");
    const duckEl = document.getElementById("duck");
    const muteAllBtn = document.getElementById("muteAll");
    const bgAllBtn = document.getElementById("bgAll");
    const saveBtn = document.getElementById("save");
    const loadBtn = document.getElementById("load");
    const clearBtn = document.getElementById("clear");

    // populate count selector 1..12
    for(let i=1;i<=12;i++){
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = String(i);
      countEl.appendChild(opt);
    }
    countEl.value = "9";

    // runtime state
    let playersReady = false;
    let players = [];     // { player, tileId, videoId, vol, look, promoted }
    let promotedIndex = null;

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function bestGrid(n){
      // choose cols/rows to minimize empty space and keep near-square
      let best = { cols:1, rows:n, score:Infinity };
      for(let cols=1; cols<=4; cols++){
        const rows = Math.ceil(n / cols);
        // prefer cols >= rows for wide screens, but not mandatory
        const aspectBias = Math.abs(cols - rows) * 0.6;
        const empties = (cols * rows) - n;
        const score = (empties * 2.2) + aspectBias + Math.abs(cols/rows - 1) * 0.9;
        if(score < best.score) best = { cols, rows, score };
      }
      return best;
    }

    function setGrid(n){
      const { cols } = bestGrid(n);
      gridEl.style.gridTemplateColumns = `repeat(${cols}, minmax(0, 1fr))`;
    }

    function parseYouTubeId(input){
      if(!input) return null;
      const s = input.trim();
      if(/^[a-zA-Z0-9_-]{11}$/.test(s)) return s;

      try{
        const url = new URL(s);
        if(url.hostname.includes("youtu.be")){
          const id = url.pathname.replace("/","").trim();
          if(/^[a-zA-Z0-9_-]{11}$/.test(id)) return id;
        }
        if(url.searchParams.get("v")){
          const id = url.searchParams.get("v").trim();
          if(/^[a-zA-Z0-9_-]{11}$/.test(id)) return id;
        }
        const em = url.pathname.match(/\/embed\/([a-zA-Z0-9_-]{11})/);
        if(em) return em[1];
        const sh = url.pathname.match(/\/shorts\/([a-zA-Z0-9_-]{11})/);
        if(sh) return sh[1];
      } catch(e){}
      return null;
    }

    function mkTile(index){
      const tile = document.createElement("div");
      tile.className = "tile";
      tile.dataset.index = String(index);

      const tileId = `tile_${index}`;
      const camLabel = `CH ${String(index+1).padStart(2, "0")}`;

      tile.innerHTML = `
        <div class="screen">
          <div id="${tileId}" style="width:100%;height:100%;"></div>
          <div class="fx"></div>
        </div>

        <div class="hud">
          <div class="hudTop">
            <div class="cam">${camLabel}</div>
            <input class="url" placeholder="YOUTUBE URL OR ID" />
            <button class="loadBtn">LOAD</button>
            <button class="promoteBtn">PROMOTE</button>
          </div>

          <div class="hudGrid">
            <div class="ctrl">
              <div class="row"><label>Gain</label><div class="val" data-val="gain">0%</div></div>
              <input class="gain" type="range" min="0" max="100" step="1" value="0" />
              <div class="row">
                <button class="muteBtn">MUTE</button>
                <button class="bgBtn">BACKGROUND</button>
              </div>
            </div>

            <div class="ctrl">
              <div class="row"><label>Look</label><div class="val" data-val="look">NEUTRAL</div></div>
              <div class="row"><span class="val">DESAT</span><span class="val" data-val="desat">60%</span></div>
              <input class="desat" type="range" min="0" max="100" step="1" value="60" />

              <div class="row"><span class="val">BLUR</span><span class="val" data-val="blur">0.0</span></div>
              <input class="blur" type="range" min="0" max="10" step="0.1" value="0" />

              <div class="row"><span class="val">EXPOSURE</span><span class="val" data-val="exp">0%</span></div>
              <input class="exp" type="range" min="-40" max="40" step="1" value="0" />

              <div class="row"><span class="val">GRAIN</span><span class="val" data-val="grain">0%</span></div>
              <input class="grain" type="range" min="0" max="30" step="1" value="0" />
            </div>
          </div>
        </div>
      `;

      // Shift+Click to promote (fast operator gesture)
      tile.addEventListener("click", (e)=>{
        if(e.shiftKey){
          promote(index);
        }
      });

      // Wire controls
      const urlEl = tile.querySelector(".url");
      const loadBtn = tile.querySelector(".loadBtn");
      const promoteBtn = tile.querySelector(".promoteBtn");
      const gainEl = tile.querySelector(".gain");
      const desatEl = tile.querySelector(".desat");
      const blurEl = tile.querySelector(".blur");
      const expEl = tile.querySelector(".exp");
      const grainEl = tile.querySelector(".grain");
      const muteBtn = tile.querySelector(".muteBtn");
      const bgBtn = tile.querySelector(".bgBtn");

      const valGain = tile.querySelector('[data-val="gain"]');
      const valDesat = tile.querySelector('[data-val="desat"]');
      const valBlur = tile.querySelector('[data-val="blur"]');
      const valExp = tile.querySelector('[data-val="exp"]');
      const valGrain = tile.querySelector('[data-val="grain"]');
      const valLook = tile.querySelector('[data-val="look"]');

      function updateLookLabel(){
        const d = Number(desatEl.value);
        const b = Number(blurEl.value);
        const ex = Number(expEl.value);
        const g = Number(grainEl.value);
        // minimal heuristic label
        if(b > 2.5) valLook.textContent = "PERIPHERAL";
        else if(d > 70 && g < 5) valLook.textContent = "CLINICAL";
        else if(ex < -12) valLook.textContent = "DIM";
        else if(ex > 12) valLook.textContent = "HOT";
        else valLook.textContent = "NEUTRAL";
      }

      function applyFx(){
        const fx = tile.querySelector(".fx");
        const desat = Number(desatEl.value);
        const blur = Number(blurEl.value);
        const exp = Number(expEl.value);
        const grain = Number(grainEl.value);

        // CSS filter acts on overlay layer; overlay itself sits above the iframe.
        // This keeps the aesthetic controlled without “effects theater”.
        fx.style.filter = `
          saturate(${(100 - desat + 20)/100})
          grayscale(${desat/100})
          blur(${blur}px)
          brightness(${(100 + exp)/100})
          contrast(1.05)
        `.trim();

        // Grain via subtle patterned overlay
        fx.style.setProperty("--grainOpacity", (grain/100).toFixed(2));
        fx.style.setProperty("--exp", exp);

        fx.style.opacity = "1";
        fx.style.setProperty("--grain", grain);

        fx.style.setProperty("--grainOpacity", (grain/100).toFixed(2));
        fx.style.setProperty("--shadeOpacity", (exp < 0 ? Math.min(Math.abs(exp)/60, 0.6) : 0).toFixed(2));
        fx.style.setProperty("--liftOpacity", (exp > 0 ? Math.min(exp/80, 0.35) : 0).toFixed(2));

        fx.style.setProperty("mix-blend-mode", "normal");
        fx.style.setProperty("background", "transparent");

        // Drive pseudo layers
        fx.style.setProperty("--g", grain);
        fx.style.setProperty("--d", desat);
        fx.style.setProperty("--b", blur);

        // apply to pseudo elements
        fx.style.setProperty("--grainAlpha", (grain/100).toFixed(2));
        fx.style.setProperty("--darkAlpha", (exp < 0 ? Math.min(Math.abs(exp)/60, 0.65) : 0).toFixed(2));
        fx.style.setProperty("--lightAlpha", (exp > 0 ? Math.min(exp/80, 0.40) : 0).toFixed(2));

        // attach to CSS via inline style hooks
        fx.style.setProperty("--_grain", (grain/100).toFixed(2));

        // update visible values
        valDesat.textContent = `${desat}%`;
        valBlur.textContent = `${blur.toFixed(1)}`;
        valExp.textContent = `${exp}%`;
        valGrain.textContent = `${grain}%`;
        updateLookLabel();

        // set pseudo element opacity
        fx.style.setProperty("--grainOpacity", (grain/100).toFixed(2));
        fx.style.setProperty("--darkenOpacity", (exp < 0 ? Math.min(Math.abs(exp)/60, 0.65) : 0).toFixed(2));
        fx.style.setProperty("--lightenOpacity", (exp > 0 ? Math.min(exp/80, 0.40) : 0).toFixed(2));

        // write into inline stylesheet variables (used by ::before/::after)
        fx.style.setProperty("opacity", "1");
        fx.style.setProperty("--kgrain", (grain/100).toFixed(2));
        fx.style.setProperty("--kdark", (exp < 0 ? Math.min(Math.abs(exp)/60, 0.65) : 0).toFixed(2));
        fx.style.setProperty("--klight", (exp > 0 ? Math.min(exp/80, 0.40) : 0).toFixed(2));

        // Map the CSS variables to actual pseudo opacities using style attribute hacks:
        fx.style.setProperty("outline", "0"); // noop to keep consistent
        fx.style.setProperty("--__", "0");    // noop

        // update pseudo element opacities via dataset
        fx.dataset.grain = (grain/100).toFixed(2);
        fx.dataset.dark = (exp < 0 ? Math.min(Math.abs(exp)/60, 0.65) : 0).toFixed(2);
        fx.dataset.light = (exp > 0 ? Math.min(exp/80, 0.40) : 0).toFixed(2);

        // Apply pseudo changes
        fx.style.setProperty("mix-blend-mode", "normal");
      }

      // Patch pseudo opacity on each animation frame? no. We'll use attribute selectors in CSS:
      // We implement this with a tiny inline style element (below).
      // For now, set via style property by directly addressing pseudo elements is impossible;
      // we use CSS variables read by ::before/::after.
      // So: set CSS variables on fx and reference them in CSS:
      tile.querySelector(".fx").style.setProperty("--grainOpacity","0");
      tile.querySelector(".fx").style.setProperty("--darkenOpacity","0");
      tile.querySelector(".fx").style.setProperty("--lightenOpacity","0");

      // Controls
      loadBtn.addEventListener("click", ()=>{
        const id = parseYouTubeId(urlEl.value);
        if(!id){ alert("Invalid YouTube URL/ID."); return; }
        loadVideo(index, id);
      });

      promoteBtn.addEventListener("click", ()=> promote(index));

      gainEl.addEventListener("input", ()=>{
        const v = Number(gainEl.value);
        valGain.textContent = `${v}%`;
        setVolume(index, v);
      });

      desatEl.addEventListener("input", applyFx);
      blurEl.addEventListener("input", applyFx);
      expEl.addEventListener("input", applyFx);
      grainEl.addEventListener("input", applyFx);

      muteBtn.addEventListener("click", ()=>{
        gainEl.value = "0";
        valGain.textContent = "0%";
        setVolume(index, 0);
      });

      bgBtn.addEventListener("click", ()=>{
        // background preset: quiet + slightly peripheral look
        gainEl.value = "10";
        desatEl.value = "75";
        blurEl.value = "1.2";
        expEl.value = "-6";
        grainEl.value = "4";
        valGain.textContent = "10%";
        applyFx();
        setVolume(index, 10);
      });

      // initial FX values
      applyFx();
      valGain.textContent = `${gainEl.value}%`;

      return { tile, tileId, urlEl, gainEl, desatEl, blurEl, expEl, grainEl };
    }

    // CSS variables for pseudo elements in .fx
    const fxStyle = document.createElement("style");
    fxStyle.textContent = `
      .fx::before{ opacity: var(--kgrain, 0); }
      .fx::after{
        opacity: calc(var(--kdark, 0) + var(--klight, 0));
        background:
          linear-gradient(0deg, rgba(0,0,0, calc(var(--kdark, 0))) 0%, rgba(0,0,0, calc(var(--kdark, 0))) 100%),
          linear-gradient(0deg, rgba(255,255,255, calc(var(--klight, 0))) 0%, rgba(255,255,255, calc(var(--klight, 0))) 100%);
        mix-blend-mode: multiply;
      }
    `;
    document.head.appendChild(fxStyle);

    function rebuild(n){
      // clear players
      players = [];
      promotedIndex = null;

      // rebuild DOM
      gridEl.innerHTML = "";
      setGrid(n);

      for(let i=0;i<n;i++){
        const t = mkTile(i);
        gridEl.appendChild(t.tile);

        players.push({
          tileId: t.tileId,
          videoId: null,
          vol: 0,
          promoted: false,
          // store look sliders so we can serialize
          getLook: () => ({
            desat: Number(t.desatEl.value),
            blur: Number(t.blurEl.value),
            exp: Number(t.expEl.value),
            grain: Number(t.grainEl.value)
          }),
          setLook: (look) => {
            t.desatEl.value = String(look.desat ?? 60);
            t.blurEl.value = String(look.blur ?? 0);
            t.expEl.value = String(look.exp ?? 0);
            t.grainEl.value = String(look.grain ?? 0);
            // trigger apply via dispatch
            t.desatEl.dispatchEvent(new Event("input"));
            t.blurEl.dispatchEvent(new Event("input"));
            t.expEl.dispatchEvent(new Event("input"));
            t.grainEl.dispatchEvent(new Event("input"));
          },
          setUrlRaw: (raw) => { t.urlEl.value = raw || ""; },
          getUrlRaw: () => t.urlEl.value,
          setVolUI: (v) => { t.gainEl.value = String(v); t.gainEl.dispatchEvent(new Event("input")); },
          getVolUI: () => Number(t.gainEl.value),
          player: null
        });
      }

      // if API is ready, instantiate players (blank until loaded)
      if(playersReady){
        instantiateAllPlayers();
      }
    }

    function instantiateAllPlayers(){
      for(let i=0;i<players.length;i++){
        const p = players[i];
        // Create a YT player per tile. Even without a video loaded, we can create a placeholder player.
        // We set videoId later via loadVideo().
        p.player = new YT.Player(p.tileId, {
          width: "100%",
          height: "100%",
          videoId: "", // none
          playerVars: {
            modestbranding: 1,
            rel: 0,
            playsinline: 1
          },
          events: {
            onReady: () => {
              // keep muted until operator sets gain
              try{ p.player.mute(); p.player.setVolume(0); } catch(e){}
            }
          }
        });
      }
    }

    function loadVideo(index, videoId){
      const p = players[index];
      if(!p || !p.player) return;

      p.videoId = videoId;

      // Attempt to load. Note: embed restrictions can block playback.
      try{
        p.player.loadVideoById(videoId);
        // start muted by default; operator must raise gain
        p.player.mute();
        p.player.setVolume(0);
        p.vol = 0;
        p.setVolUI(0);
      } catch(e){
        alert("Could not load video (embed may be disabled).");
      }
    }

    function setVolume(index, vol){
      const p = players[index];
      if(!p || !p.player) return;

      vol = clamp(vol, 0, 100);
      p.vol = vol;

      // apply ducking if someone is promoted
      applyDucking();

      // set actual player volume/mute
      const effective = p._effectiveVol ?? vol;
      try{
        if(effective <= 0){
          p.player.mute();
          p.player.setVolume(0);
        } else {
          p.player.unMute();
          p.player.setVolume(effective);
        }
      } catch(e){}
    }

    function applyDucking(){
      const duck = Number(duckEl.value); // % reduction applied to non-promoted when one is promoted
      const hasPromoted = (promotedIndex !== null);

      for(let i=0;i<players.length;i++){
        const p = players[i];
        const baseVol = p.vol ?? 0;

        let eff = baseVol;
        if(hasPromoted && i !== promotedIndex){
          eff = Math.round(baseVol * (1 - duck/100));
        }
        p._effectiveVol = eff;

        if(p.player){
          try{
            if(eff <= 0){
              p.player.mute();
              p.player.setVolume(0);
            } else {
              p.player.unMute();
              p.player.setVolume(eff);
            }
          } catch(e){}
        }
      }
    }

    function promote(index){
      if(index < 0 || index >= players.length) return;

      // if already promoted, demote
      if(promotedIndex === index){
        promotedIndex = null;
      } else {
        promotedIndex = index;
      }

      // visual: promoted gets less desat, less blur, slightly lifted exposure
      players.forEach((p, i)=>{
        const tile = document.querySelector(`.tile[data-index="${i}"]`);
        if(!tile) return;

        if(promotedIndex === i){
          tile.style.borderColor = "rgba(255,255,255,.28)";
          // optional auto-look tweak (non-destructive): if operator has set something, we do not override.
          // So: only nudge if currently very peripheral.
          const look = p.getLook();
          if(look.blur >= 2.5 || look.desat >= 80){
            p.setLook({ desat: Math.min(look.desat, 55), blur: Math.max(0, look.blur - 1.5), exp: Math.max(look.exp, 6), grain: Math.min(look.grain, 6) });
          }
        } else {
          tile.style.borderColor = "rgba(255,255,255,.12)";
        }
      });

      applyDucking();
    }

    function muteAll(){
      players.forEach((p, i)=>{ p.setVolUI(0); });
      promotedIndex = null;
      applyDucking();
    }

    function backgroundAll(){
      promotedIndex = null;
      players.forEach((p, i)=>{
        // background preset without overwriting a fully custom look too aggressively:
        const look = p.getLook();
        // only soften if currently sharp/colored; otherwise leave
        const desat = Math.max(look.desat, 70);
        const blur = Math.max(look.blur, 0.8);
        const exp = Math.min(look.exp, 0);
        const grain = Math.max(look.grain, 3);

        p.setLook({ desat, blur, exp, grain });
        p.setVolUI(Math.min(p.getVolUI(), 10));
      });
      applyDucking();
    }

    function save(){
      const data = {
        count: players.length,
        gap: Number(gapEl.value),
        duck: Number(duckEl.value),
        promotedIndex,
        screens: players.map((p)=>({
          videoId: p.videoId,
          urlRaw: p.getUrlRaw(),
          vol: p.vol ?? 0,
          look: p.getLook()
        }))
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      alert("SAVED.");
    }

    function load(){
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw){ alert("NO SAVE FOUND."); return; }
      const data = JSON.parse(raw);

      countEl.value = String(clamp(Number(data.count || 9), 1, 12));
      gapEl.value = String(clamp(Number(data.gap ?? 10), 0, 24));
      duckEl.value = String(clamp(Number(data.duck ?? 55), 0, 90));
      document.documentElement.style.setProperty("--gap", `${gapEl.value}px`);

      rebuild(Number(countEl.value));

      // after rebuild, we need to wait until players exist; we handle it in a short retry
      const applyLoaded = ()=>{
        if(!playersReady) return false;
        // wait until YT players exist
        const ok = players.every(p => p.player);
        if(!ok) return false;

        data.screens?.forEach((s, i)=>{
          if(!players[i]) return;
          players[i].setUrlRaw(s.urlRaw || (s.videoId || ""));
          players[i].setLook(s.look || {});
          players[i].vol = clamp(Number(s.vol ?? 0), 0, 100);
          players[i].setVolUI(players[i].vol);
          if(s.videoId){
            loadVideo(i, s.videoId);
          }
        });

        promotedIndex = (typeof data.promotedIndex === "number") ? data.promotedIndex : null;
        applyDucking();
        if(promotedIndex !== null) promote(promotedIndex); // reapply border + look nudge
        return true;
      };

      // retry a few times (no long waits)
      let tries = 0;
      const t = setInterval(()=>{
        tries++;
        if(applyLoaded() || tries > 20){
          clearInterval(t);
        }
      }, 150);

      alert("LOADED.");
    }

    function clearAll(){
      localStorage.removeItem(STORAGE_KEY);
      // wipe UI + stop videos
      players.forEach((p)=>{
        try{ if(p.player) p.player.stopVideo(); } catch(e){}
      });
      rebuild(Number(countEl.value));
    }

    // Global controls
    countEl.addEventListener("change", ()=> rebuild(Number(countEl.value)));
    gapEl.addEventListener("input", ()=>{
      document.documentElement.style.setProperty("--gap", `${gapEl.value}px`);
    });
    duckEl.addEventListener("input", ()=> applyDucking());
    muteAllBtn.addEventListener("click", muteAll);
    bgAllBtn.addEventListener("click", backgroundAll);
    saveBtn.addEventListener("click", save);
    loadBtn.addEventListener("click", load);
    clearBtn.addEventListener("click", clearAll);

    // Escape demotes
    document.addEventListener("keydown", (e)=>{
      if(e.key === "Escape"){
        promotedIndex = null;
        applyDucking();
        // reset borders
        document.querySelectorAll(".tile").forEach(t=> t.style.borderColor="rgba(255,255,255,.12)");
      }
    });

    // YouTube API hook
    window.onYouTubeIframeAPIReady = function(){
      playersReady = true;
      rebuild(Number(countEl.value));
      instantiateAllPlayers();
    };

    // initial CSS var
    document.documentElement.style.setProperty("--gap", `${gapEl.value}px`);
  </script>
</body>
</html>
