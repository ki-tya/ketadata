<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA — SACRED GEOMETRY INTERFACE (IMMERSIVE)</title>
  <style>
    :root{
      --bg:#000;
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.55);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background:var(--bg);
      font-family: Arial, Helvetica, sans-serif;
      color: var(--fg);
    }
    canvas{ position:fixed; inset:0; width:100vw; height:100vh; display:block; }

    .hud{
      position:fixed; left:22px; top:18px;
      user-select:none; pointer-events:none;
      mix-blend-mode:screen;
    }
    .brand{
      font-weight:800;
      letter-spacing:.18em;
      text-transform:uppercase;
      font-size:16px;
      text-shadow: 0 0 18px rgba(255,255,255,.18);
    }
    .sub{
      margin-top:4px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color: var(--muted);
    }

    .dock{
      position:fixed; left:22px; bottom:18px;
      display:flex; gap:10px; pointer-events:auto;
      align-items:center;
    }
    .btn{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.22);
      color:rgba(255,255,255,.86);
      padding:10px 12px;
      border-radius:10px;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{ background:rgba(255,255,255,.10); border-color:rgba(255,255,255,.36); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }

    .panel{
      position:fixed; right:18px; top:18px;
      width:min(580px, calc(100vw - 36px));
      max-height: calc(100vh - 36px);
      overflow:auto;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.46);
      backdrop-filter: blur(10px);
      border-radius:14px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset, 0 16px 50px rgba(0,0,0,.65);
    }
    .panelHeader{
      position:sticky; top:0;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.66);
      backdrop-filter: blur(10px);
      display:flex; justify-content:space-between; align-items:center;
      z-index:10;
    }
    .panelHeader .title{
      font-weight:800;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      color:rgba(255,255,255,.86);
    }
    .panelHeader .hint{
      font-size:11px;
      letter-spacing:.08em;
      color:rgba(255,255,255,.55);
      text-align:right;
      line-height:1.2;
    }
    .panelBody{ padding:10px 12px 12px; display:flex; flex-direction:column; gap:10px; }

    .group{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      overflow:hidden;
      background:rgba(255,255,255,.02);
    }
    .group h3{
      margin:0;
      padding:10px 10px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:rgba(255,255,255,.75);
      border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    .pill{
      font-size:10px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:rgba(255,255,255,.62);
      border:1px solid rgba(255,255,255,.18);
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.20);
    }
    .rows{ padding:10px; display:flex; flex-direction:column; gap:10px; }
    .row{
      display:grid;
      grid-template-columns: 180px 1fr 70px;
      gap:10px;
      align-items:center;
    }
    .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:rgba(255,255,255,.62);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    input[type="range"]{ width:100%; accent-color: rgba(255,255,255,.92); }
    .val{ font-variant-numeric: tabular-nums; font-size:11px; color:rgba(255,255,255,.76); text-align:right; }

    .toggles{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      padding:10px;
    }
    .toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }
    .toggle span{
      font-size:11px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:rgba(255,255,255,.78);
      white-space:nowrap;
    }

    .note{
      font-size:11px;
      color:rgba(255,255,255,.55);
      line-height:1.35;
      letter-spacing:.02em;
      padding:10px 12px 0;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="brand">KETADATA</div>
    <div class="sub">SACRED GEOMETRY · IMMERSIVE FIELD</div>
  </div>

  <div class="dock">
    <button class="btn" id="invert">INVERT</button>
    <button class="btn" id="pause">PAUSE</button>
    <button class="btn" id="reseed">RESEED</button>
    <button class="btn" id="reset">RESET</button>
  </div>

  <div class="panel" id="panel">
    <div class="panelHeader">
      <div class="title">GEOMETRY CONTROLS</div>
      <div class="hint">
        SCROLL = SCALE<br/>
        DRAG = OFFSET<br/>
        [H] PANEL · [P] PAUSE · [I] INVERT
      </div>
    </div>

    <div class="note">
      Richness comes from depth layers + halo pass + portal vignette + subtle grain. Keep it light with <b>quality</b>.
      Invert flips background + all strokes; inverted mode forces source-over to keep black lines visible.
    </div>

    <div class="panelBody">

      <div class="group">
        <h3>System <span class="pill">global</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">time scale (slow-mo)</div>
            <input id="timeScale" type="range" min="0.00" max="2.00" step="0.001" value="0.40">
            <div class="val" id="timeScaleV">0.400</div>
          </div>
          <div class="row">
            <div class="label">scale</div>
            <input id="fill" type="range" min="0.35" max="3.8" step="0.01" value="1.70">
            <div class="val" id="fillV">1.70</div>
          </div>
          <div class="row">
            <div class="label">rotation</div>
            <input id="rot" type="range" min="-2.0" max="2.0" step="0.001" value="0.10">
            <div class="val" id="rotV">0.100</div>
          </div>
          <div class="row">
            <div class="label">quality</div>
            <input id="quality" type="range" min="0.25" max="1.00" step="0.01" value="0.80">
            <div class="val" id="qualityV">0.80</div>
          </div>
          <div class="row">
            <div class="label">line thickness</div>
            <input id="thick" type="range" min="0.4" max="4.2" step="0.01" value="1.15">
            <div class="val" id="thickV">1.15</div>
          </div>
          <div class="row">
            <div class="label">contrast</div>
            <input id="contrast" type="range" min="0.6" max="3.6" step="0.01" value="1.65">
            <div class="val" id="contrastV">1.65</div>
          </div>
          <div class="row">
            <div class="label">composite</div>
            <input id="comp" type="range" min="0" max="2" step="1" value="2">
            <div class="val" id="compV">screen</div>
          </div>
        </div>
      </div>

      <div class="group">
        <h3>Immersion <span class="pill">depth</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">halo</div>
            <input id="halo" type="range" min="0" max="1" step="0.01" value="0.55">
            <div class="val" id="haloV">0.55</div>
          </div>
          <div class="row">
            <div class="label">vignette portal</div>
            <input id="portal" type="range" min="0" max="1" step="0.01" value="0.55">
            <div class="val" id="portalV">0.55</div>
          </div>
          <div class="row">
            <div class="label">grain</div>
            <input id="grain" type="range" min="0" max="1" step="0.01" value="0.30">
            <div class="val" id="grainV">0.30</div>
          </div>
          <div class="row">
            <div class="label">parallax</div>
            <input id="parallax" type="range" min="0" max="1" step="0.01" value="0.35">
            <div class="val" id="parallaxV">0.35</div>
          </div>
        </div>
      </div>

      <div class="group">
        <h3>Layers <span class="pill">toggle</span></h3>
        <div class="toggles">
          <label class="toggle"><input id="L_flower" type="checkbox" checked><span>flower of life</span></label>
          <label class="toggle"><input id="L_seed" type="checkbox" checked><span>seed of life</span></label>
          <label class="toggle"><input id="L_metatron" type="checkbox" checked><span>metatron</span></label>
          <label class="toggle"><input id="L_cube" type="checkbox" checked><span>cube projection</span></label>
          <label class="toggle"><input id="L_rays" type="checkbox" checked><span>radial rays</span></label>
          <label class="toggle"><input id="L_spiral" type="checkbox" checked><span>golden spiral</span></label>
          <label class="toggle"><input id="L_field" type="checkbox" checked><span>field particles</span></label>
          <label class="toggle"><input id="L_scan" type="checkbox" checked><span>scanlines</span></label>
          <label class="toggle"><input id="L_grid" type="checkbox"><span>hex grid</span></label>
        </div>
      </div>

      <div class="group">
        <h3>Structure <span class="pill">lattice</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">radius (circles)</div>
            <input id="rad" type="range" min="16" max="240" step="1" value="82">
            <div class="val" id="radV">82</div>
          </div>
          <div class="row">
            <div class="label">rings (extent)</div>
            <input id="rings" type="range" min="1" max="6" step="1" value="3">
            <div class="val" id="ringsV">3</div>
          </div>
          <div class="row">
            <div class="label">metatron edges</div>
            <input id="metaEdges" type="range" min="0" max="1" step="0.01" value="0.70">
            <div class="val" id="metaEdgesV">0.70</div>
          </div>
          <div class="row">
            <div class="label">ray density</div>
            <input id="rayN" type="range" min="6" max="120" step="1" value="44">
            <div class="val" id="rayNV">44</div>
          </div>
          <div class="row">
            <div class="label">ray length</div>
            <input id="rayLen" type="range" min="0.3" max="2.0" step="0.01" value="1.15">
            <div class="val" id="rayLenV">1.15</div>
          </div>
          <div class="row">
            <div class="label">spiral turns</div>
            <input id="spiralTurns" type="range" min="0" max="10" step="0.01" value="5.20">
            <div class="val" id="spiralTurnsV">5.20</div>
          </div>
          <div class="row">
            <div class="label">spiral weight</div>
            <input id="spiralW" type="range" min="0" max="1" step="0.01" value="0.62">
            <div class="val" id="spiralWV">0.62</div>
          </div>
        </div>
      </div>

      <div class="group">
        <h3>FX <span class="pill">pulse</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">strobe</div>
            <input id="strobe" type="range" min="0" max="1" step="0.01" value="0.12">
            <div class="val" id="strobeV">0.12</div>
          </div>
          <div class="row">
            <div class="label">breathing</div>
            <input id="breathe" type="range" min="0" max="1" step="0.01" value="0.20">
            <div class="val" id="breatheV">0.20</div>
          </div>
          <div class="row">
            <div class="label">breath speed</div>
            <input id="breatheSpd" type="range" min="0" max="3" step="0.01" value="1.05">
            <div class="val" id="breatheSpdV">1.05</div>
          </div>
          <div class="row">
            <div class="label">edge fade</div>
            <input id="edgeFade" type="range" min="0" max="1" step="0.01" value="0.45">
            <div class="val" id="edgeFadeV">0.45</div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha:false });

      let W=0, H=0, DPR=Math.min(2, window.devicePixelRatio||1);

      // cheap grain tile (reused)
      const grainCanvas = document.createElement('canvas');
      const gctx = grainCanvas.getContext('2d');

      function regenGrainTile(){
        const s = 180;
        grainCanvas.width = s;
        grainCanvas.height = s;
        const img = gctx.createImageData(s, s);
        for (let i=0;i<img.data.length;i+=4){
          const v = (Math.random()*255)|0;
          img.data[i+0]=v; img.data[i+1]=v; img.data[i+2]=v;
          img.data[i+3]=255;
        }
        gctx.putImageData(img,0,0);
      }
      regenGrainTile();

      function resize(){
        W=innerWidth; H=innerHeight;
        canvas.width = Math.floor(W*DPR);
        canvas.height = Math.floor(H*DPR);
        canvas.style.width = W+'px';
        canvas.style.height = H+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize);
      resize();

      const $ = (id)=>document.getElementById(id);

      const sliders = [
        'timeScale','fill','rot','quality','thick','contrast','comp',
        'halo','portal','grain','parallax',
        'rad','rings','metaEdges','rayN','rayLen','spiralTurns','spiralW',
        'strobe','breathe','breatheSpd','edgeFade'
      ];
      const ui = {};
      for (const id of sliders) ui[id] = $(id);

      const layers = {
        flower: $('L_flower'),
        seed: $('L_seed'),
        metatron: $('L_metatron'),
        cube: $('L_cube'),
        rays: $('L_rays'),
        spiral: $('L_spiral'),
        field: $('L_field'),
        scan: $('L_scan'),
        grid: $('L_grid'),
      };

      function compLabel(v){ return v===0 ? 'source-over' : (v===1 ? 'lighter' : 'screen'); }

      function sync(){
        $('timeScaleV').textContent = (+ui.timeScale.value).toFixed(3);
        $('fillV').textContent = (+ui.fill.value).toFixed(2);
        $('rotV').textContent = (+ui.rot.value).toFixed(3);
        $('qualityV').textContent = (+ui.quality.value).toFixed(2);
        $('thickV').textContent = (+ui.thick.value).toFixed(2);
        $('contrastV').textContent = (+ui.contrast.value).toFixed(2);
        $('compV').textContent = compLabel((+ui.comp.value)|0);

        $('haloV').textContent = (+ui.halo.value).toFixed(2);
        $('portalV').textContent = (+ui.portal.value).toFixed(2);
        $('grainV').textContent = (+ui.grain.value).toFixed(2);
        $('parallaxV').textContent = (+ui.parallax.value).toFixed(2);

        $('radV').textContent = ui.rad.value;
        $('ringsV').textContent = ui.rings.value;
        $('metaEdgesV').textContent = (+ui.metaEdges.value).toFixed(2);
        $('rayNV').textContent = ui.rayN.value;
        $('rayLenV').textContent = (+ui.rayLen.value).toFixed(2);
        $('spiralTurnsV').textContent = (+ui.spiralTurns.value).toFixed(2);
        $('spiralWV').textContent = (+ui.spiralW.value).toFixed(2);

        $('strobeV').textContent = (+ui.strobe.value).toFixed(2);
        $('breatheV').textContent = (+ui.breathe.value).toFixed(2);
        $('breatheSpdV').textContent = (+ui.breatheSpd.value).toFixed(2);
        $('edgeFadeV').textContent = (+ui.edgeFade.value).toFixed(2);
      }

      let dirty = true;

      sliders.forEach(id => ui[id].addEventListener('input', () => { dirty=true; sync(); }));
      Object.values(layers).forEach(chk => chk.addEventListener('change', () => { dirty=true; }));
      sync();

      const st = {
        t: 0,
        invert:false,
        paused:false,
        scale: 1.0,
        wheel: 0,
        drag:false,
        ox:0, oy:0,
        lx:0, ly:0,
        seed: (Math.random()*1e9)|0,
        mx: 0.5, my: 0.5
      };

      $('invert').onclick = ()=> { st.invert = !st.invert; dirty=true; };
      $('pause').onclick = ()=> st.paused = !st.paused;
      $('reseed').onclick = ()=> { st.seed = (Math.random()*1e9)|0; regenField(); regenGrainTile(); dirty=true; };
      $('reset').onclick = ()=> {
        st.t=0; st.invert=false; st.paused=false; st.scale=1.0; st.wheel=0; st.ox=0; st.oy=0;
        st.seed = (Math.random()*1e9)|0;
        regenField();
        regenGrainTile();
        dirty=true;
      };

      addEventListener('keydown', (e)=>{
        if (e.key === 'i' || e.key === 'I'){ st.invert = !st.invert; dirty=true; }
        if (e.key === 'p' || e.key === 'P') st.paused = !st.paused;
        if (e.key === 'h' || e.key === 'H') {
          const panel = document.getElementById('panel');
          panel.style.display = (panel.style.display === 'none') ? '' : 'none';
        }
      });

      addEventListener('wheel', (e)=>{
        const d = Math.max(-160, Math.min(160, e.deltaY));
        st.wheel += (-d/160) * 0.16;
        st.wheel = clamp(st.wheel, -0.70, 0.95);
      }, { passive:true });

      addEventListener('pointerdown', (e)=>{ st.drag=true; st.lx=e.clientX; st.ly=e.clientY; });
      addEventListener('pointerup', ()=> st.drag=false);
      addEventListener('pointercancel', ()=> st.drag=false);
      addEventListener('pointermove', (e)=>{
        st.mx = clamp(e.clientX / Math.max(1,W), 0, 1);
        st.my = clamp(e.clientY / Math.max(1,H), 0, 1);

        if (!st.drag) return;
        const dx = e.clientX - st.lx;
        const dy = e.clientY - st.ly;
        st.lx = e.clientX; st.ly = e.clientY;
        st.ox += dx;
        st.oy += dy;
        st.ox = clamp(st.ox, -W*0.35, W*0.35);
        st.oy = clamp(st.oy, -H*0.35, H*0.35);
        dirty = true;
      });

      // ========= Geometry cache (bounded cost) =========
      let cached = { key:'', pts:[], map:null, seedIdx:[], metaIdx:[], metaEdges:[], cubeEdges:[] };

      function hexLatticePoints(radPx, rings){
        const d = radPx;
        const h = d * Math.sqrt(3)/2;
        const pts = [];
        const map = new Map();

        for (let q=-rings; q<=rings; q++){
          for (let r=-rings; r<=rings; r++){
            const s = -q - r;
            const dist = Math.max(Math.abs(q), Math.abs(r), Math.abs(s));
            if (dist > rings) continue;
            const x = d * (q + r/2);
            const y = h * r;
            map.set(q+','+r, pts.length);
            pts.push({ x,y,q,r });
          }
        }
        return { pts, map };
      }

      function keyForCache(){ return [ui.rad.value, ui.rings.value].join('|'); }

      function hexDist(a,b){
        const dq = a.q-b.q, dr=a.r-b.r, ds=(-a.q-a.r)-(-b.q-b.r);
        return (Math.abs(dq)+Math.abs(dr)+Math.abs(ds))/2;
      }

      function rebuildCache(){
        const rad = +ui.rad.value;
        const rings = (+ui.rings.value)|0;

        const { pts, map } = hexLatticePoints(rad, rings);

        const neighbors = [[ 1,0],[0,1],[-1,1],[-1,0],[0,-1],[1,-1]];
        const centerIdx = map.get('0,0') ?? 0;
        const seedIdx = [centerIdx];
        for (const [q,r] of neighbors){
          const idx = map.get(q+','+r);
          if (idx != null) seedIdx.push(idx);
        }

        const metaIdx = [];
        for (let i=0;i<pts.length;i++){
          const p=pts[i];
          const s=-p.q-p.r;
          const dist = Math.max(Math.abs(p.q), Math.abs(p.r), Math.abs(s));
          if (dist <= 2) metaIdx.push(i);
        }

        const metaEdges = [];
        for (let i=0;i<metaIdx.length;i++){
          for (let j=i+1;j<metaIdx.length;j++){
            const ai=metaIdx[i], bj=metaIdx[j];
            const d = hexDist(pts[ai], pts[bj]);
            if (d===1 || d===2) metaEdges.push({ a:ai, b:bj, d });
          }
        }

        // cube-ish subset
        const cubeEdges = [];
        for (const e of metaEdges){
          if (e.d===1 && (e.a===centerIdx || e.b===centerIdx)) cubeEdges.push(e);
        }
        for (const e of metaEdges){
          if (e.d===2){
            const h = ((e.a*73856093) ^ (e.b*19349663) ^ (st.seed|0)) >>> 0;
            if ((h % 5) === 0) cubeEdges.push(e);
          }
        }

        cached = { key:keyForCache(), pts, map, seedIdx, metaIdx, metaEdges, cubeEdges };
      }

      function ensureCache(){
        const k = keyForCache();
        if (dirty || cached.key !== k){
          rebuildCache();
          dirty = false;
        }
      }

      // ========= Field particles (immersive, light) =========
      let field = [];
      function rand01(n){
        // deterministic-ish
        n = (n ^ (n >>> 16)) >>> 0;
        n = Math.imul(n, 2246822519) >>> 0;
        n = (n ^ (n >>> 13)) >>> 0;
        n = Math.imul(n, 3266489917) >>> 0;
        n = (n ^ (n >>> 16)) >>> 0;
        return (n / 4294967295);
      }

      function regenField(){
        const N = 520; // capped base; scaled down by quality at draw time
        field = new Array(N);
        for (let i=0;i<N;i++){
          const a = rand01((st.seed + i*17)|0) * Math.PI*2;
          const r = Math.sqrt(rand01((st.seed + i*97)|0));
          field[i] = {
            a,
            r,
            s: 0.4 + rand01((st.seed + i*313)|0)*1.6,
            p: rand01((st.seed + i*701)|0) * Math.PI*2
          };
        }
      }
      regenField();

      // ========= Drawing helpers =========
      function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
      function lerp(a,b,t){ return a + (b-a)*t; }

      function edgeFadeAlpha(x,y,cx,cy,edgeFade){
        if (edgeFade <= 0) return 1;
        const nx = (x - cx) / (W*0.5);
        const ny = (y - cy) / (H*0.5);
        const d = Math.sqrt(nx*nx + ny*ny);
        const a = 1 - edgeFade * clamp((d - 0.52) / 0.62, 0, 1);
        return clamp(a, 0, 1);
      }

      function setStrokeRGBA(fg, a){
        ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
      }

      function drawCircle(x,y,r, fg, a){
        if (a <= 0.001) return;
        setStrokeRGBA(fg, a);
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.stroke();
      }

      function drawLine(x0,y0,x1,y1, fg, a){
        if (a <= 0.001) return;
        setStrokeRGBA(fg, a);
        ctx.beginPath();
        ctx.moveTo(x0,y0);
        ctx.lineTo(x1,y1);
        ctx.stroke();
      }

      function radialBackground(inv, cx, cy, portal, t){
        // Lightweight “nebula” background using a couple radial gradients.
        const bg0 = inv ? 255 : 0;
        const bg1 = inv ? 235 : 18;
        const bg2 = inv ? 215 : 40;

        ctx.fillStyle = `rgb(${bg0},${bg0},${bg0})`;
        ctx.fillRect(0,0,W,H);

        const k = clamp(portal, 0, 1);
        if (k <= 0.001) return;

        const jitter = 0.06 * Math.min(W,H);
        const px = cx + (Math.sin(t*0.17)+Math.cos(t*0.11))*jitter;
        const py = cy + (Math.cos(t*0.13)+Math.sin(t*0.19))*jitter;

        const R1 = Math.min(W,H) * lerp(0.35, 0.65, k);
        const R2 = Math.min(W,H) * lerp(0.75, 1.05, k);

        const g1 = ctx.createRadialGradient(px,py, 0, px,py, R1);
        g1.addColorStop(0, `rgba(${bg2},${bg2},${bg2},${0.22*k})`);
        g1.addColorStop(1, `rgba(${bg0},${bg0},${bg0},0)`);

        const g2 = ctx.createRadialGradient(cx,cy, 0, cx,cy, R2);
        g2.addColorStop(0, `rgba(${bg1},${bg1},${bg1},${0.18*k})`);
        g2.addColorStop(1, `rgba(${bg0},${bg0},${bg0},0)`);

        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = g2; ctx.fillRect(0,0,W,H);
        ctx.fillStyle = g1; ctx.fillRect(0,0,W,H);
      }

      function portalVignette(inv, portal){
        // Darken edges into a “portal” ring. In invert mode, invert the logic.
        const k = clamp(portal,0,1);
        if (k <= 0.001) return;

        const cx = W*0.5, cy = H*0.5;
        const R = Math.min(W,H) * lerp(0.62, 0.78, k);
        const g = ctx.createRadialGradient(cx,cy, R*0.25, cx,cy, R);

        if (!inv){
          g.addColorStop(0, `rgba(0,0,0,0)`);
          g.addColorStop(1, `rgba(0,0,0,${0.72*k})`);
        } else {
          // On white bg: add a gentle “edge burn” using a gray vignette
          g.addColorStop(0, `rgba(255,255,255,0)`);
          g.addColorStop(1, `rgba(255,255,255,${0.50*k})`);
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = g;
        ctx.fillRect(0,0,W,H);
      }

      function grainOverlay(inv, amount, t){
        const k = clamp(amount,0,1);
        if (k <= 0.001) return;

        // slow drift
        const ox = Math.floor((Math.sin(t*0.07)+1)*40);
        const oy = Math.floor((Math.cos(t*0.05)+1)*40);

        ctx.globalCompositeOperation = inv ? 'multiply' : 'screen';
        ctx.globalAlpha = 0.10 * k;
        ctx.drawImage(grainCanvas, -ox, -oy, W+180, H+180);
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
      }

      // ========= Main loop =========
      let last = performance.now();
      function loop(now){
        const rawDt = Math.min(0.033, (now-last)/1000);
        last = now;

        st.wheel *= 0.88;
        st.scale += st.wheel;
        st.scale = clamp(st.scale, 0.55, 2.40);

        const dt = rawDt * (+ui.timeScale.value);
        if (!st.paused) st.t += dt;

        render();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      function render(){
        ensureCache();

        const inv = st.invert;
        const bg = inv ? 255 : 0;
        const fg = inv ? 0 : 255;

        const thick = +ui.thick.value;
        const contrast = +ui.contrast.value;
        const quality = +ui.quality.value;

        const rotSpeed = +ui.rot.value;
        const baseScale = +ui.fill.value;

        const strobe = +ui.strobe.value;
        const breatheAmt = +ui.breathe.value;
        const breatheSpd = +ui.breatheSpd.value;
        const edgeFade = +ui.edgeFade.value;

        const halo = +ui.halo.value;
        const portal = +ui.portal.value;
        const grain = +ui.grain.value;
        const parallax = +ui.parallax.value;

        // Center with parallax (mouse-driven), plus drag offset
        const px = (st.mx - 0.5) * Math.min(W,H) * 0.18 * parallax;
        const py = (st.my - 0.5) * Math.min(W,H) * 0.18 * parallax;

        const cx = W*0.5 + st.ox + px;
        const cy = H*0.5 + st.oy + py;

        // Background: radial depth + portal
        radialBackground(inv, cx, cy, portal, st.t);

        // Exposure envelope (bounded)
        const stro = strobe * (0.5 + 0.5*Math.sin(st.t*12.0));
        const exposure = (1.0 + stro*0.75) * contrast;

        // Composite: invert forces source-over so black lines show on white
        const comp = (+ui.comp.value)|0;
        ctx.globalCompositeOperation = inv
          ? 'source-over'
          : (comp===0 ? 'source-over' : (comp===1 ? 'lighter' : 'screen'));

        // Global transform + breathing
        const breathe = 1.0 + breatheAmt * Math.sin(st.t*breatheSpd);
        const S = baseScale * st.scale * breathe;

        const ang = st.t * rotSpeed;
        const ca = Math.cos(ang), sa = Math.sin(ang);

        // depth layers: we draw same geometry at 3 depths with slight scale/rot offsets
        // (cheap "3D" without expensive filters)
        const depthLayers = [
          { k: 0.92, a: 0.55, r: -0.12 },
          { k: 1.00, a: 1.00, r:  0.00 },
          { k: 1.08, a: 0.48, r:  0.10 }
        ];

        const rad = +ui.rad.value;
        const rings = (+ui.rings.value)|0;

        // halo pass: draw subtle “glow stroke” behind (no blur filters; just thicker, lower alpha)
        const haloOn = halo > 0.001;

        function X(x,y, S2, rot2){
          const c = Math.cos(ang+rot2), s = Math.sin(ang+rot2);
          return cx + (x*c - y*s) * S2;
        }
        function Y(x,y, S2, rot2){
          const c = Math.cos(ang+rot2), s = Math.sin(ang+rot2);
          return cy + (x*s + y*c) * S2;
        }

        function drawGeometryPass(passAlpha, S2, rot2, glow){
          // glow: thicker, dimmer line underlay
          ctx.lineWidth = glow ? (thick * lerp(1.8, 3.2, halo)) : thick;

          // Flower of Life
          if (layers.flower.checked){
            const pts = cached.pts;
            const maxCircles = Math.floor(pts.length * clamp(quality, 0.22, 1.0));
            const a0 = (glow ? 0.06 : 0.16) * exposure * passAlpha;

            for (let i=0;i<maxCircles;i++){
              const p = pts[i];
              const x = X(p.x,p.y, S2, rot2), y = Y(p.x,p.y, S2, rot2);
              const a = a0 * edgeFadeAlpha(x,y,cx,cy,edgeFade);
              drawCircle(x,y, rad*S2, fg, a);
            }
          }

          // Seed of Life (weighted)
          if (layers.seed.checked){
            const a0 = (glow ? 0.08 : 0.30) * exposure * passAlpha;
            for (const idx of cached.seedIdx){
              const p = cached.pts[idx];
              if (!p) continue;
              const x = X(p.x,p.y, S2, rot2), y = Y(p.x,p.y, S2, rot2);
              const a = a0 * edgeFadeAlpha(x,y,cx,cy,edgeFade);
              drawCircle(x,y, rad*S2, fg, a);
            }
          }

          // Metatron
          if (layers.metatron.checked){
            const strength = +ui.metaEdges.value;
            const pts = cached.pts;
            const edges = cached.metaEdges;
            const maxE = Math.floor(edges.length * clamp(quality, 0.20, 1.0));

            const a0 = (glow ? 0.06 : 0.20) * exposure * strength * passAlpha;

            let drawn = 0;
            // dist=1
            for (let i=0;i<edges.length && drawn<maxE;i++){
              const e = edges[i];
              if (e.d !== 1) continue;
              const A = pts[e.a], B = pts[e.b];
              const x0 = X(A.x,A.y, S2, rot2), y0 = Y(A.x,A.y, S2, rot2);
              const x1 = X(B.x,B.y, S2, rot2), y1 = Y(B.x,B.y, S2, rot2);
              const mx = (x0+x1)*0.5, my=(y0+y1)*0.5;
              const a = a0 * edgeFadeAlpha(mx,my,cx,cy,edgeFade);
              drawLine(x0,y0,x1,y1, fg, a);
              drawn++;
            }
            // dist=2 thinned
            const a1 = a0 * 0.55;
            const mod = Math.max(2, Math.floor(6 - quality*4));
            for (let i=0;i<edges.length && drawn<maxE;i++){
              const e = edges[i];
              if (e.d !== 2) continue;
              const h = (((e.a*73856093) ^ (e.b*19349663) ^ (st.seed|0)) >>> 0);
              if ((h % mod) !== 0) continue;

              const A = pts[e.a], B = pts[e.b];
              const x0 = X(A.x,A.y, S2, rot2), y0 = Y(A.x,A.y, S2, rot2);
              const x1 = X(B.x,B.y, S2, rot2), y1 = Y(B.x,B.y, S2, rot2);
              const mx = (x0+x1)*0.5, my=(y0+y1)*0.5;
              const a = a1 * edgeFadeAlpha(mx,my,cx,cy,edgeFade);
              drawLine(x0,y0,x1,y1, fg, a);
              drawn++;
            }

            // centers
            const aC = (glow ? 0.04 : 0.14) * exposure * strength * passAlpha;
            const maxCenters = Math.floor(cached.metaIdx.length * clamp(quality*1.2, 0.25, 1.0));
            for (let i=0;i<maxCenters;i++){
              const p = pts[cached.metaIdx[i]];
              const x = X(p.x,p.y, S2, rot2), y = Y(p.x,p.y, S2, rot2);
              const a = aC * edgeFadeAlpha(x,y,cx,cy,edgeFade);
              drawCircle(x,y, rad*S2*0.12, fg, a);
            }
          }

          // Cube projection
          if (layers.cube.checked){
            const pts = cached.pts;
            const edges = cached.cubeEdges;
            const maxE = Math.floor(edges.length * clamp(quality, 0.20, 1.0));
            const a0 = (glow ? 0.05 : 0.16) * exposure * passAlpha;
            for (let i=0;i<maxE;i++){
              const e = edges[i];
              const A = pts[e.a], B = pts[e.b];
              const x0 = X(A.x,A.y, S2, rot2), y0 = Y(A.x,A.y, S2, rot2);
              const x1 = X(B.x,B.y, S2, rot2), y1 = Y(B.x,B.y, S2, rot2);
              const mx = (x0+x1)*0.5, my=(y0+y1)*0.5;
              const a = a0 * edgeFadeAlpha(mx,my,cx,cy,edgeFade);
              drawLine(x0,y0,x1,y1, fg, a);
            }
          }

          // Rays
          if (layers.rays.checked){
            const N = (+ui.rayN.value)|0;
            const len = +ui.rayLen.value;
            const Rmax = Math.min(W,H) * 0.52 * len;
            const n2 = Math.max(4, Math.floor(N * clamp(quality, 0.25, 1.0)));

            const a0 = (glow ? 0.03 : 0.11) * exposure * passAlpha;
            for (let i=0;i<n2;i++){
              const t = (i/n2)*Math.PI*2 + ang*0.35 + rot2*0.2;
              const x1 = cx + Math.cos(t)*Rmax;
              const y1 = cy + Math.sin(t)*Rmax;
              const a = a0 * edgeFadeAlpha(x1,y1,cx,cy,edgeFade);
              drawLine(cx,cy,x1,y1, fg, a);
            }
          }

          // Spiral
          if (layers.spiral.checked){
            const turns = +ui.spiralTurns.value;
            const w = +ui.spiralW.value;
            const seg = Math.floor(lerp(420, 1200, clamp(quality, 0.25, 1.0)));
            const phi = (1 + Math.sqrt(5)) / 2;
            const b = Math.log(phi) / (Math.PI/2);

            const a0 = (glow ? 0.03 : 0.18) * exposure * w * passAlpha;

            ctx.beginPath();
            let started=false;

            for (let i=0;i<=seg;i++){
              const u = (i/seg) * (Math.PI*2*turns);
              const rr = Math.exp(b * u) * (rad*0.012) * S2 * (Math.min(W,H));
              const x = cx + Math.cos(u + ang*0.55 + rot2)*rr;
              const y = cy + Math.sin(u + ang*0.55 + rot2)*rr;
              const a = a0 * edgeFadeAlpha(x,y,cx,cy,edgeFade);
              if (a < 0.01) continue;
              if (!started){ ctx.moveTo(x,y); started=true; }
              else ctx.lineTo(x,y);
            }
            if (started){
              setStrokeRGBA(fg, clamp(a0,0,1));
              ctx.stroke();
            }
          }

          // optional hex grid
          if (layers.grid.checked){
            const pts = cached.pts;
            const max = Math.floor(pts.length * clamp(quality*1.1, 0.25, 1.0));
            const a0 = (glow ? 0.01 : 0.07) * exposure * passAlpha;
            for (let i=0;i<max;i++){
              const p = pts[i];
              const x = X(p.x,p.y, S2, rot2), y = Y(p.x,p.y, S2, rot2);
              const a = a0 * edgeFadeAlpha(x,y,cx,cy,edgeFade);
              drawLine(x-4,y, x+4,y, fg, a);
              drawLine(x,y-4, x,y+4, fg, a);
            }
          }
        }

        // --- HALO UNDERLAY PASS (glow look without heavy blur) ---
        if (haloOn){
          // keep halo from becoming “fog”: cap alpha and reduce when inverted
          const hK = halo * (inv ? 0.55 : 1.0);
          for (const L of depthLayers){
            drawGeometryPass(0.65 * hK * L.a, S*L.k, L.r, true);
          }
        }

        // --- MAIN PASS ---
        ctx.lineWidth = thick;
        for (const L of depthLayers){
          drawGeometryPass(1.0 * L.a, S*L.k, L.r, false);
        }

        // Field particles (adds immersion; capped by quality)
        if (layers.field.checked){
          const N = Math.floor(field.length * clamp(quality, 0.25, 1.0));
          const Rmax = Math.min(W,H) * 0.58;

          // draw as tiny drifting dashes
          ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';
          ctx.lineWidth = 1;

          const a0 = 0.10 * exposure * (inv ? 0.65 : 1.0);
          for (let i=0;i<N;i++){
            const f = field[i];
            const tt = st.t * f.s;
            const a = f.a + 0.25*Math.sin(tt + f.p);
            const rr = f.r * Rmax * (0.65 + 0.35*Math.sin(st.t*0.18 + f.p));
            const x = cx + Math.cos(a)*rr;
            const y = cy + Math.sin(a)*rr;

            const vx = Math.cos(a + Math.PI/2) * 8;
            const vy = Math.sin(a + Math.PI/2) * 8;

            const aa = a0 * edgeFadeAlpha(x,y,cx,cy,edgeFade);
            setStrokeRGBA(fg, aa);
            ctx.beginPath();
            ctx.moveTo(x - vx*0.5, y - vy*0.5);
            ctx.lineTo(x + vx*0.5, y + vy*0.5);
            ctx.stroke();
          }
        }

        // Scanlines (always source-over so they read)
        ctx.globalCompositeOperation = 'source-over';
        if (layers.scan.checked){
          const step = 9;
          const yOff = (st.t*70) % step;
          ctx.lineWidth = 1;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.045*contrast})`;
          for (let y=-step; y<H+step; y+=step){
            ctx.beginPath();
            ctx.moveTo(0, y+yOff);
            ctx.lineTo(W, y+yOff);
            ctx.stroke();
          }
        }

        // Portal vignette (frame the ritual)
        portalVignette(inv, portal);

        // Grain overlay (texture)
        grainOverlay(inv, grain, st.t);
      }

      // panel value sync
      function syncLabels(){
        $('timeScaleV').textContent = (+ui.timeScale.value).toFixed(3);
        $('fillV').textContent = (+ui.fill.value).toFixed(2);
        $('rotV').textContent = (+ui.rot.value).toFixed(3);
        $('qualityV').textContent = (+ui.quality.value).toFixed(2);
        $('thickV').textContent = (+ui.thick.value).toFixed(2);
        $('contrastV').textContent = (+ui.contrast.value).toFixed(2);
        $('compV').textContent = compLabel((+ui.comp.value)|0);

        $('haloV').textContent = (+ui.halo.value).toFixed(2);
        $('portalV').textContent = (+ui.portal.value).toFixed(2);
        $('grainV').textContent = (+ui.grain.value).toFixed(2);
        $('parallaxV').textContent = (+ui.parallax.value).toFixed(2);

        $('radV').textContent = ui.rad.value;
        $('ringsV').textContent = ui.rings.value;
        $('metaEdgesV').textContent = (+ui.metaEdges.value).toFixed(2);
        $('rayNV').textContent = ui.rayN.value;
        $('rayLenV').textContent = (+ui.rayLen.value).toFixed(2);
        $('spiralTurnsV').textContent = (+ui.spiralTurns.value).toFixed(2);
        $('spiralWV').textContent = (+ui.spiralW.value).toFixed(2);

        $('strobeV').textContent = (+ui.strobe.value).toFixed(2);
        $('breatheV').textContent = (+ui.breathe.value).toFixed(2);
        $('breatheSpdV').textContent = (+ui.breatheSpd.value).toFixed(2);
        $('edgeFadeV').textContent = (+ui.edgeFade.value).toFixed(2);
      }

      // hook label sync (keeps UI consistent even if someone edits)
      sliders.forEach(id => ui[id].addEventListener('input', syncLabels));
      syncLabels();

    })();
  </script>
</body>
</html>
