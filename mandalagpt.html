<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hypnotic Fractal Bloom</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #050509;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      cursor: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    canvas {
      display: block;
      filter: contrast(1.2) saturate(1.3);
    }

    #speedControl {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(5, 5, 15, 0.92);
      padding: 12px 20px;
      border-radius: 999px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.25s ease;
      pointer-events: none;
      z-index: 1000;
      border: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(8px);
    }

    #speedControl.visible {
      opacity: 1;
      pointer-events: auto;
    }

    #speedLabel {
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 6px;
    }

    #speedSlider {
      width: 220px;
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(
        to right,
        #2f80ed,
        #9b51e0,
        #f2994a,
        #eb5757
      );
      outline: none;
      -webkit-appearance: none;
      display: block;
    }

    #speedSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #f2f2f2;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.5);
    }

    #speedSlider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #f2f2f2;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.5);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    }
  </style>
</head>
<body>
  <canvas id="bloom"></canvas>

  <div id="speedControl">
    <div id="speedLabel">Pulse / Drift</div>
    <input type="range" id="speedSlider" min="20" max="260" value="120" />
  </div>

  <script>
    const canvas = document.getElementById("bloom");
    const ctx = canvas.getContext("2d");

    const speedControl = document.getElementById("speedControl");
    const speedSlider = document.getElementById("speedSlider");

    let speedMultiplier = 1.2;
    let hideTimeout;
    let time = 0;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    resizeCanvas();

    window.addEventListener("resize", resizeCanvas);

    function getCenter() {
      return {
        x: canvas.width / 2,
        y: canvas.height / 2,
      };
    }

    // Show / hide speed control & cursor
    document.addEventListener("mousemove", () => {
      speedControl.classList.add("visible");
      document.body.style.cursor = "auto";

      clearTimeout(hideTimeout);
      hideTimeout = setTimeout(() => {
        speedControl.classList.remove("visible");
        document.body.style.cursor = "none";
      }, 2000);
    });

    // Speed slider
    speedSlider.addEventListener("input", (e) => {
      const val = e.target.value / 120;
      // Add some non-linearity so extremes feel more dramatic
      speedMultiplier = Math.pow(val, 1.4);
    });

    function hsla(h, s, l, a) {
      return `hsla(${h}, ${s}%, ${l}%, ${a})`;
    }

    // Main layers
    const symmetry = 20;
    const baseRadius = 120;

    function drawBreathingBackground(center) {
      const maxR = Math.hypot(canvas.width, canvas.height) * 0.7;
      const t = time * 0.4;
      const pulse = Math.sin(t) * 0.18 + 0.4;

      const gradient = ctx.createRadialGradient(
        center.x,
        center.y,
        maxR * 0.1,
        center.x,
        center.y,
        maxR
      );

      const hueA = (t * 40) % 360;
      const hueB = (t * 40 + 120) % 360;
      const hueC = (t * 40 + 240) % 360;

      gradient.addColorStop(
        0,
        hsla(hueA, 80, 50 + pulse * 10, 1)
      );
      gradient.addColorStop(
        0.45,
        hsla(hueB, 70, 22 + pulse * 12, 1)
      );
      gradient.addColorStop(
        0.9,
        hsla(hueC, 65, 7 + pulse * 12, 1)
      );

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawFractalPetalRing(radius, layers, phase) {
      const petals = 40;
      ctx.save();

      for (let layer = 0; layer < layers; layer++) {
        const r = radius + layer * 14;
        const localPhase = phase + layer * 0.5;
        const hueShift = (time * 60 + layer * 20) % 360;
        const alphaBase = 0.45 - layer * 0.03;

        ctx.beginPath();
        for (let i = 0; i <= petals; i++) {
          const t = i / petals;
          const angle = t * Math.PI * 2;

          const n1 = Math.sin(angle * 3 + localPhase * 1.3) * 22;
          const n2 = Math.cos(angle * 5 - localPhase * 0.9) * 14;
          const n3 = Math.sin(angle * 9 + localPhase * 2.2) * 8;

          const rr = r + n1 + n2 + n3;
          const x = Math.cos(angle) * rr;
          const y = Math.sin(angle) * rr;

          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();

        const hue = (hueShift + layer * 8) % 360;
        ctx.strokeStyle = hsla(hue, 80, 70, alphaBase);
        ctx.lineWidth = 1.8 - layer * 0.08;
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawSpiralArcs(radius, bands, phase) {
      ctx.save();

      for (let band = 0; band < bands; band++) {
        const r = radius + band * 30;
        const thickness = 18 + Math.sin(time * 2 + band) * 6;
        const hueBase = (time * 90 + band * 30) % 360;

        const segments = 24;
        for (let i = 0; i < segments; i++) {
          const startAngle =
            (Math.PI * 2 * (i / segments)) +
            phase * 0.8 +
            band * 0.12;
          const endAngle = startAngle + Math.PI / 10;

          const wobble =
            Math.sin(time * 4 + i * 1.5 + band * 0.9) * 10;
          const rr = r + wobble;

          const grad = ctx.createRadialGradient(
            Math.cos(startAngle) * rr * 1.02,
            Math.sin(startAngle) * rr * 1.02,
            rr * 0.4,
            Math.cos(startAngle) * rr,
            Math.sin(startAngle) * rr,
            rr * 1.4
          );

          grad.addColorStop(
            0,
            hsla((hueBase + i * 5) % 360, 95, 82, 0.9)
          );
          grad.addColorStop(
            0.4,
            hsla((hueBase + i * 5 + 40) % 360, 90, 62, 0.7)
          );
          grad.addColorStop(
            1,
            hsla((hueBase + i * 5 + 80) % 360, 75, 30, 0)
          );

          ctx.strokeStyle = grad;
          ctx.lineWidth = thickness;
          ctx.beginPath();
          ctx.arc(0, 0, rr, startAngle, endAngle);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    function drawNoiseHalo(radius, count, phase) {
      ctx.save();

      for (let i = 0; i < count; i++) {
        const angle =
          (Math.PI * 2 * i) / count +
          phase +
          Math.sin(time * 5 + i * 0.37) * 0.12;
        const jitter =
          Math.sin(time * 7 + i * 1.1) * 18 +
          Math.cos(time * 3.5 + i * 0.7) * 10;
        const r = radius + jitter;

        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;

        const size =
          2.5 +
          Math.sin(time * 6 + i * 0.9) * 1.5 +
          Math.random() * 0.6;

        const hue = (time * 120 + i * 3) % 360;
        const alpha = 0.26 + Math.sin(time * 4 + i) * 0.12;

        const grad = ctx.createRadialGradient(
          x,
          y,
          0,
          x,
          y,
          size * 3
        );
        grad.addColorStop(0, hsla(hue, 90, 85, alpha));
        grad.addColorStop(0.5, hsla(hue, 80, 55, alpha * 0.7));
        grad.addColorStop(1, hsla(hue, 70, 25, 0));

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, size * 3, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawCorePortal() {
      const rings = 18;
      const maxR = 70;

      for (let i = 0; i < rings; i++) {
        const t = i / (rings - 1);
        const wobble =
          Math.sin(time * 5 - i * 0.5) * 2.5 +
          Math.cos(time * 3.2 + i * 0.7) * 1.5;
        const r = t * maxR + wobble;

        const hue = (time * 180 + i * 10) % 360;
        const alpha = 0.9 - t * 0.9;

        ctx.beginPath();
        const points = 80;
        for (let p = 0; p <= points; p++) {
          const a = (Math.PI * 2 * p) / points;
          const innerNoise =
            Math.sin(a * 6 + time * 7 + i * 0.6) * (2 + t * 4);
          const rr = r + innerNoise;
          const x = Math.cos(a) * rr;
          const y = Math.sin(a) * rr;
          if (p === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();

        ctx.strokeStyle = hsla(hue, 90, 80, alpha * 0.8);
        ctx.lineWidth = 2.6 - t * 2.1;
        ctx.stroke();
      }

      // Bright center flash
      const flashPulse = Math.sin(time * 8) * 0.5 + 0.7;
      const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 26);
      grad.addColorStop(0, `rgba(255, 255, 255, ${0.95 * flashPulse})`);
      grad.addColorStop(0.4, `rgba(255, 245, 230, ${0.7 * flashPulse})`);
      grad.addColorStop(1, "rgba(255, 225, 190, 0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(0, 0, 26, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawRadialFractals(radius, branches, phase) {
      ctx.save();

      for (let i = 0; i < branches; i++) {
        const baseAngle =
          (Math.PI * 2 * i) / branches +
          phase +
          Math.sin(time * 2.7 + i * 0.5) * 0.08;

        const length = radius;
        const segments = 6;

        let x = 0;
        let y = 0;
        let angle = baseAngle;

        ctx.beginPath();
        ctx.moveTo(x, y);

        for (let s = 0; s < segments; s++) {
          const segT = s / segments;
          const segLen = length * (0.18 + 0.12 * s);

          angle +=
            Math.sin(time * 3 + i * 0.7 + s * 0.8) * 0.38;

          x += Math.cos(angle) * segLen;
          y += Math.sin(angle) * segLen;

          ctx.lineTo(x, y);
        }

        const hue = (time * 90 + i * 7) % 360;
        const alpha = 0.5 + Math.sin(time * 5 + i) * 0.25;

        ctx.strokeStyle = hsla(hue, 92, 80, alpha);
        ctx.lineWidth = 1.2;
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawBloom() {
      const center = getCenter();

      // Soft motion jitter in speed (for unpredictable acceleration / slowing)
      const erratic =
        Math.sin(time * 1.5) * 0.35 +
        Math.sin(time * 0.37) * 0.15;
      const dt = 0.018 * speedMultiplier * (1 + erratic * 0.5);

      drawBreathingBackground(center);

      ctx.save();
      ctx.translate(center.x, center.y);

      const phase = time * 1.6;

      // Symmetric structure
      ctx.save();
      const rotationSym = (Math.PI * 2) / symmetry;

      for (let i = 0; i < symmetry; i++) {
        ctx.save();
        ctx.rotate(rotationSym * i);

        drawFractalPetalRing(baseRadius, 4, phase + i * 0.15);
        drawRadialFractals(baseRadius * 1.3, 3, phase * 0.9 + i * 0.24);

        ctx.restore();
      }
      ctx.restore();

      drawSpiralArcs(baseRadius * 1.4, 5, phase * 0.7);
      drawNoiseHalo(baseRadius * 2.2, 220, phase * 0.4);

      drawCorePortal();

      ctx.restore();

      time += dt;
      requestAnimationFrame(drawBloom);
    }

    drawBloom();
  </script>
</body>
</html>
