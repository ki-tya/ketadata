<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ASSOCIATION FIELD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      cursor: none;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      filter: contrast(1.35);
    }
  </style>
</head>
<body>
  <canvas id="field"></canvas>

  <script>
    const canvas = document.getElementById("field");
    const ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener("resize", resize);

    const NODES = 64;
    const nodes = [];
    let t = 0;

    function randRange(a, b) {
      return a + Math.random() * (b - a);
    }

    function initNodes() {
      nodes.length = 0;
      const { width: w, height: h } = canvas;
      const cx = w / 2;
      const cy = h / 2;
      const maxR = Math.min(w, h) * 0.42;

      for (let i = 0; i < NODES; i++) {
        const u = i / NODES;
        // radial-ish distribution: some structure, some noise
        const angle = u * Math.PI * 2 + randRange(-0.3, 0.3);
        const radius = maxR * (0.2 + 0.7 * Math.sqrt(Math.random()));
        const jitterX = randRange(-30, 30);
        const jitterY = randRange(-30, 30);

        nodes.push({
          x: cx + Math.cos(angle) * radius + jitterX,
          y: cy + Math.sin(angle) * radius + jitterY,
          baseX: 0, // not used but kept for potential morphing
          baseY: 0,
          phase: Math.random() * Math.PI * 2,
          weight: Math.random()
        });
      }
    }

    initNodes();

    function dist(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function draw() {
      const { width: w, height: h } = canvas;
      const cx = w / 2;
      const cy = h / 2;

      // Slight trail, not full clear: memory of previous activations
      ctx.fillStyle = "rgba(0,0,0,0.24)";
      ctx.fillRect(0, 0, w, h);

      ctx.save();
      ctx.globalCompositeOperation = "lighter";

      // subtle center glow = baseline activity
      const coreR = Math.min(w, h) * 0.18;
      const coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR);
      coreGrad.addColorStop(0, "rgba(255,255,255,0.08)");
      coreGrad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = coreGrad;
      ctx.beginPath();
      ctx.arc(cx, cy, coreR, 0, Math.PI * 2);
      ctx.fill();

      // pick a moving "focus" seed for association chains
      const focusIndex = Math.floor((Math.sin(t * 0.4) * 0.5 + 0.5) * (NODES - 1));
      const focus = nodes[focusIndex];

      // --- EDGES: association strengths between nodes ---
      for (let i = 0; i < NODES; i++) {
        const a = nodes[i];

        // "activation" of a node based on time + proximity to focus
        const dFocus = dist(a, focus) / Math.min(w, h);
        const closeness = Math.max(0, 1 - dFocus * 2.2);
        const localPhase = t * 1.6 + a.phase;
        const activation = (Math.sin(localPhase * 1.1) * 0.5 + 0.5) * 0.6 + closeness * 0.8;

        for (let j = i + 1; j < NODES; j++) {
          const b = nodes[j];
          const d = dist(a, b);

          const maxLinkDist = Math.min(w, h) * 0.5;
          if (d > maxLinkDist) continue;

          // base affinity from distance: closer = stronger
          const proximity = Math.max(0, 1 - d / maxLinkDist);

          // time-based flicker different per pair
          const pairPhase = t * 2.2 + i * 3.17 + j * 1.91;
          const flicker = (Math.sin(pairPhase) + 1) / 2;

          const strength = (activation + flicker * 0.7) * proximity;

          // only draw associations above a threshold
          if (strength > 0.28) {
            const alpha = (strength - 0.28) * 1.4;
            const lineWidth = 0.4 + strength * 1.7;

            // brighter if one of them is close to focus
            const focusBoost = (i === focusIndex || j === focusIndex) ? 0.3 : 0;
            const finalAlpha = Math.min(1, alpha + focusBoost);

            ctx.strokeStyle = `rgba(255,255,255,${finalAlpha})`;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }
        }
      }

      // --- HIGHLIGHTED PATH: one active association chain ---
      ctx.lineWidth = 2.2;
      ctx.strokeStyle = "rgba(255,255,255,0.98)";
      let current = focusIndex;
      ctx.beginPath();
      ctx.moveTo(nodes[current].x, nodes[current].y);

      const chainLength = 10;
      for (let step = 0; step < chainLength; step++) {
        let bestIdx = current;
        let bestScore = -Infinity;
        for (let j = 0; j < NODES; j++) {
          if (j === current) continue;
          const a = nodes[current];
          const b = nodes[j];
          const d = dist(a, b);
          if (d === 0) continue;

          const proximity = Math.max(0, 1 - d / (Math.min(w, h) * 0.4));
          const temporal = Math.sin(t * 1.8 + j * 0.9 + step * 1.3) * 0.5 + 0.5;
          const score = proximity * 0.7 + temporal * 0.8;

          if (score > bestScore) {
            bestScore = score;
            bestIdx = j;
          }
        }
        current = bestIdx;
        ctx.lineTo(nodes[current].x, nodes[current].y);
      }
      ctx.stroke();

      // --- NODES: concepts themselves ---
      for (let i = 0; i < NODES; i++) {
        const n = nodes[i];
        const dFocus = dist(n, focus) / Math.min(w, h);
        const closeness = Math.max(0, 1 - dFocus * 3);

        const baseSize = 2.4 + closeness * 5;
        const pulse = Math.sin(t * 3.2 + n.phase * 2) * 0.5 + 0.5;
        const size = baseSize + pulse * 1.6 * (i === focusIndex ? 1.7 : 0.8);

        const alpha = 0.45 + closeness * 0.5 + (i === focusIndex ? 0.3 : 0);
        ctx.fillStyle = `rgba(255,255,255,${Math.min(1, alpha)})`;
        ctx.beginPath();
        ctx.arc(n.x, n.y, size, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();

      t += 0.015;
      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>
