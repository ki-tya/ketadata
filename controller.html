<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>KETADATA — TESTER</title>

<style>
:root{
  /* core */
  --void:#000;
  --fg:#fff;
  --muted:#666;
  --hot:#ffffff;

  /* gradients (editable) */
  --bg1:#050508;
  --bg2:#120000;
  --tx1:#ffffff;
  --tx2:#ff2a2a; /* richer, less muted */

  /* motion */
  --spinSpeed: 18s;   /* hue spin period */
  --radialSpeed: 14s; /* radial angle drift period */

  /* fonts */
  --nameFont: Arial, Helvetica, sans-serif;
  --uiFont: Arial, Helvetica, sans-serif;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
}

*{ box-sizing:border-box; }
html,body{ height:100%; }
body{
  margin:0;
  background:var(--void);
  color:var(--fg);
  font-family:var(--uiFont);
  overflow:hidden;
}

/* ======= VISUAL SURFACE (this is what we flash) ======= */
.stage{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  /* base gradient */
  background:
    radial-gradient(circle at var(--radialX, 50%) var(--radialY, 50%), var(--bg1), var(--bg2));
  /* subtle “laser” feel via blend */
  background-blend-mode: screen;
  will-change: filter, background, transform;
}

/* optional continuous hue spin (dark-mode UI vibe) */
.stage.huespin{
  animation: hueSpin var(--spinSpeed) linear infinite;
}
@keyframes hueSpin{
  from{ filter:hue-rotate(0deg); }
  to{ filter:hue-rotate(360deg); }
}

/* ======= BIG WORD ======= */
.word{
  font-family:var(--nameFont);
  font-weight:900;
  letter-spacing:.06em;
  white-space:nowrap;
  line-height:.92;
  user-select:none;
  /* text gradient */
  background: linear-gradient(90deg, var(--tx1), var(--tx2));
  -webkit-background-clip:text;
  background-clip:text;
  color:transparent;
  padding: 0.1em 0.02em;
}

/* ======= INPUT (bottom center) ======= */
.inputWrap{
  position:fixed;
  left:50%;
  bottom:18px;
  transform:translateX(-50%);
  width:min(520px, 92vw);
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:center;
}
.inputWrap input{
  width:100%;
  background:transparent;
  color:var(--fg);
  border:1px solid rgba(255,255,255,.18);
  padding:10px 12px;
  font-size:11px;
  letter-spacing:.22em;
  text-transform:uppercase;
  outline:none;
}
.inputWrap .hint{
  font-family:var(--mono);
  font-size:10px;
  letter-spacing:.18em;
  color:rgba(255,255,255,.55);
  white-space:nowrap;
}

/* ======= OPEN-PLAN PANELS ======= */
.dock{
  position:fixed;
  top:14px;
  left:14px;
  right:14px;
  display:grid;
  grid-template-columns: 1.2fr 1fr;
  gap:12px;
  pointer-events:none; /* panels re-enable */
}
.panel{
  pointer-events:auto;
  background: rgba(0,0,0,.72);
  border:1px solid rgba(255,255,255,.14);
  padding:12px;
}
.panelHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom:10px;
}
.panelHeader b{
  font-family:var(--mono);
  font-size:11px;
  letter-spacing:.22em;
  text-transform:uppercase;
}
.panelHeader .mini{
  font-family:var(--mono);
  font-size:10px;
  letter-spacing:.18em;
  color:rgba(255,255,255,.55);
}
.toggle{
  background:transparent;
  border:1px solid rgba(255,255,255,.18);
  color:var(--muted);
  padding:7px 10px;
  font-size:11px;
  letter-spacing:.18em;
  font-family:var(--mono);
  cursor:pointer;
}
.toggle:hover{ color:var(--hot); border-color:rgba(255,255,255,.45); }

.rows{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px 14px;
}
@media (max-width: 980px){
  .dock{ grid-template-columns: 1fr; }
  .rows{ grid-template-columns: 1fr; }
}

/* controls */
.ctrl{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.label{
  font-family:var(--mono);
  font-size:10px;
  letter-spacing:.18em;
  color:rgba(255,255,255,.62);
  text-transform:uppercase;
}
.rangeRow{
  display:flex;
  gap:10px;
  align-items:center;
}
input[type="range"]{ width:100%; }
select, input[type="color"]{
  background:transparent;
  color:var(--fg);
  border:1px solid rgba(255,255,255,.18);
  padding:8px 10px;
  font-size:11px;
  letter-spacing:.12em;
  outline:none;
  width:100%;
}
small.kbd{
  font-family:var(--mono);
  font-size:10px;
  letter-spacing:.12em;
  color:rgba(255,255,255,.55);
}
.kbdKey{
  display:inline-block;
  border:1px solid rgba(255,255,255,.22);
  padding:2px 6px;
  margin:0 4px;
  font-family:var(--mono);
  font-size:10px;
  letter-spacing:.12em;
  color:rgba(255,255,255,.72);
}

/* link-like buttons */
.kRow{ display:flex; gap:8px; flex-wrap:wrap; }
.kBtn{
  background:transparent;
  border:none;
  color:#666;
  font-family:var(--mono);
  font-size:11px;
  letter-spacing:.18em;
  cursor:pointer;
  padding:6px 0;
  text-transform:uppercase;
}
.kBtn:hover{ color:#fff; }
.kBtn[data-active="true"]{ color:#fff; }

.hidden{ display:none; }
</style>
</head>

<body>

<div id="stage" class="stage huespin">
  <div id="word" class="word">WHATEVER</div>
</div>

<div class="dock">

  <!-- TESTER (roomy) -->
  <div class="panel" id="tester">
    <div class="panelHeader">
      <b>[TESTER]</b>
      <div style="display:flex; gap:10px; align-items:center;">
        <span class="mini">OPEN / PLAN</span>
        <button class="toggle" id="toggleTester">[TOGGLE]</button>
      </div>
    </div>

    <div id="testerBody">
      <div class="rows">
        <div class="ctrl">
          <div class="label">NAME FONT</div>
          <select id="nameFont">
            <option value="Arial, Helvetica, sans-serif">ARIAL (SANS)</option>
            <option value="ui-sans-serif, system-ui, -apple-system, 'Helvetica Neue', Helvetica, Arial, sans-serif">SYSTEM UI</option>
            <option value="'Helvetica Neue', Helvetica, Arial, sans-serif">HELVETICA NEUE</option>
            <option value="'Arial Black', Arial, sans-serif">ARIAL BLACK</option>
          </select>
          <small class="kbd">UI FONT stays ARIAL per spec.</small>
        </div>

        <div class="ctrl">
          <div class="label">TEXT SIZE (MANUAL)</div>
          <div class="rangeRow">
            <input id="textScale" type="range" min="0" max="100" value="50" />
          </div>
          <small class="kbd">Still auto-fits; this biases the fit.</small>
        </div>

        <div class="ctrl">
          <div class="label">TEXT GRADIENT A</div>
          <input type="color" id="tx1" value="#ffffff">
        </div>

        <div class="ctrl">
          <div class="label">TEXT GRADIENT B (HOT RED)</div>
          <input type="color" id="tx2" value="#ff2a2a">
        </div>

        <div class="ctrl">
          <div class="label">BG GRADIENT A</div>
          <input type="color" id="bg1" value="#050508">
        </div>

        <div class="ctrl">
          <div class="label">BG GRADIENT B (DARKROOM)</div>
          <input type="color" id="bg2" value="#120000">
          <small class="kbd">Try dried-blood: #2a0000 / #3a0000.</small>
        </div>

        <div class="ctrl">
          <div class="label">HUE SPIN SPEED</div>
          <input id="spinSpeed" type="range" min="4" max="40" value="18"/>
          <small class="kbd">Lower = faster rotation.</small>
        </div>

        <div class="ctrl">
          <div class="label">RADIAL DRIFT SPEED</div>
          <input id="radialSpeed" type="range" min="4" max="40" value="14"/>
          <small class="kbd">Auto-moving radial angle.</small>
        </div>
      </div>

      <div style="margin-top:10px;">
        <small class="kbd">
          <span class="kbdKey">SPACE</span> toggle current light
          <span class="kbdKey">1–6</span> select + start
          <span class="kbdKey">0</span> stop
        </small>
      </div>
    </div>
  </div>

  <!-- LIGHT CONTROLLER -->
  <div class="panel" id="lights">
    <div class="panelHeader">
      <b>[STROBE EFFECTS]</b>
      <div style="display:flex; gap:10px; align-items:center;">
        <span class="mini" id="status">OFF</span>
        <button class="toggle" id="toggleLights">[TOGGLE]</button>
      </div>
    </div>

    <div id="lightsBody">
      <div class="kRow">
        <button class="kBtn" data-e="1">[1 STROBE]</button>
        <button class="kBtn" data-e="2">[2 EMDR]</button>
        <button class="kBtn" data-e="3">[3 NYAN]</button>
        <button class="kBtn" data-e="4">[4 HEARTBEAT]</button>
        <button class="kBtn" data-e="5">[5 VIOLET/UV]</button>
        <button class="kBtn" data-e="6">[6 PAPARAZZI]</button>
      </div>

      <div style="margin-top:10px;" class="rows">
        <div class="ctrl">
          <div class="label">EFFECT SPEED</div>
          <input id="fxSpeed" type="range" min="10" max="120" value="50"/>
          <small class="kbd">Lower = faster.</small>
        </div>
        <div class="ctrl">
          <div class="label">INTENSITY</div>
          <input id="fxIntensity" type="range" min="0" max="100" value="70"/>
          <small class="kbd">Affects contrast/brightness.</small>
        </div>
      </div>
    </div>
  </div>

</div>

<div class="inputWrap">
  <input id="textInput" maxlength="11" placeholder="TYPE PHRASE (MAX 11)"/>
  <div class="hint">ENTER TO APPLY</div>
</div>

<script>
/* ===== DOM ===== */
const stage = document.getElementById("stage");
const word  = document.getElementById("word");
const input = document.getElementById("textInput");

const testerBody = document.getElementById("testerBody");
const lightsBody = document.getElementById("lightsBody");
document.getElementById("toggleTester").onclick = ()=> testerBody.classList.toggle("hidden");
document.getElementById("toggleLights").onclick = ()=> lightsBody.classList.toggle("hidden");

/* ===== AUTO FIT (edge-to-edge) ===== */
let bias = 0; // from slider
function fit(){
  // start guess based on viewport width
  let size = Math.max(40, Math.floor(innerWidth * 0.12));
  size = size + Math.floor((bias - 50) * 2); // bias influence
  word.style.fontSize = size + "px";

  // tighten/expand until it fits ~98.5% width
  const target = innerWidth * 0.985;
  let guard = 0;

  while(word.scrollWidth < target && guard < 250){
    size += 2;
    word.style.fontSize = size + "px";
    guard++;
  }
  while(word.scrollWidth > target && size > 10 && guard < 500){
    size -= 2;
    word.style.fontSize = size + "px";
    guard++;
  }
}
window.addEventListener("resize", fit);

input.addEventListener("keydown",(e)=>{
  if(e.key === "Enter"){
    word.textContent = (input.value || "WHATEVER").toUpperCase();
    fit();
  }
});

/* ===== UI CONTROLS ===== */
document.body.style.fontFamily = "Arial, Helvetica, sans-serif"; // UI font spec

document.getElementById("nameFont").onchange = (e)=>{
  document.documentElement.style.setProperty("--nameFont", e.target.value);
  fit();
};

document.getElementById("textScale").oninput = (e)=>{
  bias = parseInt(e.target.value, 10);
  fit();
};

["bg1","bg2","tx1","tx2"].forEach(id=>{
  document.getElementById(id).oninput = (e)=>{
    document.documentElement.style.setProperty(`--${id}`, e.target.value);
  };
});

document.getElementById("spinSpeed").oninput = (e)=>{
  document.documentElement.style.setProperty("--spinSpeed", `${e.target.value}s`);
};
document.getElementById("radialSpeed").oninput = (e)=>{
  document.documentElement.style.setProperty("--radialSpeed", `${e.target.value}s`);
};

/* ===== RADIAL DRIFT (auto-moving angle) ===== */
let rT = 0;
function radialTick(){
  rT += 0.01;
  // map to 0..100 for gradient anchor
  const x = 50 + Math.cos(rT) * 28;
  const y = 50 + Math.sin(rT*1.17) * 22;
  stage.style.setProperty("--radialX", x + "%");
  stage.style.setProperty("--radialY", y + "%");
  requestAnimationFrame(radialTick);
}
radialTick();

/* ===== LIGHT ENGINE (applies to STAGE, not BODY) ===== */
let activeEffect = 0;   // 1..6
let running = false;
let fxTimer = null;
let fxCount = 0;

const status = document.getElementById("status");
const fxSpeed = document.getElementById("fxSpeed");
const fxIntensity = document.getElementById("fxIntensity");
const effectButtons = Array.from(document.querySelectorAll(".kBtn[data-e]"));

function setStatus(){
  status.textContent = running ? `ON — ${activeEffect || "?"}` : "OFF";
}
function paintButtons(){
  effectButtons.forEach(b=>{
    b.dataset.active = (parseInt(b.dataset.e,10) === activeEffect) ? "true" : "false";
  });
}

function clearFX(){
  clearInterval(fxTimer);
  fxTimer = null;
  fxCount = 0;
  stage.style.filter = "none";
  stage.style.backgroundColor = "";
  // restore gradient surface (keep huespin/radial)
  stage.classList.add("huespin");
}

function startFX(){
  if(!activeEffect) return;
  clearFX();
  running = true;
  setStatus();
  paintButtons();

  // when effects run, we temporarily kill hue spin so effects read clean/aggressive
  stage.classList.remove("huespin");

  const interval = () => Math.max(10, parseInt(fxSpeed.value,10));
  const inten = () => Math.max(0, Math.min(100, parseInt(fxIntensity.value,10)));

  fxTimer = setInterval(()=>{
    fxCount++;
    const I = inten()/100;

    // 1 STROBE (B/W)
    if(activeEffect === 1){
      const on = (fxCount % 2 === 0);
      stage.style.background = on ? "#ffffff" : "#000000";
      stage.style.filter = `contrast(${1.5 + I*2.5}) brightness(${1 + I*0.8})`;
    }

    // 2 EMDR (left-right flashes; simulated by moving gradient anchor + alternating)
    if(activeEffect === 2){
      const on = (fxCount % 2 === 0);
      const x = on ? "25%" : "75%";
      stage.style.background =
        `radial-gradient(circle at ${x} 50%, #ffffff, #000000 60%)`;
      stage.style.filter = `contrast(${1.6 + I*2.2}) brightness(${1 + I*0.7})`;
    }

    // 3 NYAN (fast chroma pulses)
    if(activeEffect === 3){
      const hue = (fxCount * 36) % 360;
      const light = 40 + Math.sin(fxCount*0.35) * 25;
      stage.style.background = `hsl(${hue}, 100%, ${light}%)`;
      stage.style.filter = `saturate(${2 + I*4}) contrast(${1.2 + I*2}) brightness(${1 + I*0.8})`;
    }

    // 4 HEARTBEAT (two-beat red pulse)
    if(activeEffect === 4){
      const beat = fxCount % 18;
      const pulse = (beat === 0 || beat === 2) ? 1 : (beat < 6 ? 0.35 : 0);
      const red = Math.floor(40 + pulse * 215);
      stage.style.background = `rgb(${red},0,0)`;
      stage.style.filter = `contrast(${1.4 + I*2.2}) brightness(${1 + pulse*(0.9 + I)})`;
    }

    // 5 VIOLET/UV (spiral-ish violet drift)
    if(activeEffect === 5){
      const hue = 270 + Math.sin(fxCount*0.18) * 35;
      const light = 20 + Math.abs(Math.sin(fxCount*0.12)) * 45;
      stage.style.background = `hsl(${hue}, 95%, ${light}%)`;
      stage.style.filter = `hue-rotate(${fxCount*2}deg) saturate(${2 + I*4}) contrast(${1.4 + I*2.2}) brightness(${1 + I*0.7})`;
    }

    // 6 PAPARAZZI (double-flash cadence)
    if(activeEffect === 6){
      const m = fxCount % 50;
      const flash = (m === 0 || m === 2);
      stage.style.background = flash ? "#ffffff" : "#000000";
      stage.style.filter = flash
        ? `brightness(${2.5 + I*4}) contrast(${2 + I*4})`
        : "none";
    }
  }, interval());
}

function stopFX(){
  running = false;
  setStatus();
  clearFX();
}

function toggleFX(){
  if(!activeEffect){
    activeEffect = 1; // default to strobe
    paintButtons();
  }
  if(running) stopFX();
  else startFX();
}

/* Buttons: select + start immediately */
effectButtons.forEach(btn=>{
  btn.addEventListener("click", ()=>{
    activeEffect = parseInt(btn.dataset.e,10);
    paintButtons();
    startFX();
  });
});

/* Sliders update while running */
fxSpeed.oninput = ()=>{ if(running) startFX(); };
fxIntensity.oninput = ()=>{ /* intensity read live each tick */ };

/* Keyboard */
document.addEventListener("keydown",(e)=>{
  if(e.code === "Space"){
    e.preventDefault();
    toggleFX();
    return;
  }
  if(e.key === "0"){
    stopFX();
    return;
  }
  if(e.key >= "1" && e.key <= "6"){
    activeEffect = parseInt(e.key,10);
    paintButtons();
    startFX();
    return;
  }
});

/* init */
word.textContent = "WHATEVER";
fit();
paintButtons();
setStatus();
</script>

</body>
</html>
