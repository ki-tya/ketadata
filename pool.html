<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA // INFINITY POOL</title>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --stroke:rgba(255,255,255,0.16);
      --stroke2:rgba(255,255,255,0.10);
      --glass:rgba(255,255,255,0.06);
      --muted:rgba(255,255,255,0.55);
      --muted2:rgba(255,255,255,0.38);
      --panel:rgba(0,0,0,0.90);
      --shadow:rgba(0,0,0,0.78);
      --w: #ffffff;
      --b: #000000;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Arial, Helvetica, sans-serif;}
    body{overflow:hidden;}
    button,input,select{font-family:inherit}

    /* Top bar */
    #topbar{
      position:fixed; inset:0 0 auto 0;
      height:48px;
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid var(--stroke2);
      background:#000;
      user-select:none;
      z-index:50;
    }
    #brand{
      display:flex; align-items:center; gap:10px;
      font-size:11px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.80);
      min-width:240px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .whiteBox{width:10px;height:10px;background:#fff;display:inline-block;}
    .btn{
      border:1px solid var(--stroke);
      background:transparent;
      color:rgba(255,255,255,0.86);
      padding:7px 10px;
      font-size:11px;
      letter-spacing:0.14em;
      text-transform:uppercase;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{background:var(--glass);border-color:rgba(255,255,255,0.34);}
    .btnPrimary{background:rgba(255,255,255,0.06);border-color:rgba(255,255,255,0.30);}
    .btnPrimary:hover{background:rgba(255,255,255,0.09);border-color:rgba(255,255,255,0.44);}

    /* Required primitive: NOTE icon */
    #noteIcon{
      width:28px;height:28px;
      display:grid;place-items:center;
      border:1px solid rgba(255,255,255,0.20);
      background:rgba(255,255,255,0.10);
      cursor:pointer;
    }
    #noteIcon:hover{border-color:rgba(255,255,255,0.36);background:rgba(255,255,255,0.14);}

    /* Stage */
    #stage{
      position:fixed; inset:48px 0 0 0;
      background:#000;
    }
    canvas{display:block;width:100%;height:100%}

    /* CC button (control layer toggle) */
    #ccBtn{
      position:fixed;
      right:12px; top:60px;
      width:28px;height:28px;
      border:1px solid rgba(255,255,255,0.24);
      background:rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      cursor:pointer;
      display:grid;place-items:center;
      padding:0;
      z-index:60;
    }
    #ccBtn:hover{background:rgba(255,255,255,0.06);border-color:rgba(255,255,255,0.38);}
    #ccGlyph{width:10px;height:10px;border:1px solid rgba(255,255,255,0.55);opacity:0.85;}

    /* Control panel (off-stage) */
    #panel{
      position:fixed;
      left:12px; top:60px;
      width:min(360px, calc(100% - 24px));
      border:1px solid rgba(255,255,255,0.22);
      background:var(--panel);
      box-shadow:0 28px 110px rgba(0,0,0,0.82);
      padding:12px;
      display:none;
      z-index:70;
    }
    #panel.open{display:block;}
    #panelHeader{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      margin-bottom:10px;
      user-select:none;
    }
    #panelHeader .t{
      margin:0;
      font-size:11px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.84);
      display:flex;align-items:center;gap:10px;
    }
    .field{display:grid;gap:6px;margin-bottom:10px;}
    label{
      font-size:11px;
      letter-spacing:0.12em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.60);
    }
    input[type="range"]{width:100%}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
    .stat{
      font-size:10px;
      letter-spacing:0.16em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.46);
    }

    /* Hotkey nodes (subtle) */
    .node{
      position:fixed;
      width:8px;height:8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(255,255,255,0.06);
      opacity:0.32;
      z-index:65;
      cursor:pointer;
      user-select:none;
    }
    .node:hover{opacity:0.80;border-color:rgba(255,255,255,0.34);background:rgba(255,255,255,0.12);}
    #n1{left:12px;bottom:12px;}
    #n2{left:28px;bottom:28px;}
    #n3{left:44px;bottom:12px;}

    /* Global note modal */
    #modalBack{
      position:fixed; inset:0;
      background:rgba(0,0,0,0.72);
      display:none;
      z-index:90;
    }
    #modal{
      position:absolute; right:16px; top:58px;
      width:min(520px, calc(100% - 32px));
      border:1px solid rgba(255,255,255,0.22);
      background:rgba(0,0,0,0.92);
      box-shadow:0 28px 110px rgba(0,0,0,0.82);
      padding:12px;
    }
    #modalTitle{
      margin:0 0 10px 0;
      font-size:11px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.82);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      user-select:none;
    }
    textarea{
      width:100%;
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(255,255,255,0.04);
      color:rgba(255,255,255,0.90);
      padding:9px 10px;
      font-size:12px;
      outline:none;
      resize:vertical;
      min-height:120px;
    }
    textarea:focus{border-color:rgba(255,255,255,0.36);background:rgba(255,255,255,0.06);}

    /* Toast */
    #toast{
      position:fixed;
      left:50%;
      top:68px;
      transform:translateX(-50%);
      padding:8px 10px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.72);
      color:rgba(255,255,255,0.65);
      font-size:11px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      display:none;
      z-index:95;
    }
  </style>
</head>

<body>
  <div id="topbar">
    <div id="brand">
      <span class="whiteBox" aria-hidden="true"></span>
      <span>KETADATA // INFINITY POOL (VI)</span>
    </div>
    <div class="row">
      <button id="noteIcon" type="button" aria-label="Global Note">
        <span class="whiteBox" aria-hidden="true"></span>
      </button>
      <button id="exportState" class="btn btnPrimary" type="button">Export State</button>
      <button id="copyPrompt" class="btn" type="button">Copy Prompt</button>
    </div>
  </div>

  <button id="ccBtn" type="button" aria-label="Command/Control"><span id="ccGlyph" aria-hidden="true"></span></button>

  <!-- subtle hotkey nodes -->
  <div class="node" id="n1" title="1: white mode"></div>
  <div class="node" id="n2" title="2: pulse mode"></div>
  <div class="node" id="n3" title="3: freeze"></div>

  <div id="panel" aria-label="Controls">
    <div id="panelHeader">
      <p class="t"><span class="whiteBox" style="width:9px;height:9px;"></span> COMMAND / CONTROL</p>
      <button id="closePanel" class="btn" type="button">Close</button>
    </div>

    <div class="field">
      <label>Mode</label>
      <div class="row">
        <button id="mPool" class="btn btnPrimary" type="button">Pool</button>
        <button id="mWhite" class="btn" type="button">White</button>
        <button id="mPulse" class="btn" type="button">Pulse</button>
      </div>
      <div class="stat" id="modeStat">MODE: POOL</div>
    </div>

    <div class="field">
      <label for="intensity">Intensity</label>
      <input id="intensity" type="range" min="0" max="100" value="62" />
      <div class="stat" id="intStat">62</div>
    </div>

    <div class="field">
      <label for="wind">Wind / Ripple</label>
      <input id="wind" type="range" min="0" max="100" value="48" />
      <div class="stat" id="windStat">48</div>
    </div>

    <div class="field">
      <label for="horizon">Horizon Lift</label>
      <input id="horizon" type="range" min="0" max="100" value="54" />
      <div class="stat" id="horStat">54</div>
    </div>

    <div class="field">
      <label for="noise">Grain</label>
      <input id="noise" type="range" min="0" max="100" value="18" />
      <div class="stat" id="noiseStat">18</div>
    </div>

    <div class="field">
      <label for="sigil">Sigil Density</label>
      <input id="sigil" type="range" min="0" max="100" value="24" />
      <div class="stat" id="sigilStat">24</div>
      <div class="hint" style="color:rgba(255,255,255,0.42);font-size:11px;letter-spacing:0.04em;">
        Angular = mind lines. Circular = sensor halos. White square = note atom.
      </div>
    </div>
  </div>

  <div id="stage">
    <canvas id="c"></canvas>
  </div>

  <!-- GLOBAL NOTE MODAL -->
  <div id="modalBack" aria-hidden="true">
    <div id="modal" role="dialog" aria-label="Global Note">
      <div id="modalTitle">
        <span><span class="whiteBox" style="width:9px;height:9px;"></span> GLOBAL NOTE</span>
        <button id="closeModal" class="btn" type="button">Close</button>
      </div>
      <div class="field">
        <textarea id="globalNote" placeholder="system constraints / observations"></textarea>
        <div class="stat" style="margin-top:8px;">SAVED IN STATE</div>
      </div>
      <div class="row">
        <button id="saveGlobal" class="btn btnPrimary" type="button">Save</button>
        <button id="clearGlobal" class="btn" type="button">Clear</button>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <script>
    // =========================
    // KETADATA // INFINITY POOL (VI)
    // - infinity plane water shader (canvas)
    // - horizon / sky gradient
    // - subtle sigils: angular (mind), circular (senses)
    // - note primitive: white square icon
    // - CC toggles control panel (off-stage)
    // - hotkey nodes + keyboard: 1/2/3
    // - exportState() + copyPrompt()
    // =========================

    const el = (id)=>document.getElementById(id);
    const c = el('c');
    const ctx = c.getContext('2d', { alpha:false });

    const panel = el('panel');
    const ccBtn = el('ccBtn');
    const closePanel = el('closePanel');

    const noteIcon = el('noteIcon');
    const modalBack = el('modalBack');
    const closeModal = el('closeModal');
    const globalNoteEl = el('globalNote');
    const saveGlobal = el('saveGlobal');
    const clearGlobal = el('clearGlobal');

    const exportStateBtn = el('exportState');
    const copyPromptBtn = el('copyPrompt');

    const mPool = el('mPool');
    const mWhite = el('mWhite');
    const mPulse = el('mPulse');
    const modeStat = el('modeStat');

    const intensity = el('intensity');
    const wind = el('wind');
    const horizon = el('horizon');
    const noise = el('noise');
    const sigil = el('sigil');

    const intStat = el('intStat');
    const windStat = el('windStat');
    const horStat = el('horStat');
    const noiseStat = el('noiseStat');
    const sigilStat = el('sigilStat');

    const n1 = el('n1'), n2 = el('n2'), n3 = el('n3');

    const toastEl = el('toast');

    const uid = ()=>Math.random().toString(36).slice(2,9)+"-"+Date.now().toString(36);
    const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));

    function toast(msg, ms=650){
      toastEl.textContent = msg;
      toastEl.style.display = 'block';
      clearTimeout(toast._t);
      toast._t = setTimeout(()=>{ toastEl.style.display='none'; }, ms);
    }
    async function copyText(s){
      try{ await navigator.clipboard.writeText(s); toast("COPIED"); }
      catch{ window.prompt("Copy:", s); }
    }
    function encode(obj){ return btoa(unescape(encodeURIComponent(JSON.stringify(obj)))); }
    function decode(b64){ return JSON.parse(decodeURIComponent(escape(atob(b64)))); }

    // State
    let state = {
      v: 1,
      page: "ketadata-infinity-pool-vi",
      mode: "pool",  // pool|white|pulse
      intensity: 62,
      wind: 48,
      horizon: 54,
      noise: 18,
      sigil: 24,
      frozen: false,
      globalNote: "",
      seed: uid()
    };

    // load from hash
    (function(){
      const m = location.hash.match(/state=([^&]+)/);
      if(!m) return;
      try{
        const s = decode(m[1]);
        if(s && s.v === 1) state = { ...state, ...s };
      }catch{}
    })();

    // Resize
    let W=0,H=0, DPR=1;
    function resize(){
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      W = Math.floor(window.innerWidth * DPR);
      H = Math.floor((window.innerHeight - 48) * DPR);
      c.width = W;
      c.height = H;
      c.style.width = "100%";
      c.style.height = "100%";
    }
    window.addEventListener('resize', resize);
    resize();

    // UI sync
    function setMode(m){
      state.mode = m;
      mPool.classList.toggle('btnPrimary', m==='pool');
      mWhite.classList.toggle('btnPrimary', m==='white');
      mPulse.classList.toggle('btnPrimary', m==='pulse');
      modeStat.textContent = "MODE: " + m.toUpperCase();
    }
    function syncControls(){
      intensity.value = String(state.intensity);
      wind.value = String(state.wind);
      horizon.value = String(state.horizon);
      noise.value = String(state.noise);
      sigil.value = String(state.sigil);
      intStat.textContent = String(state.intensity);
      windStat.textContent = String(state.wind);
      horStat.textContent = String(state.horizon);
      noiseStat.textContent = String(state.noise);
      sigilStat.textContent = String(state.sigil);
      globalNoteEl.value = state.globalNote || "";
      setMode(state.mode);
    }
    syncControls();

    // Panel toggle (CC)
    function openPanel(){ panel.classList.add('open'); }
    function closePanelFn(){ panel.classList.remove('open'); }

    ccBtn.addEventListener('click', ()=>{
      panel.classList.toggle('open');
    });
    closePanel.addEventListener('click', closePanelFn);

    // Note modal
    function showModal(){
      modalBack.style.display = "block";
      modalBack.setAttribute('aria-hidden','false');
      globalNoteEl.value = state.globalNote || "";
      setTimeout(()=>globalNoteEl.focus(), 0);
    }
    function hideModal(){
      modalBack.style.display = "none";
      modalBack.setAttribute('aria-hidden','true');
    }
    noteIcon.addEventListener('click', showModal);
    closeModal.addEventListener('click', hideModal);
    modalBack.addEventListener('click', (e)=>{ if(e.target===modalBack) hideModal(); });

    saveGlobal.addEventListener('click', ()=>{
      state.globalNote = globalNoteEl.value;
      toast("SAVED");
      hideModal();
    });
    clearGlobal.addEventListener('click', ()=>{
      state.globalNote = "";
      globalNoteEl.value = "";
      toast("CLEARED");
    });

    // Controls -> state
    intensity.addEventListener('input', ()=>{ state.intensity = +intensity.value; intStat.textContent=intensity.value; });
    wind.addEventListener('input', ()=>{ state.wind = +wind.value; windStat.textContent=wind.value; });
    horizon.addEventListener('input', ()=>{ state.horizon = +horizon.value; horStat.textContent=horizon.value; });
    noise.addEventListener('input', ()=>{ state.noise = +noise.value; noiseStat.textContent=noise.value; });
    sigil.addEventListener('input', ()=>{ state.sigil = +sigil.value; sigilStat.textContent=sigil.value; });

    mPool.addEventListener('click', ()=> setMode('pool'));
    mWhite.addEventListener('click', ()=> setMode('white'));
    mPulse.addEventListener('click', ()=> setMode('pulse'));

    // Subtle nodes + hotkeys
    function toggleFreeze(){
      state.frozen = !state.frozen;
      toast(state.frozen ? "FREEZE" : "RUN");
    }
    n1.addEventListener('click', ()=>{ setMode('white'); toast("WHITE"); });
    n2.addEventListener('click', ()=>{ setMode('pulse'); toast("PULSE"); });
    n3.addEventListener('click', toggleFreeze);

    window.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape'){
        if(panel.classList.contains('open')) closePanelFn();
        if(modalBack.style.display === 'block') hideModal();
      }
      if(e.key === '1'){ setMode('white'); }
      if(e.key === '2'){ setMode('pulse'); }
      if(e.key === '0'){ setMode('pool'); }
      if(e.key === '3'){ toggleFreeze(); }
      if(e.key === 'c' || e.key === 'C'){ panel.classList.toggle('open'); }
    });

    // Exports
    function exportState(){
      const safe = JSON.parse(JSON.stringify(state));
      const b64 = encode(safe);
      const url = location.origin + location.pathname + "#state=" + b64;
      return { safe, url };
    }
    function buildPrompt(){
      const s = state;
      const payload = {
        page: s.page,
        mode: s.mode,
        params: {
          intensity: s.intensity,
          wind: s.wind,
          horizon: s.horizon,
          noise: s.noise,
          sigil: s.sigil,
          frozen: s.frozen
        },
        note: s.globalNote || ""
      };
      return [
        "KETADATA VI PROMPT",
        "SCENE: INFINITY POOL / PENTHOUSE VIBE / BLACKFIELD LUX",
        "RULES: minimal UI, CC toggles controls off-stage, hotkeys subtle nodes, mind=angular, senses=circular, note=white square.",
        `MODE: ${s.mode.toUpperCase()}`,
        s.globalNote ? `GLOBAL NOTE: ${s.globalNote}` : "GLOBAL NOTE: (none)",
        "TASK: revise the visual system while preserving primitives; increase spatial depth + horizon illusion; keep no kitsch.",
        "STATE(JSON):",
        JSON.stringify(payload, null, 2)
      ].join("\n");
    }

    exportStateBtn.addEventListener('click', async ()=>{
      const { url } = exportState();
      await copyText(url);
      location.hash = url.split("#")[1];
    });
    copyPromptBtn.addEventListener('click', async ()=>{ await copyText(buildPrompt()); });

    // ========= Visual engine =========
    // A lightweight water plane + horizon + sky gradient + reflections.
    // Uses no external assets. Tuned for "ketadata vibes" (clean, brutal, spectral).

    function randFromSeed(seed){
      // xorshift-ish from string
      let h = 2166136261 >>> 0;
      for(let i=0;i<seed.length;i++){
        h ^= seed.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return function(){
        h += 0x6D2B79F5;
        let t = Math.imul(h ^ (h >>> 15), 1 | h);
        t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    const rng = randFromSeed(state.seed);

    // Pre-generate subtle skyline anchors (abstract)
    const skyline = Array.from({length: 42}, (_,i)=>({
      x: rng(),
      h: 0.08 + rng()*0.22,
      w: 0.006 + rng()*0.02,
      a: 0.05 + rng()*0.12
    })).sort((a,b)=>a.x-b.x);

    function lerp(a,b,t){ return a+(b-a)*t; }

    function drawSky(t){
      const lift = state.horizon/100;
      const yH = Math.floor(H*(0.36 - 0.16*lift)); // horizon line position
      // sky gradient
      const g = ctx.createLinearGradient(0, 0, 0, yH);
      const pulse = (state.mode==='pulse') ? (0.5 + 0.5*Math.sin(t*0.8)) : 0.0;

      const c1 = `rgba(2,2,6,1)`;
      const c2 = `rgba(${Math.floor(12+20*pulse)},${Math.floor(18+26*pulse)},${Math.floor(42+40*pulse)},1)`;
      const c3 = `rgba(${Math.floor(90+70*pulse)},${Math.floor(110+60*pulse)},${Math.floor(140+40*pulse)},1)`;

      g.addColorStop(0, c1);
      g.addColorStop(0.62, c2);
      g.addColorStop(1, c3);

      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,yH);

      // far haze
      const haze = ctx.createLinearGradient(0, yH-40, 0, yH+80);
      haze.addColorStop(0, `rgba(255,255,255,0.00)`);
      haze.addColorStop(1, `rgba(255,255,255,${0.06 + 0.06*(state.intensity/100)})`);
      ctx.fillStyle = haze;
      ctx.fillRect(0,yH-40,W,140);

      // skyline (abstract, minimal)
      ctx.save();
      ctx.translate(0, yH);
      ctx.fillStyle = `rgba(0,0,0,0.55)`;
      skyline.forEach(b=>{
        const x = Math.floor(b.x*W);
        const w = Math.floor(b.w*W);
        const h = Math.floor(b.h*H);
        ctx.globalAlpha = b.a;
        ctx.fillRect(x, -h, w, h);
      });
      ctx.restore();

      return yH;
    }

    function drawDeckAndEdges(yH){
      // deck (left + right negative space)
      ctx.save();
      // left frame
      const frameW = Math.floor(W*0.07);
      ctx.fillStyle = `rgba(0,0,0,0.88)`;
      ctx.fillRect(0,0,frameW,H);
      // right frame (architectural slab)
      const rW = Math.floor(W*0.20);
      ctx.fillRect(W-rW,0,rW,H);

      // thin strokes
      ctx.globalAlpha = 1;
      ctx.strokeStyle = `rgba(255,255,255,0.10)`;
      ctx.lineWidth = Math.max(1, Math.floor(1*DPR));
      ctx.beginPath();
      ctx.moveTo(frameW, 0); ctx.lineTo(frameW, H);
      ctx.moveTo(W-rW, 0); ctx.lineTo(W-rW, H);
      ctx.stroke();

      // subtle downlights on right slab
      const n = 10;
      for(let i=0;i<n;i++){
        const px = W - rW + (rW*0.12) + (i*(rW*0.08));
        const py = yH*0.35 + (i%2)*12*DPR;
        ctx.fillStyle = `rgba(255,255,255,0.08)`;
        ctx.fillRect(px, py, 2*DPR, 2*DPR);
      }
      ctx.restore();
    }

    function drawWater(t, yH){
      // water occupies lower portion with an infinity edge slightly below horizon
      const lift = state.horizon/100;
      const edgeY = Math.floor(yH + H*(0.12 - 0.05*lift)); // infinity edge line
      const topY = Math.floor(yH + H*(0.02));
      const bottomY = H;

      // base water gradient
      const g = ctx.createLinearGradient(0, topY, 0, bottomY);
      const I = state.intensity/100;

      // palette shifts
      const pulse = (state.mode==='pulse') ? (0.5 + 0.5*Math.sin(t*0.9)) : 0.0;

      const a1 = 0.86;
      const cTop = `rgba(${Math.floor(10+20*pulse)},${Math.floor(24+40*pulse)},${Math.floor(44+70*pulse)},${a1})`;
      const cMid = `rgba(${Math.floor(8+18*pulse)},${Math.floor(14+28*pulse)},${Math.floor(24+50*pulse)},${0.94})`;
      const cBot = `rgba(0,0,0,1)`;

      g.addColorStop(0, cTop);
      g.addColorStop(0.62, cMid);
      g.addColorStop(1, cBot);

      ctx.fillStyle = g;
      ctx.fillRect(0, topY, W, bottomY-topY);

      // reflection strip (infinity edge)
      ctx.save();
      ctx.globalAlpha = 0.34 + 0.22*I;
      ctx.fillStyle = `rgba(255,255,255,0.10)`;
      ctx.fillRect(0, edgeY, W, Math.max(1, Math.floor(2*DPR)));
      ctx.restore();

      // ripples (procedural)
      const windK = state.wind/100;
      const rippleAmp = (8 + 38*windK) * DPR;
      const rippleFreq = 0.0022 + 0.0042*windK;
      const rippleSpeed = 0.6 + 1.8*windK;
      const bands = 110;

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for(let i=0;i<bands;i++){
        const y = topY + (i/(bands-1))*(bottomY-topY);
        const ny = (y-topY)/(bottomY-topY);
        // closer ripples are stronger
        const amp = rippleAmp * (0.12 + 1.15*ny);
        const phase = t*rippleSpeed + ny*6.0;
        const w = 0.8 + 2.0*ny;

        const wave = Math.sin((y*DPR)*rippleFreq + phase) * amp;
        const wave2 = Math.cos((y*DPR)*rippleFreq*1.7 + phase*1.22) * amp*0.55;

        const shimmer = 0.012 + 0.030*I + 0.018*pulse;
        ctx.strokeStyle = `rgba(255,255,255,${shimmer*(0.18+ny)})`;
        ctx.lineWidth = Math.max(1, Math.floor(w*DPR));

        ctx.beginPath();
        // draw a polyline wave across width
        const step = Math.max(10, Math.floor(26*DPR));
        for(let x=0;x<=W;x+=step){
          const nx = x/W;
          const wob = Math.sin((nx*W)*0.008 + phase*0.9) * amp*0.18;
          const y2 = y + (wave + wave2)*0.07 + wob;
          if(x===0) ctx.moveTo(x, y2);
          else ctx.lineTo(x, y2);
        }
        ctx.stroke();
      }
      ctx.restore();

      // subtle grain
      const gn = state.noise/100;
      if(gn > 0){
        ctx.save();
        ctx.globalAlpha = 0.10*gn;
        const nDots = Math.floor((W*H)/ (14000/DPR) * gn);
        ctx.fillStyle = `rgba(255,255,255,0.45)`;
        for(let i=0;i<nDots;i++){
          const x = (rng()*W)|0;
          const y = (topY + rng()*(bottomY-topY))|0;
          ctx.fillRect(x,y,1*DPR,1*DPR);
        }
        ctx.restore();
      }

      return { topY, edgeY };
    }

    function drawSigils(t, yH, waterTop){
      const dens = state.sigil/100;
      if(dens <= 0.01) return;

      const count = Math.floor(10 + 110*dens);
      ctx.save();
      ctx.globalAlpha = 0.10 + 0.26*dens;
      ctx.strokeStyle = `rgba(255,255,255,0.16)`;
      ctx.lineWidth = Math.max(1, Math.floor(1*DPR));

      const pulse = (state.mode==='pulse') ? (0.5 + 0.5*Math.sin(t*1.2)) : 0.0;

      for(let i=0;i<count;i++){
        const px = rng()*W;
        const py = lerp(yH*0.16, H*0.96, rng());
        const inWater = py > waterTop;
        const a = (inWater ? 0.06 : 0.03) + 0.06*dens + 0.08*pulse;

        // mind (angular) above horizon-ish; senses (circular) in/near water
        const chooseAngular = (!inWater && rng() < 0.62) || (inWater && rng() < 0.22);

        ctx.globalAlpha = a;

        if(chooseAngular){
          // angular: chevrons / brackets
          const s = (8 + rng()*26)*DPR;
          const rot = (rng()*Math.PI*2);
          ctx.save();
          ctx.translate(px,py);
          ctx.rotate(rot);
          ctx.beginPath();
          ctx.moveTo(-s*0.6, -s*0.2);
          ctx.lineTo(-s*0.1, -s*0.6);
          ctx.lineTo(s*0.6, -s*0.2);
          ctx.moveTo(-s*0.6, s*0.2);
          ctx.lineTo(-s*0.1, s*0.6);
          ctx.lineTo(s*0.6, s*0.2);
          ctx.stroke();
          ctx.restore();
        }else{
          // circular: halos
          const r = (6 + rng()*22)*DPR;
          ctx.beginPath();
          ctx.arc(px,py,r,0,Math.PI*2);
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    function applyModeOverlay(t){
      if(state.mode === 'white'){
        // white room vibe: desaturating veil + hard white wash
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = `rgba(255,255,255,0.22)`;
        ctx.fillRect(0,0,W,H);
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = `rgba(255,255,255,0.08)`;
        ctx.fillRect(0,0,W,H);
        ctx.restore();
      } else if(state.mode === 'pulse'){
        const p = 0.5 + 0.5*Math.sin(t*1.35);
        ctx.save();
        ctx.globalCompositeOperation = 'overlay';
        ctx.fillStyle = `rgba(${Math.floor(40+110*p)},${Math.floor(30+90*p)},${Math.floor(90+140*p)},0.12)`;
        ctx.fillRect(0,0,W,H);
        ctx.restore();
      }
    }

    let last = performance.now();
    let time = 0;

    function frame(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      if(!state.frozen) time += dt;

      // clear
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,W,H);

      // scene
      const yH = drawSky(time);
      const water = drawWater(time, yH);
      drawSigils(time, yH, water.topY);

      drawDeckAndEdges(yH);
      applyModeOverlay(time);

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

  </script>
</body>
</html>
