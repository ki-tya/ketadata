<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA // SOVEREIGN MOTION (VIZ + INTENSE + REACTIVE)</title>

<style>
:root{
  --bg:#000;
  --fg:rgba(255,255,255,.86);
  --muted:rgba(255,255,255,.52);
  --line:rgba(255,255,255,.14);
  --line2:rgba(255,255,255,.22);
  --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  --sans: Arial,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  --top:44px;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);overflow:hidden;font-family:var(--sans)}
#top{
  position:fixed;left:0;right:0;top:0;height:var(--top);
  display:flex;align-items:center;gap:8px;padding:6px 8px;
  background:rgba(0,0,0,.78);border-bottom:1px solid var(--line);z-index:10;
}
.btn,.chip{
  height:30px;display:inline-flex;align-items:center;gap:8px;padding:0 10px;
  border:1px solid var(--line2);background:rgba(0,0,0,.30);color:var(--fg);
  font:12px/1 var(--sans);white-space:nowrap;user-select:none;
}
.btn{cursor:pointer}
.btn:active{transform:translateY(1px)}
.k{font-family:var(--mono);opacity:.9}
.sep{flex:1}
input[type="range"]{width:120px;accent-color:#fff}

#stage{
  position:fixed;left:0;top:var(--top);
  width:100vw;height:calc(100vh - var(--top));
}

video{position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0}

/* VIZ panel */
#viz{
  position:fixed;right:8px;bottom:8px;
  width:260px;height:160px;
  border:1px solid var(--line);
  background:#000;z-index:20;
  display:none;
}
body.showviz #viz{display:block}

/* Hide chrome for fullscreen */
body.fs #top{display:none}
body.fs #stage{top:0;height:100vh}

#hint{
  position:fixed;left:8px;bottom:8px;
  border:1px solid var(--line);
  background:rgba(0,0,0,.55);
  padding:6px 8px;
  font:12px/1.2 var(--sans);
  color:var(--muted);
  z-index:20;
  max-width:70ch;
}
body.showviz #hint{bottom:176px}
body.fs #hint{display:none}

body.invert{filter:invert(1)}
</style>
</head>

<body>
<div id="top">
  <div class="chip k">KETADATA // SOVEREIGN MOTION</div>

  <div class="btn" id="start">START CAM</div>
  <div class="btn" id="stopCam">STOP CAM</div>
  <div class="btn" id="run">STOP</div>
  <div class="btn" id="invert">INVERT</div>
  <div class="btn" id="vizBtn">VIZ</div>
  <div class="btn" id="fsBtn">FULL</div>
  <div class="btn" id="sizeBtn">PARTICLES: SMALL</div>

  <div class="chip">INT <input id="intensity" type="range" min="0" max="100" value="85"></div>
  <div class="chip">COUNT <input id="count" type="range" min="2000" max="90000" value="32000"></div>
  <div class="chip">THR <input id="thr" type="range" min="1" max="80" value="14"></div>

  <div class="sep"></div>
  <div class="chip k" id="status">LOCAL</div>
</div>

<canvas id="stage"></canvas>
<canvas id="viz" width="260" height="160"></canvas>
<video id="video" playsinline muted autoplay></video>

<div id="hint">
  <div style="color:rgba(255,255,255,.86)">HOTKEYS: F = fullscreen, V = viz, S = particle size, I = invert.</div>
  <div>More reactive: motion energy boosts pull, brightness, and burst.</div>
</div>

<script>
(() => {
  const $ = id => document.getElementById(id);

  const canvas = $("stage");
  const ctx = canvas.getContext("2d",{alpha:false});
  const viz = $("viz");
  const vctx = viz.getContext("2d");

  let W=0,H=0,DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const ow = canvas.offsetWidth || 1;
    const oh = canvas.offsetHeight || 1;
    W = Math.max(1, Math.floor(ow * DPR));
    H = Math.max(1, Math.floor(oh * DPR));
    canvas.width = W;
    canvas.height = H;
  }
  addEventListener("resize", resize);
  addEventListener("orientationchange", () => setTimeout(resize, 60));
  setTimeout(resize, 0);

  const STATE={
    running:true,
    intensity:0.85,
    targetCount:32000,
    motionThr:14,
    camOn:false,
    showViz:false,
    particleSize:1,    // 1 small, 2 large
    fs:false,
    // motion energy smoothing
    energy:0,
    energySmooth:0
  };

  const setStatus = s => ($("status").textContent = s);

  function toggleViz(){
    STATE.showViz = !STATE.showViz;
    document.body.classList.toggle("showviz", STATE.showViz);
  }
  function toggleFS(){
    STATE.fs = !STATE.fs;
    document.body.classList.toggle("fs", STATE.fs);
    // try real fullscreen if allowed (works when served via https/localhost; may fail silently on file://)
    if(STATE.fs){
      const el = document.documentElement;
      if(el.requestFullscreen) el.requestFullscreen().catch(()=>{});
      else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    }else{
      if(document.exitFullscreen) document.exitFullscreen().catch(()=>{});
      else if(document.webkitExitFullscreen) document.webkitExitFullscreen();
    }
    setTimeout(resize, 60);
  }
  function toggleSize(){
    STATE.particleSize = (STATE.particleSize===1) ? 2 : 1;
    $("sizeBtn").textContent = "PARTICLES: " + (STATE.particleSize===1 ? "SMALL" : "BIG");
  }

  $("invert").onclick = () => document.body.classList.toggle("invert");
  $("vizBtn").onclick = toggleViz;
  $("fsBtn").onclick = toggleFS;
  $("sizeBtn").onclick = toggleSize;

  $("intensity").oninput = e => STATE.intensity = (+e.target.value)/100;
  $("count").oninput = e => STATE.targetCount = (+e.target.value)|0;
  $("thr").oninput = e => STATE.motionThr = (+e.target.value)|0;

  $("run").onclick = () => {
    STATE.running = !STATE.running;
    $("run").textContent = STATE.running ? "STOP" : "RUN";
  };

  addEventListener("keydown",(e)=>{
    if(e.repeat) return;
    const k = e.key.toLowerCase();
    if(k==="v") toggleViz();
    if(k==="f") toggleFS();
    if(k==="s") toggleSize();
    if(k==="i") document.body.classList.toggle("invert");
  });

  /* ===== PARTICLES ===== */
  let P=[];
  function seed(n){
    P.length=0;
    for(let i=0;i<n;i++){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()-.5)*.65,
        vy:(Math.random()-.5)*.65,
        m:Math.random()
      });
    }
  }
  function ensureCount(){
    const n = STATE.targetCount|0;
    if(P.length===n) return;
    if(P.length>n){ P.length=n; return; }
    while(P.length<n){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()-.5)*.65,
        vy:(Math.random()-.5)*.65,
        m:Math.random()
      });
    }
  }

  /* ===== ATTRACTORS ===== */
  const A=[
    {x:0,y:0,str:1.25,alive:true},  // mouse
    {x:0,y:0,str:0,alive:false},    // left
    {x:0,y:0,str:0,alive:false}     // right
  ];

  let mouseDown=false;
  addEventListener("pointerdown",e=>{mouseDown=true;setMouse(e)});
  addEventListener("pointerup",()=>mouseDown=false);
  addEventListener("pointermove",setMouse);

  function setMouse(e){
    const r=canvas.getBoundingClientRect();
    A[0].x=(e.clientX-r.left)*DPR;
    A[0].y=(e.clientY-r.top)*DPR;
    A[0].str=mouseDown?3.4:1.8;
  }

  /* ===== WEBCAM MOTION ===== */
  const video=$("video");
  let stream=null;

  const DET_W=220, DET_H=124;
  const det=document.createElement("canvas");
  det.width=DET_W; det.height=DET_H;
  const dctx=det.getContext("2d",{willReadFrequently:true});

  let prevLuma=null;

  function stopCam(){
    if(stream){
      try{ for(const t of stream.getTracks()) t.stop(); }catch(_){}
    }
    stream=null;
    STATE.camOn=false;
    prevLuma=null;
    A[1].alive=false; A[1].str=0;
    A[2].alive=false; A[2].str=0;
    STATE.energy=0; STATE.energySmooth=0;
    setStatus("LOCAL");
  }

  async function startCam(){
    if(STATE.camOn) return;
    setStatus("CAM REQUEST");
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:"user", width:{ideal:1280}, height:{ideal:720} },
        audio:false
      });
      video.srcObject = stream;
      await video.play();
      STATE.camOn=true;
      prevLuma=null;
      setStatus("CAM ON");
    }catch(e){
      setStatus("CAM BLOCKED");
    }
  }

  $("start").onclick=startCam;
  $("stopCam").onclick=stopCam;

  function updateMotion(){
    if(!STATE.camOn){
      STATE.energy = 0;
      return;
    }

    dctx.save();
    dctx.scale(-1,1);
    dctx.drawImage(video, -DET_W, 0, DET_W, DET_H);
    dctx.restore();

    const img = dctx.getImageData(0,0,DET_W,DET_H).data;

    const cur = new Uint8Array(DET_W*DET_H);
    let p=0;
    for(let i=0;i<img.length;i+=4){
      const r=img[i], g=img[i+1], b=img[i+2];
      cur[p++] = (r*0.2126 + g*0.7152 + b*0.0722) | 0;
    }

    if(!prevLuma){
      prevLuma = cur;
      A[1].alive=false; A[1].str=0;
      A[2].alive=false; A[2].str=0;
      STATE.energy = 0;
      if(STATE.showViz) drawViz(cur, null);
      return;
    }

    const thr = STATE.motionThr|0;

    let lx=0,ly=0,lm=0, rx=0,ry=0,rm=0;
    let total=0;

    const mask = STATE.showViz ? new Uint8ClampedArray(DET_W*DET_H) : null;

    for(let y=0;y<DET_H;y++){
      for(let x=0;x<DET_W;x++){
        const idx = y*DET_W + x;
        const d = Math.abs(cur[idx] - prevLuma[idx]);
        prevLuma[idx] = cur[idx];

        if(d < thr){
          if(mask) mask[idx]=0;
          continue;
        }

        const w = d;
        total += w;
        if(mask) mask[idx]=255;

        if(x < DET_W/2){
          lm += w; lx += x*w; ly += y*w;
        }else{
          rm += w; rx += x*w; ry += y*w;
        }
      }
    }

    if(lm){
      A[1].x = (lx/lm)/DET_W * W;
      A[1].y = (ly/lm)/DET_H * H;
      A[1].str = Math.min(7.0, lm/2200);
      A[1].alive = A[1].str > 0.12;
    }else{
      A[1].str=0; A[1].alive=false;
    }

    if(rm){
      A[2].x = (rx/rm)/DET_W * W;
      A[2].y = (ry/rm)/DET_H * H;
      A[2].str = Math.min(7.0, rm/2200);
      A[2].alive = A[2].str > 0.12;
    }else{
      A[2].str=0; A[2].alive=false;
    }

    // normalized energy 0..1.6-ish
    const norm = (DET_W*DET_H) * 8.0;
    STATE.energy = Math.max(0, Math.min(1.6, total / norm));

    if(STATE.showViz) drawViz(cur, mask);
  }

  function drawViz(curLuma, mask){
    const w = viz.width, h = viz.height;
    vctx.fillStyle="#000";
    vctx.fillRect(0,0,w,h);

    const imgData = vctx.createImageData(DET_W, DET_H);
    for(let i=0;i<curLuma.length;i++){
      const v = curLuma[i];
      const o = i*4;
      imgData.data[o]=v; imgData.data[o+1]=v; imgData.data[o+2]=v; imgData.data[o+3]=255;
    }
    const tmp = document.createElement("canvas");
    tmp.width=DET_W; tmp.height=DET_H;
    tmp.getContext("2d").putImageData(imgData,0,0);

    vctx.imageSmoothingEnabled=false;
    vctx.globalAlpha=0.40;
    vctx.drawImage(tmp,0,0,DET_W,DET_H,0,0,w,h);
    vctx.globalAlpha=1;

    if(mask){
      const maskImg = vctx.createImageData(DET_W, DET_H);
      for(let i=0;i<mask.length;i++){
        const a = mask[i];
        const o=i*4;
        maskImg.data[o]=255; maskImg.data[o+1]=255; maskImg.data[o+2]=255;
        maskImg.data[o+3]=a;
      }
      const tmp2 = document.createElement("canvas");
      tmp2.width=DET_W; tmp2.height=DET_H;
      tmp2.getContext("2d").putImageData(maskImg,0,0);

      vctx.globalAlpha=0.98;
      vctx.drawImage(tmp2,0,0,DET_W,DET_H,0,0,w,h);
      vctx.globalAlpha=1;
    }

    const sx=w/W, sy=h/H;
    vctx.fillStyle="rgba(255,255,255,.86)";
    if(A[1].alive) vctx.fillRect(A[1].x*sx-3, A[1].y*sy-3, 6,6);
    if(A[2].alive) vctx.fillRect(A[2].x*sx-3, A[2].y*sy-3, 6,6);

    vctx.strokeStyle="rgba(255,255,255,.22)";
    vctx.lineWidth=1;
    vctx.strokeRect(0.5,0.5,w-1,h-1);

    // energy bar
    const e = Math.max(0, Math.min(1, STATE.energy/1.2));
    vctx.fillStyle="rgba(255,255,255,.22)";
    vctx.fillRect(6, h-10, w-12, 4);
    vctx.fillStyle="rgba(255,255,255,.86)";
    vctx.fillRect(6, h-10, (w-12)*e, 4);
  }

  /* ===== LOOP ===== */
  let last=performance.now();
  function frame(t){
    requestAnimationFrame(frame);
    if(!STATE.running) return;

    resize();

    if(P.length===0){
      seed(STATE.targetCount|0);
    }

    ensureCount();
    updateMotion();

    // smooth motion energy
    STATE.energySmooth = STATE.energySmooth*0.88 + STATE.energy*0.12;

    const dt = Math.min(32, t-last); last=t;

    // trails: energy reduces clearing => more intensity when you move
    const trail = 0.075 - Math.min(0.045, STATE.energySmooth*0.035);
    ctx.globalCompositeOperation="source-over";
    ctx.fillStyle = `rgba(0,0,0,${Math.max(0.02, trail)})`;
    ctx.fillRect(0,0,W,H);

    const inten = STATE.intensity;

    // Reactive physics: motion energy boosts pull + reduces damping + adds jitter bursts
    const e = Math.min(1.2, STATE.energySmooth);
    const pull = (0.0011 + 0.0100*inten) * (1.0 + 2.2*e);
    const damp = (0.992 - 0.12*inten) * (1.0 - 0.22*e);
    const jitter = (0.00006 + 0.00045*inten) * (1.0 + 3.4*e);

    // Point style: switch small/big
    const px = (STATE.particleSize===1) ? 1 : (inten>0.55 ? 2 : 2);

    // Brightness: energy increases alpha
    ctx.globalCompositeOperation="lighter";
    const alpha = Math.min(0.90, 0.20 + 0.28*inten + 0.40*e);
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;

    // Periodic pulse when you move a lot (dance “kick”)
    const pulse = (e > 0.45) ? (0.018 * (e-0.45)) : 0;

    // Update particles
    for(const p of P){
      let ax=0, ay=0;

      // attractors
      for(let i=0;i<A.length;i++){
        const a=A[i];
        if(i>0 && !a.alive) continue;

        const dx=a.x-p.x, dy=a.y-p.y;
        const inv=1/(dx*dx+dy*dy+120);
        ax += dx*inv*pull*a.str;
        ay += dy*inv*pull*a.str;
      }

      // reactive burst outward from screen center
      if(pulse>0){
        const cx=W*0.5, cy=H*0.5;
        const sx=p.x-cx, sy=p.y-cy;
        const inv = 1/(Math.hypot(sx,sy)+120);
        ax += sx * pulse * inv * dt;
        ay += sy * pulse * inv * dt;
      }

      // noise
      ax += (Math.random()-0.5)*jitter;
      ay += (Math.random()-0.5)*jitter;

      p.vx = (p.vx + ax*dt) * damp;
      p.vy = (p.vy + ay*dt) * damp;

      p.x = (p.x + p.vx*dt + W) % W;
      p.y = (p.y + p.vy*dt + H) % H;

      ctx.fillRect(p.x, p.y, px, px);
    }

    ctx.globalCompositeOperation="source-over";

    if(STATE.camOn){
      const live = (A[1].alive || A[2].alive);
      setStatus(live ? "CAM + MOTION" : "CAM (LOW MOTION)");
    }else{
      setStatus("LOCAL");
    }
  }

  requestAnimationFrame(frame);

  addEventListener("beforeunload", () => { try{ stopCam(); }catch(_){} });
})();
</script>

<!--
AE: KETADATA
EE: SOVEREIGN_MOTION_REACTIVE_FULLSCREEN_SIZE_TOGGLE
WB: SINGLE_FILE_HTML
FILE_ID: KETA_SOV_MOTION_REACTIVE_FS_SIZE_v1
ROOM_ID: BASE
VERSION: 1
UPDATED_AT: 2026-01-08
CHANGELOG:
- v1: more reactive via motion-energy coupling; adds FULL toggle + browser fullscreen attempt; adds particle size toggle; keeps VIZ
-->
</body>
</html>
