<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>KETADATA_SHELL_KERNEL_v1.html</title>

<!-- =========================================================
AE ▸ VOID KERNEL (BLACK / SHARP / INDUSTRIAL CHIC)
========================================================= -->
<style>
:root{
  --bg:#000; --fg:#fff; --muted:#8a8a8a; --line:#222; --line2:#333;
  --top:44px; --bot:34px;

  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --sans: Arial, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;

  /* AE: controller polish — SHARP */
  --ctl-radius:0px;
  --ctl-alpha:0.80;
  --ctl-bg: rgba(0,0,0,var(--ctl-alpha));
  --note-border: rgba(255,255,255,0.78); /* thin, high intensity */
}

*{box-sizing:border-box}
html,body{height:100%; margin:0}
body{
  background:var(--bg);
  color:var(--fg);
  font-family:var(--sans);
  overflow:hidden;
  user-select:none;
}

#root{
  position:fixed;
  inset:0;
  background:#000;
}
#root.invert{ filter: invert(1); }

/* Stage: "lights" operate here */
#stage{
  position:absolute;
  inset:0;
  background:#000;
  filter:none;
}

/* EE: motion layer (industrial scanflow) — Space toggles */
#motion{
  position:absolute;
  inset:0;
  pointer-events:none;
  opacity:0;
  background:
    repeating-linear-gradient(
      135deg,
      rgba(255,255,255,0.06) 0px,
      rgba(255,255,255,0.06) 1px,
      rgba(0,0,0,0) 12px,
      rgba(0,0,0,0) 22px
    );
  mix-blend-mode: screen;
  transform: translate3d(0,0,0);
}
#motion.run{
  opacity:0.12;
  animation: scanflow 2.2s linear infinite;
}
@keyframes scanflow{
  0%   { transform: translate3d(-80px, 60px, 0); }
  100% { transform: translate3d(80px, -60px, 0); }
}

/* =========================================================
AE ▸ TOP BAR
========================================================= */
.topbar{
  position:absolute;
  top:0; left:0; right:0;
  height:var(--top);
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:0 10px;
  border-bottom:1px solid var(--line);
  background:linear-gradient(180deg,#070707,#000);
  z-index:10;
}
.brand{
  display:flex; align-items:center; gap:10px;
  font-family:var(--mono);
  font-size:12px;
  letter-spacing:.10em;
  text-transform:uppercase;
}
.brand .sq{
  width:10px; height:10px;
  border:1px solid var(--fg);
  background:#000;
}
.roomBadge{
  display:flex; gap:8px; align-items:center;
  font-family:var(--mono);
  font-size:11px;
  letter-spacing:.10em;
  text-transform:uppercase;
  color:var(--muted);
  border:1px solid var(--line2);
  padding:4px 8px;
}
.actions{
  display:flex; align-items:center; gap:8px;
  font-family:var(--mono);
  font-size:12px;
}
.btn{
  background:transparent;
  color:var(--fg);
  border:1px solid var(--line2);
  padding:6px 10px;
  font-family:var(--mono);
  font-size:12px;
  letter-spacing:.08em;
  text-transform:uppercase;
  cursor:pointer;
}
.btn:hover{border-color:var(--fg)}
.btn:active{transform:translateY(1px)}
.kbd{border:1px solid var(--line2); padding:2px 6px; color:var(--muted); font-size:11px}

/* KETA NOTE icon: filled when collapsed, hollow when open */
.ketaIcon{
  width:16px; height:16px;
  border:2px solid var(--fg);
  background:var(--fg);
  cursor:pointer;
}
.ketaIcon.open{ background:#000; }

/* =========================================================
AE ▸ BOTTOM BAR + DRAWER
========================================================= */
.bottombar{
  position:absolute;
  left:0; right:0; bottom:0;
  height:var(--bot);
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:0 10px;
  border-top:1px solid var(--line);
  background:linear-gradient(0deg,#070707,#000);
  z-index:10;
  font-family:var(--mono);
  font-size:11px;
  color:var(--muted);
}
.toggle{
  border:1px solid var(--line2);
  background:transparent;
  color:var(--fg);
  padding:4px 8px;
  font-family:var(--mono);
  font-size:11px;
  letter-spacing:.08em;
  text-transform:uppercase;
  cursor:pointer;
}
.toggle:hover{border-color:var(--fg)}

/* Drawer becomes a KD module (movable/resizable/collapsible) */
.drawer{
  position:absolute;
  left:0; right:auto; bottom:auto;
  height:38%;
  min-height:220px;
  border:1px solid var(--line);
  background:linear-gradient(180deg,#060606,#000);
  display:none;
  z-index:20;
}
.drawer.open{display:flex; flex-direction:column}
.drawerHead{
  padding:8px 10px;
  border-bottom:1px solid var(--line);
  font-family:var(--mono);
  font-size:12px;
  letter-spacing:.10em;
  text-transform:uppercase;
  display:flex;
  justify-content:space-between;
  align-items:center;
  user-select:none;
}
.drawerBody{padding:10px; min-height:0; flex:1; overflow:auto}
textarea{
  width:100%;
  border:1px solid var(--line2);
  background:#050505;
  color:var(--fg);
  font-family:var(--mono);
  font-size:12px;
  padding:10px;
  line-height:1.35;
  outline:none;
  resize:vertical;
  min-height:140px;
}

/* =========================================================
AE ▸ KETA NOTE (THIN / ELEGANT / SHARP)
========================================================= */
.ketaNote{
  position:absolute;
  top:60px; right:auto;
  width:340px; height:220px;
  display:none;
  z-index:30;
  overflow:hidden;

  border-radius:var(--ctl-radius);
  background:var(--ctl-bg);
  border:1px solid var(--note-border);
  backdrop-filter: blur(6px);
}
.ketaNote.open{display:flex; flex-direction:column}
.ketaHead{
  padding:8px 10px;
  border-bottom:1px solid rgba(255,255,255,0.14);
  font-family:var(--mono);
  font-size:11px;
  letter-spacing:.14em;
  text-transform:uppercase;
  display:flex;
  justify-content:space-between;
  align-items:center;
  user-select:none;
}
.ketaBody{padding:10px; min-height:0; flex:1}
.ketaNote textarea{
  background:#000;
  color:#fff;
  border:1px solid rgba(255,255,255,0.22);
  width:100%;
  height:100%;
  resize:none;
  padding:10px;
  outline:none;
}
.headBtn{
  background:transparent;
  color:var(--fg);
  border:1px solid rgba(255,255,255,0.18);
  padding:2px 8px;
  font-family:var(--mono);
  font-size:12px;
  letter-spacing:.08em;
  text-transform:uppercase;
  cursor:pointer;
}
.headBtn:hover{border-color:rgba(255,255,255,0.6)}

/* Toast */
.toast{
  position:absolute;
  left:12px;
  top:calc(var(--top) + 12px);
  padding:8px 10px;
  border:1px solid var(--line2);
  background:rgba(8,8,8,0.82);
  font-family:var(--mono);
  font-size:11px;
  letter-spacing:.06em;
  color:var(--fg);
  display:none;
  z-index:40;
}

/* RoomUrl banner */
#roomJump{
  position:absolute;
  left:10px;
  top:calc(var(--top) + 10px);
  display:none;
  align-items:center;
  gap:10px;
  padding:8px 10px;
  border:1px solid var(--line2);
  background:rgba(0,0,0,0.82);
  z-index:25;
  font-family:var(--mono);
  font-size:11px;
  letter-spacing:.08em;
  text-transform:uppercase;
}
#roomJump.show{display:flex}

/* =========================================================
WB/EE ▸ KD MODULE PRIMITIVE (MOVE/RESIZE/COLLAPSE)
========================================================= */
.kd-module{ position:absolute; pointer-events:auto; }
.kd-h{
  cursor:move;
  user-select:none;
  touch-action:none;
}
.kd-b.kd-closed{ display:none !important; }
.kd-r{
  position:absolute;
  right:-1px; bottom:-1px;
  width:14px; height:14px;
  border:1px solid var(--line2);
  background:rgba(16,16,16,0.6);
  cursor:nwse-resize;
  touch-action:none;
}

/* WB: protect against any aggressive wrapper pointer-events */
#drawer, #ketaNote, .drawerHead, .ketaHead{
  pointer-events:auto !important;
}
</style>
</head>

<body>
<div id="root">
  <div id="stage" aria-label="KETADATA STAGE"></div>
  <div id="motion" aria-hidden="true"></div>

  <div id="roomJump">
    <span id="roomJumpTxt">ROOM LINK DETECTED</span>
    <button class="btn" id="btnGoRoom">GO</button>
    <button class="btn" id="btnDismissRoom">DISMISS</button>
  </div>

  <div class="toast" id="toast"></div>

  <!-- WB ▸ TOPBAR -->
  <div class="topbar">
    <div style="display:flex; gap:10px; align-items:center">
      <div class="brand">
        <span class="sq"></span>
        <span>KETADATA // SHELL // KERNEL</span>
        <span style="color:var(--muted); letter-spacing:.02em; text-transform:none">v1</span>
      </div>
      <div class="roomBadge" title="Room in state">
        <span>ROOM</span>
        <span id="roomName">BASE</span>
      </div>
    </div>
    <div class="actions">
      <button class="btn" id="btnImport">IMPORT</button>
      <button class="btn" id="btnExport">EXPORT</button>
      <button class="btn" id="btnCopy">COPY</button>
      <span class="kbd" title="Invert all colors">Shift+I</span>
      <span class="kbd" title="Select light preset">1–6</span>
      <span class="kbd" title="Toggle light on/off + motion transport">Space</span>
      <div id="ketaIcon" class="ketaIcon" title="KETA_NOTE"></div>
    </div>
  </div>

  <!-- WB ▸ SYSTEM DRAWER (KD MODULE) -->
  <div class="drawer kd-module" id="drawer"
       data-kd-module="DRAWER"
       data-kd-handle=".drawerHead"
       data-kd-body=".drawerBody"
       data-kd-resize=".kd-r">
    <div class="drawerHead kd-h">
      <div>SYSTEM UNIVERSALS</div>
      <div style="display:flex; gap:8px; align-items:center">
        <span id="sig" style="color:var(--muted); font-family:var(--mono); font-size:11px">∅</span>
        <button class="btn" id="btnCopyUniversals">COPY</button>
        <button class="btn" id="btnCloseDrawer">CLOSE</button>
      </div>
    </div>

    <div class="drawerBody kd-b">
      <textarea id="universals" placeholder="LAWS / CONSTRAINTS / REFERENCES"></textarea>
      <div style="margin-top:8px; color:var(--muted); font-family:var(--mono); font-size:11px">
        EE: axiom → KETADATA ⇒ KETA_NOTE ⇒ EXPORTABLE STATE
      </div>

      <!-- =====================================================
      ROOM SECTION (UPDATED: MULTI PRESETS + ACTIVE ROOM)
      ====================================================== -->
      <div style="margin-top:8px; display:flex; gap:8px; align-items:center; font-family:var(--mono); font-size:11px; letter-spacing:.08em; text-transform:uppercase; color:var(--muted)">
        <span>ROOM</span>
        <input id="roomInput" style="flex:1; background:#000; color:#fff; border:1px solid var(--line2); padding:6px 8px; font-family:var(--mono); outline:none" placeholder="e.g. VAULT / LAB / BASEMENT" />
      </div>

      <div style="margin-top:8px; display:flex; gap:8px; align-items:center; font-family:var(--mono); font-size:11px; letter-spacing:.08em; text-transform:uppercase; color:var(--muted)">
        <span>ROOM URL</span>
        <input id="roomUrlInput" style="flex:1; background:#000; color:#fff; border:1px solid var(--line2); padding:6px 8px; font-family:var(--mono); outline:none" placeholder="optional: ketadata.com/vault/index.html" />
      </div>

      <div style="margin-top:8px; display:flex; gap:8px; align-items:center">
        <button class="btn" id="btnSaveRoom" title="Add/Update preset for this ROOM">SAVE PRESET</button>
        <button class="btn" id="btnSetActiveRoom" title="Set this ROOM as active (ROOM + ROOM URL)">SET ACTIVE</button>
        <button class="btn" id="btnDeleteRoom" title="Delete preset for this ROOM">DELETE</button>
      </div>

      <div style="margin-top:10px; border-top:1px solid var(--line); padding-top:10px">
        <div style="font-family:var(--mono); font-size:12px; letter-spacing:.10em; text-transform:uppercase; color:var(--muted); margin-bottom:8px">
          ROOM PRESETS
        </div>
        <div id="roomList" style="display:flex; flex-direction:column; gap:6px"></div>
        <div style="margin-top:8px; color:var(--muted); font-family:var(--mono); font-size:11px">
          CLICK = LOAD INTO FIELDS. DOUBLE CLICK = SET ACTIVE.
        </div>
      </div>
      <!-- ===================================================== -->
    </div>

    <div class="kd-r" aria-hidden="true"></div>
  </div>

  <!-- WB ▸ BOTTOMBAR -->
  <div class="bottombar">
    <div style="display:flex; gap:10px; align-items:center">
      <button class="toggle" id="toggleDrawer">SYSTEM</button>
      <span>STATE: <span id="sig2">∅</span></span>
    </div>
    <div style="display:flex; gap:12px; align-items:center">
      <span>LIGHT: <span id="lightLabel">1</span></span>
      <span>RUN: <span id="runLabel">OFF</span></span>
      <span>MOTION: <span id="motionLabel">OFF</span></span>
    </div>
  </div>

  <!-- WB ▸ KETA NOTE (KD MODULE) -->
  <div class="ketaNote kd-module" id="ketaNote"
       data-kd-module="KETA_NOTE"
       data-kd-handle=".ketaHead"
       data-kd-body=".ketaBody"
       data-kd-resize=".kd-r">
    <div class="ketaHead kd-h" id="ketaHead">
      <div>KETA_NOTE</div>
      <button class="headBtn" id="btnHideNote">-</button>
    </div>
    <div class="ketaBody kd-b">
      <textarea id="ketaText" placeholder="GLOBAL NOTE"></textarea>
    </div>
    <div class="kd-r" aria-hidden="true"></div>
  </div>

  <input id="file" type="file" accept="application/json" style="display:none" />
</div>

<script>
/* =========================================================
EE ▸ ENGINE ▸ KERNEL LAW (STATE + INVERT + LIGHTS + TRANSPORT)
========================================================= */

/* =========================================================
WB ▸ SOVEREIGN STORAGE KEY
========================================================= */
const FILE_ID = "KETADATA_SHELL_V4";
const ROOM_ID = "BASE";
const VERSION_ID = "shellv4.base.v4"; /* bumped because state shape changed */
const STORAGE_KEY = `KDT::STATE::${FILE_ID}::${ROOM_ID}::${VERSION_ID}`;

// WB ▸ GLOBAL NOTE KEY (INTENTIONAL GLOBAL)
const GLOBAL_KETA_NOTE_KEY = "KDT_GLOBAL_KETA_NOTE_V1";

const DEFAULT = {
  version: "KETADATA_SHELL_KERNEL_v1",
  updatedAt: new Date().toISOString(),

  // EE: required atoms
  ketaNote: "",
  universals: "",

  // EE: room routing surface (optional)
  room: "BASE",
  roomUrl: "",

  // EE: KETA_NOTE meta (continuity label surface)
  ketaNoteMeta: {
    version: "KETA_NOTE_META_v1",
    noteId: "GLOBAL",
    roomId: "BASE",
    stateId: null,
    categoryIds: [],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },

  ui: {
    invert:false,
    lightPreset: 1,
    lightRunning: false,
    motionOn: false
  },

  /* EE/WB: module law storage (movable/resizable/collapsible) */
  modules: {
    DRAWER: { x: 0, y: 56, w: window.innerWidth, h: Math.max(260, Math.round(window.innerHeight*0.38)), open: false },
    KETA_NOTE: { x: Math.max(16, window.innerWidth - 16 - 340), y: 60, w: 340, h: 220, open: false }
  },

  payload: {}
};

let STATE = loadLocal() || structuredClone(DEFAULT);

// WB ▸ GLOBAL NOTE CONTINUITY
{ const g = loadGlobalKetaNote(); if(g) STATE.ketaNote = g; }

const $ = (id)=>document.getElementById(id);
const stage = $("stage");
const root = $("root");
const motion = $("motion");

function nowISO(){ return new Date().toISOString(); }

// WB ▸ GLOBAL NOTE IO
function loadGlobalKetaNote(){
  try{ return localStorage.getItem(GLOBAL_KETA_NOTE_KEY) ?? ""; }catch(e){ return ""; }
}
function saveGlobalKetaNote(text){
  try{ localStorage.setItem(GLOBAL_KETA_NOTE_KEY, String(text ?? "")); }catch(e){}
}

function stableSig(){
  const core = JSON.stringify({
    v:STATE.version,
    room:STATE.room,
    url:STATE.roomUrl,
    i:STATE.ui.invert,
    p:STATE.ui.lightPreset,
    r:STATE.ui.lightRunning,
    m:STATE.ui.motionOn,
    k:(STATE.ketaNote||"").length,
    u:(STATE.universals||"").length,
    mods:{
      d:STATE.modules?.DRAWER ? [STATE.modules.DRAWER.x,STATE.modules.DRAWER.y,STATE.modules.DRAWER.w,STATE.modules.DRAWER.h,STATE.modules.DRAWER.open] : null,
      n:STATE.modules?.KETA_NOTE ? [STATE.modules.KETA_NOTE.x,STATE.modules.KETA_NOTE.y,STATE.modules.KETA_NOTE.w,STATE.modules.KETA_NOTE.h,STATE.modules.KETA_NOTE.open] : null
    }
  });
  let h=2166136261;
  for(let i=0;i<core.length;i++){ h^=core.charCodeAt(i); h=Math.imul(h,16777619); }
  return (h>>>0).toString(16).slice(0,8);
}

/* =========================================================
EE/WB ▸ KETA_NOTE CONTINUITY (ROOM + MINIMAL STATE LABELING)
========================================================= */
function ensureKetaNoteMeta(){
  if(!STATE.ketaNoteMeta || typeof STATE.ketaNoteMeta !== "object"){
    STATE.ketaNoteMeta = structuredClone(DEFAULT.ketaNoteMeta);
  }else{
    const m = STATE.ketaNoteMeta;
    STATE.ketaNoteMeta = Object.assign(structuredClone(DEFAULT.ketaNoteMeta), m);
  }
}

function syncKetaNoteMeta(reason){
  ensureKetaNoteMeta();
  const room = (STATE.room || "BASE").trim();
  const roomId = room.toUpperCase();
  const stateId = stableSig();
  STATE.ketaNoteMeta.roomId = roomId;
  STATE.ketaNoteMeta.stateId = stateId;
  STATE.ketaNoteMeta.updatedAt = nowISO();
  if(reason){
    if(!STATE.ketaNoteMeta._last) STATE.ketaNoteMeta._last = {};
    STATE.ketaNoteMeta._last = { reason, at: STATE.ketaNoteMeta.updatedAt };
  }
}

/* =========================================================
EE/WB ▸ MODULE KERNEL (MOVE/RESIZE/COLLAPSE) — SHELL ENFORCED
- Any element with data-kd-module becomes a movable/resizable module.
- Stored in STATE.modules[id] = {x,y,w,h,open}
- Typing guards: no drag/resize while typing in inputs/textareas/contenteditable.
========================================================= */
(function KDModuleKernel(){
  const qsa = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const qs  = (sel, root=document) => root.querySelector(sel);

  function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
  function isTypingTarget(t){
    if(!t) return false;
    const tag = (t.tagName||"").toLowerCase();
    if(tag==="input" || tag==="textarea" || tag==="select") return true;
    if(t.isContentEditable) return true;
    return false;
  }

  function ensureModuleState(id, fallback){
    if(!STATE.modules || typeof STATE.modules !== "object") STATE.modules = {};
    if(!STATE.modules[id]) STATE.modules[id] = fallback;
    const s = STATE.modules[id];
    for(const k of Object.keys(fallback)) if(s[k] === undefined) s[k] = fallback[k];
    return s;
  }

  function applyRect(el, s){
    el.style.left = (s.x||0) + "px";
    el.style.top  = (s.y||0) + "px";
    el.style.width  = (s.w||320) + "px";
    el.style.height = (s.h||240) + "px";
  }

  function applyOpen(el, s, bodySel){
    const body = bodySel ? qs(bodySel, el) : null;
    if(body) body.classList.toggle("kd-closed", !s.open);
    // module-specific open classes preserved (drawer/open, ketaNote/open)
    if(el.id === "drawer") el.classList.toggle("open", !!s.open);
    if(el.id === "ketaNote") {
      el.classList.toggle("open", !!s.open);
      $("ketaIcon").classList.toggle("open", !!s.open);
    }
  }

  function initOne(el){
    const id = el.getAttribute("data-kd-module");
    if(!id) return;

    const handleSel = el.getAttribute("data-kd-handle") || ".kd-h";
    const bodySel   = el.getAttribute("data-kd-body")   || ".kd-b";
    const resizeSel = el.getAttribute("data-kd-resize") || ".kd-r";

    // Fallback from current DOM rect if state missing
    const r = el.getBoundingClientRect();
    const fallback = {
      x: Math.max(0, Math.round(r.left)),
      y: Math.max(0, Math.round(r.top)),
      w: Math.max(240, Math.round(r.width || 320)),
      h: Math.max(120, Math.round(r.height || 240)),
      open: el.classList.contains("open")
    };

    const s = ensureModuleState(id, fallback);

    // Apply from state
    applyRect(el, s);
    applyOpen(el, s, bodySel);

    // Move
    const handle = qs(handleSel, el);
    if(handle){
      let on=false, sx=0, sy=0, bx=0, by=0;

      const start = (cx, cy) => { on=true; sx=cx; sy=cy; bx=s.x; by=s.y; };
      const move  = (cx, cy) => {
        if(!on) return;
        s.x = Math.max(0, bx + (cx - sx));
        s.y = Math.max(0, by + (cy - sy));
        el.style.left = s.x + "px";
        el.style.top  = s.y + "px";
      };
      const end = () => { if(!on) return; on=false; persist(); };

      handle.addEventListener("pointerdown", (e)=>{
        if(isTypingTarget(e.target) || isTypingTarget(document.activeElement)) return;
        if(e.target && e.target.closest("button")) return;
        start(e.clientX, e.clientY);
        try{ el.setPointerCapture(e.pointerId); }catch(_){}
        e.preventDefault();
      });
      handle.addEventListener("pointermove", (e)=> move(e.clientX, e.clientY));
      handle.addEventListener("pointerup", end);
      handle.addEventListener("pointercancel", end);

      // Mouse fallback
      handle.addEventListener("mousedown", (e)=>{
        if(isTypingTarget(e.target) || isTypingTarget(document.activeElement)) return;
        if(e.target && e.target.closest("button")) return;
        start(e.clientX, e.clientY);
        e.preventDefault();
      });
      window.addEventListener("mousemove", (e)=> move(e.clientX, e.clientY));
      window.addEventListener("mouseup", end);
    }

    // Resize
    const grip = qs(resizeSel, el);
    if(grip){
      let on=false, sx=0, sy=0, bw=0, bh=0;

      const start = (cx, cy) => { on=true; sx=cx; sy=cy; bw=s.w; bh=s.h; };
      const move  = (cx, cy) => {
        if(!on) return;
        const minW = 260, minH = 180;
        s.w = clamp(bw + (cx - sx), minW, window.innerWidth);
        s.h = clamp(bh + (cy - sy), minH, window.innerHeight);
        el.style.width  = s.w + "px";
        el.style.height = s.h + "px";
      };
      const end = () => { if(!on) return; on=false; persist(); };

      grip.addEventListener("pointerdown", (e)=>{
        if(isTypingTarget(e.target) || isTypingTarget(document.activeElement)) return;
        start(e.clientX, e.clientY);
        try{ grip.setPointerCapture(e.pointerId); }catch(_){}
        e.preventDefault();
      });
      grip.addEventListener("pointermove", (e)=> move(e.clientX, e.clientY));
      grip.addEventListener("pointerup", end);
      grip.addEventListener("pointercancel", end);

      grip.addEventListener("mousedown", (e)=>{
        if(isTypingTarget(e.target) || isTypingTarget(document.activeElement)) return;
        start(e.clientX, e.clientY);
        e.preventDefault();
      });
      window.addEventListener("mousemove", (e)=> move(e.clientX, e.clientY));
      window.addEventListener("mouseup", end);
    }

    // Collapse toggles (module-specific buttons)
    if(el.id === "drawer"){
      // drawer open/close is driven by STATE.modules.DRAWER.open
      // buttons already exist; wiring outside
    }
    if(el.id === "ketaNote"){
      // note open/close driven by STATE.modules.KETA_NOTE.open
    }
  }

  window.KD_INIT_MODULES = function(root=document){
    qsa("[data-kd-module]", root).forEach(initOne);
  };

  window.KD_APPLY_MODULES = function(){
    const drawer = $("drawer");
    const note = $("ketaNote");
    if(STATE.modules?.DRAWER && drawer){
      const s = STATE.modules.DRAWER;
      drawer.style.left = (s.x||0) + "px";
      drawer.style.top  = (s.y||0) + "px";
      drawer.style.width  = (s.w||window.innerWidth) + "px";
      drawer.style.height = (s.h||Math.round(window.innerHeight*0.38)) + "px";
      drawer.classList.toggle("open", !!s.open);
      drawer.style.display = s.open ? "flex" : "none";
    }
    if(STATE.modules?.KETA_NOTE && note){
      const s = STATE.modules.KETA_NOTE;
      note.style.left = (s.x||0) + "px";
      note.style.top  = (s.y||0) + "px";
      note.style.width  = (s.w||340) + "px";
      note.style.height = (s.h||220) + "px";
      note.classList.toggle("open", !!s.open);
      note.style.display = s.open ? "flex" : "none";
      $("ketaIcon").classList.toggle("open", !!s.open);
    }
  };
})();

/* =========================================================
EE/WB ▸ PERSISTENCE
========================================================= */
function persist(){
  STATE.updatedAt = nowISO();
  syncKetaNoteMeta("persist");
  saveGlobalKetaNote(STATE.ketaNote || "");
  try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(STATE)); }catch(e){}
  render();
}

function loadLocal(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return null;
    return mergeDefault(JSON.parse(raw));
  }catch(e){ return null; }
}

function mergeDefault(obj){
  const out = structuredClone(DEFAULT);
  Object.assign(out, obj||{});
  out.ui = Object.assign(structuredClone(DEFAULT.ui), (obj&&obj.ui)||{});
  out.payload = Object.assign({}, (obj&&obj.payload)||{});

  // ensure meta is present + tolerant
  if(obj && obj.ketaNoteMeta){
    out.ketaNoteMeta = Object.assign(structuredClone(DEFAULT.ketaNoteMeta), obj.ketaNoteMeta);
  }

  // modules tolerant merge
  out.modules = Object.assign(structuredClone(DEFAULT.modules), (obj&&obj.modules)||{});
  if(out.modules.DRAWER) out.modules.DRAWER = Object.assign(structuredClone(DEFAULT.modules.DRAWER), out.modules.DRAWER);
  if(out.modules.KETA_NOTE) out.modules.KETA_NOTE = Object.assign(structuredClone(DEFAULT.modules.KETA_NOTE), out.modules.KETA_NOTE);

  return out;
}

function exportState(){
  syncKetaNoteMeta("export");
  return JSON.stringify({ STORAGE_KEY, FILE_ID, ROOM_ID, VERSION_ID, STATE }, null, 2);
}

function importState(text){
  const parsed = JSON.parse(text);
  const incoming = parsed && parsed.STATE ? parsed.STATE : parsed;

  STATE = mergeDefault(incoming);
  saveGlobalKetaNote(STATE.ketaNote || "");
  stopLight(true);
  if(STATE.ui.lightRunning) startLight(STATE.ui.lightPreset);

  syncKetaNoteMeta("import");
  persist();
}

/* =========================================================
EE ▸ INVERT (Shift+I)
========================================================= */
function setInvert(on){ STATE.ui.invert = !!on; persist(); }

/* =========================================================
EE ▸ TRANSPORT (Space) — toggles light running + motion
========================================================= */
function toggleTransport(){
  if(STATE.ui.lightRunning) stopLight(true);
  else startLight(STATE.ui.lightPreset);

  STATE.ui.motionOn = !STATE.ui.motionOn;

  toast(`TRANSPORT ${STATE.ui.lightRunning ? "ON" : "OFF"} / MOTION ${STATE.ui.motionOn ? "ON" : "OFF"}`);
  persist();
}

/* =========================================================
EE ▸ LIGHTS 1–6
========================================================= */
let lightInterval = null;
let lightCount = 0, lightAuxA = 0, lightAuxB = 0;

function resetStage(){
  stage.style.backgroundColor = "#000000";
  stage.style.filter = "none";
  lightCount = 0; lightAuxA = 0; lightAuxB = 0;
}

function startLight(preset){
  stopLight(true);
  resetStage();
  STATE.ui.lightPreset = preset;
  STATE.ui.lightRunning = true;

  if(preset === 1){
    lightInterval = setInterval(()=>{
      const curr = stage.style.backgroundColor || "black";
      stage.style.backgroundColor = (curr === "black" || curr === "rgb(0, 0, 0)") ? "white" : "black";
      stage.style.filter = "none";
    }, 50);
  }

  if(preset === 2){
    lightInterval = setInterval(()=>{
      lightAuxA = (lightAuxA + 30) % 360;
      lightAuxB += 0.5;
      const lightness = 50 + Math.sin(lightAuxB) * 40;
      stage.style.backgroundColor = `hsl(${lightAuxA}, 100%, ${lightness}%)`;
      stage.style.filter = "none";
    }, 10);
  }

  if(preset === 3){
    lightInterval = setInterval(()=>{
      lightCount++;
      const beat = lightCount % 16;

      if (beat === 0 || beat === 1) {
        stage.style.backgroundColor = "#ffffff";
        stage.style.filter = "invert(1) contrast(3) brightness(2)";
      } else if (beat === 2) {
        stage.style.backgroundColor = "#000000";
        stage.style.filter = "invert(1) contrast(2)";
      } else if (beat === 3) {
        stage.style.backgroundColor = "#00ff00";
        stage.style.filter = "contrast(2) saturate(3)";
      } else if (beat === 4) {
        stage.style.backgroundColor = "#ff00ff";
        stage.style.filter = "invert(1) hue-rotate(90deg)";
      } else if (beat === 5 || beat === 6) {
        stage.style.backgroundColor = "#00ffff";
        stage.style.filter = "invert(0.7) contrast(2)";
      } else if (beat === 7) {
        stage.style.backgroundColor = "#ffffff";
        stage.style.filter = "invert(1) brightness(3)";
      } else if (beat === 8) {
        stage.style.backgroundColor = "#000000";
        stage.style.filter = "invert(1) contrast(3)";
      } else if (beat === 9 || beat === 10) {
        stage.style.backgroundColor = "#00ff00";
        stage.style.filter = "saturate(5) contrast(2)";
      } else if (beat === 11) {
        stage.style.backgroundColor = "#ff00ff";
        stage.style.filter = "invert(1) saturate(3)";
      } else {
        stage.style.backgroundColor = "#0088ff";
        stage.style.filter = "contrast(1.5) brightness(1.2)";
      }
    }, 30);
  }

  if(preset === 4){
    lightInterval = setInterval(()=>{
      lightAuxA += 0.08;
      lightCount++;

      const red = Math.abs(Math.sin(lightAuxA)) * 255;
      const pulse = Math.abs(Math.sin(lightAuxA * 0.5));
      const contrast = 2 + pulse * 2;
      const saturation = 4 + pulse * 2;

      if (lightCount % 8 === 0) {
        stage.style.backgroundColor = "#000000";
        stage.style.filter = "brightness(3) contrast(3)";
      } else if (lightCount % 8 === 1) {
        stage.style.backgroundColor = `rgb(${red}, 0, 0)`;
        stage.style.filter = `contrast(${contrast + 1}) saturate(${saturation + 2}) brightness(${1.5 + pulse * 0.5})`;
      } else {
        stage.style.backgroundColor = `rgb(${red}, 0, 0)`;
        stage.style.filter = `contrast(${contrast}) saturate(${saturation}) brightness(${1.2 + pulse * 0.5})`;
      }
    }, 20);
  }

  if(preset === 5){
    lightInterval = setInterval(()=>{
      lightAuxA += 15;
      lightAuxB = (lightAuxB + 2) % 100;

      const hue = 260 + Math.sin(lightAuxA * 0.1) * 40;
      const saturation = 80 + Math.cos(lightAuxA * 0.05) * 20;
      const lightness = 30 + Math.sin(lightAuxB * 0.1) * 30;

      const spiralBrightness = 1 + Math.abs(Math.sin(lightAuxA * 0.05)) * 0.8;
      const spiralContrast = 1.5 + Math.abs(Math.cos(lightAuxA * 0.08)) * 1;

      stage.style.backgroundColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
      stage.style.filter = `contrast(${spiralContrast}) saturate(2) brightness(${spiralBrightness}) hue-rotate(${lightAuxA * 0.5}deg)`;
    }, 25);
  }

  if(preset === 6){
    lightInterval = setInterval(()=>{
      lightCount++;

      if (lightCount % 50 === 0) {
        stage.style.backgroundColor = "#ffffff";
        stage.style.filter = "brightness(5) contrast(5)";
      } else if (lightCount % 50 === 1) {
        stage.style.backgroundColor = "#000000";
        stage.style.filter = "none";
      } else if (lightCount % 50 === 2) {
        stage.style.backgroundColor = "#ffffff";
        stage.style.filter = "brightness(5) contrast(5)";
      } else {
        stage.style.backgroundColor = "#000000";
        stage.style.filter = "none";
      }
    }, 30);
  }

  persist();
}

function stopLight(silent=false){
  if(lightInterval){ clearInterval(lightInterval); lightInterval = null; }
  STATE.ui.lightRunning = false;
  resetStage();
  if(!silent) persist();
}

function selectPreset(preset){
  STATE.ui.lightPreset = preset;
  if(STATE.ui.lightRunning) startLight(preset);
  else persist();
}

/* =========================================================
WB ▸ ROOM PRESETS (MULTI-ROOM REGISTRY)
========================================================= */
function ensureRoomPresets(){
  if(!STATE.payload || typeof STATE.payload !== "object") STATE.payload = {};
  if(!Array.isArray(STATE.payload.roomPresets)) STATE.payload.roomPresets = [];
}
function canonRoomName(name){
  return String(name || "").trim().toUpperCase();
}
function upsertRoomPreset(roomName, url){
  ensureRoomPresets();
  const room = canonRoomName(roomName) || "BASE";
  const roomUrl = String(url || "").trim();

  const idx = STATE.payload.roomPresets.findIndex(r => canonRoomName(r.room) === room);
  const preset = { room, roomUrl, updatedAt: nowISO() };

  if(idx >= 0) STATE.payload.roomPresets[idx] = Object.assign({}, STATE.payload.roomPresets[idx], preset);
  else STATE.payload.roomPresets.unshift(Object.assign({ createdAt: nowISO() }, preset));

  return preset;
}
function deleteRoomPreset(roomName){
  ensureRoomPresets();
  const room = canonRoomName(roomName);
  if(!room) return;
  STATE.payload.roomPresets = STATE.payload.roomPresets.filter(r => canonRoomName(r.room) !== room);
}
function loadPresetToFields(roomName){
  ensureRoomPresets();
  const room = canonRoomName(roomName);
  const preset = STATE.payload.roomPresets.find(r => canonRoomName(r.room) === room);
  if(!preset) return;
  $("roomInput").value = preset.room || "";
  $("roomUrlInput").value = preset.roomUrl || "";
}
function setActiveRoom(roomName, url){
  STATE.room = (canonRoomName(roomName) || "BASE").trim();
  STATE.roomUrl = String(url || "").trim();
}
function renderRoomList(){
  const el = $("roomList");
  if(!el) return;

  ensureRoomPresets();

  const presets = STATE.payload.roomPresets.slice().sort((a,b)=>{
    const ta = Date.parse(a.updatedAt || a.createdAt || 0);
    const tb = Date.parse(b.updatedAt || b.createdAt || 0);
    return tb - ta;
  });

  el.innerHTML = "";

  if(!presets.length){
    const empty = document.createElement("div");
    empty.style.border = "1px solid var(--line2)";
    empty.style.padding = "8px 10px";
    empty.style.fontFamily = "var(--mono)";
    empty.style.fontSize = "11px";
    empty.style.letterSpacing = ".08em";
    empty.style.textTransform = "uppercase";
    empty.style.color = "var(--muted)";
    empty.textContent = "NO PRESETS";
    el.appendChild(empty);
    return;
  }

  presets.forEach(p=>{
    const row = document.createElement("div");
    row.style.border = "1px solid var(--line2)";
    row.style.padding = "8px 10px";
    row.style.fontFamily = "var(--mono)";
    row.style.fontSize = "11px";
    row.style.letterSpacing = ".08em";
    row.style.textTransform = "uppercase";
    row.style.color = "var(--fg)";
    row.style.cursor = "pointer";
    row.style.display = "flex";
    row.style.justifyContent = "space-between";
    row.style.gap = "10px";

    const left = document.createElement("div");
    left.textContent = p.room || "ROOM";

    const right = document.createElement("div");
    right.style.color = "var(--muted)";
    right.style.whiteSpace = "nowrap";
    right.style.overflow = "hidden";
    right.style.textOverflow = "ellipsis";
    right.style.maxWidth = "55%";
    right.textContent = (p.roomUrl && p.roomUrl.trim()) ? "URL" : "NO URL";

    row.addEventListener("click", ()=>{
      loadPresetToFields(p.room);
      toast("PRESET LOADED");
    });

    row.addEventListener("dblclick", ()=>{
      setActiveRoom(p.room, p.roomUrl);
      toast("ACTIVE ROOM SET");
      persist();
    });

    if(canonRoomName(STATE.room) === canonRoomName(p.room)){
      row.style.borderColor = "var(--fg)";
    }

    row.appendChild(left);
    row.appendChild(right);
    el.appendChild(row);
  });
}

/* =========================================================
WB ▸ UI / IO / NOTE / DRAWER / HOTKEYS
========================================================= */
function setDrawer(open){
  STATE.modules.DRAWER.open = !!open;
  persist();
}
function setKetaNote(open){
  STATE.modules.KETA_NOTE.open = !!open;
  persist();
}

function download(filename, text){
  const blob = new Blob([text], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 800);
}

async function copy(text){
  try{ await navigator.clipboard.writeText(text); toast("COPIED"); }
  catch(e){ toast("COPY FAILED"); }
}

let toastTimer=null;
function toast(msg){
  const t = $("toast");
  t.textContent = msg;
  t.style.display = "block";
  if(toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>{ t.style.display="none"; }, 900);
}

function render(){
  root.classList.toggle("invert", !!STATE.ui.invert);
  motion.classList.toggle("run", !!STATE.ui.motionOn);

  $("ketaText").value = STATE.ketaNote || "";
  $("universals").value = STATE.universals || "";

  $("roomName").textContent = (STATE.room || "BASE").toUpperCase();
  $("roomInput").value = STATE.room || "";
  $("roomUrlInput").value = STATE.roomUrl || "";

  const s = stableSig();
  $("sig").textContent = s;
  $("sig2").textContent = s;

  $("lightLabel").textContent = String(STATE.ui.lightPreset);
  $("runLabel").textContent = STATE.ui.lightRunning ? "ON" : "OFF";
  $("motionLabel").textContent = STATE.ui.motionOn ? "ON" : "OFF";

  const hasUrl = !!(STATE.roomUrl && String(STATE.roomUrl).trim());
  $("roomJump").classList.toggle("show", hasUrl);
  if(hasUrl){
    $("roomJumpTxt").textContent = `ROOM LINK: ${(STATE.room||"ROOM").toUpperCase()}`;
  }

  renderRoomList();

  // Apply module rect/open every render (literal state)
  if(window.KD_APPLY_MODULES) window.KD_APPLY_MODULES();
}

/* Buttons */
$("btnImport").addEventListener("click", ()=> $("file").click());
$("file").addEventListener("change", async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const txt = await f.text();
  importState(txt);
  e.target.value = "";
  toast("STATE IMPORTED");
});

$("btnExport").addEventListener("click", ()=>{ download("KETADATA_SHELL_KERNEL_v1_state.json", exportState()); toast("STATE EXPORTED"); });
$("btnCopy").addEventListener("click", ()=> copy(exportState()));

$("toggleDrawer").addEventListener("click", ()=> setDrawer(!STATE.modules.DRAWER.open));
$("btnCloseDrawer").addEventListener("click", ()=> setDrawer(false));
$("btnCopyUniversals").addEventListener("click", ()=> copy(STATE.universals || ""));

$("universals").addEventListener("input", ()=>{ STATE.universals = $("universals").value; persist(); });

$("ketaIcon").addEventListener("click", ()=>{
  const open = !STATE.modules.KETA_NOTE.open;
  setKetaNote(open);
  toast(open ? "KETA_NOTE OPEN" : "KETA_NOTE CLOSED");
});
$("btnHideNote").addEventListener("click", ()=> setKetaNote(false));
$("ketaText").addEventListener("input", ()=>{ STATE.ketaNote = $("ketaText").value; saveGlobalKetaNote(STATE.ketaNote); persist(); });

/* UPDATED: room preset actions */
$("btnSaveRoom").addEventListener("click", ()=>{
  const roomName = $("roomInput").value || "BASE";
  const url = $("roomUrlInput").value || "";
  upsertRoomPreset(roomName, url);
  toast("PRESET SAVED");
  persist();
});
$("btnSetActiveRoom").addEventListener("click", ()=>{
  const roomName = $("roomInput").value || "BASE";
  const url = $("roomUrlInput").value || "";
  upsertRoomPreset(roomName, url);
  setActiveRoom(roomName, url);
  toast("ACTIVE ROOM SET");
  persist();
});
$("btnDeleteRoom").addEventListener("click", ()=>{
  const roomName = $("roomInput").value || "";
  if(!roomName.trim()){
    toast("NO ROOM");
    return;
  }
  deleteRoomPreset(roomName);
  toast("PRESET DELETED");
  persist();
});

$("btnGoRoom").addEventListener("click", ()=>{
  if(!STATE.roomUrl) return;
  window.location.href = STATE.roomUrl;
});
$("btnDismissRoom").addEventListener("click", ()=>{
  STATE.roomUrl = "";
  persist();
});

/* Hotkeys (unchanged) */
document.addEventListener("keydown", (e)=>{
  const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
  const typing = (tag==="textarea" || tag==="input");

  if(e.shiftKey && e.key.toLowerCase()==="i"){
    e.preventDefault();
    setInvert(!STATE.ui.invert);
    toast(STATE.ui.invert ? "INVERT ON" : "INVERT OFF");
    return;
  }

  if(!typing && /^[1-6]$/.test(e.key)){
    e.preventDefault();
    selectPreset(parseInt(e.key,10));
    toast(`LIGHT ${STATE.ui.lightPreset} SELECTED`);
    return;
  }

  if(!typing && (e.code==="Space" || e.key===" ")){
    e.preventDefault();
    toggleTransport();
    return;
  }

  if(e.key==="Escape"){
    setDrawer(false);
    setKetaNote(false);
    stopLight(true);
    STATE.ui.motionOn = false;
    toast("CLOSED");
    persist();
    return;
  }
});

/* Boot */
ensureKetaNoteMeta();
syncKetaNoteMeta("boot");

// init modules after state is deep-filled and DOM exists
if(window.KD_INIT_MODULES) window.KD_INIT_MODULES(document);

// render from state
render();

window.KETA_NOTE = {
  setCategoryIds(ids){
    ensureKetaNoteMeta();
    STATE.ketaNoteMeta.categoryIds = Array.isArray(ids) ? ids.slice(0,64) : [];
    STATE.ketaNoteMeta.updatedAt = nowISO();
    persist();
  },
  getMeta(){
    ensureKetaNoteMeta();
    return structuredClone(STATE.ketaNoteMeta);
  }
};

/* =========================================================
AE: sharp, thin, machinic note; all caps commands; industrial density
EE: KETA_NOTE + exportable state; invert-all; lights 1–6; transport motion
EE/WB: modules = literal UI rect/open for drawer + note (movable/resizable/collapsible)
WB: tolerant merge; page sovereignty; stage pointer-events none
========================================================= */
</script>
</body>
</html>

<!--
============================================================
KETADATA HTML SERIALIZATION STAMP
FILE_ID: KETADATA_SHELL_V4
ROOM_ID: BASE
VERSION: shellv4.base.v4
UPDATED_AT: 2025-12-30T00:00:00-05:00
AUTHOR: KNG / BIGGIE
INTENT: KERNEL SHELL (SINGLE-FILE)
STATUS: CANONICAL
NOTES: UI LOCKED. ONLY CHANGE WHEN EXPLICITLY REQUESTED.

AE: SHARP BLACK/WHITE. GEOMETRIC. NO KITSCH. ALL CAPS COMMANDS.
EE: EXPORTABLE STATE. KETA_NOTE PERSISTENCE. INVERT. LIGHTS 1–6. TRANSPORT.
EE/WB: MODULE LAW (MOVE/RESIZE/COLLAPSE) STORED IN STATE.modules.
WB: TOLERANT MERGE. PAGE SOVEREIGN STORAGE KEY. ROOM/STATE LABELING INTO NOTE META.

LOCALSTORAGE_KEY: KDT::STATE::KETADATA_SHELL_V4::BASE::shellv4.base.v4
EXPORT_ENVELOPE: { STORAGE_KEY, FILE_ID, ROOM_ID, VERSION_ID, STATE }

NEW ROOM PRESETS:
- STORED IN: STATE.payload.roomPresets[]
- ACTIVE ROOM STILL: STATE.room / STATE.roomUrl

CHANGELOG:
- 2025-12-30: Added STATE.modules for core movable/resizable/collapsible primitives (DRAWER, KETA_NOTE).
- 2025-12-30: Enforced KD module kernel in Shell (no per-surface drift).
- 2025-12-30: VERSION bump to shellv4.base.v4 due to state shape change.
============================================================
-->
