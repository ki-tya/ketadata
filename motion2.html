<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA // DANCE FIELD (SOVEREIGN)</title>
<style>
:root{
  --bg:#000;
  --fg:rgba(255,255,255,.86);
  --muted:rgba(255,255,255,.52);
  --line:rgba(255,255,255,.14);
  --line2:rgba(255,255,255,.22);
  --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  --sans: Arial,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  --top:44px;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);overflow:hidden;font-family:var(--sans)}
#top{
  position:fixed;left:0;right:0;top:0;height:var(--top);
  display:flex;align-items:center;gap:8px;padding:6px 8px;
  background:rgba(0,0,0,.78);border-bottom:1px solid var(--line);z-index:10;
}
.btn,.chip{
  height:30px;display:inline-flex;align-items:center;gap:8px;padding:0 10px;
  border:1px solid var(--line2);background:rgba(0,0,0,.30);color:var(--fg);
  font:12px/1 var(--sans);white-space:nowrap;user-select:none;
}
.btn{cursor:pointer}
.btn:active{transform:translateY(1px)}
.k{font-family:var(--mono);opacity:.9}
.sep{flex:1}
input[type="range"]{width:130px;accent-color:#fff}
#stage{
  position:fixed;left:0;top:var(--top);
  width:100vw;height:calc(100vh - var(--top));
}
video{position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0}
body.invert{filter:invert(1)}
</style>
</head>
<body>

<div id="top">
  <div class="chip k">KETADATA // DANCE FIELD</div>

  <div class="btn" id="start">START CAM</div>
  <div class="btn" id="stop">STOP</div>
  <div class="btn" id="invert">INVERT</div>
  <div class="btn" id="mode">MODE: RAVE</div>

  <div class="chip">ENERGY <input id="energy" type="range" min="0" max="100" value="70"></div>
  <div class="chip">COUNT <input id="count" type="range" min="4000" max="60000" value="26000"></div>
  <div class="chip">THR <input id="thr" type="range" min="1" max="80" value="14"></div>

  <div class="sep"></div>
  <div class="chip k" id="status">LOCAL</div>
</div>

<canvas id="stage"></canvas>
<video id="video" playsinline muted></video>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const canvas = $("stage");
  const ctx = canvas.getContext("2d",{alpha:false});

  let W=0,H=0,DPR=1;
  function resize(){
    DPR=Math.max(1,Math.min(2,window.devicePixelRatio||1));
    W=Math.floor(canvas.offsetWidth*DPR);
    H=Math.floor(canvas.offsetHeight*DPR);
    canvas.width=W; canvas.height=H;
  }
  addEventListener("resize",resize); resize();

  const STATE={
    running:true,
    energy:0.70,
    targetCount:26000,
    motionThr:14,
    camOn:false,
    mode:0, // 0 rave, 1 pulse, 2 smoke
    t0:performance.now(),
    // beat engine (synthetic)
    bpm:128,
    beat:0,
    beatPhase:0,
    energySmooth:0,
    kick:0,
    snare:0,
    hat:0
  };

  const setStatus = (s)=>$("status").textContent=s;

  $("invert").onclick=()=>document.body.classList.toggle("invert");
  $("stop").onclick=()=>{
    STATE.running=!STATE.running;
    $("stop").textContent=STATE.running?"STOP":"RUN";
  };
  $("energy").oninput=(e)=>STATE.energy=(+e.target.value)/100;
  $("count").oninput=(e)=>STATE.targetCount=(+e.target.value)|0;
  $("thr").oninput=(e)=>STATE.motionThr=(+e.target.value)|0;

  const modeNames=["RAVE","PULSE","SMOKE"];
  $("mode").onclick=()=>{
    STATE.mode=(STATE.mode+1)%3;
    $("mode").textContent="MODE: "+modeNames[STATE.mode];
  };

  /* ===== particles ===== */
  let P=[];
  function seed(n){
    P.length=0;
    for(let i=0;i<n;i++){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()-.5)*0.25,
        vy:(Math.random()-.5)*0.25,
        h:Math.random() // hue-ish param for shimmering (no explicit colors used; drives alpha patterns)
      });
    }
  }
  seed(STATE.targetCount);

  function ensureCount(){
    const n=STATE.targetCount|0;
    if(P.length===n) return;
    if(n<P.length){P.length=n; return;}
    while(P.length<n){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()-.5)*0.25,
        vy:(Math.random()-.5)*0.25,
        h:Math.random()
      });
    }
  }

  /* ===== attractors ===== */
  // [0]=mouse, [1]=motion-left, [2]=motion-right, [3]=center-vortex
  const A=[
    {x:W*.5,y:H*.5,str:1},
    {x:W*.35,y:H*.5,str:0},
    {x:W*.65,y:H*.5,str:0},
    {x:W*.5,y:H*.5,str:0.9}
  ];

  let mouseDown=false;
  addEventListener("pointerdown",(e)=>{mouseDown=true;setMouse(e)});
  addEventListener("pointerup",()=>{mouseDown=false});
  addEventListener("pointermove",setMouse);

  function setMouse(e){
    const r=canvas.getBoundingClientRect();
    A[0].x=(e.clientX-r.left)*DPR;
    A[0].y=(e.clientY-r.top)*DPR;
    A[0].str=mouseDown?2.4:1.2;
  }

  /* ===== webcam motion (sovereign) ===== */
  const video=$("video");
  let stream=null;

  const DET_W=180, DET_H=100;
  const det=document.createElement("canvas");
  det.width=DET_W; det.height=DET_H;
  const dctx=det.getContext("2d",{willReadFrequently:true});
  let prev=null;

  async function startCam(){
    if(STATE.camOn) return;
    setStatus("CAM REQUEST");
    try{
      stream=await navigator.mediaDevices.getUserMedia({
        video:{facingMode:"user", width:{ideal:1280}, height:{ideal:720}},
        audio:false
      });
      video.srcObject=stream;
      await video.play();
      STATE.camOn=true;
      prev=null;
      setStatus("CAM ON");
    }catch{
      setStatus("CAM BLOCKED");
    }
  }
  $("start").onclick=startCam;

  function updateMotion(){
    if(!STATE.camOn) { A[1].str=0; A[2].str=0; return 0; }

    dctx.save();
    dctx.scale(-1,1);
    dctx.drawImage(video,-DET_W,0,DET_W,DET_H);
    dctx.restore();

    const img=dctx.getImageData(0,0,DET_W,DET_H).data;
    if(!prev){ prev=new Uint8ClampedArray(img); return 0; }

    let lx=0,ly=0,lm=0, rx=0,ry=0,rm=0;
    let total=0;

    const thr=STATE.motionThr|0;

    for(let y=0;y<DET_H;y++){
      for(let x=0;x<DET_W;x++){
        const i=(y*DET_W+x)*4;
        const d=Math.abs(img[i]-prev[i]); // red channel diff (fast)
        prev[i]=img[i];
        if(d<thr) continue;
        total += d;

        if(x<DET_W/2){ lm+=d; lx+=x*d; ly+=y*d; }
        else{ rm+=d; rx+=x*d; ry+=y*d; }
      }
    }

    if(lm){
      A[1].x=(lx/lm)/DET_W*W;
      A[1].y=(ly/lm)/DET_H*H;
      A[1].str=Math.min(3.2, lm/5200);
    }else A[1].str=0;

    if(rm){
      A[2].x=(rx/rm)/DET_W*W;
      A[2].y=(ry/rm)/DET_H*H;
      A[2].str=Math.min(3.2, rm/5200);
    }else A[2].str=0;

    // normalized scene energy 0..1-ish
    const norm = (DET_W*DET_H) * 10.0;
    return Math.max(0, Math.min(1.4, total / norm));
  }

  /* ===== beat engine (synthetic, no audio) ===== */
  function beatUpdate(t){
    const bpm = STATE.bpm;
    const bps = bpm/60;
    const phase = (t/1000)*bps;          // beats elapsed
    const frac = phase - Math.floor(phase);

    // kick: sharp at beat start
    const kick = Math.pow(Math.max(0, 1 - frac*9), 3);

    // snare: on off-beat (approx at 0.5)
    const snareFrac = Math.abs(frac-0.5);
    const snare = Math.pow(Math.max(0, 1 - snareFrac*10), 5) * 0.8;

    // hat: fast ticks
    const hat = Math.pow(Math.max(0, 1 - ((frac*4)%1)*12), 6) * 0.35;

    STATE.kick = kick;
    STATE.snare = snare;
    STATE.hat = hat;
    STATE.beatPhase = frac;
  }

  /* ===== draw helpers (no explicit colors, only alpha/ops) ===== */
  function clearWithTrail(alpha){
    // alpha: 0..1 => more alpha means more clearing (less trail)
    ctx.globalCompositeOperation="source-over";
    ctx.fillStyle = `rgba(0,0,0,${alpha})`;
    ctx.fillRect(0,0,W,H);
  }

  function drawSigil(t, intensity){
    // subtle center pulse ring (white via alpha only)
    const cx=W*0.5, cy=H*0.5;
    const r = (Math.min(W,H)*0.18) * (1 + 0.35*STATE.kick);
    const a = 0.05 + 0.14*intensity;
    ctx.globalCompositeOperation="lighter";
    ctx.strokeStyle = `rgba(255,255,255,${a})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.stroke();
    ctx.globalCompositeOperation="source-over";
  }

  /* ===== main loop ===== */
  let last=performance.now();

  function frame(t){
    requestAnimationFrame(frame);
    if(!STATE.running) return;

    ensureCount();
    resize(); // safe: keeps iOS correct under dynamic bars

    beatUpdate(t);

    const dt = Math.min(32, t-last); last=t;
    const motionEnergy = updateMotion();

    // combine slider energy + motion energy
    const e = Math.max(0, Math.min(1.5, STATE.energy*1.15 + motionEnergy*0.95));
    STATE.energySmooth = STATE.energySmooth*0.90 + e*0.10;

    // mode-dependent trail + impulse
    if(STATE.mode===0){ // RAVE: strong trails, staccato pulses
      clearWithTrail(0.10 + 0.14*(1-STATE.kick));
    }else if(STATE.mode===1){ // PULSE: cleaner, more readable
      clearWithTrail(0.18 + 0.10*(1-STATE.kick));
    }else{ // SMOKE: long trails
      clearWithTrail(0.06 + 0.08*(1-STATE.kick));
    }

    // center vortex attractor moves slightly with beat
    const wob = (STATE.snare - STATE.kick) * 0.04;
    A[3].x = W*(0.5 + wob);
    A[3].y = H*(0.5 - wob);

    // base forces
    const pull = 0.0007 + 0.0048 * Math.min(1, STATE.energySmooth);
    const damp = 0.988 - 0.09 * Math.min(1, STATE.energySmooth);
    const jitter = 0.00010 + 0.00075 * Math.min(1, STATE.energySmooth);

    // beat “push” multiplier
    const beatPush = 1 + 1.6*STATE.kick + 0.6*STATE.hat;

    // draw particles
    ctx.globalCompositeOperation="lighter";

    // alpha shifts with beat (still monochrome)
    const pointA = 0.06 + 0.08*STATE.kick + 0.03*STATE.hat;
    ctx.fillStyle = `rgba(255,255,255,${pointA})`;

    const cx=W*0.5, cy=H*0.5;

    for(let i=0;i<P.length;i++){
      const p=P[i];

      let ax=0, ay=0;

      // attractors: mouse + motion + vortex
      for(let j=0;j<A.length;j++){
        const a=A[j];
        if(j===1 || j===2){
          if(a.str<=0.001) continue;
        }

        const dx=a.x-p.x, dy=a.y-p.y;
        const d2 = dx*dx + dy*dy + 90.0;
        const inv = 1.0/d2;

        // mode shapes behavior
        let s = pull * a.str;

        if(STATE.mode===0){ // RAVE: punchier grabs
          s *= beatPush;
        }else if(STATE.mode===1){ // PULSE: smoother
          s *= (1 + 0.9*STATE.kick);
        }else{ // SMOKE: softer
          s *= (0.8 + 0.6*STATE.kick);
        }

        ax += dx*inv*s;
        ay += dy*inv*s;

        // add slight swirl around center in RAVE/SMOKE
        if(j===3){
          const sx = p.x - cx, sy = p.y - cy;
          const swirl = (STATE.mode===0 ? 0.00015 : 0.00010) * (0.7 + 1.2*STATE.kick);
          ax += (-sy) * swirl;
          ay += ( sx) * swirl;
        }
      }

      // micro noise
      ax += (Math.random()-0.5)*jitter;
      ay += (Math.random()-0.5)*jitter;

      p.vx = (p.vx + ax*dt) * damp;
      p.vy = (p.vy + ay*dt) * damp;

      // “dance floor push” on kick: radial burst outward
      if(STATE.kick > 0.6){
        const sx = p.x - cx, sy = p.y - cy;
        const inv = 1/ (Math.hypot(sx,sy) + 80);
        const burst = 0.020 * (STATE.kick-0.6) * dt * inv;
        p.vx += sx * burst;
        p.vy += sy * burst;
      }

      p.x = (p.x + p.vx*dt + W) % W;
      p.y = (p.y + p.vy*dt + H) % H;

      ctx.fillRect(p.x, p.y, 1, 1);
    }

    ctx.globalCompositeOperation="source-over";

    // optional sigil pulse
    if(STATE.mode!==1) drawSigil(t, Math.min(1, STATE.energySmooth));

    // status
    if(STATE.camOn){
      const live = (A[1].str>0.15)||(A[2].str>0.15);
      setStatus(live ? "CAM + DANCE" : "CAM (LOW MOTION)");
    }else{
      setStatus("LOCAL (MOUSE)");
    }
  }

  requestAnimationFrame(frame);

  // hard stop on unload
  addEventListener("beforeunload", () => {
    try{
      if(stream){ for(const tr of stream.getTracks()) tr.stop(); }
    }catch(_){}
  });

})();
</script>

<!--
AE: KETADATA
EE: DANCE_FIELD_SOVEREIGN
WB: SINGLE_FILE_HTML
FILE_ID: KETA_DANCE_FIELD_SOV_v1
ROOM_ID: BASE
VERSION: 1
UPDATED_AT: 2026-01-08
CHANGELOG:
- v1: sovereign webcam motion + beat-simulated particle rave field for dancing
-->
</body>
</html>
