<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA — THINKER INTERFACES (FOUCAULT → … → FREUD)</title>
  <style>
    :root{
      --bg:#000;
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.56);
      --hair:rgba(255,255,255,.14);
      --panel:rgba(0,0,0,.58);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; overflow:hidden;
      background:var(--bg); color:var(--fg);
      font-family: Arial, Helvetica, sans-serif;
    }
    canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block;}

    .hud{
      position:fixed; left:18px; top:16px;
      user-select:none; pointer-events:none;
      mix-blend-mode:screen;
    }
    .brand{
      font-weight:900;
      letter-spacing:.18em;
      text-transform:uppercase;
      font-size:15px;
      text-shadow:0 0 18px rgba(255,255,255,.18);
    }
    .sub{
      margin-top:4px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:var(--muted);
      line-height:1.25;
      max-width: 62ch;
    }

    .dock{
      position:fixed; left:18px; bottom:16px;
      display:flex; flex-wrap:wrap; gap:10px; align-items:center;
      pointer-events:auto;
    }
    .btn, select{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.22);
      color:rgba(255,255,255,.86);
      padding:10px 12px;
      border-radius:10px;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
      outline:none;
    }
    select{ cursor:pointer; }
    .btn:hover, select:hover{ background:rgba(255,255,255,.10); border-color:rgba(255,255,255,.36); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }

    .panel{
      position:fixed; right:16px; top:16px;
      width:min(780px, calc(100vw - 32px));
      max-height: calc(100vh - 32px);
      overflow:auto;
      border:1px solid rgba(255,255,255,.18);
      background:var(--panel);
      backdrop-filter: blur(10px);
      border-radius:14px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset, 0 16px 50px rgba(0,0,0,.65);
    }
    .panelHeader{
      position:sticky; top:0;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.74);
      display:flex; justify-content:space-between; align-items:center;
      z-index:10;
    }
    .title{
      font-weight:900;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      color:rgba(255,255,255,.86);
    }
    .hint{
      font-size:11px;
      letter-spacing:.08em;
      color:rgba(255,255,255,.55);
      text-align:right;
      line-height:1.2;
    }
    .panelBody{ padding:10px 12px 14px; display:flex; flex-direction:column; gap:10px; }

    .block{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      overflow:hidden;
      background:rgba(255,255,255,.02);
    }
    .block h3{
      margin:0;
      padding:10px 10px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:rgba(255,255,255,.75);
      border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      display:flex; justify-content:space-between; align-items:center; gap:10px;
    }
    .pill{
      font-size:10px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:rgba(255,255,255,.62);
      border:1px solid rgba(255,255,255,.18);
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.20);
      white-space:nowrap;
    }
    .rows{ padding:10px; display:flex; flex-direction:column; gap:10px; }
    .row{
      display:grid;
      grid-template-columns: 260px 1fr 70px;
      gap:10px;
      align-items:center;
    }
    .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:rgba(255,255,255,.62);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    input[type="range"]{ width:100%; accent-color: rgba(255,255,255,.92); }
    .val{ font-variant-numeric: tabular-nums; font-size:11px; color:rgba(255,255,255,.76); text-align:right; }

    .status{
      padding:10px;
      border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
      display:flex; flex-direction:column; gap:8px;
    }
    .mono{
      font-variant-numeric: tabular-nums;
      letter-spacing:.10em;
      text-transform:uppercase;
      font-size:10px;
      color:rgba(255,255,255,.74);
      line-height:1.35;
    }
    .card{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      background:rgba(0,0,0,.45);
      padding:10px;
      font-size:12px;
      line-height:1.35;
      letter-spacing:.02em;
      white-space:pre-wrap;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="brand">KETADATA</div>
    <div class="sub" id="modeSub">THINKER MODE · SELECT BELOW · CLICK = EVENT · DRAG = GESTURE · SCROLL = ZOOM · [H] PANEL · [P] PAUSE · [I] INVERT</div>
  </div>

  <div class="dock">
    <select id="mode">
      <option value="foucault">FOUCAULT</option>
      <option value="bataille">BATAILLE</option>
      <option value="baudrillard">BAUDRILLARD</option>
      <option value="benjamin">BENJAMIN</option>
      <option value="flusser">FLUSSER</option>
      <option value="barthes">BARTHES</option>
      <option value="sontag">SONTAG</option>
      <option value="lacan">LACAN</option>
      <option value="freud">FREUD</option>
      <option value="pause">PAUSE</option>
    </select>
    <button class="btn" id="invert">INVERT</button>
    <button class="btn" id="pauseBtn">PAUSE</button>
    <button class="btn" id="reseed">RESEED</button>
    <button class="btn" id="clear">CLEAR</button>
    <button class="btn" id="reset">RESET</button>
  </div>

  <div class="panel" id="panel">
    <div class="panelHeader">
      <div class="title">CONTROL SURFACE</div>
      <div class="hint">
        CLICK = MARK / PUNCTUM / CONFESSION (mode-dependent)<br/>
        DRAG = PAN (or GESTURE) · SCROLL = ZOOM
      </div>
    </div>

    <div class="panelBody">
      <div class="block">
        <h3>Global <span class="pill">performance-safe</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">time scale (slow-mo)</div>
            <input id="timeScale" type="range" min="0.000" max="2.000" step="0.001" value="0.35">
            <div class="val" id="timeScaleV">0.350</div>
          </div>
          <div class="row">
            <div class="label">intensity</div>
            <input id="intensity" type="range" min="0.00" max="2.00" step="0.01" value="1.05">
            <div class="val" id="intensityV">1.05</div>
          </div>
          <div class="row">
            <div class="label">noise</div>
            <input id="noise" type="range" min="0.00" max="1.00" step="0.01" value="0.28">
            <div class="val" id="noiseV">0.28</div>
          </div>
          <div class="row">
            <div class="label">trace</div>
            <input id="trace" type="range" min="0.000" max="0.22" step="0.001" value="0.055">
            <div class="val" id="traceV">0.055</div>
          </div>
          <div class="row">
            <div class="label">zoom</div>
            <input id="zoom" type="range" min="0.55" max="2.60" step="0.01" value="1.20">
            <div class="val" id="zoomV">1.20</div>
          </div>
        </div>
        <div class="status">
          <div class="mono" id="stat">—</div>
          <div class="card" id="card">MODE NOTES WILL APPEAR HERE.</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha:false });

      let W=0, H=0, DPR=Math.min(2, window.devicePixelRatio||1);
      function resize(){
        W=innerWidth; H=innerHeight;
        canvas.width = Math.floor(W*DPR);
        canvas.height = Math.floor(H*DPR);
        canvas.style.width = W+'px';
        canvas.style.height = H+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize);
      resize();

      const $ = (id)=>document.getElementById(id);
      const ui = {
        mode: $('mode'),
        timeScale: $('timeScale'),
        intensity: $('intensity'),
        noise: $('noise'),
        trace: $('trace'),
        zoom: $('zoom'),
      };
      const vv = {
        timeScaleV: $('timeScaleV'),
        intensityV: $('intensityV'),
        noiseV: $('noiseV'),
        traceV: $('traceV'),
        zoomV: $('zoomV'),
      };

      function syncVals(){
        vv.timeScaleV.textContent = (+ui.timeScale.value).toFixed(3);
        vv.intensityV.textContent = (+ui.intensity.value).toFixed(2);
        vv.noiseV.textContent = (+ui.noise.value).toFixed(2);
        vv.traceV.textContent = (+ui.trace.value).toFixed(3);
        vv.zoomV.textContent = (+ui.zoom.value).toFixed(2);
      }
      Object.values(ui).forEach(el=>{
        if (!el || !el.addEventListener) return;
        el.addEventListener('input', syncVals);
        el.addEventListener('change', syncVals);
      });
      syncVals();

      const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
      const lerp=(a,b,t)=>a+(b-a)*t;
      const hash32=(n)=>{n=(n^(n>>>16))>>>0;n=Math.imul(n,2246822519)>>>0;n=(n^(n>>>13))>>>0;n=Math.imul(n,3266489917)>>>0;n=(n^(n>>>16))>>>0;return n>>>0;}
      const rnd01=(n)=>hash32(n)/4294967295;

      const st = {
        t:0,
        invert:false,
        paused:false,
        seed:(Math.random()*1e9)|0,
        ox:0, oy:0,
        wheel:0,
        zoom:1.0,

        // interaction
        dragging:false,
        dragType:"pan",
        lx:0, ly:0,
        mx:0, my:0,

        // events
        marks:[],     // generic marks in stage coords
        log:[],       // text log lines for some modes

        // mode-specific state
        panoptic: { heat:0.0, gaze:0.0 },        // Foucault
        excess:   { ex:0.22, burn:0.0 },         // Bataille
        sim:      { drift:0.0, copies:3 },       // Baudrillard
        aura:     { aura:1.0, repro:0.0 },       // Benjamin
        app:      { prog:0.0, gesture:0.0 },     // Flusser
        punct:    { x:0, y:0, p:0.0 },           // Barthes
        ethic:    { regard:0.45, shock:0.0 },    // Sontag
        rsi:      { slip:0.0 },                  // Lacan
        dream:    { cond:0.55, disp:0.55 },      // Freud
      };

      function stageToScreen(x,y){
        const S = Math.min(W,H) * 0.60 * st.zoom;
        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;
        return { x: cx + x*S, y: cy + y*S };
      }
      function screenToStage(sx,sy){
        const S = Math.min(W,H) * 0.60 * st.zoom;
        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;
        return { x: (sx-cx)/S, y: (sy-cy)/S };
      }

      function setModeNotes(mode){
        const sub = $('modeSub');
        const card = $('card');
        const title = ui.mode.options[ui.mode.selectedIndex].textContent;

        const notes = {
          foucault:
`FOUCAULT (DISCIPLINE / PANOPTICON)
- The grid is the institution. The cone is the gaze.
- Click creates a “confession record” (it increases legibility and pressure).
- Drag near center draws a “corridor” (routing bodies).
- The more marks you add, the more the gaze stabilizes.`,
          bataille:
`BATAILLE (EXCESS / EXPENDITURE)
- Excess meter grows unless you burn it.
- Click adds “expenditure” (burn) that releases pressure but leaves residue.
- Drag is “waste motion” — it throws particles outward.
- You can run this very slow and still watch the economy.`,
          baudrillard:
`BAUDRILLARD (SIMULACRA)
- Reality is the weakest layer. Copies dominate.
- Click spawns a new copy-layer offset (“copy of copy”).
- Drag introduces drift and detaches sign from referent.`,
          benjamin:
`BENJAMIN (AURA / REPRODUCTION)
- Aura decays as reproduction increases.
- Click makes a reproduction (a stamp). Aura fades; archive thickens.
- Drag moves the “original” through its copies.`,
          flusser:
`FLUSSER (APPARATUS / PROGRAM)
- You operate inside a program; gestures are permitted moves.
- Click adds a node to the apparatus graph.
- Drag draws a “gesture path” that the program learns.`,
          barthes:
`BARTHES (PUNCTUM)
- Click sets the punctum: the single wound-point.
- Everything else is studium (field / discourse).
- The punctum radiates constraint and pulls attention.`,
          sontag:
`SONTAG (REGARDING / ETHICS)
- Regard slider is implicit: the interface judges your looking.
- Click adds an “image event”; shock accumulates if regard is low.
- Drag is “circulation”: images move faster than thought.`,
          lacan:
`LACAN (RSI: REAL / SYMBOLIC / IMAGINARY)
- Three rings. Slip = misalignment.
- Click adds a signifier chain (Symbolic spikes).
- Drag near edges produces Real intrusions (glitches).`,
          freud:
`FREUD (DREAMWORK)
- Condensation: many → one.
- Displacement: affect shifts onto the wrong object.
- Click drops dream fragments; the engine condenses/displaces them over time.`,
          pause:
`PAUSE
- Rendering continues at minimal load, but the engine stops producing meaning.
- Use this as a hard break: no new events.`
        };
        sub.textContent = `THINKER MODE · ${title} · CLICK/DRAG ARE MODE-DEPENDENT · [H] PANEL · [P] PAUSE · [I] INVERT`;
        card.textContent = notes[mode] || "—";
      }

      function reseed(){
        st.seed = (Math.random()*1e9)|0;
        st.marks.length = 0;
        st.log.length = 0;
        st.panoptic.heat = 0;
        st.panoptic.gaze = 0;
        st.excess.ex = 0.22;
        st.excess.burn = 0;
        st.sim.drift = 0;
        st.sim.copies = 3;
        st.aura.aura = 1.0;
        st.aura.repro = 0.0;
        st.app.prog = 0.0;
        st.app.gesture = 0.0;
        st.punct.p = 0.0;
        st.ethic.shock = 0.0;
        st.rsi.slip = 0.0;
        st.dream.cond = 0.55;
        st.dream.disp = 0.55;
      }

      function clearAll(){
        st.marks.length = 0;
        st.log.length = 0;
      }

      // Buttons
      $('invert').onclick = ()=> st.invert = !st.invert;
      $('pauseBtn').onclick = ()=> st.paused = !st.paused;
      $('reseed').onclick = ()=> reseed();
      $('clear').onclick = ()=> clearAll();
      $('reset').onclick = ()=>{
        st.t=0; st.invert=false; st.paused=false; st.ox=0; st.oy=0; st.wheel=0; st.zoom=1.0;
        ui.timeScale.value=0.35; ui.intensity.value=1.05; ui.noise.value=0.28; ui.trace.value=0.055; ui.zoom.value=1.20;
        syncVals();
        ui.mode.value = "foucault";
        setModeNotes("foucault");
        reseed();
      };

      addEventListener('keydown', (e)=>{
        if (e.key==='i' || e.key==='I') st.invert = !st.invert;
        if (e.key==='p' || e.key==='P') st.paused = !st.paused;
        if (e.key==='h' || e.key==='H'){
          const panel = $('panel');
          panel.style.display = (panel.style.display === 'none') ? '' : 'none';
        }
      });

      addEventListener('wheel', (e)=>{
        const d = Math.max(-160, Math.min(160, e.deltaY));
        st.wheel += (-d/160) * 0.18;
        st.wheel = clamp(st.wheel, -0.85, 0.95);
      }, { passive:true });

      ui.mode.addEventListener('change', ()=>{
        const m = ui.mode.value;
        setModeNotes(m);
        if (m === "pause") st.paused = true;
      });

      // Interaction: click/drag interpreted by mode
      addEventListener('pointerdown', (e)=>{
        st.dragging = true;
        st.lx = e.clientX; st.ly = e.clientY;
        st.mx = e.clientX; st.my = e.clientY;

        const m = ui.mode.value;
        const p = screenToStage(e.clientX, e.clientY);

        // Always allow pan if Alt held
        st.dragType = (e.altKey) ? "pan" : "gesture";

        if (st.dragType === "gesture"){
          if (m === "barthes"){
            st.punct.x = p.x; st.punct.y = p.y; st.punct.p = 1.0;
          } else if (m === "foucault"){
            // confession record
            st.marks.push({x:p.x,y:p.y, t:st.t, k:"confess"});
            st.log.unshift(`CONFESSION RECORDED @ ${new Date().toLocaleTimeString()}`);
            if (st.log.length > 7) st.log.pop();
            st.panoptic.heat = clamp(st.panoptic.heat + 0.22, 0, 1.2);
          } else if (m === "bataille"){
            st.marks.push({x:p.x,y:p.y, t:st.t, k:"spend"});
            st.excess.burn = clamp(st.excess.burn + 0.65, 0, 2.0);
          } else if (m === "baudrillard"){
            st.marks.push({x:p.x,y:p.y, t:st.t, k:"copy"});
            st.sim.copies = clamp(st.sim.copies + 1, 1, 9);
          } else if (m === "benjamin"){
            st.marks.push({x:p.x,y:p.y, t:st.t, k:"repro"});
            st.aura.repro = clamp(st.aura.repro + 0.12, 0, 2.5);
          } else if (m === "flusser"){
            st.marks.push({x:p.x,y:p.y, t:st.t, k:"node"});
            st.app.prog = clamp(st.app.prog + 0.08, 0, 1.5);
          } else if (m === "sontag"){
            st.marks.push({x:p.x,y:p.y, t:st.t, k:"image"});
            const regard = st.ethic.regard;
            st.ethic.shock = clamp(st.ethic.shock + (0.15 + 0.35*(1-regard)), 0, 2.0);
          } else if (m === "lacan"){
            st.marks.push({x:p.x,y:p.y, t:st.t, k:"signifier"});
            st.rsi.slip = clamp(st.rsi.slip + 0.10, 0, 1.4);
          } else if (m === "freud"){
            st.marks.push({x:p.x,y:p.y, t:st.t, k:"fragment"});
          }
        }
      });

      addEventListener('pointerup', ()=>{ st.dragging=false; st.dragType="pan"; });
      addEventListener('pointercancel', ()=>{ st.dragging=false; st.dragType="pan"; });

      addEventListener('pointermove', (e)=>{
        st.mx = e.clientX; st.my = e.clientY;
        if (!st.dragging) return;

        const dx = e.clientX - st.lx;
        const dy = e.clientY - st.ly;
        st.lx = e.clientX; st.ly = e.clientY;

        if (st.dragType === "pan"){
          st.ox += dx; st.oy += dy;
          st.ox = clamp(st.ox, -W*0.60, W*0.60);
          st.oy = clamp(st.oy, -H*0.60, H*0.60);
          return;
        }

        // gesture drag by mode
        const m = ui.mode.value;
        const p = screenToStage(e.clientX, e.clientY);
        const v = Math.sqrt(dx*dx + dy*dy);

        if (m === "foucault"){
          // corridor routing marks (bodies)
          st.marks.push({x:p.x,y:p.y, t:st.t, k:"corridor", vx:dx, vy:dy});
          st.panoptic.gaze = clamp(st.panoptic.gaze + 0.006*v, 0, 1.2);
        } else if (m === "bataille"){
          // waste motion throws expenditure
          st.marks.push({x:p.x,y:p.y, t:st.t, k:"waste", vx:dx, vy:dy});
          st.excess.ex = clamp(st.excess.ex + 0.0009*v, 0, 1.6);
        } else if (m === "baudrillard"){
          st.sim.drift = clamp(st.sim.drift + 0.0010*v, 0, 1.6);
        } else if (m === "benjamin"){
          // move “original” by panning inside the system (light gesture)
          st.aura.repro = clamp(st.aura.repro + 0.0004*v, 0, 2.5);
        } else if (m === "flusser"){
          st.app.gesture = clamp(st.app.gesture + 0.0012*v, 0, 1.6);
        } else if (m === "sontag"){
          st.ethic.shock = clamp(st.ethic.shock + 0.0008*v, 0, 2.0);
        } else if (m === "lacan"){
          // Real intrusion if dragging near edges
          const r = Math.sqrt(p.x*p.x + p.y*p.y);
          if (r > 0.78) st.rsi.slip = clamp(st.rsi.slip + 0.02, 0, 1.6);
        } else if (m === "freud"){
          // drag alters condensation/displacement
          st.dream.cond = clamp(st.dream.cond + dx*0.0005, 0, 1.0);
          st.dream.disp = clamp(st.dream.disp + dy*0.0005, 0, 1.0);
        }
      });

      // Update per mode
      function step(dt){
        const m = ui.mode.value;
        const I = +ui.intensity.value;
        const N = +ui.noise.value;

        // zoom smoothing
        st.wheel *= 0.88;
        st.zoom += st.wheel;
        st.zoom = clamp(st.zoom, 0.55, 2.60);
        st.zoom = lerp(st.zoom, +ui.zoom.value, clamp(dt*0.9,0,1));

        // housekeeping
        // trim marks (keep it light)
        if (st.marks.length > 1100) st.marks.splice(0, st.marks.length - 1100);

        if (m === "foucault"){
          // gaze stabilizes as records increase
          const leg = clamp(st.marks.length/220, 0, 1);
          st.panoptic.gaze = lerp(st.panoptic.gaze, 0.15 + 0.95*leg, clamp(dt*(0.25+0.6*I),0,1));
          st.panoptic.heat *= Math.pow(0.12, dt*0.25);
        }

        if (m === "bataille"){
          // excess grows; burn releases
          st.excess.ex += dt*(0.02 + 0.05*I);
          st.excess.ex = clamp(st.excess.ex, 0, 1.6);
          const burn = st.excess.burn * dt * (0.12 + 0.28*I);
          st.excess.ex = clamp(st.excess.ex - burn, 0, 1.6);
          st.excess.burn *= Math.pow(0.02, dt*0.9);
        }

        if (m === "baudrillard"){
          st.sim.drift *= Math.pow(0.10, dt*0.25);
        }

        if (m === "benjamin"){
          // aura decays as reproduction rises
          st.aura.aura -= dt*(0.01 + 0.03*I) * (1 + st.aura.repro*0.6);
          st.aura.aura = clamp(st.aura.aura, 0, 1);
          st.aura.repro *= Math.pow(0.15, dt*0.18);
        }

        if (m === "flusser"){
          // program tightens: gestures increase program constraint
          st.app.prog = clamp(st.app.prog + dt*(0.005 + 0.020*I) + st.app.gesture*dt*0.01, 0, 1.5);
          st.app.gesture *= Math.pow(0.08, dt*0.35);
        }

        if (m === "barthes"){
          st.punct.p *= Math.pow(0.03, dt*0.60);
        }

        if (m === "sontag"){
          // regard mapped from intensity/noise for now (practical control without adding more sliders)
          st.ethic.regard = clamp(0.15 + 0.70*(1 - N) * (0.65 + 0.35*(2-I)/2), 0, 1);
          st.ethic.shock *= Math.pow(0.06, dt*0.25);
        }

        if (m === "lacan"){
          st.rsi.slip *= Math.pow(0.08, dt*0.35);
        }

        if (m === "freud"){
          // dreamwork slowly condenses/displaces marks
          const cond = st.dream.cond;
          const disp = st.dream.disp;
          for (let i=0;i<st.marks.length;i++){
            const mk = st.marks[i];
            if (mk.k !== "fragment") continue;
            // condensation: pull toward center
            mk.x = lerp(mk.x, 0, dt*(0.02 + 0.09*cond));
            mk.y = lerp(mk.y, 0, dt*(0.02 + 0.09*cond));
            // displacement: rotate affect to a different locus
            const a = (disp-0.5) * 0.55;
            const x = mk.x, y = mk.y;
            mk.x = x*Math.cos(a) - y*Math.sin(a);
            mk.y = x*Math.sin(a) + y*Math.cos(a);
          }
        }
      }

      // Draw per mode (invert must invert background + geometry)
      function draw(){
        const inv = st.invert;
        const bg = inv ? 255 : 0;
        const fg = inv ? 0 : 255;

        const tr = +ui.trace.value;
        if (tr > 0){
          ctx.fillStyle = `rgba(${bg},${bg},${bg},${clamp(tr,0,1)})`;
          ctx.fillRect(0,0,W,H);
        } else {
          ctx.fillStyle = `rgb(${bg},${bg},${bg})`;
          ctx.fillRect(0,0,W,H);
        }

        // In invert mode: keep source-over so geometry truly becomes black.
        ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';

        const m = ui.mode.value;
        const I = +ui.intensity.value;
        const N = +ui.noise.value;

        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;
        const S  = Math.min(W,H) * 0.60 * st.zoom;

        // helper: light noise wobble
        const wob = (a, k=1)=> (Math.sin(st.t*(0.9+0.7*k) + a) * 0.5 + Math.cos(st.t*(0.6+0.9*k) + a*1.7)*0.5) * N;

        // shared field: faint boundary ring
        ctx.lineWidth = 1.2;
        ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.06})`;
        ctx.beginPath();
        ctx.arc(cx,cy, Math.min(W,H)*0.38, 0, Math.PI*2);
        ctx.stroke();

        if (m === "pause"){
          // minimal: just a calm grid
          ctx.lineWidth = 1.0;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.10})`;
          const step = 48;
          for (let x=0;x<W;x+=step){
            ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
          }
          for (let y=0;y<H;y+=step){
            ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
          }
        }

        if (m === "foucault"){
          // Panopticon: radial cells + scanning gaze cone
          const cells = Math.floor(lerp(10, 28, clamp(I/2,0,1)));
          const rings = 6;
          ctx.lineWidth = 1.1;

          // institutional grid (radial)
          for (let i=0;i<cells;i++){
            const a = (i/cells)*Math.PI*2 + st.t*(0.04 + 0.08*st.panoptic.gaze);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.10})`;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + Math.cos(a)*Math.min(W,H)*0.42, cy + Math.sin(a)*Math.min(W,H)*0.42);
            ctx.stroke();
          }
          for (let r=1;r<=rings;r++){
            const rr = (r/rings)*Math.min(W,H)*0.40;
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.06})`;
            ctx.beginPath(); ctx.arc(cx,cy,rr,0,Math.PI*2); ctx.stroke();
          }

          // gaze cone (power)
          const gaze = st.panoptic.gaze;
          const ang = st.t*(0.35 + 0.55*gaze);
          const span = 0.38 - 0.22*gaze;
          ctx.globalCompositeOperation = 'source-over';
          ctx.fillStyle = inv ? `rgba(0,0,0,${0.10 + 0.20*gaze})` : `rgba(255,255,255,${0.10 + 0.20*gaze})`;
          ctx.beginPath();
          ctx.moveTo(cx,cy);
          ctx.arc(cx,cy, Math.min(W,H)*0.45, ang-span, ang+span);
          ctx.closePath();
          ctx.fill();
          ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';

          // marks as “records”
          for (let i=0;i<st.marks.length;i++){
            const mk = st.marks[i];
            if (mk.k !== "confess" && mk.k !== "corridor") continue;
            const p = stageToScreen(mk.x, mk.y);
            const a = clamp(0.06 + 0.22*Math.exp(-(st.t-mk.t)*0.25), 0, 0.35);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
            ctx.beginPath();
            ctx.rect(p.x-6, p.y-6, 12, 12);
            ctx.stroke();
          }

          // confession log in status
          const top = st.log[0] || "—";
          $('stat').textContent = `FOUCAULT · LEGIBILITY ${(st.marks.length)} · GAZE ${st.panoptic.gaze.toFixed(2)} · TOP: ${top}`;
        }

        if (m === "bataille"){
          // Excess: engine + spill field
          const ex = st.excess.ex;        // 0..1.6
          const burn = st.excess.burn;    // transient
          const centerR = (10 + 46*ex) * (0.85 + 0.15*Math.sin(st.t*0.6));
          ctx.lineWidth = 1.3;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.12 + 0.18*clamp(ex/1.6,0,1)})`;
          ctx.beginPath(); ctx.arc(cx,cy,centerR,0,Math.PI*2); ctx.stroke();

          // expenditure rays
          const rays = Math.floor(lerp(24, 110, clamp(I/2,0,1)));
          for (let i=0;i<rays;i++){
            const a = (i/rays)*Math.PI*2 + st.t*(0.10 + 0.22*I);
            const rr = (Math.min(W,H)*0.12 + Math.min(W,H)*0.30*rnd01(st.seed+i*97));
            const k = clamp(ex/1.6,0,1);
            const len = rr * (0.35 + 0.80*k) * (1 + 0.35*burn);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.03 + 0.14*k})`;
            ctx.beginPath();
            ctx.moveTo(cx + Math.cos(a)*centerR*0.2, cy + Math.sin(a)*centerR*0.2);
            ctx.lineTo(cx + Math.cos(a)*len, cy + Math.sin(a)*len);
            ctx.stroke();
          }

          // marks (waste scars)
          for (let i=0;i<st.marks.length;i++){
            const mk = st.marks[i];
            if (mk.k !== "spend" && mk.k !== "waste") continue;
            const p = stageToScreen(mk.x, mk.y);
            const age = (st.t - mk.t);
            const a = clamp(0.10*Math.exp(-age*0.35), 0, 0.16);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 6 + 16*rnd01(st.seed+i*31), 0, Math.PI*2);
            ctx.stroke();
          }

          $('stat').textContent = `BATAILLE · EXCESS ${(st.excess.ex).toFixed(2)} · BURN ${(st.excess.burn).toFixed(2)} · MARKS ${st.marks.length}`;
        }

        if (m === "baudrillard"){
          // Simulacra layers: multiple offset render passes (cheap)
          const copies = st.sim.copies|0;
          const drift = st.sim.drift;
          const baseA = 0.07;

          function drawLayer(k){
            const off = (k - (copies-1)/2) * (6 + 18*drift);
            const a = clamp(baseA + 0.03*k, 0, 0.22);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
            ctx.lineWidth = 1.1;

            // “sign ring”
            ctx.beginPath();
            ctx.arc(cx+off, cy-off, Math.min(W,H)*(0.18 + 0.06*k) , 0, Math.PI*2);
            ctx.stroke();

            // “map precedes territory”: a grid that drifts
            const step = 46;
            for (let x=0;x<W;x+=step){
              ctx.beginPath();
              ctx.moveTo(x+off*0.6, 0);
              ctx.lineTo(x-off*0.4, H);
              ctx.stroke();
            }
          }

          for (let k=0;k<copies;k++) drawLayer(k);

          // marks are “new copies”
          for (let i=0;i<st.marks.length;i++){
            const mk = st.marks[i];
            if (mk.k !== "copy") continue;
            const p = stageToScreen(mk.x, mk.y);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.18})`;
            ctx.beginPath();
            ctx.rect(p.x-10, p.y-10, 20, 20);
            ctx.stroke();
          }

          $('stat').textContent = `BAUDRILLARD · COPIES ${copies} · DRIFT ${drift.toFixed(2)} · MARKS ${st.marks.length}`;
        }

        if (m === "benjamin"){
          // Aura vs reproduction: aura halo fades, stamps accumulate
          const aura = st.aura.aura;
          const halo = Math.min(W,H)*(0.10 + 0.30*aura);
          ctx.lineWidth = 1.5;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.05 + 0.22*aura})`;
          ctx.beginPath(); ctx.arc(cx,cy,halo,0,Math.PI*2); ctx.stroke();

          // mechanical reproduction grid
          const step = 54;
          const repro = st.aura.repro;
          ctx.lineWidth = 1.0;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.03 + 0.10*clamp(repro/2.5,0,1)})`;
          for (let y=0;y<H;y+=step){
            ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
          }

          // stamps (reproductions)
          for (let i=0;i<st.marks.length;i++){
            const mk = st.marks[i];
            if (mk.k !== "repro") continue;
            const p = stageToScreen(mk.x, mk.y);
            const age = st.t - mk.t;
            const a = clamp(0.20*Math.exp(-age*0.14), 0, 0.25);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
            ctx.beginPath();
            ctx.rect(p.x-8, p.y-8, 16, 16);
            ctx.stroke();
          }

          $('stat').textContent = `BENJAMIN · AURA ${aura.toFixed(2)} · REPRO ${(st.aura.repro).toFixed(2)} · STAMPS ${st.marks.filter(m=>m.k==="repro").length}`;
        }

        if (m === "flusser"){
          // Apparatus graph: nodes + permitted edges (program)
          const prog = st.app.prog;
          const nodeCount = clamp(8 + Math.floor(st.marks.filter(m=>m.k==="node").length), 8, 64);

          // draw “program rails”
          const rails = Math.floor(lerp(8, 28, clamp(prog/1.5,0,1)));
          ctx.lineWidth = 1.1;
          for (let i=0;i<rails;i++){
            const a = (i/rails)*Math.PI*2 + st.t*(0.05 + 0.18*prog);
            const r = Math.min(W,H)*(0.10 + 0.26*rnd01(st.seed+i*71));
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.05 + 0.10*clamp(prog/1.5,0,1)})`;
            ctx.beginPath();
            ctx.arc(cx,cy,r, a, a+Math.PI*0.75);
            ctx.stroke();
          }

          // nodes arranged on a circle (cheap graph)
          for (let i=0;i<nodeCount;i++){
            const a = (i/nodeCount)*Math.PI*2 + st.t*(0.03 + 0.10*prog);
            const r = 0.25 + 0.22*rnd01(st.seed+i*19);
            const x = Math.cos(a)*r, y = Math.sin(a)*r;
            const p = stageToScreen(x,y);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.12})`;
            ctx.beginPath(); ctx.arc(p.x,p.y, 5 + 6*(i%3===0), 0, Math.PI*2); ctx.stroke();

            // edges to next few nodes (permitted moves)
            const j = (i + 1 + (i%3)) % nodeCount;
            const a2 = (j/nodeCount)*Math.PI*2 + st.t*(0.03 + 0.10*prog);
            const r2 = 0.25 + 0.22*rnd01(st.seed+j*19);
            const x2 = Math.cos(a2)*r2, y2 = Math.sin(a2)*r2;
            const p2 = stageToScreen(x2,y2);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.04 + 0.06*clamp(prog/1.5,0,1)})`;
            ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
          }

          // gesture path marks faintly
          for (let i=0;i<st.marks.length;i++){
            const mk = st.marks[i];
            if (mk.k !== "node") continue;
            const p = stageToScreen(mk.x, mk.y);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.10})`;
            ctx.beginPath(); ctx.rect(p.x-6,p.y-6,12,12); ctx.stroke();
          }

          $('stat').textContent = `FLUSSER · PROGRAM ${prog.toFixed(2)} · NODES ${nodeCount}`;
        }

        if (m === "barthes"){
          // Studium field: quiet grid
          ctx.lineWidth = 1.0;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.08})`;
          const step = 64;
          for (let x=0;x<W;x+=step){
            ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
          }

          // Punctum: wound point + radiating constraint
          const p = stageToScreen(st.punct.x, st.punct.y);
          const wound = st.punct.p;
          if (wound > 0.01){
            ctx.lineWidth = 1.6;
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(0.18 + 0.30*wound,0,0.55)})`;
            ctx.beginPath(); ctx.arc(p.x,p.y, 8 + 70*wound, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(p.x-18, p.y); ctx.lineTo(p.x+18, p.y);
            ctx.moveTo(p.x, p.y-18); ctx.lineTo(p.x, p.y+18);
            ctx.stroke();
          }

          $('stat').textContent = `BARTHES · PUNCTUM ${(st.punct.p).toFixed(2)} · CLICK TO SET WOUND`;
        }

        if (m === "sontag"){
          // Ethics overlay: regard vs shock
          const regard = st.ethic.regard;
          const shock = st.ethic.shock;

          // circulation bands
          ctx.lineWidth = 1.2;
          const bands = 14;
          for (let i=0;i<bands;i++){
            const r = Math.min(W,H)*(0.10 + 0.022*i) * (1 + 0.04*Math.sin(st.t*0.7+i));
            const a = 0.03 + 0.06*(1-regard) + 0.07*clamp(shock/2,0,1);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(a,0,0.25)})`;
            ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
          }

          // image events
          for (let i=0;i<st.marks.length;i++){
            const mk = st.marks[i];
            if (mk.k !== "image") continue;
            const p = stageToScreen(mk.x, mk.y);
            const age = st.t - mk.t;
            const a = clamp(0.18*Math.exp(-age*0.20), 0, 0.18);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
            ctx.beginPath();
            ctx.moveTo(p.x-12, p.y); ctx.lineTo(p.x+12, p.y);
            ctx.stroke();
          }

          $('stat').textContent = `SONTAG · REGARD ${regard.toFixed(2)} · SHOCK ${shock.toFixed(2)} · EVENTS ${st.marks.filter(m=>m.k==="image").length}`;
        }

        if (m === "lacan"){
          // RSI rings with slip + intrusions
          const slip = st.rsi.slip;
          const R = Math.min(W,H)*0.18;
          const off = 52 * slip;

          // imaginary / symbolic / real rings
          const rings = [
            {x:-R*0.55, y:0, label:"IMAGINARY"},
            {x:R*0.55,  y:0, label:"SYMBOLIC"},
            {x:0, y:-R*0.62, label:"REAL"}
          ];

          ctx.lineWidth = 1.6;
          for (let i=0;i<3;i++){
            const rr = rings[i];
            const px = cx + rr.x + (i===2? -off: off*(i===0?-1:1))*0.25;
            const py = cy + rr.y + (i===2? off: -off)*0.15;
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.16 + 0.10*i})`;
            ctx.beginPath(); ctx.arc(px,py, R, 0, Math.PI*2); ctx.stroke();
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.07})`;
            ctx.beginPath(); ctx.arc(px,py, R*(0.62 + 0.08*Math.sin(st.t+i)), 0, Math.PI*2); ctx.stroke();
          }

          // signifier chain spikes (marks)
          const count = st.marks.filter(m=>m.k==="signifier").length;
          const spikes = Math.min(64, 6 + count);
          for (let i=0;i<spikes;i++){
            const a = (i/spikes)*Math.PI*2 + st.t*(0.10 + 0.12*I);
            const len = 40 + 90*clamp(slip/1.6,0,1);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.06 + 0.10*clamp(count/40,0,1)})`;
            ctx.beginPath();
            ctx.moveTo(cx,cy);
            ctx.lineTo(cx + Math.cos(a)*len, cy + Math.sin(a)*len);
            ctx.stroke();
          }

          $('stat').textContent = `LACAN · RSI SLIP ${slip.toFixed(2)} · SIGNIFIERS ${count}`;
        }

        if (m === "freud"){
          // Dreamwork: fragments condense/displace; draw as soft constellations
          const cond = st.dream.cond;
          const disp = st.dream.disp;

          // field
          ctx.lineWidth = 1.0;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.08})`;
          const step = 72;
          for (let y=0;y<H;y+=step){
            ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
          }

          // fragments
          let frag = 0;
          for (let i=0;i<st.marks.length;i++){
            const mk = st.marks[i];
            if (mk.k !== "fragment") continue;
            frag++;
            const p = stageToScreen(mk.x, mk.y);
            const a = 0.08 + 0.14*cond;
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(a,0,0.28)})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 6 + 18*(0.2 + 0.8*disp), 0, Math.PI*2);
            ctx.stroke();
          }

          // condensation “knot”
          ctx.lineWidth = 1.6;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.10 + 0.22*cond})`;
          ctx.beginPath();
          ctx.arc(cx,cy, 16 + 78*cond, 0, Math.PI*2);
          ctx.stroke();

          $('stat').textContent = `FREUD · FRAGMENTS ${frag} · CONDENSATION ${cond.toFixed(2)} · DISPLACEMENT ${disp.toFixed(2)}`;
        }

        // draw marks lightly for most modes (generic)
        if (m !== "pause" && st.marks.length){
          const keep = (m === "foucault" || m === "benjamin" || m === "bataille") ? 0 : 1;
          if (keep){
            ctx.lineWidth = 1.1;
            for (let i=0;i<st.marks.length;i++){
              const mk = st.marks[i];
              const p = stageToScreen(mk.x, mk.y);
              const age = st.t - mk.t;
              const a = clamp(0.08*Math.exp(-age*0.25), 0, 0.10);
              ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
              ctx.beginPath();
              ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
              ctx.stroke();
            }
          }
        }

        ctx.globalCompositeOperation = 'source-over';
      }

      // Loop
      let last = performance.now();
      function frame(now){
        const rawDt = Math.min(0.033, (now-last)/1000);
        last = now;

        const dt = rawDt * (+ui.timeScale.value) * (0.55 + 0.65*(+ui.intensity.value));
        if (!st.paused){
          st.t += dt;
          step(dt);
        }
        draw();
        requestAnimationFrame(frame);
      }

      // init
      setModeNotes(ui.mode.value);
      reseed();
      requestAnimationFrame(frame);
    })();
  </script>
</body>
</html>
