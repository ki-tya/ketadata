<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA — TORUS VIGNETTE + CUT HOLE</title>
  <style>
    :root{
      --bg:#000;
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.55);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background:var(--bg);
      font-family: Arial, Helvetica, sans-serif;
      color: var(--fg);
    }
    canvas{ position:fixed; inset:0; width:100vw; height:100vh; display:block; }
    .hud{
      position:fixed; left:22px; top:18px;
      user-select:none; pointer-events:none;
      mix-blend-mode:screen;
    }
    .brand{
      font-weight:800;
      letter-spacing:.18em;
      text-transform:uppercase;
      font-size:16px;
      text-shadow: 0 0 18px rgba(255,255,255,.18);
    }
    .sub{
      margin-top:4px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color: var(--muted);
    }
    .dock{
      position:fixed; left:22px; bottom:18px;
      display:flex; gap:10px; pointer-events:auto;
      align-items:center;
    }
    .btn{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.22);
      color:rgba(255,255,255,.86);
      padding:10px 12px;
      border-radius:10px;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{ background:rgba(255,255,255,.10); border-color:rgba(255,255,255,.36); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }

    .panel{
      position:fixed; right:18px; bottom:18px;
      width:min(440px, calc(100vw - 36px));
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.46);
      backdrop-filter: blur(10px);
      border-radius:14px;
      overflow:hidden;
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset, 0 16px 50px rgba(0,0,0,.65);
    }
    .panelHeader{
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.12);
      display:flex; justify-content:space-between; align-items:center;
    }
    .panelHeader .title{
      font-weight:800;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      color:rgba(255,255,255,.86);
    }
    .panelHeader .hint{
      font-size:11px;
      letter-spacing:.08em;
      color:rgba(255,255,255,.55);
    }
    .panelBody{ padding:10px 12px 12px; display:flex; flex-direction:column; gap:9px; }
    .row{ display:grid; grid-template-columns: 132px 1fr 54px; gap:10px; align-items:center; }
    .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:rgba(255,255,255,.62);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    input[type="range"]{ width:100%; accent-color: rgba(255,255,255,.92); }
    .val{ font-variant-numeric: tabular-nums; font-size:11px; color:rgba(255,255,255,.76); text-align:right; }
    .note{
      margin-top:4px;
      font-size:11px;
      color:rgba(255,255,255,.55);
      line-height:1.35;
      letter-spacing:.02em;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="brand">KETADATA</div>
    <div class="sub">FULL-SCREEN TORUS VIGNETTE · CENTER HOLE CUT-OUT</div>
  </div>

  <div class="dock">
    <button class="btn" id="invert">INVERT</button>
    <button class="btn" id="pulse">PULSE</button>
    <button class="btn" id="reset">RESET</button>
  </div>

  <div class="panel">
    <div class="panelHeader">
      <div class="title">PARAMETERS</div>
      <div class="hint">SCROLL = SCALE · DRAG = OFFSET</div>
    </div>
    <div class="panelBody">
      <div class="row">
        <div class="label">spin</div>
        <input id="spin" type="range" min="0" max="3" step="0.01" value="1.20">
        <div class="val" id="spinV">1.20</div>
      </div>
      <div class="row">
        <div class="label">vignette fill</div>
        <input id="fill" type="range" min="0.9" max="2.8" step="0.01" value="2.05">
        <div class="val" id="fillV">2.05</div>
      </div>
      <div class="row">
        <div class="label">wire density</div>
        <input id="dens" type="range" min="10" max="72" step="1" value="40">
        <div class="val" id="densV">40</div>
      </div>
      <div class="row">
        <div class="label">thickness</div>
        <input id="thick" type="range" min="0.6" max="3.6" step="0.01" value="1.45">
        <div class="val" id="thickV">1.45</div>
      </div>
      <div class="row">
        <div class="label">hole radius</div>
        <input id="hole" type="range" min="0.06" max="0.28" step="0.001" value="0.12">
        <div class="val" id="holeV">0.12</div>
      </div>
      <div class="row">
        <div class="label">contrast</div>
        <input id="contrast" type="range" min="0.6" max="2.8" step="0.01" value="1.55">
        <div class="val" id="conV">1.55</div>
      </div>

      <div class="note">
        Hole is punched out of the wireframe (not painted on top). Rim only.
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha:false });

      let W=0, H=0, DPR=Math.min(2, window.devicePixelRatio||1);
      function resize(){
        W = innerWidth; H = innerHeight;
        canvas.width = Math.floor(W*DPR);
        canvas.height = Math.floor(H*DPR);
        canvas.style.width = W+'px';
        canvas.style.height = H+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize);
      resize();

      const $ = (id)=>document.getElementById(id);
      const ui = {
        spin: $('spin'), fill: $('fill'), dens: $('dens'), thick: $('thick'),
        hole: $('hole'), contrast: $('contrast'),
        spinV: $('spinV'), fillV: $('fillV'), densV: $('densV'),
        thickV: $('thickV'), holeV: $('holeV'), conV: $('conV')
      };
      function sync(){
        ui.spinV.textContent = (+ui.spin.value).toFixed(2);
        ui.fillV.textContent = (+ui.fill.value).toFixed(2);
        ui.densV.textContent = ui.dens.value;
        ui.thickV.textContent = (+ui.thick.value).toFixed(2);
        ui.holeV.textContent = (+ui.hole.value).toFixed(2);
        ui.conV.textContent = (+ui.contrast.value).toFixed(2);
      }
      Object.values(ui).forEach(v => (v && v.tagName === 'INPUT') ? v.addEventListener('input', sync) : null);
      sync();

      const st = {
        t: 0,
        invert: false,
        pulse: 0,
        scale: 1.0,
        wheel: 0,
        drag:false,
        ox:0, oy:0,
        lx:0, ly:0
      };

      $('invert').onclick = ()=> st.invert = !st.invert;
      $('pulse').onclick = ()=> st.pulse = Math.min(1, st.pulse + 0.95);
      $('reset').onclick = ()=> { st.t=0; st.pulse=0; st.scale=1.0; st.wheel=0; st.ox=0; st.oy=0; st.invert=false; };

      addEventListener('keydown', (e)=>{
        if (e.code === 'Space'){ e.preventDefault(); st.pulse = Math.min(1, st.pulse + 0.95); }
        if (e.key === 'i' || e.key === 'I') st.invert = !st.invert;
      });

      addEventListener('wheel', (e)=>{
        const d = Math.max(-160, Math.min(160, e.deltaY));
        st.wheel += (-d/160) * 0.18;
        st.wheel = clamp(st.wheel, -0.70, 0.95);
      }, { passive:true });

      addEventListener('pointerdown', (e)=>{ st.drag=true; st.lx=e.clientX; st.ly=e.clientY; });
      addEventListener('pointerup', ()=> st.drag=false);
      addEventListener('pointercancel', ()=> st.drag=false);
      addEventListener('pointermove', (e)=>{
        if (!st.drag) return;
        const dx = e.clientX - st.lx;
        const dy = e.clientY - st.ly;
        st.lx = e.clientX; st.ly = e.clientY;
        st.ox += dx;
        st.oy += dy;
        st.ox = clamp(st.ox, -W*0.28, W*0.28);
        st.oy = clamp(st.oy, -H*0.28, H*0.28);
      });

      // 3D transforms
      function rotX(p, a){
        const s=Math.sin(a), c=Math.cos(a);
        return { x:p.x, y:p.y*c - p.z*s, z:p.y*s + p.z*c };
      }
      function rotY(p, a){
        const s=Math.sin(a), c=Math.cos(a);
        return { x:p.x*c + p.z*s, y:p.y, z:-p.x*s + p.z*c };
      }
      function rotZ(p, a){
        const s=Math.sin(a), c=Math.cos(a);
        return { x:p.x*c - p.y*s, y:p.x*s + p.y*c, z:p.z };
      }
      function project(p, cx, cy, fov){
        const camZ = 5.2;                  // farther camera for stability when scaling up
        const z = (camZ - p.z);
        const k = fov / Math.max(0.0001, z);
        return { x: cx + p.x*k, y: cy + p.y*k, k };
      }
      function torus(u, v, R, r){
        const cu=Math.cos(u), su=Math.sin(u);
        const cv=Math.cos(v), sv=Math.sin(v);
        return {
          x: (R + r*cv) * cu,
          y: (R + r*cv) * su,
          z: r * sv
        };
      }

      let last = performance.now();
      function loop(now){
        const dt = Math.min(0.033, (now-last)/1000);
        last = now;

        st.wheel *= 0.88;
        st.scale += st.wheel;
        st.scale = clamp(st.scale, 0.70, 1.70);

        st.pulse *= 0.90;
        if (st.pulse < 0.0008) st.pulse = 0;

        st.t += dt;

        render();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      function render(){
        const inv = st.invert;
        const bg = inv ? 255 : 0;
        const fg = inv ? 0 : 255;

        const spin = +ui.spin.value;
        const fill = +ui.fill.value;         // how much it fills the screen (vignette)
        const dens = +ui.dens.value | 0;
        const thick = +ui.thick.value;
        const holeN = +ui.hole.value;
        const contrast = +ui.contrast.value;

        ctx.fillStyle = `rgb(${bg},${bg},${bg})`;
        ctx.fillRect(0,0,W,H);

        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;

        // Make torus "vignette full-screen":
        // - increase geometry scale (R, r)
        // - increase fov
        // - apply fill factor and user scroll scale
        const breathe = 1.0 + 0.06*Math.sin(st.t*1.1) + st.pulse*0.06;
        const R = 1.55 * breathe;         // major radius (bigger than before)
        const r = 0.78 * breathe;         // tube radius (bigger than before)

        const a = st.t * (0.55 + spin*0.95);
        const b = st.t * (0.33 + spin*0.55);
        const c = st.t * (0.21 + spin*0.34);

        // FOV + fill + scale => full-frame torus
        const fov = 740 * st.scale * fill;

        // Hole size in pixels
        const holeR = Math.min(W,H) * holeN;

        // Wire rendering
        ctx.globalCompositeOperation = 'lighter';
        ctx.lineWidth = thick;

        const Nu = dens;                         // ring segments
        const Nv = Math.max(10, (dens*0.62)|0);   // tube segments
        const du = (Math.PI*2)/Nu;
        const dv = (Math.PI*2)/Nv;

        // Alpha envelope
        const exposure = (1.0 + 0.22*Math.sin(st.t*12.0) + st.pulse*0.55) * contrast;

        function strokeSegment(x0,y0,x1,y1, depth){
          // Hard reject anything that would draw into the hole:
          if (segmentHitsCircle(x0,y0,x1,y1,cx,cy,holeR)) return;

          const alpha = clamp((0.08 + depth*0.92) * exposure, 0, 1);
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha})`;
          ctx.beginPath();
          ctx.moveTo(x0,y0);
          ctx.lineTo(x1,y1);
          ctx.stroke();
        }

        // We draw two sets of polylines: u-lines and v-lines.
        // Depth cue based on p.z (closer to camera => brighter).
        for (let j=0;j<Nv;j++){
          const v = j*dv;
          let prev = null;
          for (let i=0;i<=Nu;i++){
            const u = i*du;

            let p = torus(u,v,R,r);
            p = rotZ(rotY(rotX(p, b), a), c);

            const depth = clamp((p.z + 2.2) / 4.4, 0, 1);

            const q = project(p, cx, cy, fov);
            // Outward vignette push: expand more as you move away from center
            const w = outwardVignetteWarp(q.x, q.y, cx, cy, 0.14);

            const cur = { x:w.x, y:w.y, depth };
            if (prev) strokeSegment(prev.x, prev.y, cur.x, cur.y, (prev.depth+cur.depth)*0.5);
            prev = cur;
          }
        }

        for (let i=0;i<Nu;i++){
          const u = i*du;
          let prev = null;
          for (let j=0;j<=Nv;j++){
            const v = j*dv;

            let p = torus(u,v,R,r);
            p = rotZ(rotY(rotX(p, b), a), c);

            const depth = clamp((p.z + 2.2) / 4.4, 0, 1);

            const q = project(p, cx, cy, fov);
            const w = outwardVignetteWarp(q.x, q.y, cx, cy, 0.14);

            const cur = { x:w.x, y:w.y, depth };
            if (prev) strokeSegment(prev.x, prev.y, cur.x, cur.y, (prev.depth+cur.depth)*0.5);
            prev = cur;
          }
        }

        // IMPORTANT CHANGE:
        // Punch the hole out of what we drew, instead of painting a circle on top.
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'rgba(0,0,0,1)';
        ctx.beginPath();
        ctx.arc(cx, cy, holeR, 0, Math.PI*2);
        ctx.fill();

        // Return to normal for rim/scanlines
        ctx.globalCompositeOperation = 'source-over';

        // Rim only (so the hole reads as a void aperture)
        const rimA = clamp(0.30*contrast + st.pulse*0.35, 0, 1);
        ctx.strokeStyle = `rgba(${fg},${fg},${fg},${rimA})`;
        ctx.lineWidth = 2.0 + st.pulse*1.4;
        ctx.beginPath();
        ctx.arc(cx, cy, holeR, 0, Math.PI*2);
        ctx.stroke();

        // Micro scanlines (subtle texture)
        const step = 9;
        const yOff = (st.t*70) % step;
        ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.05*contrast})`;
        ctx.lineWidth = 1;
        for (let y=-step; y<H+step; y+=step){
          ctx.beginPath();
          ctx.moveTo(0, y+yOff);
          ctx.lineTo(W, y+yOff);
          ctx.stroke();
        }
      }

      // Expand slightly with radius: gives the “vignette torus” push.
      function outwardVignetteWarp(x,y,cx,cy,amt){
        const dx = x - cx, dy = y - cy;
        const d = Math.sqrt(dx*dx + dy*dy);
        const maxD = Math.max(1, Math.min(innerWidth, innerHeight) * 0.55);
        const k = 1.0 + amt * (d / maxD);
        return { x: cx + dx*k, y: cy + dy*k };
      }

      function segmentHitsCircle(x0,y0,x1,y1,cx,cy,r){
        const rr = r*r;
        const dx0=x0-cx, dy0=y0-cy;
        const dx1=x1-cx, dy1=y1-cy;

        const d0=dx0*dx0+dy0*dy0;
        const d1=dx1*dx1+dy1*dy1;

        // If either endpoint inside, it hits.
        if (d0 < rr || d1 < rr) return true;

        // Distance from center to segment
        const vx = x1-x0, vy = y1-y0;
        const wx = cx-x0, wy = cy-y0;
        const c1 = wx*vx + wy*vy;
        if (c1 <= 0) return false;
        const c2 = vx*vx + vy*vy;
        if (c2 <= c1) return false;

        const t = c1 / c2;
        const px = x0 + t*vx, py = y0 + t*vy;
        const ddx = px - cx, ddy = py - cy;
        return (ddx*ddx + ddy*ddy) < rr;
      }

      function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    })();
  </script>
</body>
</html>
