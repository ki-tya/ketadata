<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA — DONUT CORE</title>
  <style>
    :root{
      --bg:#000;
      --fg:255;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background:var(--bg);
      font-family: Arial, Helvetica, sans-serif;
      color: rgba(255,255,255,.88);
    }
    canvas{ position:fixed; inset:0; width:100vw; height:100vh; display:block; }
    .hud{
      position:fixed; left:22px; top:18px;
      user-select:none; pointer-events:none;
      mix-blend-mode:screen;
    }
    .hud .brand{
      font-weight:800; letter-spacing:.18em; text-transform:uppercase; font-size:16px;
      text-shadow: 0 0 18px rgba(255,255,255,.18);
    }
    .hud .sub{
      margin-top:4px;
      font-size:11px; letter-spacing:.14em; text-transform:uppercase;
      color: rgba(255,255,255,.55);
    }
    .dock{
      position:fixed; left:22px; bottom:18px;
      display:flex; gap:10px; pointer-events:auto;
    }
    .btn{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.22);
      color:rgba(255,255,255,.86);
      padding:10px 12px;
      border-radius:10px;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{ background:rgba(255,255,255,.10); border-color:rgba(255,255,255,.36); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }
    .hint{
      position:fixed;
      right:18px; bottom:18px;
      text-align:right;
      font-size:11px;
      letter-spacing:.10em;
      color:rgba(255,255,255,.55);
      user-select:none;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="brand">KETADATA</div>
    <div class="sub">DONUT CORE · PERPETUAL INFLOW</div>
  </div>

  <div class="dock">
    <button class="btn" id="pulse">PULSE</button>
    <button class="btn" id="invert">INVERT</button>
    <button class="btn" id="reset">RESET</button>
  </div>

  <div class="hint">
    SCROLL = THRUST · DRAG = WARP · SPACE = PULSE · I = INVERT
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha:false });

      let W=0,H=0,DPR=Math.min(2, window.devicePixelRatio||1);
      function resize(){
        W=innerWidth; H=innerHeight;
        canvas.width = Math.floor(W*DPR);
        canvas.height = Math.floor(H*DPR);
        canvas.style.width = W+'px';
        canvas.style.height = H+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize);
      resize();

      const st = {
        t: 0,
        invert:false,
        thrust: 1.15,     // ALWAYS MOVING
        wheel: 0,
        pulse: 0,
        drag:false,
        warpX: 0,
        warpY: 0,
        lastX: 0,
        lastY: 0
      };

      // minimal "data dust" points that get sucked into the donut center
      const dust = [];
      const DUST_N = 900;
      function reseedDust(){
        dust.length = 0;
        for (let i=0;i<DUST_N;i++){
          dust.push({
            a: Math.random()*Math.PI*2,
            r: 0.15 + Math.random()*0.95,
            z: Math.random(),              // depth along flow [0..1]
            w: 0.6 + Math.random()*2.2,
            s: 0.5 + Math.random()*1.7,
            p: Math.random()*Math.PI*2
          });
        }
      }
      reseedDust();

      // controls
      const pulseBtn = document.getElementById('pulse');
      const invertBtn = document.getElementById('invert');
      const resetBtn = document.getElementById('reset');

      pulseBtn.onclick = () => st.pulse = Math.min(1, st.pulse + 0.95);
      invertBtn.onclick = () => st.invert = !st.invert;
      resetBtn.onclick = () => { st.t=0; st.thrust=1.15; st.wheel=0; st.pulse=0; st.warpX=0; st.warpY=0; st.invert=false; reseedDust(); };

      addEventListener('keydown', (e)=>{
        if (e.code === 'Space'){ e.preventDefault(); st.pulse = Math.min(1, st.pulse + 0.95); }
        if (e.key === 'i' || e.key === 'I') st.invert = !st.invert;
      });

      addEventListener('wheel', (e)=>{
        const d = Math.max(-160, Math.min(160, e.deltaY));
        st.wheel += (-d/160)*0.75;
        st.wheel = clamp(st.wheel, -1.2, 3.2);
      }, { passive:true });

      addEventListener('pointerdown', (e)=>{ st.drag=true; st.lastX=e.clientX; st.lastY=e.clientY; });
      addEventListener('pointerup', ()=> st.drag=false);
      addEventListener('pointercancel', ()=> st.drag=false);
      addEventListener('pointermove', (e)=>{
        if (!st.drag) return;
        const dx = e.clientX - st.lastX;
        const dy = e.clientY - st.lastY;
        st.lastX = e.clientX;
        st.lastY = e.clientY;
        st.warpX += dx * 0.003;
        st.warpY += dy * 0.003;
        st.warpX = clamp(st.warpX, -1.8, 1.8);
        st.warpY = clamp(st.warpY, -1.8, 1.8);
      });

      let last = performance.now();
      function loop(now){
        const dt = Math.min(0.033, (now-last)/1000);
        last = now;

        st.wheel *= 0.90;
        st.thrust += st.wheel * 0.35;
        st.thrust *= 0.97;
        st.thrust = clamp(st.thrust, 0.25, 3.6);

        st.pulse *= 0.90;
        if (st.pulse < 0.0008) st.pulse = 0;

        st.t += dt * (0.85 + st.thrust*1.15);

        render(dt);

        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      function render(dt){
        const inv = st.invert;
        const bg = inv ? 255 : 0;
        const fg = inv ? 0 : 255;

        ctx.fillStyle = `rgb(${bg},${bg},${bg})`;
        ctx.fillRect(0,0,W,H);

        const cx = W*0.5;
        const cy = H*0.5;

        // "donut" parameters
        const R = Math.min(W,H) * 0.22;     // torus major radius (ring centerline)
        const r0 = Math.min(W,H) * 0.075;   // torus tube radius
        const ringScale = 1.0 + st.pulse*0.06;

        // warp offsets: you can "misalign" the donut mouth
        const wx = st.warpX * 120;
        const wy = st.warpY * 120;

        // camera rotation around donut axis (keeps it alive)
        const spin = st.t*0.55;
        const wob = 0.35*Math.sin(st.t*0.45) + 0.20*Math.sin(st.t*0.92);

        // strobe/exposure
        const exposure = 1.0 + 0.22*Math.sin(st.t*12.0) + st.pulse*0.55;

        // Draw ring field: many "slices" of the torus, scrolling into the donut center.
        // We render a stack of ellipses that converge into the donut hole,
        // which reads as moving into the center of a ring.
        ctx.save();
        ctx.translate(cx+wx, cy+wy);
        ctx.globalCompositeOperation = 'lighter';

        const slices = 170;
        for (let i=0;i<slices;i++){
          // z is depth into the donut hole. we wrap it to be endless.
          const z = ((i / slices) + (st.t*0.18)) % 1;  // 0..1
          // perspective: near (z close to 1) = large/bright, far = small/faint
          const p = Math.pow(1 - z, 2.35); // far gets tiny

          // the donut mouth is a ring: we create an ellipse for the torus tube cross-section,
          // but offset it around a circle of radius R.
          const ang = spin + i*0.045 + wob*p;
          const ox = Math.cos(ang) * R * ringScale;
          const oy = Math.sin(ang) * R * ringScale;

          // size of the tube slice shrinks into depth
          const tube = (r0 * (0.55 + 1.65*(1-p))) * (0.55 + st.pulse*0.30);

          // overall scale compresses into the center (the donut hole)
          const scl = lerp(1.35, 0.02, (1 - p)); // near big, far tiny

          // center sink pull: everything trends to 0 as z advances
          const pull = lerp(1.0, 0.0, (1 - p));
          const x = ox * pull;
          const y = oy * pull;

          // line weight + alpha
          const alpha = clamp((0.12 + (1-p)*0.95) * exposure, 0, 1);
          const lw = 1.0 + (1-p)*2.6 + st.pulse*2.0;

          // subtle squaring for "system" feel
          const squ = 2.4 + 0.8*Math.sin(st.t*0.6 + i*0.02);

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(ang*0.35);

          // draw "tube slice" as a superellipse — reads like hard-edged ring material
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha})`;
          ctx.lineWidth = lw;

          drawSuperellipse(ctx, 0, 0, tube*scl, tube*scl*0.92, squ);

          // ribs: indicates forward motion into the donut mouth
          const ribs = 8;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha*0.55})`;
          ctx.lineWidth = Math.max(1, lw*0.72);
          for (let k=0;k<ribs;k++){
            const a2 = (Math.PI*2/ribs)*k + ang*0.2;
            ctx.beginPath();
            ctx.moveTo(Math.cos(a2)*tube*scl*0.25, Math.sin(a2)*tube*scl*0.25);
            ctx.lineTo(Math.cos(a2)*tube*scl*1.05, Math.sin(a2)*tube*scl*1.05);
            ctx.stroke();
          }

          ctx.restore();
        }

        ctx.restore();
        ctx.globalCompositeOperation = 'source-over';

        // Data dust: particles orbit ring centerline, then get sucked into donut hole
        drawDust(cx+wx, cy+wy, fg, exposure, R, r0);

        // Mouth: visible donut hole sink (center of screen)
        drawMouth(cx+wx, cy+wy, fg, exposure);
      }

      function drawDust(cx, cy, fg, exposure, R, r0){
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';

        // flow speed
        const flow = (0.28 + st.thrust*0.26);

        for (let i=0;i<dust.length;i++){
          const d = dust[i];
          d.z += flow * 0.010;
          if (d.z > 1.02){
            d.z = 0;
            d.a = Math.random()*Math.PI*2;
            d.r = 0.15 + Math.random()*0.95;
            d.w = 0.6 + Math.random()*2.2;
            d.s = 0.5 + Math.random()*1.7;
            d.p = Math.random()*Math.PI*2;
          }

          // p: far -> near (near = bigger/brighter)
          const p = Math.pow(d.z, 1.75);

          // centerline orbit angle
          const ang = (st.t*0.72) + d.a + Math.sin(st.t*0.35 + d.p)*0.25;

          // centerline position
          const ox = Math.cos(ang) * R;
          const oy = Math.sin(ang) * R;

          // pull inward as it "approaches" the center hole
          const pull = (1 - p);
          const x = cx + ox * pull + (noise(i*0.33 + st.t*1.2)*2-1) * 8;
          const y = cy + oy * pull + (noise(i*0.29 + st.t*1.0)*2-1) * 8;

          const size = (0.6 + d.w) * (0.25 + p*2.1) + st.pulse*2.2;
          const a = clamp((0.10 + p*0.75) * exposure, 0, 1);

          ctx.fillStyle = `rgba(${fg},${fg},${fg},${a})`;
          ctx.fillRect(x, y, size*0.7, size*0.7);
        }

        ctx.restore();
        ctx.globalCompositeOperation = 'source-over';
      }

      function drawMouth(cx, cy, fg, exposure){
        const r = 16 + st.pulse*18;
        const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r*12);
        g.addColorStop(0, `rgba(${fg},${fg},${fg},${clamp(0.62*exposure,0,1)})`);
        g.addColorStop(0.32, `rgba(${fg},${fg},${fg},${clamp(0.12*exposure,0,1)})`);
        g.addColorStop(1, `rgba(${fg},${fg},${fg},0)`);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(cx, cy, r*12, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(0.85*exposure,0,1)})`;
        ctx.lineWidth = 2.2;
        ctx.beginPath();
        ctx.arc(cx, cy, r*2.0, 0, Math.PI*2);
        ctx.stroke();
      }

      function drawSuperellipse(ctx, x, y, rx, ry, n){
        const steps = 160;
        ctx.beginPath();
        for (let i=0;i<=steps;i++){
          const t = (i/steps) * Math.PI*2;
          const ct = Math.cos(t), stt = Math.sin(t);
          const px = x + Math.sign(ct) * Math.pow(Math.abs(ct), 2/n) * rx;
          const py = y + Math.sign(stt) * Math.pow(Math.abs(stt), 2/n) * ry;
          if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.closePath();
        ctx.stroke();
      }

      function noise(x){
        const s = Math.sin(x*12.9898) * 43758.5453;
        return s - Math.floor(s);
      }

      function lerp(a,b,t){ return a + (b-a)*t; }
      function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    })();
  </script>
</body>
</html>
