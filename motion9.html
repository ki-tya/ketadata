<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA // CAM SUBSTANCE MOTION (SOVEREIGN)</title>

<style>
:root{
  --bg:#000;
  --fg:rgba(255,255,255,.86);
  --muted:rgba(255,255,255,.52);
  --line:rgba(255,255,255,.14);
  --line2:rgba(255,255,255,.22);
  --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  --sans: Arial,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  --top:44px;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);overflow:hidden;font-family:var(--sans)}
#top{
  position:fixed;left:0;right:0;top:0;height:var(--top);
  display:flex;align-items:center;gap:8px;padding:6px 8px;
  background:rgba(0,0,0,.78);border-bottom:1px solid var(--line);
  z-index:10;
}
.btn,.chip{
  height:30px;display:inline-flex;align-items:center;gap:8px;
  padding:0 10px;border:1px solid var(--line2);
  background:rgba(0,0,0,.30);color:var(--fg);
  font:12px/1 var(--sans);white-space:nowrap;user-select:none;
}
.btn{cursor:pointer}
.btn:active{transform:translateY(1px)}
.k{font-family:var(--mono);opacity:.9}
.sep{flex:1}
input[type="range"]{width:120px;accent-color:#fff}

#stage{
  position:fixed;left:0;top:var(--top);
  width:100vw;height:calc(100vh - var(--top));
}
video{position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0}

#viz{
  position:fixed;right:8px;bottom:8px;width:260px;height:160px;
  border:1px solid var(--line);background:#000;z-index:20;display:none;
}
body.showviz #viz{display:block}
body.invert{filter:invert(1)}
</style>
</head>

<body>
<div id="top">
  <div class="chip k">KETADATA // CAM SUBSTANCE</div>

  <div class="btn" id="start">START CAM</div>
  <div class="btn" id="stopCam">STOP CAM</div>
  <div class="btn" id="run">STOP</div>
  <div class="btn" id="invert">INVERT</div>
  <div class="btn" id="vizBtn">VIZ</div>

  <div class="chip">FLOW <input id="flow" type="range" min="0" max="100" value="72"></div>
  <div class="chip">TRAIL <input id="trail" type="range" min="0" max="100" value="78"></div>
  <div class="chip">THR <input id="thr" type="range" min="1" max="80" value="14"></div>
  <div class="chip">DENS <input id="dens" type="range" min="20000" max="140000" value="70000"></div>

  <div class="sep"></div>
  <div class="chip k" id="status">LOCAL</div>
</div>

<canvas id="stage"></canvas>
<canvas id="viz" width="260" height="160"></canvas>
<video id="video" playsinline muted autoplay></video>

<script>
(() => {
  const $ = id => document.getElementById(id);

  // main canvas
  const canvas = $("stage");
  const ctx = canvas.getContext("2d",{alpha:false});

  // viz
  const viz = $("viz");
  const vctx = viz.getContext("2d");

  let W=0,H=0,DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    W = Math.max(1, Math.floor((canvas.offsetWidth||1) * DPR));
    H = Math.max(1, Math.floor((canvas.offsetHeight||1) * DPR));
    canvas.width=W; canvas.height=H;
  }
  addEventListener("resize", resize);
  addEventListener("orientationchange", () => setTimeout(resize, 60));
  setTimeout(resize, 0);

  const STATE={
    running:true,
    flow:0.72,
    trail:0.78,
    thr:14,
    dens:70000,
    camOn:false,
    showViz:false
  };

  const setStatus = s => ($("status").textContent = s);

  $("invert").onclick = () => document.body.classList.toggle("invert");
  $("vizBtn").onclick = () => {
    STATE.showViz = !STATE.showViz;
    document.body.classList.toggle("showviz", STATE.showViz);
  };

  $("flow").oninput  = e => STATE.flow  = (+e.target.value)/100;
  $("trail").oninput = e => STATE.trail = (+e.target.value)/100;
  $("thr").oninput   = e => STATE.thr   = (+e.target.value)|0;
  $("dens").oninput  = e => { STATE.dens = (+e.target.value)|0; };

  $("run").onclick = () => {
    STATE.running = !STATE.running;
    $("run").textContent = STATE.running ? "STOP" : "RUN";
  };

  // ===== CAM + MOTION FIELD =====
  const video = $("video");
  let stream=null;

  // detection resolution (field grid)
  const DET_W = 160, DET_H = 90;
  const det = document.createElement("canvas");
  det.width=DET_W; det.height=DET_H;
  const dctx = det.getContext("2d",{willReadFrequently:true});

  // velocity field (grid = DET_W x DET_H)
  // vx, vy as float arrays
  let VX = new Float32Array(DET_W*DET_H);
  let VY = new Float32Array(DET_W*DET_H);

  let prevLuma = null; // Uint8Array DET_W*DET_H

  function stopCam(){
    if(stream){
      try{ for(const t of stream.getTracks()) t.stop(); }catch(_){}
    }
    stream=null;
    STATE.camOn=false;
    prevLuma=null;
    VX.fill(0); VY.fill(0);
    setStatus("LOCAL");
  }

  async function startCam(){
    if(STATE.camOn) return;
    setStatus("CAM REQUEST");
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:"user", width:{ideal:1280}, height:{ideal:720} },
        audio:false
      });
      video.srcObject = stream;
      await video.play();
      STATE.camOn=true;
      prevLuma=null;
      setStatus("CAM ON");
    }catch(e){
      setStatus("CAM BLOCKED");
    }
  }
  $("start").onclick = startCam;
  $("stopCam").onclick = stopCam;

  // Build a velocity “substance” from motion:
  // - compute luma diff
  // - for pixels above threshold, push velocity outward from motion direction proxy
  //   (we approximate direction by local gradient of diff)
  function updateField(){
    if(!STATE.camOn) return;

    // selfie mirror
    dctx.save();
    dctx.scale(-1,1);
    dctx.drawImage(video, -DET_W, 0, DET_W, DET_H);
    dctx.restore();

    const data = dctx.getImageData(0,0,DET_W,DET_H).data;

    const cur = new Uint8Array(DET_W*DET_H);
    let p=0;
    for(let i=0;i<data.length;i+=4){
      const r=data[i], g=data[i+1], b=data[i+2];
      cur[p++] = (r*0.2126 + g*0.7152 + b*0.0722) | 0;
    }

    if(!prevLuma){
      prevLuma = cur;
      return;
    }

    const thr = STATE.thr|0;

    // decay existing field (substance inertia)
    const decay = 0.88 + 0.10*STATE.flow; // higher flow => less decay (more persistence)
    for(let i=0;i<VX.length;i++){
      VX[i] *= decay;
      VY[i] *= decay;
    }

    // inject motion
    // compute diff map first (reuse a small temp for gradients)
    const diff = new Uint8Array(DET_W*DET_H);
    for(let i=0;i<diff.length;i++){
      const d = Math.abs(cur[i] - prevLuma[i]);
      prevLuma[i] = cur[i];
      diff[i] = d;
    }

    // gradient-based direction + injection
    // strength scales with flow
    const inject = 0.0025 + 0.012*STATE.flow;

    for(let y=1;y<DET_H-1;y++){
      let row = y*DET_W;
      for(let x=1;x<DET_W-1;x++){
        const i = row + x;
        const d = diff[i];
        if(d < thr) continue;

        // gradient of diff (approx motion edge direction)
        const gx = (diff[i+1] - diff[i-1]);
        const gy = (diff[i+DET_W] - diff[i-DET_W]);

        // normalize (avoid div0)
        const mag = Math.hypot(gx,gy) + 1e-6;

        // push velocity along gradient (gives liquid smear around moving shapes)
        const ux = gx / mag;
        const uy = gy / mag;

        // weight by intensity
        const w = (d - thr) / (80 - thr + 1e-6); // 0..1-ish
        const s = inject * (0.25 + 2.0*w);

        VX[i] += ux * s;
        VY[i] += uy * s;
      }
    }

    if(STATE.showViz){
      drawViz(diff);
    }
  }

  function drawViz(diff){
    const w=viz.width, h=viz.height;
    vctx.fillStyle="#000";
    vctx.fillRect(0,0,w,h);

    // render diff as white mask
    const img = vctx.createImageData(DET_W, DET_H);
    for(let i=0;i<diff.length;i++){
      const v = diff[i];
      const o=i*4;
      img.data[o]=255; img.data[o+1]=255; img.data[o+2]=255;
      img.data[o+3]=Math.max(0, Math.min(255, (v - STATE.thr) * 8));
    }
    const tmp=document.createElement("canvas");
    tmp.width=DET_W; tmp.height=DET_H;
    tmp.getContext("2d").putImageData(img,0,0);

    vctx.imageSmoothingEnabled=false;
    vctx.drawImage(tmp,0,0,DET_W,DET_H,0,0,w,h);

    // velocity field glyphs (sparse)
    vctx.strokeStyle="rgba(255,255,255,.55)";
    vctx.lineWidth=1;
    const step=10;
    for(let y=0;y<DET_H;y+=step){
      for(let x=0;x<DET_W;x+=step){
        const i=y*DET_W+x;
        const vx=VX[i]*2200, vy=VY[i]*2200;
        const px=x/DET_W*w, py=y/DET_H*h;
        vctx.beginPath();
        vctx.moveTo(px,py);
        vctx.lineTo(px+vx, py+vy);
        vctx.stroke();
      }
    }

    vctx.strokeStyle="rgba(255,255,255,.22)";
    vctx.strokeRect(0.5,0.5,w-1,h-1);
  }

  // ===== PARTICLES ADVECTED BY FIELD =====
  // Particles live in screen space; field is in DET grid.
  let P=[];
  function reseed(n){
    P.length=0;
    for(let i=0;i<n;i++){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()-.5)*0.2,
        vy:(Math.random()-.5)*0.2
      });
    }
  }
  reseed(STATE.dens);

  function ensureDensity(){
    const n=STATE.dens|0;
    if(P.length===n) return;
    if(P.length>n){ P.length=n; return; }
    while(P.length<n){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()-.5)*0.2,
        vy:(Math.random()-.5)*0.2
      });
    }
  }

  // sample velocity field at pixel position
  function sampleField(x,y){
    // map to det coords
    const fx = (x/W) * (DET_W-1);
    const fy = (y/H) * (DET_H-1);
    const x0 = fx|0, y0 = fy|0;
    const x1 = Math.min(DET_W-1, x0+1);
    const y1 = Math.min(DET_H-1, y0+1);
    const tx = fx - x0;
    const ty = fy - y0;

    const i00 = y0*DET_W+x0;
    const i10 = y0*DET_W+x1;
    const i01 = y1*DET_W+x0;
    const i11 = y1*DET_W+x1;

    // bilinear
    const vx0 = VX[i00]*(1-tx) + VX[i10]*tx;
    const vx1 = VX[i01]*(1-tx) + VX[i11]*tx;
    const vy0 = VY[i00]*(1-tx) + VY[i10]*tx;
    const vy1 = VY[i01]*(1-tx) + VY[i11]*tx;

    return {
      vx: vx0*(1-ty) + vx1*ty,
      vy: vy0*(1-ty) + vy1*ty
    };
  }

  // ===== LOOP =====
  let last=performance.now();
  function frame(t){
    requestAnimationFrame(frame);
    if(!STATE.running) return;

    resize();
    ensureDensity();
    updateField();

    const dt = Math.min(32, t-last); last=t;

    // trails: higher trail slider => longer persistence
    const a = 0.20 - 0.18*STATE.trail; // 0.02..0.20
    ctx.globalCompositeOperation="source-over";
    ctx.fillStyle=`rgba(0,0,0,${Math.max(0.02, Math.min(0.20,a))})`;
    ctx.fillRect(0,0,W,H);

    // draw particles bright
    ctx.globalCompositeOperation="lighter";
    ctx.fillStyle="rgba(255,255,255,0.22)";

    // scale field effect
    const fieldScale = (0.8 + 3.2*STATE.flow) * 2400; // screen-space multiplier

    // particle noise (keeps it alive even without cam)
    const baseJitter = 0.02 + 0.08*STATE.flow;

    for(const p of P){
      const f = sampleField(p.x, p.y);

      // advect velocity by field + a touch of jitter
      p.vx = p.vx*0.92 + f.vx*fieldScale + (Math.random()-0.5)*baseJitter;
      p.vy = p.vy*0.92 + f.vy*fieldScale + (Math.random()-0.5)*baseJitter;

      p.x = (p.x + p.vx*dt + W) % W;
      p.y = (p.y + p.vy*dt + H) % H;

      ctx.fillRect(p.x, p.y, 1, 1);
    }

    ctx.globalCompositeOperation="source-over";

    if(STATE.camOn){
      setStatus("CAM + SUBSTANCE");
    }else{
      setStatus("LOCAL");
    }
  }
  requestAnimationFrame(frame);

  addEventListener("beforeunload", () => { try{ stopCam(); }catch(_){} });

})();
</script>

<!--
AE: KETADATA
EE: CAM_SUBSTANCE_MOTION_FIELD
WB: SINGLE_FILE_HTML
FILE_ID: KETA_CAM_SUBSTANCE_v1
ROOM_ID: BASE
VERSION: 1
UPDATED_AT: 2026-01-08
CHANGELOG:
- v1: motion-derived velocity field; particles advected like substance; VIZ shows diff mask + field vectors
-->
</body>
</html>
