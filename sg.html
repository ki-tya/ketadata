<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA — SACRED GEOMETRY INTERFACE</title>
  <style>
    :root{
      --bg:#000;
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.55);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background:var(--bg);
      font-family: Arial, Helvetica, sans-serif;
      color: var(--fg);
    }
    canvas{ position:fixed; inset:0; width:100vw; height:100vh; display:block; }

    .hud{
      position:fixed; left:22px; top:18px;
      user-select:none; pointer-events:none;
      mix-blend-mode:screen;
    }
    .brand{
      font-weight:800;
      letter-spacing:.18em;
      text-transform:uppercase;
      font-size:16px;
      text-shadow: 0 0 18px rgba(255,255,255,.18);
    }
    .sub{
      margin-top:4px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color: var(--muted);
    }

    .dock{
      position:fixed; left:22px; bottom:18px;
      display:flex; gap:10px; pointer-events:auto;
      align-items:center;
    }
    .btn{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.22);
      color:rgba(255,255,255,.86);
      padding:10px 12px;
      border-radius:10px;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{ background:rgba(255,255,255,.10); border-color:rgba(255,255,255,.36); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }

    .panel{
      position:fixed; right:18px; top:18px;
      width:min(560px, calc(100vw - 36px));
      max-height: calc(100vh - 36px);
      overflow:auto;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.46);
      backdrop-filter: blur(10px);
      border-radius:14px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset, 0 16px 50px rgba(0,0,0,.65);
    }
    .panelHeader{
      position:sticky; top:0;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.66);
      backdrop-filter: blur(10px);
      display:flex; justify-content:space-between; align-items:center;
      z-index:10;
    }
    .panelHeader .title{
      font-weight:800;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      color:rgba(255,255,255,.86);
    }
    .panelHeader .hint{
      font-size:11px;
      letter-spacing:.08em;
      color:rgba(255,255,255,.55);
      text-align:right;
      line-height:1.2;
    }
    .panelBody{ padding:10px 12px 12px; display:flex; flex-direction:column; gap:10px; }

    .group{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      overflow:hidden;
      background:rgba(255,255,255,.02);
    }
    .group h3{
      margin:0;
      padding:10px 10px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:rgba(255,255,255,.75);
      border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    .pill{
      font-size:10px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:rgba(255,255,255,.62);
      border:1px solid rgba(255,255,255,.18);
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.20);
    }
    .rows{ padding:10px; display:flex; flex-direction:column; gap:10px; }
    .row{
      display:grid;
      grid-template-columns: 170px 1fr 70px;
      gap:10px;
      align-items:center;
    }
    .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:rgba(255,255,255,.62);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    input[type="range"]{ width:100%; accent-color: rgba(255,255,255,.92); }
    .val{ font-variant-numeric: tabular-nums; font-size:11px; color:rgba(255,255,255,.76); text-align:right; }

    .toggles{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      padding:10px;
    }
    .toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }
    .toggle span{
      font-size:11px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:rgba(255,255,255,.78);
      white-space:nowrap;
    }

    .note{
      font-size:11px;
      color:rgba(255,255,255,.55);
      line-height:1.35;
      letter-spacing:.02em;
      padding:10px 12px 0;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="brand">KETADATA</div>
    <div class="sub">SACRED GEOMETRY · CONTROLLED COMPLEXITY</div>
  </div>

  <div class="dock">
    <button class="btn" id="invert">INVERT</button>
    <button class="btn" id="pause">PAUSE</button>
    <button class="btn" id="reseed">RESEED</button>
    <button class="btn" id="reset">RESET</button>
  </div>

  <div class="panel" id="panel">
    <div class="panelHeader">
      <div class="title">GEOMETRY CONTROLS</div>
      <div class="hint">
        SCROLL = SCALE<br/>
        DRAG = OFFSET<br/>
        [H] PANEL · [P] PAUSE · [I] INVERT
      </div>
    </div>

    <div class="note">
      This is intentionally dense but bounded: precomputed lattices + capped segments. Use <b>quality</b> to keep it light.
      Invert flips background + all strokes; in invert mode blending is forced to source-over.
    </div>

    <div class="panelBody">

      <div class="group">
        <h3>System <span class="pill">global</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">time scale (slow-mo)</div>
            <input id="timeScale" type="range" min="0.00" max="2.00" step="0.001" value="0.45">
            <div class="val" id="timeScaleV">0.450</div>
          </div>
          <div class="row">
            <div class="label">scale</div>
            <input id="fill" type="range" min="0.4" max="3.5" step="0.01" value="1.55">
            <div class="val" id="fillV">1.55</div>
          </div>
          <div class="row">
            <div class="label">rotation</div>
            <input id="rot" type="range" min="-2.0" max="2.0" step="0.001" value="0.12">
            <div class="val" id="rotV">0.120</div>
          </div>
          <div class="row">
            <div class="label">quality</div>
            <input id="quality" type="range" min="0.30" max="1.00" step="0.01" value="0.78">
            <div class="val" id="qualityV">0.78</div>
          </div>
          <div class="row">
            <div class="label">line thickness</div>
            <input id="thick" type="range" min="0.4" max="3.8" step="0.01" value="1.20">
            <div class="val" id="thickV">1.20</div>
          </div>
          <div class="row">
            <div class="label">contrast</div>
            <input id="contrast" type="range" min="0.6" max="3.2" step="0.01" value="1.55">
            <div class="val" id="contrastV">1.55</div>
          </div>
          <div class="row">
            <div class="label">composite</div>
            <input id="comp" type="range" min="0" max="2" step="1" value="2">
            <div class="val" id="compV">screen</div>
          </div>
        </div>
      </div>

      <div class="group">
        <h3>Layers <span class="pill">toggle</span></h3>
        <div class="toggles">
          <label class="toggle"><input id="L_flower" type="checkbox" checked><span>flower of life</span></label>
          <label class="toggle"><input id="L_seed" type="checkbox" checked><span>seed of life</span></label>
          <label class="toggle"><input id="L_metatron" type="checkbox" checked><span>metatron</span></label>
          <label class="toggle"><input id="L_cube" type="checkbox" checked><span>cube projection</span></label>
          <label class="toggle"><input id="L_rays" type="checkbox" checked><span>radial rays</span></label>
          <label class="toggle"><input id="L_spiral" type="checkbox" checked><span>golden spiral</span></label>
          <label class="toggle"><input id="L_grid" type="checkbox"><span>hex grid</span></label>
          <label class="toggle"><input id="L_scan" type="checkbox" checked><span>scanlines</span></label>
        </div>
      </div>

      <div class="group">
        <h3>Structure <span class="pill">lattice</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">radius (circles)</div>
            <input id="rad" type="range" min="16" max="220" step="1" value="78">
            <div class="val" id="radV">78</div>
          </div>
          <div class="row">
            <div class="label">rings (extent)</div>
            <input id="rings" type="range" min="1" max="6" step="1" value="3">
            <div class="val" id="ringsV">3</div>
          </div>
          <div class="row">
            <div class="label">metatron edges</div>
            <input id="metaEdges" type="range" min="0" max="1" step="0.01" value="0.65">
            <div class="val" id="metaEdgesV">0.65</div>
          </div>
          <div class="row">
            <div class="label">ray density</div>
            <input id="rayN" type="range" min="6" max="96" step="1" value="36">
            <div class="val" id="rayNV">36</div>
          </div>
          <div class="row">
            <div class="label">ray length</div>
            <input id="rayLen" type="range" min="0.3" max="1.8" step="0.01" value="1.10">
            <div class="val" id="rayLenV">1.10</div>
          </div>
          <div class="row">
            <div class="label">spiral turns</div>
            <input id="spiralTurns" type="range" min="0" max="9" step="0.01" value="4.80">
            <div class="val" id="spiralTurnsV">4.80</div>
          </div>
          <div class="row">
            <div class="label">spiral weight</div>
            <input id="spiralW" type="range" min="0" max="1" step="0.01" value="0.55">
            <div class="val" id="spiralWV">0.55</div>
          </div>
        </div>
      </div>

      <div class="group">
        <h3>FX <span class="pill">texture</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">strobe</div>
            <input id="strobe" type="range" min="0" max="1" step="0.01" value="0.12">
            <div class="val" id="strobeV">0.12</div>
          </div>
          <div class="row">
            <div class="label">breathing</div>
            <input id="breathe" type="range" min="0" max="1" step="0.01" value="0.18">
            <div class="val" id="breatheV">0.18</div>
          </div>
          <div class="row">
            <div class="label">breath speed</div>
            <input id="breatheSpd" type="range" min="0" max="3" step="0.01" value="1.05">
            <div class="val" id="breatheSpdV">1.05</div>
          </div>
          <div class="row">
            <div class="label">fade to edge</div>
            <input id="edgeFade" type="range" min="0" max="1" step="0.01" value="0.35">
            <div class="val" id="edgeFadeV">0.35</div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha:false });

      let W=0, H=0, DPR=Math.min(2, window.devicePixelRatio||1);
      function resize(){
        W=innerWidth; H=innerHeight;
        canvas.width = Math.floor(W*DPR);
        canvas.height = Math.floor(H*DPR);
        canvas.style.width = W+'px';
        canvas.style.height = H+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize);
      resize();

      const $ = (id)=>document.getElementById(id);
      const sliders = [
        'timeScale','fill','rot','quality','thick','contrast','comp',
        'rad','rings','metaEdges','rayN','rayLen','spiralTurns','spiralW',
        'strobe','breathe','breatheSpd','edgeFade'
      ];
      const ui = {};
      for (const id of sliders) ui[id] = $(id);

      const layers = {
        flower: $('L_flower'),
        seed: $('L_seed'),
        metatron: $('L_metatron'),
        cube: $('L_cube'),
        rays: $('L_rays'),
        spiral: $('L_spiral'),
        grid: $('L_grid'),
        scan: $('L_scan')
      };

      function compLabel(v){ return v===0 ? 'source-over' : (v===1 ? 'lighter' : 'screen'); }

      function sync(){
        $('timeScaleV').textContent = (+ui.timeScale.value).toFixed(3);
        $('fillV').textContent = (+ui.fill.value).toFixed(2);
        $('rotV').textContent = (+ui.rot.value).toFixed(3);
        $('qualityV').textContent = (+ui.quality.value).toFixed(2);
        $('thickV').textContent = (+ui.thick.value).toFixed(2);
        $('contrastV').textContent = (+ui.contrast.value).toFixed(2);
        $('compV').textContent = compLabel((+ui.comp.value)|0);

        $('radV').textContent = ui.rad.value;
        $('ringsV').textContent = ui.rings.value;
        $('metaEdgesV').textContent = (+ui.metaEdges.value).toFixed(2);
        $('rayNV').textContent = ui.rayN.value;
        $('rayLenV').textContent = (+ui.rayLen.value).toFixed(2);
        $('spiralTurnsV').textContent = (+ui.spiralTurns.value).toFixed(2);
        $('spiralWV').textContent = (+ui.spiralW.value).toFixed(2);

        $('strobeV').textContent = (+ui.strobe.value).toFixed(2);
        $('breatheV').textContent = (+ui.breathe.value).toFixed(2);
        $('breatheSpdV').textContent = (+ui.breatheSpd.value).toFixed(2);
        $('edgeFadeV').textContent = (+ui.edgeFade.value).toFixed(2);
      }
      sliders.forEach(id => ui[id].addEventListener('input', () => { dirty=true; sync(); }));
      Object.values(layers).forEach(chk => chk.addEventListener('change', () => { dirty=true; }));
      sync();

      const st = {
        t: 0,
        invert:false,
        paused:false,
        scale: 1.0,
        wheel: 0,
        drag:false,
        ox:0, oy:0,
        lx:0, ly:0,
        seed: Math.random()*1e9
      };

      $('invert').onclick = ()=> { st.invert = !st.invert; dirty=true; };
      $('pause').onclick = ()=> st.paused = !st.paused;
      $('reseed').onclick = ()=> { st.seed = Math.random()*1e9; dirty=true; };
      $('reset').onclick = ()=> {
        st.t=0; st.invert=false; st.paused=false; st.scale=1.0; st.wheel=0; st.ox=0; st.oy=0;
        st.seed = Math.random()*1e9; dirty=true;
      };

      addEventListener('keydown', (e)=>{
        if (e.key === 'i' || e.key === 'I'){ st.invert = !st.invert; dirty=true; }
        if (e.key === 'p' || e.key === 'P') st.paused = !st.paused;
        if (e.key === 'h' || e.key === 'H') {
          const panel = document.getElementById('panel');
          panel.style.display = (panel.style.display === 'none') ? '' : 'none';
        }
      });

      addEventListener('wheel', (e)=>{
        const d = Math.max(-160, Math.min(160, e.deltaY));
        st.wheel += (-d/160) * 0.16;
        st.wheel = clamp(st.wheel, -0.70, 0.95);
      }, { passive:true });

      addEventListener('pointerdown', (e)=>{ st.drag=true; st.lx=e.clientX; st.ly=e.clientY; });
      addEventListener('pointerup', ()=> st.drag=false);
      addEventListener('pointercancel', ()=> st.drag=false);
      addEventListener('pointermove', (e)=>{
        if (!st.drag) return;
        const dx = e.clientX - st.lx;
        const dy = e.clientY - st.ly;
        st.lx = e.clientX; st.ly = e.clientY;
        st.ox += dx;
        st.oy += dy;
        st.ox = clamp(st.ox, -W*0.35, W*0.35);
        st.oy = clamp(st.oy, -H*0.35, H*0.35);
        dirty = true;
      });

      // ========= Geometry cache (keeps it light) =========
      let cached = {
        key: '',
        pts: [],           // lattice points
        seedIdx: [],       // 7 points (seed of life)
        metaIdx: [],       // 13 points for metatron circle centers
        cubeEdges: [],     // selected edges for cube projection
        metaEdges: []      // all candidate edges with distances
      };

      function hexLatticePoints(radPx, rings){
        // point spacing = rad (classic flower-of-life)
        const d = radPx;
        const h = d * Math.sqrt(3)/2;

        const pts = [];
        const map = new Map();

        for (let q=-rings; q<=rings; q++){
          for (let r=-rings; r<=rings; r++){
            const s = -q - r;
            // keep within hex distance <= rings
            const dist = Math.max(Math.abs(q), Math.abs(r), Math.abs(s));
            if (dist > rings) continue;

            const x = d * (q + r/2);
            const y = h * r;

            const key = q + ',' + r;
            map.set(key, pts.length);
            pts.push({ x,y,q,r });
          }
        }
        return { pts, map };
      }

      function keyForCache(){
        // only regenerate lattice if these change
        return [
          ui.rad.value, ui.rings.value
        ].join('|');
      }

      function rebuildCache(){
        const rad = +ui.rad.value;
        const rings = (+ui.rings.value)|0;

        const { pts, map } = hexLatticePoints(rad, rings);

        // Identify seed-of-life indices: center + 6 around (distance==1)
        // center = q=0,r=0, and neighbors:
        const neighbors = [
          [ 1, 0],
          [ 0, 1],
          [-1, 1],
          [-1, 0],
          [ 0,-1],
          [ 1,-1]
        ];

        const centerIdx = map.get('0,0') ?? 0;
        const seedIdx = [centerIdx];
        for (const [q,r] of neighbors){
          const idx = map.get(q+','+r);
          if (idx != null) seedIdx.push(idx);
        }

        // Metatron: typically 13 circles = center + 12 around.
        // We'll approximate using rings>=2: pick all points with hex distance <= 2.
        const metaIdx = [];
        for (let i=0;i<pts.length;i++){
          const p=pts[i];
          const s = -p.q - p.r;
          const dist = Math.max(Math.abs(p.q), Math.abs(p.r), Math.abs(s));
          if (dist <= 2) metaIdx.push(i);
        }

        // Candidate edges among metatron points:
        // connect points whose lattice distance is 1 or 2 (bounded).
        function hexDist(a,b){
          const dq = a.q-b.q, dr=a.r-b.r, ds=(-a.q-a.r)-(-b.q-b.r);
          return (Math.abs(dq)+Math.abs(dr)+Math.abs(ds))/2;
        }

        const metaEdges = [];
        for (let i=0;i<metaIdx.length;i++){
          for (let j=i+1;j<metaIdx.length;j++){
            const ai=metaIdx[i], bj=metaIdx[j];
            const da = hexDist(pts[ai], pts[bj]);
            if (da === 1 || da === 2){
              metaEdges.push({ a:ai, b:bj, d:da });
            }
          }
        }

        // Cube-ish projection: pick a subset of edges to suggest a cube.
        // We'll connect a few “axes”: center to 6 neighbors (dist=1) and some dist=2 spokes.
        const cubeEdges = [];
        for (const e of metaEdges){
          if (e.d === 1){
            // keep center spokes
            if (e.a === centerIdx || e.b === centerIdx) cubeEdges.push(e);
          }
        }
        for (const e of metaEdges){
          if (e.d === 2){
            // keep a sparse sample for diagonals
            // deterministic selection based on indices:
            const h = ((e.a*73856093) ^ (e.b*19349663)) >>> 0;
            if ((h % 5) === 0) cubeEdges.push(e);
          }
        }

        cached = {
          key: keyForCache(),
          pts,
          seedIdx,
          metaIdx,
          cubeEdges,
          metaEdges
        };
      }

      let dirty = true;

      function ensureCache(){
        const k = keyForCache();
        if (dirty || cached.key !== k){
          rebuildCache();
          dirty = false;
        }
      }

      // ========= Drawing helpers =========
      function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
      function lerp(a,b,t){ return a + (b-a)*t; }

      function edgeFadeAlpha(x,y,cx,cy,edgeFade){
        if (edgeFade <= 0) return 1;
        const nx = (x - cx) / (W*0.5);
        const ny = (y - cy) / (H*0.5);
        const d = Math.sqrt(nx*nx + ny*ny);      // 0 center .. ~1 corners
        // fade near edges: 1 at center, down toward edges
        const a = 1 - edgeFade * clamp((d - 0.55) / 0.55, 0, 1);
        return clamp(a, 0, 1);
      }

      function setStrokeRGBA(fg, a){
        ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
      }

      function drawCircle(x,y,r, fg, a){
        if (a <= 0.001) return;
        setStrokeRGBA(fg, a);
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.stroke();
      }

      function drawLine(x0,y0,x1,y1, fg, a){
        if (a <= 0.001) return;
        setStrokeRGBA(fg, a);
        ctx.beginPath();
        ctx.moveTo(x0,y0);
        ctx.lineTo(x1,y1);
        ctx.stroke();
      }

      // ========= Main loop =========
      let last = performance.now();
      function loop(now){
        const rawDt = Math.min(0.033, (now-last)/1000);
        last = now;

        st.wheel *= 0.88;
        st.scale += st.wheel;
        st.scale = clamp(st.scale, 0.55, 2.40);

        const dt = rawDt * (+ui.timeScale.value);
        if (!st.paused) st.t += dt;

        render();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      function render(){
        ensureCache();

        const inv = st.invert;
        const bg = inv ? 255 : 0;
        const fg = inv ? 0 : 255;

        ctx.fillStyle = `rgb(${bg},${bg},${bg})`;
        ctx.fillRect(0,0,W,H);

        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;

        const thick = +ui.thick.value;
        const contrast = +ui.contrast.value;
        const quality = +ui.quality.value;

        const rotSpeed = +ui.rot.value;
        const baseScale = +ui.fill.value;

        const strobe = +ui.strobe.value;
        const breatheAmt = +ui.breathe.value;
        const breatheSpd = +ui.breatheSpd.value;
        const edgeFade = +ui.edgeFade.value;

        const rad = +ui.rad.value;

        // Exposure envelope (kept bounded)
        const stro = strobe * (0.5 + 0.5*Math.sin(st.t*12.0));
        const exposure = (1.0 + stro*0.75) * contrast;

        // Composite: in invert mode force source-over so black is visible
        const comp = (+ui.comp.value)|0;
        ctx.globalCompositeOperation = inv ? 'source-over' : (comp===0 ? 'source-over' : (comp===1 ? 'lighter' : 'screen'));

        ctx.lineWidth = thick;

        // Global transform
        const breathe = 1.0 + breatheAmt * Math.sin(st.t*breatheSpd);
        const S = baseScale * st.scale * breathe;

        const ang = st.t * rotSpeed;

        // Precompute sin/cos once
        const ca = Math.cos(ang), sa = Math.sin(ang);

        function X(x,y){ return cx + (x*ca - y*sa) * S; }
        function Y(x,y){ return cy + (x*sa + y*ca) * S; }

        // ========== Layer: Hex Grid (light) ==========
        if (layers.grid.checked){
          // capped draw count: scale with quality
          const pts = cached.pts;
          const max = Math.floor(pts.length * clamp(quality*1.15, 0.30, 1.0));
          const a0 = 0.10 * exposure;
          for (let i=0;i<max;i++){
            const p = pts[i];
            const x = X(p.x,p.y), y = Y(p.x,p.y);
            const a = a0 * edgeFadeAlpha(x,y,cx,cy,edgeFade);
            // tiny cross
            drawLine(x-4,y, x+4,y, fg, a);
            drawLine(x,y-4, x,y+4, fg, a);
          }
        }

        // ========== Layer: Flower of Life ==========
        if (layers.flower.checked){
          const pts = cached.pts;
          // circle drawing is the main cost. cap by quality and rings.
          const maxCircles = Math.floor(pts.length * clamp(quality, 0.30, 1.0));
          const a0 = 0.18 * exposure;

          for (let i=0;i<maxCircles;i++){
            const p = pts[i];
            const x = X(p.x,p.y), y = Y(p.x,p.y);
            const a = a0 * edgeFadeAlpha(x,y,cx,cy,edgeFade);
            drawCircle(x,y, rad*S, fg, a);
          }
        }

        // ========== Layer: Seed of Life (heavier outline) ==========
        if (layers.seed.checked){
          const a0 = 0.34 * exposure;
          for (const idx of cached.seedIdx){
            const p = cached.pts[idx];
            if (!p) continue;
            const x = X(p.x,p.y), y = Y(p.x,p.y);
            const a = a0 * edgeFadeAlpha(x,y,cx,cy,edgeFade);
            // two circles: main + halo
            drawCircle(x,y, rad*S, fg, a);
            drawCircle(x,y, rad*S*1.01, fg, a*0.55);
          }
        }

        // ========== Layer: Metatron edges ==========
        if (layers.metatron.checked){
          const strength = +ui.metaEdges.value;
          const pts = cached.pts;
          const edges = cached.metaEdges;

          // cap edges by quality
          const maxE = Math.floor(edges.length * clamp(quality, 0.25, 1.0));
          const a0 = 0.22 * exposure * strength;

          // Use deterministic ordering: favor dist=1 edges, then dist=2
          let drawn = 0;
          // pass 1 (dist=1)
          for (let i=0;i<edges.length && drawn<maxE;i++){
            const e = edges[i];
            if (e.d !== 1) continue;
            const A = pts[e.a], B = pts[e.b];
            const x0 = X(A.x,A.y), y0=Y(A.x,A.y);
            const x1 = X(B.x,B.y), y1=Y(B.x,B.y);
            const mx = (x0+x1)*0.5, my=(y0+y1)*0.5;
            const a = a0 * edgeFadeAlpha(mx,my,cx,cy,edgeFade);
            drawLine(x0,y0,x1,y1, fg, a);
            drawn++;
          }
          // pass 2 (dist=2) sparse
          const a1 = a0 * 0.55;
          for (let i=0;i<edges.length && drawn<maxE;i++){
            const e = edges[i];
            if (e.d !== 2) continue;
            // deterministic thinning based on indices + seed
            const h = (((e.a*73856093) ^ (e.b*19349663) ^ (st.seed|0)) >>> 0);
            if ((h % Math.max(2, Math.floor(6 - quality*4))) !== 0) continue;

            const A = pts[e.a], B = pts[e.b];
            const x0 = X(A.x,A.y), y0=Y(A.x,A.y);
            const x1 = X(B.x,B.y), y1=Y(B.x,B.y);
            const mx = (x0+x1)*0.5, my=(y0+y1)*0.5;
            const a = a1 * edgeFadeAlpha(mx,my,cx,cy,edgeFade);
            drawLine(x0,y0,x1,y1, fg, a);
            drawn++;
          }

          // Draw Metatron centers (subtle)
          const aC = 0.18 * exposure * strength;
          const maxCenters = Math.floor(cached.metaIdx.length * clamp(quality*1.2, 0.30, 1.0));
          for (let i=0;i<maxCenters;i++){
            const p = pts[cached.metaIdx[i]];
            const x = X(p.x,p.y), y=Y(p.x,p.y);
            const a = aC * edgeFadeAlpha(x,y,cx,cy,edgeFade);
            drawCircle(x,y, rad*S*0.12, fg, a);
          }
        }

        // ========== Layer: Cube projection ==========
        if (layers.cube.checked){
          const pts = cached.pts;
          const edges = cached.cubeEdges;

          const maxE = Math.floor(edges.length * clamp(quality, 0.25, 1.0));
          const a0 = 0.18 * exposure;

          for (let i=0;i<maxE;i++){
            const e = edges[i];
            const A = pts[e.a], B = pts[e.b];
            const x0 = X(A.x,A.y), y0=Y(A.x,A.y);
            const x1 = X(B.x,B.y), y1=Y(B.x,B.y);
            const mx = (x0+x1)*0.5, my=(y0+y1)*0.5;
            const a = a0 * edgeFadeAlpha(mx,my,cx,cy,edgeFade);
            drawLine(x0,y0,x1,y1, fg, a);
          }
        }

        // ========== Layer: Radial Rays ==========
        if (layers.rays.checked){
          const N = (+ui.rayN.value)|0;
          const len = +ui.rayLen.value;
          const a0 = 0.14 * exposure;
          const Rmax = Math.min(W,H) * 0.52 * len;

          // keep rays light: use quality to reduce count
          const n2 = Math.max(4, Math.floor(N * clamp(quality, 0.30, 1.0)));
          for (let i=0;i<n2;i++){
            const t = (i/n2)*Math.PI*2 + ang*0.35;
            const x1 = cx + Math.cos(t)*Rmax;
            const y1 = cy + Math.sin(t)*Rmax;
            const a = a0 * edgeFadeAlpha(x1,y1,cx,cy,edgeFade);
            drawLine(cx,cy,x1,y1, fg, a);
          }
        }

        // ========== Layer: Golden Spiral ==========
        if (layers.spiral.checked){
          const turns = +ui.spiralTurns.value;
          const w = +ui.spiralW.value;
          const a0 = 0.20 * exposure * w;

          // capped segments scaled by quality (prevents heaviness)
          const seg = Math.floor(lerp(420, 1100, clamp(quality, 0.30, 1.0)));
          const phi = (1 + Math.sqrt(5)) / 2;
          const b = Math.log(phi) / (Math.PI/2);   // growth per quarter-turn

          ctx.beginPath();
          let started = false;

          for (let i=0;i<=seg;i++){
            const u = (i/seg) * (Math.PI*2*turns);
            const r = Math.exp(b * u) * (rad*0.012) * S * (Math.min(W,H)); // normalized
            const x = cx + Math.cos(u + ang*0.55) * r;
            const y = cy + Math.sin(u + ang*0.55) * r;

            const a = a0 * edgeFadeAlpha(x,y,cx,cy,edgeFade);
            // local alpha modulation: if too low, skip point to reduce draw cost
            if (a < 0.01) continue;

            if (!started){ ctx.moveTo(x,y); started=true; }
            else ctx.lineTo(x,y);
          }

          if (started){
            setStrokeRGBA(fg, clamp(a0,0,1));
            ctx.stroke();
          }
        }

        // Return to normal composite for scanlines (so they always read)
        ctx.globalCompositeOperation = 'source-over';

        if (layers.scan.checked){
          const step = 9;
          const yOff = (st.t*70) % step;
          ctx.lineWidth = 1;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.045*contrast})`;
          for (let y=-step; y<H+step; y+=step){
            ctx.beginPath();
            ctx.moveTo(0, y+yOff);
            ctx.lineTo(W, y+yOff);
            ctx.stroke();
          }
        }
      }

      // Kick cache build once
      rebuildCache();

    })();
  </script>
</body>
</html>
