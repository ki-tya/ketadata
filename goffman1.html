<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA — GOFFMAN INTERFACE (DRAMATURGY / FRAME ENGINE)</title>
  <style>
    :root{
      --bg:#000;
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.56);
      --hair:rgba(255,255,255,.14);
      --panel:rgba(0,0,0,.58);
      --panel2:rgba(255,255,255,.03);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; overflow:hidden;
      background:var(--bg); color:var(--fg);
      font-family: Arial, Helvetica, sans-serif;
    }
    canvas{ position:fixed; inset:0; width:100vw; height:100vh; display:block; }

    .hud{
      position:fixed; left:18px; top:16px;
      user-select:none; pointer-events:none;
      mix-blend-mode:screen;
    }
    .brand{
      font-weight:900;
      letter-spacing:.18em;
      text-transform:uppercase;
      font-size:15px;
      text-shadow:0 0 18px rgba(255,255,255,.18);
    }
    .sub{
      margin-top:4px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:var(--muted);
      line-height:1.25;
      max-width: 66ch;
    }

    .dock{
      position:fixed; left:18px; bottom:16px;
      display:flex; flex-wrap:wrap;
      gap:10px; align-items:center;
      pointer-events:auto;
    }
    .btn, select{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.22);
      color:rgba(255,255,255,.86);
      padding:10px 12px;
      border-radius:10px;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
      outline:none;
    }
    .btn:hover, select:hover{
      background:rgba(255,255,255,.10);
      border-color:rgba(255,255,255,.36);
      transform: translateY(-1px);
    }
    .btn:active{ transform: translateY(0px); }

    .panel{
      position:fixed; right:16px; top:16px;
      width:min(820px, calc(100vw - 32px));
      max-height: calc(100vh - 32px);
      overflow:auto;
      border:1px solid rgba(255,255,255,.18);
      background:var(--panel);
      backdrop-filter: blur(10px);
      border-radius:14px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset, 0 16px 50px rgba(0,0,0,.65);
    }
    .panelHeader{
      position:sticky; top:0;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.74);
      backdrop-filter: blur(10px);
      display:flex; justify-content:space-between; align-items:center;
      z-index:10;
    }
    .title{
      font-weight:900;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      color:rgba(255,255,255,.86);
    }
    .hint{
      font-size:11px;
      letter-spacing:.08em;
      color:rgba(255,255,255,.55);
      text-align:right;
      line-height:1.2;
    }
    .panelBody{ padding:10px 12px 14px; display:flex; flex-direction:column; gap:10px; }

    .block{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      overflow:hidden;
      background:var(--panel2);
    }
    .block h3{
      margin:0;
      padding:10px 10px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:rgba(255,255,255,.75);
      border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      display:flex; justify-content:space-between; align-items:center; gap:10px;
    }
    .pill{
      font-size:10px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:rgba(255,255,255,.62);
      border:1px solid rgba(255,255,255,.18);
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.20);
      white-space:nowrap;
    }
    .rows{ padding:10px; display:flex; flex-direction:column; gap:10px; }
    .row{
      display:grid;
      grid-template-columns: 280px 1fr 70px;
      gap:10px;
      align-items:center;
    }
    .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:rgba(255,255,255,.62);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    input[type="range"]{ width:100%; accent-color: rgba(255,255,255,.92); }
    .val{ font-variant-numeric: tabular-nums; font-size:11px; color:rgba(255,255,255,.76); text-align:right; }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 980px){ .grid2{ grid-template-columns:1fr; } }

    .toggles{
      padding:10px;
      display:flex; flex-wrap:wrap; gap:8px;
      border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
    }
    .toggle{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }
    .toggle span{
      font-size:11px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:rgba(255,255,255,.78);
      white-space:nowrap;
    }

    .status{
      padding:10px;
      border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
      display:flex; flex-direction:column; gap:10px;
    }
    .mono{
      font-variant-numeric: tabular-nums;
      letter-spacing:.10em;
      text-transform:uppercase;
      font-size:10px;
      color:rgba(255,255,255,.74);
      line-height:1.35;
    }
    .bar{
      height:12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.04);
      overflow:hidden;
    }
    .fill{ height:100%; width:0%; background:rgba(255,255,255,.60); }

    .card{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      background:rgba(0,0,0,.45);
      padding:10px;
      font-size:12px;
      line-height:1.35;
      letter-spacing:.02em;
      white-space:pre-wrap;
    }

    /* ===== controller fix (no other behavior changes) ===== */
    canvas{ z-index:0; }
    .dock{ z-index:20; }
    .panel{ z-index:30; }
    .panel input,
    .panel button,
    .panel label,
    .panel select,
    .dock input,
    .dock button,
    .dock label,
    .dock select{
      pointer-events:auto;
      touch-action: manipulation;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="brand">KETADATA</div>
    <div class="sub" id="sub">
      GOFFMAN MODE · DRAMATURGY / FRAME ANALYSIS · FRONTSTAGE vs BACKSTAGE · FACE-WORK / TEAM / STIGMA · CLICK = SIGN-VEHICLE · DRAG = EPISODE · HOLD [SPACE] = COOLING-OUT
    </div>
  </div>

  <div class="dock">
    <select id="frame">
      <option value="civil">FRAME: CIVIL INATTENTION</option>
      <option value="status">FRAME: STATUS DISPLAY</option>
      <option value="service">FRAME: SERVICE ENCOUNTER</option>
      <option value="intimacy">FRAME: INTIMACY</option>
      <option value="conflict">FRAME: CONFLICT</option>
      <option value="irony">FRAME: IRONIC PERFORMANCE</option>
      <option value="stigma">FRAME: STIGMA MANAGEMENT</option>
      <option value="institution">FRAME: TOTAL INSTITUTION</option>
    </select>
    <button class="btn" id="invert">INVERT</button>
    <button class="btn" id="pause">PAUSE</button>
    <button class="btn" id="reseed">RESEED CAST</button>
    <button class="btn" id="clear">CLEAR EPISODES</button>
    <button class="btn" id="reset">RESET</button>
  </div>

  <div class="panel" id="panel">
    <div class="panelHeader">
      <div class="title">IMPRESSION ENGINE</div>
      <div class="hint">
        CLICK = SIGN-VEHICLE · DRAG = EPISODE (FRONTSTAGE) · SHIFT+DRAG = BACKSTAGE PREP<br/>
        SCROLL = ZOOM · DRAG EMPTY = PAN · [H] PANEL · [I] INVERT · [P] PAUSE
      </div>
    </div>

    <div class="panelBody">
      <div class="grid2">
        <div class="block">
          <h3>Stage Physics <span class="pill">motion</span></h3>
          <div class="rows">
            <div class="row">
              <div class="label">time scale (slow-mo)</div>
              <input id="timeScale" type="range" min="0.000" max="2.000" step="0.001" value="0.28">
              <div class="val" id="timeScaleV">0.280</div>
            </div>
            <div class="row">
              <div class="label">complexity (intricacy)</div>
              <input id="complex" type="range" min="0.40" max="2.60" step="0.01" value="1.70">
              <div class="val" id="complexV">1.70</div>
            </div>
            <div class="row">
              <div class="label">stage depth (front↔back)</div>
              <input id="depth" type="range" min="0.10" max="1.20" step="0.01" value="0.72">
              <div class="val" id="depthV">0.72</div>
            </div>
            <div class="row">
              <div class="label">trace (residue)</div>
              <input id="trace" type="range" min="0.000" max="0.22" step="0.001" value="0.055">
              <div class="val" id="traceV">0.055</div>
            </div>
            <div class="row">
              <div class="label">zoom</div>
              <input id="zoom" type="range" min="0.55" max="2.60" step="0.01" value="1.15">
              <div class="val" id="zoomV">1.15</div>
            </div>
          </div>
          <div class="toggles">
            <label class="toggle"><input id="T_prosc" type="checkbox" checked><span>proscenium</span></label>
            <label class="toggle"><input id="T_aud" type="checkbox" checked><span>audience arcs</span></label>
            <label class="toggle"><input id="T_masks" type="checkbox" checked><span>mask mesh</span></label>
            <label class="toggle"><input id="T_scripts" type="checkbox" checked><span>scripts</span></label>
            <label class="toggle"><input id="T_frames" type="checkbox" checked><span>frame grid</span></label>
            <label class="toggle"><input id="T_spot" type="checkbox" checked><span>spotlight</span></label>
          </div>
        </div>

        <div class="block">
          <h3>Interaction Order <span class="pill">social mechanics</span></h3>
          <div class="rows">
            <div class="row">
              <div class="label">audience pressure (gaze)</div>
              <input id="gaze" type="range" min="0.00" max="2.00" step="0.01" value="1.10">
              <div class="val" id="gazeV">1.10</div>
            </div>
            <div class="row">
              <div class="label">team cohesion</div>
              <input id="team" type="range" min="0.00" max="2.00" step="0.01" value="0.95">
              <div class="val" id="teamV">0.95</div>
            </div>
            <div class="row">
              <div class="label">stigma noise</div>
              <input id="stigma" type="range" min="0.00" max="2.00" step="0.01" value="0.55">
              <div class="val" id="stigmaV">0.55</div>
            </div>
            <div class="row">
              <div class="label">leak rate (backstage→front)</div>
              <input id="leak" type="range" min="0.00" max="2.00" step="0.01" value="0.62">
              <div class="val" id="leakV">0.62</div>
            </div>
            <div class="row">
              <div class="label">repair rate (face-work)</div>
              <input id="repair" type="range" min="0.00" max="2.00" step="0.01" value="0.90">
              <div class="val" id="repairV">0.90</div>
            </div>
          </div>
          <div class="status">
            <div class="mono" id="stat">—</div>
            <div class="mono">FACE-WORK</div>
            <div class="bar"><div class="fill" id="faceFill"></div></div>
            <div class="mono">LEGIBILITY (HOW “READABLE” YOU’VE MADE THE SCENE)</div>
            <div class="bar"><div class="fill" id="legFill"></div></div>
            <div class="card" id="card">CLICK TO DROP SIGN-VEHICLES. DRAG TO RUN EPISODES. HOLD [SPACE] TO COOL-OUT (REPAIR FACE).</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha:false });

      let W=0, H=0, DPR=Math.min(2, window.devicePixelRatio||1);
      function resize(){
        W=innerWidth; H=innerHeight;
        canvas.width = Math.floor(W*DPR);
        canvas.height = Math.floor(H*DPR);
        canvas.style.width = W+'px';
        canvas.style.height = H+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize);
      resize();

      const $ = (id)=>document.getElementById(id);
      const ui = {
        frame: $('frame'),
        timeScale: $('timeScale'),
        complex: $('complex'),
        depth: $('depth'),
        trace: $('trace'),
        zoom: $('zoom'),
        gaze: $('gaze'),
        team: $('team'),
        stigma: $('stigma'),
        leak: $('leak'),
        repair: $('repair'),
        T_prosc: $('T_prosc'),
        T_aud: $('T_aud'),
        T_masks: $('T_masks'),
        T_scripts: $('T_scripts'),
        T_frames: $('T_frames'),
        T_spot: $('T_spot'),
      };
      const vv = {
        timeScaleV: $('timeScaleV'),
        complexV: $('complexV'),
        depthV: $('depthV'),
        traceV: $('traceV'),
        zoomV: $('zoomV'),
        gazeV: $('gazeV'),
        teamV: $('teamV'),
        stigmaV: $('stigmaV'),
        leakV: $('leakV'),
        repairV: $('repairV'),
      };

      function syncVals(){
        vv.timeScaleV.textContent = (+ui.timeScale.value).toFixed(3);
        vv.complexV.textContent   = (+ui.complex.value).toFixed(2);
        vv.depthV.textContent     = (+ui.depth.value).toFixed(2);
        vv.traceV.textContent     = (+ui.trace.value).toFixed(3);
        vv.zoomV.textContent      = (+ui.zoom.value).toFixed(2);
        vv.gazeV.textContent      = (+ui.gaze.value).toFixed(2);
        vv.teamV.textContent      = (+ui.team.value).toFixed(2);
        vv.stigmaV.textContent    = (+ui.stigma.value).toFixed(2);
        vv.leakV.textContent      = (+ui.leak.value).toFixed(2);
        vv.repairV.textContent    = (+ui.repair.value).toFixed(2);
      }
      Object.values(ui).forEach(el=>{
        if (!el || !el.addEventListener) return;
        el.addEventListener('input', syncVals);
        el.addEventListener('change', syncVals);
      });
      syncVals();

      const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
      const lerp=(a,b,t)=>a+(b-a)*t;
      const tau = Math.PI*2;

      function hash32(n){
        n = (n ^ (n >>> 16)) >>> 0;
        n = Math.imul(n, 2246822519) >>> 0;
        n = (n ^ (n >>> 13)) >>> 0;
        n = Math.imul(n, 3266489917) >>> 0;
        n = (n ^ (n >>> 16)) >>> 0;
        return n >>> 0;
      }
      function rnd01(n){ return hash32(n) / 4294967295; }

      const st = {
        t:0,
        invert:false,
        paused:false,
        seed:(Math.random()*1e9)|0,

        ox:0, oy:0,
        wheel:0,
        zoom:1.0,

        mx:0, my:0,
        dragging:false,
        dragType:"pan", // pan | episodeFront | episodeBack
        lastX:0, lastY:0,

        holding:false,
        holdTime:0.0,

        // dramaturgical variables
        face:0.78,       // 0..1 (maintained face)
        legibility:0.18, // 0..1 (how readable you made the scene)
        tension:0.22,    // 0..1 (risk of breakdown)

        // spotlight
        spotX:0, spotY:0,
        spotR:240,

        // cast
        actors:[],
        audience:[],
        props:[],
        scripts:[],
        signs:[],
        leaks:[],
        breaks:[]
      };

      function stageScale(){ return Math.min(W,H) * 0.60 * st.zoom; }
      function stageCenter(){ return { x: W*0.5 + st.ox, y: H*0.5 + st.oy }; }
      function stageToScreen(x,y){
        const S = stageScale();
        const c = stageCenter();
        return { x: c.x + x*S, y: c.y + y*S };
      }
      function screenToStage(sx,sy){
        const S = stageScale();
        const c = stageCenter();
        return { x: (sx-c.x)/S, y: (sy-c.y)/S };
      }

      // FRAME MODIFIERS (goffman: “what’s going on here?” changes everything)
      const FRAMES = {
        civil:      { gaze:0.70, stigma:0.55, team:0.85, leak:0.45, legGain:0.65, tensGain:0.75, note:"CIVIL INATTENTION: minimal but constant monitoring." },
        status:     { gaze:1.25, stigma:0.65, team:0.95, leak:0.55, legGain:0.95, tensGain:0.95, note:"STATUS DISPLAY: sign-vehicles dominate (dress, posture, tokens)." },
        service:    { gaze:1.00, stigma:0.60, team:1.10, leak:0.62, legGain:0.90, tensGain:0.90, note:"SERVICE ENCOUNTER: scripts + roles + repair work." },
        intimacy:   { gaze:0.55, stigma:0.40, team:1.15, leak:0.85, legGain:0.55, tensGain:0.70, note:"INTIMACY: backstage bleeds forward; repairs are softer." },
        conflict:   { gaze:1.35, stigma:1.05, team:0.70, leak:0.60, legGain:1.05, tensGain:1.35, note:"CONFLICT: face is fragile; breakdowns propagate." },
        irony:      { gaze:0.90, stigma:0.55, team:0.90, leak:0.75, legGain:0.85, tensGain:0.90, note:"IRONIC PERFORMANCE: frames jitter; meaning slips." },
        stigma:     { gaze:1.10, stigma:1.35, team:0.85, leak:0.70, legGain:0.85, tensGain:1.15, note:"STIGMA MANAGEMENT: concealment, passing, and information control." },
        institution:{ gaze:1.60, stigma:0.85, team:0.55, leak:0.35, legGain:1.10, tensGain:1.25, note:"TOTAL INSTITUTION: surveillance, routinization, restricted backstage." }
      };

      function reseedCast(){
        st.seed = (Math.random()*1e9)|0;

        st.actors.length = 0;
        st.audience.length = 0;
        st.props.length = 0;
        st.scripts.length = 0;
        st.signs.length = 0;
        st.leaks.length = 0;
        st.breaks.length = 0;

        st.face = 0.78;
        st.legibility = 0.18;
        st.tension = 0.22;

        const castN = 10 + Math.floor(rnd01(st.seed+11)*12); // 10..21
        for (let i=0;i<castN;i++){
          const a = rnd01(st.seed+i*97)*tau;
          const r = 0.10 + 0.55*Math.sqrt(rnd01(st.seed+i*31));
          const role = rnd01(st.seed+i*19); // 0..1 role axis
          const frontBias = rnd01(st.seed+i*41); // 0=backstage,1=frontstage
          st.actors.push({
            id:i,
            x: Math.cos(a)*r,
            y: Math.sin(a)*r*0.72,
            vx:0, vy:0,
            role, frontBias,
            mask: {
              // “mask geometry”: cheap polygonal signature
              k: 5 + Math.floor(rnd01(st.seed+i*13)*6), // 5..10
              rot: rnd01(st.seed+i*73)*tau
            },
            face: 0.70 + 0.30*rnd01(st.seed+i*59),
            script: rnd01(st.seed+i*7),
            team: rnd01(st.seed+i*101),
            stigma: rnd01(st.seed+i*107),
          });
        }

        const audN = 28 + Math.floor(rnd01(st.seed+999)*26); // 28..53
        for (let i=0;i<audN;i++){
          const a = (i/audN)*tau + rnd01(st.seed+i*17)*0.09;
          const r = 0.86 + 0.16*rnd01(st.seed+i*23);
          st.audience.push({ a, r, w: 0.4 + 0.6*rnd01(st.seed+i*29) });
        }

        const propN = 18 + Math.floor(rnd01(st.seed+1234)*22); // 18..39
        for (let i=0;i<propN;i++){
          const px = (rnd01(st.seed+i*113)*2-1) * (0.55 + 0.25*rnd01(st.seed+i*3));
          const py = (rnd01(st.seed+i*127)*2-1) * (0.55 + 0.25*rnd01(st.seed+i*5));
          st.props.push({ x:px, y:py, t:0, kind: (i%3) });
        }

        const scriptN = 7 + Math.floor(rnd01(st.seed+777)*8); // 7..14
        for (let i=0;i<scriptN;i++){
          const ax = (rnd01(st.seed+i*211)*2-1) * 0.60;
          const ay = (rnd01(st.seed+i*223)*2-1) * 0.45;
          st.scripts.push({ x:ax, y:ay, p:rnd01(st.seed+i*239) });
        }

        st.spotX = W*0.5; st.spotY = H*0.5;
        st.spotR = 260;
        updateCard();
      }

      function updateCard(extra=""){
        const f = FRAMES[ui.frame.value] || FRAMES.civil;
        const lines = [
          `FRAME: ${ui.frame.options[ui.frame.selectedIndex].textContent.replace("FRAME: ","")}`,
          f.note,
          "",
          `FACE is the maintained line. LEGIBILITY is the readability you forced into the scene.`,
          `TENSION rises with gaze+stigma+leaks, drops with repair+team coherence.`,
          "",
          `CONTROLS: CLICK drops sign-vehicles. DRAG performs episodes (frontstage). SHIFT+DRAG does backstage prep (reduces tension, risks leaks). HOLD [SPACE] cools-out (repairs face).`,
        ];
        $('card').textContent = lines.join("\n") + (extra ? `\n\n${extra}` : "");
      }

      // EVENTS
      function addSign(x,y,type=0){
        st.signs.push({
          x,y,
          type,
          t: st.t,
          life: 1.0,
          w: 0.35 + 0.65*rnd01(st.seed + st.signs.length*33)
        });
        if (st.signs.length > 320) st.signs.shift();
      }

      function addLeak(){
        // connect random backstage point to frontstage point
        const a = rnd01(st.seed + ((st.t*1000)|0) + st.leaks.length*11)*tau;
        const r1 = 0.25 + 0.45*rnd01(st.seed + st.leaks.length*17);
        const r2 = 0.55 + 0.35*rnd01(st.seed + st.leaks.length*19);
        const x1 = Math.cos(a)*r1, y1 = Math.sin(a)*r1*0.72;
        const x2 = Math.cos(a+0.7)*r2, y2 = Math.sin(a+0.7)*r2*0.72;
        st.leaks.push({ x1,y1,x2,y2, t:st.t, life:1.0 });
        if (st.leaks.length > 240) st.leaks.shift();
      }

      function addBreak(x,y){
        st.breaks.push({ x,y, t:st.t, life:1.0 });
        if (st.breaks.length > 80) st.breaks.shift();
      }

      function clamp01(x){ return clamp(x,0,1); }

      // MECHANICS (not decoration)
      function step(dt){
        const f = FRAMES[ui.frame.value] || FRAMES.civil;

        const C = +ui.complex.value;
        const depth = +ui.depth.value;

        const gaze = (+ui.gaze.value) * f.gaze;
        const team = (+ui.team.value) * f.team;
        const stigma = (+ui.stigma.value) * f.stigma;
        const leak = (+ui.leak.value) * f.leak;
        const repair = (+ui.repair.value);

        // zoom smoothing
        st.wheel *= 0.88;
        st.zoom += st.wheel;
        st.zoom = clamp(st.zoom, 0.55, 2.60);
        st.zoom = lerp(st.zoom, +ui.zoom.value, clamp(dt*0.9,0,1));

        // spotlight easing (follows cursor)
        st.spotX = lerp(st.spotX, st.mx, clamp(dt*(2.0 + 1.5*C),0,1));
        st.spotY = lerp(st.spotY, st.my, clamp(dt*(2.0 + 1.5*C),0,1));
        st.spotR = lerp(st.spotR, 220 + 260*(1 - st.tension), clamp(dt*(0.6 + 0.7*C),0,1));

        // holding = cooling-out (repair face)
        if (st.holding){
          st.holdTime += dt;
          const earn = clamp01((st.holdTime - 0.12) * (0.55 + 0.85*repair));
          st.face = clamp01(st.face + earn * dt * (0.40 + 0.55*repair));
          st.tension = clamp01(st.tension - earn * dt * (0.45 + 0.55*repair));
        } else {
          st.holdTime = Math.max(0, st.holdTime - dt*1.1);
        }

        // baseline: the social order makes itself legible over time (and you can accelerate it)
        const legRise = (0.010 + 0.020*C) * f.legGain * (0.55 + 0.45*gaze);
        st.legibility = clamp01(st.legibility + dt * legRise);

        // tension: surveillance + stigma + leak + low team
        const tensRise = (0.008 + 0.020*C) * f.tensGain * (0.65 + 0.55*gaze) * (0.65 + 0.65*stigma) * (0.85 + 0.35*leak) * (1.1 - 0.35*team);
        st.tension = clamp01(st.tension + dt * tensRise);

        // face erodes under tension and stigma, but is supported by team/repair
        const faceDrop = (0.006 + 0.018*C) * (0.65 + st.tension) * (0.55 + 0.55*stigma) * (1.05 - 0.30*team);
        const faceSupport = (0.004 + 0.010*C) * (0.40 + 0.60*team) * (0.35 + 0.65*repair);
        st.face = clamp01(st.face - dt*faceDrop + dt*faceSupport);

        // actor drift: front/backstage bias produces depth layering
        for (let i=0;i<st.actors.length;i++){
          const a = st.actors[i];

          // social “pulls”: toward front if high gaze, toward back if high stigma (information control)
          const frontPull = (a.frontBias*0.7 + 0.3) * (0.25 + 0.75*gaze);
          const backPull  = (1-a.frontBias*0.7) * (0.15 + 0.85*stigma);

          // frame noise shifts positions slightly (irony/conflict wobble)
          const frameNoise = (ui.frame.value==="irony" ? 1.0 : 0.0) + (ui.frame.value==="conflict" ? 0.6 : 0.0);
          const wob = frameNoise * (0.015 + 0.020*C) * Math.sin(st.t*(0.9+0.2*i) + i);

          // drift along y (“depth”) + mild orbit
          a.vx += (0.0015 + 0.0025*C) * Math.cos(st.t*0.35 + i) * (0.2 + a.team*team);
          a.vy += (0.0020 + 0.0030*C) * Math.sin(st.t*0.33 + i) * (frontPull - backPull) * depth;

          a.vx *= Math.pow(0.10, dt*0.25);
          a.vy *= Math.pow(0.10, dt*0.25);

          a.x += (a.vx + wob) * dt * (0.9 + 0.6*C);
          a.y += (a.vy - wob) * dt * (0.9 + 0.6*C);

          // keep on stage
          a.x = clamp(a.x, -0.95, 0.95);
          a.y = clamp(a.y, -0.70, 0.70);

          // face sync (micro)
          a.face = clamp01(lerp(a.face, st.face, clamp(dt*(0.18 + 0.22*team),0,1)));
        }

        // leaks: more likely when backstage work is high OR intimacy is high
        const leakChance = dt * (0.08 + 0.20*C) * leak * (0.55 + 0.85*(1-st.face)) * (0.55 + 0.75*(ui.frame.value==="intimacy" ? 1 : 0));
        if (rnd01(st.seed + ((st.t*10000)|0) + st.leaks.length*13) < leakChance) addLeak();

        // decay leaks, signs, breaks
        for (let i=st.leaks.length-1;i>=0;i--){
          st.leaks[i].life -= dt*(0.18 + 0.35*C + 0.20*st.legibility);
          if (st.leaks[i].life <= 0) st.leaks.splice(i,1);
        }
        for (let i=st.signs.length-1;i>=0;i--){
          st.signs[i].life -= dt*(0.10 + 0.25*C);
          if (st.signs[i].life <= 0) st.signs.splice(i,1);
        }
        for (let i=st.breaks.length-1;i>=0;i--){
          st.breaks[i].life -= dt*(0.20 + 0.30*C);
          if (st.breaks[i].life <= 0) st.breaks.splice(i,1);
        }

        // breakdown condition: if face low and tension high → “interaction breakdown”
        if (st.face < 0.22 && st.tension > 0.82){
          const p = screenToStage(st.spotX, st.spotY);
          addBreak(p.x, p.y);
          st.tension = clamp01(st.tension - 0.12);
          st.face = clamp01(st.face + 0.08);
          // breakdown creates legibility spike (everyone “reads” it)
          st.legibility = clamp01(st.legibility + 0.06);
        }

        // meters
        $('faceFill').style.width = Math.round(st.face*100) + "%";
        $('legFill').style.width = Math.round(st.legibility*100) + "%";

        $('stat').textContent =
          `GOFFMAN · FACE ${Math.round(st.face*100)}% · LEGIBILITY ${Math.round(st.legibility*100)}% · TENSION ${Math.round(st.tension*100)}% · CAST ${st.actors.length} · SIGNS ${st.signs.length} · LEAKS ${st.leaks.length}`;
      }

      function draw(){
        const inv = st.invert;
        const bg = inv ? 255 : 0;
        const fg = inv ? 0 : 255;

        const tr = +ui.trace.value;
        if (tr > 0){
          ctx.fillStyle = `rgba(${bg},${bg},${bg},${clamp(tr,0,1)})`;
          ctx.fillRect(0,0,W,H);
        } else {
          ctx.fillStyle = `rgb(${bg},${bg},${bg})`;
          ctx.fillRect(0,0,W,H);
        }

        // for normal mode, a little screen blend gives “stage glare”; for invert we keep source-over so lines become black.
        ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';

        const C = +ui.complex.value;
        const depth = +ui.depth.value;
        const f = FRAMES[ui.frame.value] || FRAMES.civil;

        const gaze = (+ui.gaze.value) * f.gaze;
        const team = (+ui.team.value) * f.team;
        const stigma = (+ui.stigma.value) * f.stigma;

        const center = stageCenter();
        const S = stageScale();

        // stage geometry boundaries
        const frontLineY = lerp(0.18, 0.04, clamp(depth/1.2,0,1)); // in stage coords
        const backLineY  = lerp(-0.30, -0.50, clamp(depth/1.2,0,1));

        // PROSCENIUM (hard boundary)
        if (ui.T_prosc.checked){
          ctx.lineWidth = 1.4;
          const a = clamp(0.08 + 0.12*gaze + 0.10*st.legibility, 0, 0.40);
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;

          // proscenium arch
          const r = Math.min(W,H)*0.44;
          ctx.beginPath();
          ctx.arc(center.x, center.y, r, Math.PI*1.05, Math.PI*1.95);
          ctx.stroke();

          // curtains as vertical rails
          const rails = Math.floor(lerp(8, 22, clamp(C/2.6,0,1)));
          for (let i=0;i<rails;i++){
            const t = i/(rails-1);
            const x = lerp(center.x - r*0.92, center.x + r*0.92, t);
            const y1 = center.y - r*0.40;
            const y2 = center.y + r*0.62;
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(0.03 + 0.08*(1-Math.abs(t-0.5)*2),0,0.18)})`;
            ctx.beginPath();
            ctx.moveTo(x, y1);
            ctx.lineTo(x, y2);
            ctx.stroke();
          }

          // front/backstage separators (in stage coordinates)
          const pF1 = stageToScreen(-0.92, frontLineY);
          const pF2 = stageToScreen( 0.92, frontLineY);
          const pB1 = stageToScreen(-0.92, backLineY);
          const pB2 = stageToScreen( 0.92, backLineY);

          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(0.08 + 0.10*st.legibility,0,0.28)})`;
          ctx.lineWidth = 1.2;
          ctx.beginPath(); ctx.moveTo(pF1.x,pF1.y); ctx.lineTo(pF2.x,pF2.y); ctx.stroke();
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(0.05 + 0.06*stigma,0,0.18)})`;
          ctx.beginPath(); ctx.moveTo(pB1.x,pB1.y); ctx.lineTo(pB2.x,pB2.y); ctx.stroke();
        }

        // AUDIENCE ARCS (gaze field)
        if (ui.T_aud.checked){
          const arcs = st.audience;
          ctx.lineWidth = 1.0;
          for (let i=0;i<arcs.length;i++){
            const a = arcs[i].a + st.t*(0.02 + 0.05*gaze);
            const r = arcs[i].r;
            const rr = r * Math.min(W,H)*0.44;
            const span = (0.14 + 0.26*arcs[i].w) * (0.65 + 0.45*gaze);
            const alpha = clamp(0.015 + 0.08*gaze*(0.2 + arcs[i].w), 0, 0.22);

            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha})`;
            ctx.beginPath();
            ctx.arc(center.x, center.y, rr, a-span, a+span);
            ctx.stroke();
          }
        }

        // FRAME GRID (interpretive overlay)
        if (ui.T_frames.checked){
          const step = Math.floor(lerp(86, 38, clamp(C/2.6,0,1)));
          const skew = (ui.frame.value==="irony" ? 0.16 : 0.0) + (ui.frame.value==="conflict" ? 0.10 : 0.0);
          ctx.lineWidth = 1.0;
          const alpha = clamp(0.02 + 0.06*st.legibility + 0.04*(1-team) + 0.04*skew, 0, 0.20);
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha})`;

          for (let x=0; x<W; x+=step){
            const off = (x - W/2) * skew * 0.25;
            ctx.beginPath();
            ctx.moveTo(x, 0 + off);
            ctx.lineTo(x + off, H);
            ctx.stroke();
          }
          for (let y=0; y<H; y+=step){
            const off = (y - H/2) * skew * 0.25;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(W, y + off);
            ctx.stroke();
          }
        }

        // SCRIPTS (role-lines / expected sequences)
        if (ui.T_scripts.checked){
          const scripts = st.scripts;
          const alpha0 = clamp(0.03 + 0.08*(0.3+team) + 0.06*st.legibility, 0, 0.26);
          ctx.lineWidth = 1.2;
          for (let i=0;i<scripts.length;i++){
            const s0 = scripts[i];
            const a = (s0.p*tau) + st.t*(0.10 + 0.08*C);
            const x1 = s0.x + 0.10*Math.cos(a);
            const y1 = s0.y + 0.08*Math.sin(a);
            const x2 = s0.x - 0.10*Math.sin(a*0.7);
            const y2 = s0.y + 0.10*Math.cos(a*0.7);

            const p1 = stageToScreen(x1,y1);
            const p2 = stageToScreen(x2,y2);

            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha0 * (0.55 + 0.45*Math.sin(a+i))})`;
            ctx.beginPath();
            ctx.moveTo(p1.x,p1.y);
            ctx.lineTo(p2.x,p2.y);
            ctx.stroke();
          }
        }

        // LEAKS (backstage information escaping)
        const leakAlpha = clamp(0.02 + 0.18*stigma + 0.10*(1-st.face), 0, 0.40);
        for (let i=0;i<st.leaks.length;i++){
          const L = st.leaks[i];
          const p1 = stageToScreen(L.x1,L.y1);
          const p2 = stageToScreen(L.x2,L.y2);
          const a = clamp(leakAlpha * L.life, 0, inv ? 0.45 : 0.35);
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
          ctx.lineWidth = 1.1;

          // “thread” with slight jitter
          const j = 12 * (1-L.life) * (0.6 + 0.5*C);
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.quadraticCurveTo(
            (p1.x+p2.x)/2 + Math.sin(st.t*2.2+i)*j,
            (p1.y+p2.y)/2 + Math.cos(st.t*2.0+i)*j,
            p2.x, p2.y
          );
          ctx.stroke();
        }

        // SIGNS (sign-vehicles / tokens)
        ctx.lineWidth = 1.3;
        for (let i=0;i<st.signs.length;i++){
          const s = st.signs[i];
          const p = stageToScreen(s.x, s.y);
          const age = st.t - s.t;
          const a = clamp((0.10 + 0.16*s.w) * s.life * (0.75 + 0.55*st.legibility), 0, inv ? 0.60 : 0.45);
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;

          const r = 8 + 26*(1-s.life) + 10*s.w;
          if (s.type === 0){
            ctx.beginPath(); ctx.rect(p.x-r*0.6, p.y-r*0.6, r*1.2, r*1.2); ctx.stroke();
          } else if (s.type === 1){
            ctx.beginPath(); ctx.arc(p.x,p.y,r*0.72,0,tau); ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.moveTo(p.x-r, p.y);
            ctx.lineTo(p.x, p.y-r);
            ctx.lineTo(p.x+r, p.y);
            ctx.lineTo(p.x, p.y+r);
            ctx.closePath();
            ctx.stroke();
          }

          // small caption-line (script stub)
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a*0.65})`;
          ctx.beginPath();
          ctx.moveTo(p.x+r*0.85, p.y);
          ctx.lineTo(p.x+r*2.1,  p.y + Math.sin(age*1.2+i)*6);
          ctx.stroke();
        }

        // BREAKDOWNS (interaction order failure)
        for (let i=0;i<st.breaks.length;i++){
          const b = st.breaks[i];
          const p = stageToScreen(b.x,b.y);
          const a = clamp(0.22*b.life + 0.08*(1-st.face), 0, inv ? 0.75 : 0.55);
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
          ctx.lineWidth = 1.8;
          ctx.beginPath();
          ctx.moveTo(p.x-22, p.y-22); ctx.lineTo(p.x+22, p.y+22);
          ctx.moveTo(p.x+22, p.y-22); ctx.lineTo(p.x-22, p.y+22);
          ctx.stroke();
          ctx.lineWidth = 1.2;
          ctx.beginPath(); ctx.arc(p.x,p.y, 22 + 60*(1-b.life), 0, tau); ctx.stroke();
        }

        // ACTORS + MASKS + TEAM LINKS
        const actors = st.actors.slice().sort((a,b)=>a.y-b.y); // depth order
        const teamLinkA = clamp(0.02 + 0.10*team + 0.08*st.legibility, 0, 0.30);

        // team links (connect nearest neighbors with similar team value)
        ctx.lineWidth = 1.1;
        for (let i=0;i<actors.length;i++){
          const a1 = actors[i];
          let bestJ = -1;
          let bestD = 1e9;
          for (let j=0;j<actors.length;j++){
            if (i===j) continue;
            const a2 = actors[j];
            const dtm = Math.abs(a1.team - a2.team);
            if (dtm > 0.25) continue;
            const dx = a2.x-a1.x, dy=a2.y-a1.y;
            const d = dx*dx + dy*dy + dtm*0.25;
            if (d < bestD){ bestD = d; bestJ = j; }
          }
          if (bestJ>=0){
            const a2 = actors[bestJ];
            const p1 = stageToScreen(a1.x, a1.y);
            const p2 = stageToScreen(a2.x, a2.y);
            const a = teamLinkA * (0.55 + 0.45*(1-Math.abs(a1.team-a2.team)/0.25));
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(a,0,0.28)})`;
            ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
          }
        }

        // actor bodies + masks
        for (let i=0;i<actors.length;i++){
          const a = actors[i];
          const p = stageToScreen(a.x, a.y);

          // frontstage emphasis vs backstage (depth layering)
          const frontness = clamp01((a.y - backLineY) / (frontLineY - backLineY)); // approx
          const size = (6 + 14*frontness) * (0.85 + 0.25*(+ui.complex.value));
          const alpha = clamp(0.06 + 0.16*frontness + 0.12*(1-st.face), 0, inv ? 0.60 : 0.45);

          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha})`;
          ctx.lineWidth = 1.3;
          ctx.beginPath();
          ctx.arc(p.x, p.y, size, 0, tau);
          ctx.stroke();

          // role axis “collar”
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha*0.65})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, size*(1.35 + 0.60*a.role), 0, tau);
          ctx.stroke();

          // masks (polygonal mesh)
          if (ui.T_masks.checked){
            const k = a.mask.k;
            const rot = a.mask.rot + st.t*(0.22 + 0.18*a.script) + (ui.frame.value==="irony" ? Math.sin(st.t+i)*0.35 : 0);
            const mA = clamp(0.02 + 0.14*st.legibility + 0.10*(1-st.face) + 0.08*gaze, 0, inv ? 0.55 : 0.40);

            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${mA})`;
            ctx.lineWidth = 1.1;
            ctx.beginPath();
            for (let n=0;n<k;n++){
              const ang = rot + (n/k)*tau;
              const rr = size*(1.1 + 0.55*Math.sin(ang*1.7 + a.role*3.1));
              const x = p.x + Math.cos(ang)*rr;
              const y = p.y + Math.sin(ang)*rr;
              if (n===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.closePath();
            ctx.stroke();

            // mask “string” to center (audience reading)
            const cPull = clamp(0.03 + 0.12*gaze + 0.08*stigma, 0, 0.35);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${mA*0.65})`;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(center.x + Math.sin(st.t+i)*18*cPull, center.y + Math.cos(st.t+i)*18*cPull);
            ctx.stroke();
          }
        }

        // SPOTLIGHT (gaze)
        if (ui.T_spot.checked){
          ctx.globalCompositeOperation = 'source-over';
          const a = clamp(0.06 + 0.14*gaze + 0.12*st.tension, 0, inv ? 0.32 : 0.26);
          ctx.fillStyle = inv ? `rgba(0,0,0,${a})` : `rgba(255,255,255,${a})`;
          ctx.beginPath();
          ctx.arc(st.spotX, st.spotY, st.spotR, 0, tau);
          ctx.fill();

          // spotlight rim
          ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(0.05 + 0.10*gaze,0,0.28)})`;
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.arc(st.spotX, st.spotY, st.spotR, 0, tau);
          ctx.stroke();
        }

        ctx.globalCompositeOperation = 'source-over';
      }

      // UI actions
      $('invert').onclick = ()=> st.invert = !st.invert;
      $('pause').onclick  = ()=> st.paused = !st.paused;
      $('reseed').onclick = ()=> reseedCast();
      $('clear').onclick  = ()=>{
        st.signs.length = 0;
        st.leaks.length = 0;
        st.breaks.length = 0;
        updateCard("CLEARED EPISODES.");
      };
      $('reset').onclick  = ()=>{
        st.t=0; st.invert=false; st.paused=false; st.ox=0; st.oy=0; st.wheel=0; st.zoom=1.0;
        ui.timeScale.value=0.28;
        ui.complex.value=1.70;
        ui.depth.value=0.72;
        ui.trace.value=0.055;
        ui.zoom.value=1.15;
        ui.gaze.value=1.10;
        ui.team.value=0.95;
        ui.stigma.value=0.55;
        ui.leak.value=0.62;
        ui.repair.value=0.90;
        ui.T_prosc.checked=true;
        ui.T_aud.checked=true;
        ui.T_masks.checked=true;
        ui.T_scripts.checked=true;
        ui.T_frames.checked=true;
        ui.T_spot.checked=true;
        ui.frame.value="civil";
        syncVals();
        reseedCast();
      };

      addEventListener('keydown', (e)=>{
        if (e.key==='i' || e.key==='I') st.invert = !st.invert;
        if (e.key==='p' || e.key==='P') st.paused = !st.paused;
        if (e.key==='h' || e.key==='H'){
          const panel = $('panel');
          panel.style.display = (panel.style.display === 'none') ? '' : 'none';
        }
        if (e.code === 'Space'){
          e.preventDefault();
          st.holding = true;
        }
      });
      addEventListener('keyup', (e)=>{
        if (e.code === 'Space'){
          st.holding = false;
        }
      });

      addEventListener('wheel', (e)=>{
        const d = Math.max(-160, Math.min(160, e.deltaY));
        st.wheel += (-d/160) * 0.18;
        st.wheel = clamp(st.wheel, -0.85, 0.95);
      }, { passive:true });

      // ===== controller fix (no other behavior changes) =====
      const PANEL = document.getElementById('panel');
      const DOCK  = document.querySelector('.dock');
      function isUIEventTarget(t){
        if (!t) return false;
        if (PANEL && PANEL.contains(t)) return true;
        if (DOCK && DOCK.contains(t)) return true;
        return !!t.closest('input, button, select, textarea, label, a, [role="button"], .panel, .dock');
      }

      // pointer interaction
      function insideStage(sx,sy){
        const p = screenToStage(sx,sy);
        return (Math.abs(p.x) < 0.92 && Math.abs(p.y) < 0.72);
      }

      addEventListener('pointerdown', (e)=>{
        if (isUIEventTarget(e.target)) return; /* controller fix */

        st.mx=e.clientX; st.my=e.clientY;
        st.dragging=true;
        st.lastX=e.clientX; st.lastY=e.clientY;

        const p = screenToStage(e.clientX, e.clientY);
        const inStage = insideStage(e.clientX, e.clientY);

        // mode: if not in stage, pan; if shift, backstage; else frontstage episode
        if (!inStage || e.altKey){
          st.dragType = "pan";
        } else if (e.shiftKey){
          st.dragType = "episodeBack";
        } else {
          st.dragType = "episodeFront";
        }

        // click always drops sign-vehicle (type cycles by frame)
        const frame = ui.frame.value;
        const type =
          (frame==="status") ? 0 :
          (frame==="service") ? 1 :
          (frame==="conflict") ? 2 :
          (frame==="stigma") ? 2 :
          (frame==="institution") ? 0 :
          (frame==="irony") ? 1 :
          1;

        addSign(p.x, p.y, type);

        // click increases legibility (you produced a readable sign)
        const f = FRAMES[ui.frame.value] || FRAMES.civil;
        st.legibility = clamp01(st.legibility + 0.02*(0.7 + 0.6*f.legGain));

        // click under high gaze can raise tension (you’ve put yourself on display)
        const g = (+ui.gaze.value) * f.gaze;
        st.tension = clamp01(st.tension + 0.01*(0.5 + 0.7*g));
      });

      addEventListener('pointerup', ()=>{ st.dragging=false; st.dragType="pan"; });
      addEventListener('pointercancel', ()=>{ st.dragging=false; st.dragType="pan"; });

      addEventListener('pointermove', (e)=>{
        st.mx=e.clientX; st.my=e.clientY;

        if (!st.dragging) return;
        if (isUIEventTarget(e.target)) return; /* controller fix */

        const dx = e.clientX - st.lastX;
        const dy = e.clientY - st.lastY;
        st.lastX = e.clientX; st.lastY = e.clientY;

        if (st.dragType === "pan"){
          st.ox += dx; st.oy += dy;
          st.ox = clamp(st.ox, -W*0.60, W*0.60);
          st.oy = clamp(st.oy, -H*0.60, H*0.60);
          return;
        }

        const p = screenToStage(e.clientX, e.clientY);
        const v = Math.sqrt(dx*dx + dy*dy);
        const C = +ui.complex.value;
        const f = FRAMES[ui.frame.value] || FRAMES.civil;
        const gaze = (+ui.gaze.value) * f.gaze;
        const stigma = (+ui.stigma.value) * f.stigma;
        const team = (+ui.team.value) * f.team;
        const leak = (+ui.leak.value) * f.leak;

        // Episode mechanics
        if (st.dragType === "episodeFront"){
          // frontstage performance: raises legibility; can raise tension; can damage face if sloppy under gaze
          const legGain = (0.0008 + 0.0018*C) * f.legGain;
          st.legibility = clamp01(st.legibility + v*legGain);

          const tensGain = (0.0005 + 0.0016*C) * f.tensGain * (0.65 + 0.55*gaze) * (0.85 + 0.25*stigma);
          st.tension = clamp01(st.tension + v*tensGain);

          // face loss if tension high and team low
          const faceLoss = (0.0004 + 0.0012*C) * (0.5 + st.tension) * (1.05 - 0.35*team);
          st.face = clamp01(st.face - v*faceLoss);

          // emit occasional leak thread when performing fast under stigma
          const leakChance = (0.0000015 + 0.000004*C) * v * leak * (0.6 + 0.7*stigma);
          if (rnd01(st.seed + ((st.t*100000)|0) + st.leaks.length*7) < leakChance) addLeak();
        } else {
          // backstage prep: improves face and reduces tension BUT increases leak risk (secrets handled)
          const faceGain = (0.0006 + 0.0014*C) * (0.55 + 0.65*team);
          const tensDrop = (0.0007 + 0.0016*C) * (0.55 + 0.65*(+ui.repair.value));
          st.face = clamp01(st.face + v*faceGain);
          st.tension = clamp01(st.tension - v*tensDrop);

          const leakChance = (0.000002 + 0.000006*C) * v * leak * (0.55 + 0.75*(1-st.face));
          if (rnd01(st.seed + ((st.t*100000)|0) + st.leaks.length*11) < leakChance) addLeak();
        }

        // if face collapses mid-gesture, spawn breakdown
        if (st.face < 0.18 && st.tension > 0.78 && rnd01(st.seed + ((st.t*1000)|0)) < 0.02){
          addBreak(p.x,p.y);
        }
      });

      ui.frame.addEventListener('change', ()=>{
        updateCard();
      });

      // Loop
      let last = performance.now();
      function frame(now){
        const rawDt = Math.min(0.033, (now-last)/1000);
        last = now;

        const dt = rawDt * (+ui.timeScale.value) * (0.55 + 0.65*(+ui.complex.value));
        if (!st.paused){
          st.t += dt;
          step(dt);
        }
        draw();
        requestAnimationFrame(frame);
      }

      // Init
      reseedCast();
      requestAnimationFrame(frame);
    })();
  </script>
</body>
</html>
