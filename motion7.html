<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA // CAM SUBSTANCE (BIG VIZ + REACTIVE)</title>

<style>
:root{
  --bg:#000;
  --fg:rgba(255,255,255,.86);
  --muted:rgba(255,255,255,.52);
  --line:rgba(255,255,255,.14);
  --line2:rgba(255,255,255,.22);
  --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  --sans: Arial,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  --top:44px;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);overflow:hidden;font-family:var(--sans)}
#top{
  position:fixed;left:0;right:0;top:0;height:var(--top);
  display:flex;align-items:center;gap:8px;padding:6px 8px;
  background:rgba(0,0,0,.78);border-bottom:1px solid var(--line);
  z-index:50;
}
.btn,.chip{
  height:30px;display:inline-flex;align-items:center;gap:8px;
  padding:0 10px;border:1px solid var(--line2);
  background:rgba(0,0,0,.30);color:var(--fg);
  font:12px/1 var(--sans);white-space:nowrap;user-select:none;
}
.btn{cursor:pointer}
.btn:active{transform:translateY(1px)}
.k{font-family:var(--mono);opacity:.9}
.sep{flex:1}
input[type="range"]{width:120px;accent-color:#fff}

#stage{
  position:fixed;left:0;top:var(--top);
  width:100vw;height:calc(100vh - var(--top));
}
video{position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0}

/* VIZ modes */
#vizSmall{
  position:fixed;right:8px;bottom:8px;width:260px;height:160px;
  border:1px solid var(--line);background:#000;z-index:40;display:none;
}
#vizBig{
  position:fixed;left:0;top:var(--top);right:0;bottom:0;
  z-index:30;display:none;
}
#vizBig canvas{
  position:absolute;inset:0;width:100%;height:100%;
  background:#000;
}
#vizBig .label{
  position:absolute;left:8px;bottom:8px;
  border:1px solid var(--line);
  background:rgba(0,0,0,.55);
  padding:6px 8px;
  font:12px/1.2 var(--sans);
  color:var(--muted);
  z-index:31;
}
body.vizSmall #vizSmall{display:block}
body.vizBig #vizBig{display:block}

body.invert{filter:invert(1)}
</style>
</head>

<body>
<div id="top">
  <div class="chip k">KETADATA // CAM SUBSTANCE</div>

  <div class="btn" id="start">START CAM</div>
  <div class="btn" id="stopCam">STOP CAM</div>
  <div class="btn" id="run">STOP</div>
  <div class="btn" id="invert">INVERT</div>

  <div class="btn" id="vizToggle">VIZ: OFF</div>

  <div class="chip">FLOW <input id="flow" type="range" min="0" max="100" value="78"></div>
  <div class="chip">REACT <input id="react" type="range" min="0" max="100" value="86"></div>
  <div class="chip">TRAIL <input id="trail" type="range" min="0" max="100" value="82"></div>
  <div class="chip">THR <input id="thr" type="range" min="1" max="80" value="12"></div>
  <div class="chip">DENS <input id="dens" type="range" min="20000" max="160000" value="80000"></div>

  <div class="sep"></div>
  <div class="chip k" id="status">LOCAL</div>
</div>

<canvas id="stage"></canvas>

<!-- VIZ small -->
<canvas id="vizSmall" width="260" height="160"></canvas>

<!-- VIZ big (fullscreen viz layer) -->
<div id="vizBig">
  <canvas id="vizBigCanvas"></canvas>
  <div class="label">
    <div class="k">VIZ BIG</div>
    <div>Hotkeys: V = cycle viz • Esc = close big viz</div>
  </div>
</div>

<video id="video" playsinline muted autoplay></video>

<script>
(() => {
  const $ = id => document.getElementById(id);

  const stage = $("stage");
  const sctx = stage.getContext("2d",{alpha:false});

  const vizSmall = $("vizSmall");
  const vsctx = vizSmall.getContext("2d");

  const vizBigCanvas = $("vizBigCanvas");
  const vbctx = vizBigCanvas.getContext("2d");

  let W=0,H=0,DPR=1;
  function resizeStage(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    W = Math.max(1, Math.floor((stage.offsetWidth||1) * DPR));
    H = Math.max(1, Math.floor((stage.offsetHeight||1) * DPR));
    stage.width=W; stage.height=H;
  }

  function resizeVizBig(){
    const w = Math.max(1, Math.floor(innerWidth * DPR));
    const h = Math.max(1, Math.floor((innerHeight - parseInt(getComputedStyle(document.documentElement).getPropertyValue("--top")||"44",10)) * DPR));
    vizBigCanvas.width = w;
    vizBigCanvas.height = h;
  }

  function resizeAll(){
    resizeStage();
    resizeVizBig();
  }

  addEventListener("resize", resizeAll);
  addEventListener("orientationchange", () => setTimeout(resizeAll, 60));
  setTimeout(resizeAll, 0);

  const STATE={
    running:true,
    flow:0.78,
    react:0.86,
    trail:0.82,
    thr:12,
    dens:80000,
    camOn:false,
    vizMode:0 // 0 off, 1 small, 2 big
  };

  const setStatus = s => ($("status").textContent = s);

  $("invert").onclick = () => document.body.classList.toggle("invert");

  function applyVizMode(){
    document.body.classList.toggle("vizSmall", STATE.vizMode===1);
    document.body.classList.toggle("vizBig", STATE.vizMode===2);
    const label = STATE.vizMode===0 ? "VIZ: OFF" : (STATE.vizMode===1 ? "VIZ: SMALL" : "VIZ: BIG");
    $("vizToggle").textContent = label;
    if(STATE.vizMode===2) setTimeout(resizeVizBig, 40);
  }

  $("vizToggle").onclick = () => {
    STATE.vizMode = (STATE.vizMode + 1) % 3;
    applyVizMode();
  };

  $("flow").oninput  = e => STATE.flow  = (+e.target.value)/100;
  $("react").oninput = e => STATE.react = (+e.target.value)/100;
  $("trail").oninput = e => STATE.trail = (+e.target.value)/100;
  $("thr").oninput   = e => STATE.thr   = (+e.target.value)|0;
  $("dens").oninput  = e => STATE.dens  = (+e.target.value)|0;

  $("run").onclick = () => {
    STATE.running = !STATE.running;
    $("run").textContent = STATE.running ? "STOP" : "RUN";
  };

  addEventListener("keydown",(e)=>{
    if(e.repeat) return;
    const k = e.key.toLowerCase();
    if(k==="v"){
      STATE.vizMode = (STATE.vizMode + 1) % 3;
      applyVizMode();
    }
    if(k==="escape" && STATE.vizMode===2){
      STATE.vizMode = 0;
      applyVizMode();
    }
  });

  // ===== CAM + MOTION FIELD =====
  const video = $("video");
  let stream=null;

  const DET_W = 180, DET_H = 102; // a bit higher for more detailed substance
  const det = document.createElement("canvas");
  det.width=DET_W; det.height=DET_H;
  const dctx = det.getContext("2d",{willReadFrequently:true});

  let VX = new Float32Array(DET_W*DET_H);
  let VY = new Float32Array(DET_W*DET_H);
  let prevLuma = null;

  // for reactivity: energy estimate
  let energy=0, energySmooth=0;

  function stopCam(){
    if(stream){
      try{ for(const t of stream.getTracks()) t.stop(); }catch(_){}
    }
    stream=null;
    STATE.camOn=false;
    prevLuma=null;
    VX.fill(0); VY.fill(0);
    energy=0; energySmooth=0;
    setStatus("LOCAL");
  }

  async function startCam(){
    if(STATE.camOn) return;
    setStatus("CAM REQUEST");
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:"user", width:{ideal:1280}, height:{ideal:720} },
        audio:false
      });
      video.srcObject = stream;
      await video.play();
      STATE.camOn=true;
      prevLuma=null;
      setStatus("CAM ON");
    }catch(e){
      setStatus("CAM BLOCKED");
    }
  }

  $("start").onclick = startCam;
  $("stopCam").onclick = stopCam;

  // update velocity field from diff gradients + inject
  function updateField(){
    if(!STATE.camOn){
      energy=0;
      return null;
    }

    dctx.save();
    dctx.scale(-1,1);
    dctx.drawImage(video, -DET_W, 0, DET_W, DET_H);
    dctx.restore();

    const data = dctx.getImageData(0,0,DET_W,DET_H).data;

    const cur = new Uint8Array(DET_W*DET_H);
    let p=0;
    for(let i=0;i<data.length;i+=4){
      const r=data[i], g=data[i+1], b=data[i+2];
      cur[p++] = (r*0.2126 + g*0.7152 + b*0.0722) | 0;
    }

    if(!prevLuma){
      prevLuma = cur;
      energy=0;
      return null;
    }

    const thr = STATE.thr|0;

    // inertia
    const decay = 0.86 + 0.12*STATE.flow; // more flow => longer substance memory
    for(let i=0;i<VX.length;i++){
      VX[i] *= decay;
      VY[i] *= decay;
    }

    // diff map
    const diff = new Uint8Array(DET_W*DET_H);
    let total=0;

    for(let i=0;i<diff.length;i++){
      const d = Math.abs(cur[i] - prevLuma[i]);
      prevLuma[i] = cur[i];
      diff[i] = d;
      if(d>thr) total += (d-thr);
    }

    // energy normalized (0..~1.5)
    const norm = (DET_W*DET_H) * 8.5;
    energy = Math.max(0, Math.min(1.6, total / norm));

    // injection strength scales with reactivity + energy
    const baseInject = 0.0022 + 0.010*STATE.flow;
    const boost = 1.0 + 3.0*(STATE.react*energy);
    const inject = baseInject * boost;

    // gradient -> direction
    for(let y=1;y<DET_H-1;y++){
      let row = y*DET_W;
      for(let x=1;x<DET_W-1;x++){
        const i = row + x;
        const d = diff[i];
        if(d < thr) continue;

        const gx = (diff[i+1] - diff[i-1]);
        const gy = (diff[i+DET_W] - diff[i-DET_W]);
        const mag = Math.hypot(gx,gy) + 1e-6;

        // use negative gradient sometimes to create “swirl” around edges
        const sign = ((x+y)&1) ? 1 : -1;
        const ux = (gx/mag)*sign;
        const uy = (gy/mag)*sign;

        const w = (d - thr) / (80 - thr + 1e-6);
        const s = inject * (0.30 + 2.8*w);

        VX[i] += ux * s;
        VY[i] += uy * s;
      }
    }

    return diff;
  }

  // render viz (diff mask + sparse vectors)
  function drawViz(diff){
    if(STATE.vizMode===0 || !diff) return;

    const ctx = (STATE.vizMode===1) ? vsctx : vbctx;

    const outW = (STATE.vizMode===1) ? vizSmall.width : vizBigCanvas.width;
    const outH = (STATE.vizMode===1) ? vizSmall.height : vizBigCanvas.height;

    ctx.fillStyle="#000";
    ctx.fillRect(0,0,outW,outH);

    // diff mask
    const img = ctx.createImageData(DET_W, DET_H);
    for(let i=0;i<diff.length;i++){
      const v = diff[i];
      const o=i*4;
      img.data[o]=255; img.data[o+1]=255; img.data[o+2]=255;
      img.data[o+3]=Math.max(0, Math.min(255, (v - STATE.thr) * 9));
    }
    const tmp=document.createElement("canvas");
    tmp.width=DET_W; tmp.height=DET_H;
    tmp.getContext("2d").putImageData(img,0,0);

    ctx.imageSmoothingEnabled=false;
    ctx.globalAlpha=1;
    ctx.drawImage(tmp, 0,0, DET_W,DET_H, 0,0, outW,outH);

    // vectors
    ctx.strokeStyle="rgba(255,255,255,.55)";
    ctx.lineWidth=1;

    const step = (STATE.vizMode===1) ? 10 : 8;
    const sx = outW/DET_W, sy = outH/DET_H;

    for(let y=0;y<DET_H;y+=step){
      for(let x=0;x<DET_W;x+=step){
        const i=y*DET_W+x;
        const vx=VX[i]*2200*(1+energySmooth*1.2);
        const vy=VY[i]*2200*(1+energySmooth*1.2);
        const px=x*sx, py=y*sy;
        ctx.beginPath();
        ctx.moveTo(px,py);
        ctx.lineTo(px+vx, py+vy);
        ctx.stroke();
      }
    }

    // energy bar
    const e = Math.max(0, Math.min(1, energySmooth/1.1));
    ctx.fillStyle="rgba(255,255,255,.18)";
    ctx.fillRect(8, outH-12, outW-16, 4);
    ctx.fillStyle="rgba(255,255,255,.86)";
    ctx.fillRect(8, outH-12, (outW-16)*e, 4);

    ctx.strokeStyle="rgba(255,255,255,.22)";
    ctx.strokeRect(0.5,0.5,outW-1,outH-1);
  }

  // ===== PARTICLES ADVECTED BY FIELD =====
  let P=[];
  function reseed(n){
    P.length=0;
    for(let i=0;i<n;i++){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()-.5)*0.25,
        vy:(Math.random()-.5)*0.25,
        a:Math.random()
      });
    }
  }
  reseed(STATE.dens);

  function ensureDensity(){
    const n=STATE.dens|0;
    if(P.length===n) return;
    if(P.length>n){ P.length=n; return; }
    while(P.length<n){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()-.5)*0.25,
        vy:(Math.random()-.5)*0.25,
        a:Math.random()
      });
    }
  }

  function sampleField(x,y){
    const fx = (x/W) * (DET_W-1);
    const fy = (y/H) * (DET_H-1);
    const x0 = fx|0, y0 = fy|0;
    const x1 = Math.min(DET_W-1, x0+1);
    const y1 = Math.min(DET_H-1, y0+1);
    const tx = fx - x0;
    const ty = fy - y0;

    const i00 = y0*DET_W+x0;
    const i10 = y0*DET_W+x1;
    const i01 = y1*DET_W+x0;
    const i11 = y1*DET_W+x1;

    const vx0 = VX[i00]*(1-tx) + VX[i10]*tx;
    const vx1 = VX[i01]*(1-tx) + VX[i11]*tx;
    const vy0 = VY[i00]*(1-tx) + VY[i10]*tx;
    const vy1 = VY[i01]*(1-tx) + VY[i11]*tx;

    return {
      vx: vx0*(1-ty) + vx1*ty,
      vy: vy0*(1-ty) + vy1*ty
    };
  }

  // ===== LOOP =====
  let last=performance.now();
  function frame(t){
    requestAnimationFrame(frame);
    if(!STATE.running) return;

    resizeAll();
    ensureDensity();

    const diff = updateField();

    // smooth energy for reactivity
    energySmooth = energySmooth*0.88 + energy*0.12;

    drawViz(diff);

    const dt = Math.min(32, t-last); last=t;

    // trails (reactive: more motion => less clearing => brighter)
    const baseClear = 0.22 - 0.20*STATE.trail; // 0.02..0.22
    const reactiveClear = Math.max(0.012, baseClear - (STATE.react*energySmooth*0.06));
    sctx.globalCompositeOperation="source-over";
    sctx.fillStyle=`rgba(0,0,0,${reactiveClear})`;
    sctx.fillRect(0,0,W,H);

    // brightness + point weight (reactive)
    sctx.globalCompositeOperation="lighter";
    const alpha = Math.min(0.95, 0.18 + 0.18*STATE.flow + 0.55*(STATE.react*energySmooth));
    sctx.fillStyle=`rgba(255,255,255,${alpha})`;

    // fieldScale boosted by energy + react
    const fieldScale = (0.9 + 3.6*STATE.flow) * (2200 + 2600*(STATE.react*energySmooth));

    // jitter also boosted (gives “liquid boil” during motion)
    const jitter = (0.010 + 0.070*STATE.flow) * (1 + 5.0*(STATE.react*energySmooth));

    // draw size slightly increases with energy
    const px = (energySmooth > 0.35) ? 2 : 1;

    for(const p of P){
      const f = sampleField(p.x, p.y);

      // stronger coupling to field
      p.vx = p.vx*0.90 + f.vx*fieldScale + (Math.random()-0.5)*jitter;
      p.vy = p.vy*0.90 + f.vy*fieldScale + (Math.random()-0.5)*jitter;

      p.x = (p.x + p.vx*dt + W) % W;
      p.y = (p.y + p.vy*dt + H) % H;

      sctx.fillRect(p.x, p.y, px, px);
    }

    sctx.globalCompositeOperation="source-over";

    if(STATE.camOn) setStatus(energySmooth>0.08 ? "CAM + MOTION" : "CAM (LOW MOTION)");
    else setStatus("LOCAL");
  }
  requestAnimationFrame(frame);

  addEventListener("beforeunload", () => { try{ stopCam(); }catch(_){} });

  applyVizMode();
})();
</script>

<!--
AE: KETADATA
EE: CAM_SUBSTANCE_BIG_VIZ_REACTIVE
WB: SINGLE_FILE_HTML
FILE_ID: KETA_CAM_SUBSTANCE_BIGVIZ_REACT_v1
ROOM_ID: BASE
VERSION: 1
UPDATED_AT: 2026-01-08
CHANGELOG:
- v1: VIZ mode cycles OFF/SMALL/BIG (big is full stage layer); particles more reactive via motion-energy coupling to fieldScale/alpha/trails/jitter
-->
</body>
</html>
