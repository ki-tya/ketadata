<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA — BORGES INTERFACE (LABYRINTH INDEX / INFINITE SHELF)</title>
  <style>
    :root{
      --bg:#000;
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.56);
      --hair:rgba(255,255,255,.14);
      --panel:rgba(0,0,0,.55);
      --panel2:rgba(255,255,255,.03);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background:var(--bg);
      color:var(--fg);
      font-family: Arial, Helvetica, sans-serif;
    }
    canvas{ position:fixed; inset:0; width:100vw; height:100vh; display:block; }

    /* HUD */
    .hud{
      position:fixed; left:18px; top:16px;
      user-select:none; pointer-events:none;
      mix-blend-mode:screen;
    }
    .brand{
      font-weight:900;
      letter-spacing:.18em;
      text-transform:uppercase;
      font-size:15px;
      text-shadow:0 0 18px rgba(255,255,255,.18);
    }
    .sub{
      margin-top:4px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:var(--muted);
      line-height:1.25;
    }

    /* Dock */
    .dock{
      position:fixed; left:18px; bottom:16px;
      display:flex; flex-wrap:wrap;
      gap:10px; align-items:center;
      pointer-events:auto;
    }
    .btn{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.22);
      color:rgba(255,255,255,.86);
      padding:10px 12px;
      border-radius:10px;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{ background:rgba(255,255,255,.10); border-color:rgba(255,255,255,.36); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }

    /* Panel */
    .panel{
      position:fixed; right:16px; top:16px;
      width:min(720px, calc(100vw - 32px));
      max-height: calc(100vh - 32px);
      overflow:auto;
      border:1px solid rgba(255,255,255,.18);
      background:var(--panel);
      backdrop-filter: blur(10px);
      border-radius:14px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset, 0 16px 50px rgba(0,0,0,.65);
    }
    .panelHeader{
      position:sticky; top:0;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.72);
      backdrop-filter: blur(10px);
      display:flex; justify-content:space-between; align-items:center;
      z-index:10;
    }
    .title{
      font-weight:900;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      color:rgba(255,255,255,.86);
    }
    .hint{
      font-size:11px;
      letter-spacing:.08em;
      color:rgba(255,255,255,.55);
      text-align:right;
      line-height:1.2;
    }
    .panelBody{ padding:10px 12px 14px; display:flex; flex-direction:column; gap:10px; }

    .block{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      overflow:hidden;
      background:var(--panel2);
    }
    .block h3{
      margin:0;
      padding:10px 10px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:rgba(255,255,255,.75);
      border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      display:flex; justify-content:space-between; align-items:center;
      gap:10px;
    }
    .pill{
      font-size:10px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:rgba(255,255,255,.62);
      border:1px solid rgba(255,255,255,.18);
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.20);
      white-space:nowrap;
    }
    .rows{ padding:10px; display:flex; flex-direction:column; gap:10px; }
    .row{
      display:grid;
      grid-template-columns: 220px 1fr 70px;
      gap:10px;
      align-items:center;
    }
    .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:rgba(255,255,255,.62);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    input[type="range"]{ width:100%; accent-color: rgba(255,255,255,.92); }
    .val{ font-variant-numeric: tabular-nums; font-size:11px; color:rgba(255,255,255,.76); text-align:right; }

    .grid2{
      display:grid;
      grid-template-columns: 1.05fr 0.95fr;
      gap:10px;
    }

    .searchRow{
      padding:10px;
      display:flex;
      gap:10px;
      align-items:center;
      border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
    }
    input[type="text"]{
      width:100%;
      border:1px solid rgba(255,255,255,.16);
      border-radius:12px;
      background:rgba(0,0,0,.50);
      color:rgba(255,255,255,.86);
      padding:10px 10px;
      font-family: Arial, Helvetica, sans-serif;
      font-size:12px;
      outline:none;
    }
    input[type="text"]:focus{ border-color: rgba(255,255,255,.32); }

    /* Thread + shelf */
    .thread{
      padding:10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
    }
    .crumb{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
    }
    .crumb:hover{ background:rgba(255,255,255,.07); border-color:rgba(255,255,255,.28); }
    .crumb .k{
      font-size:10px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:rgba(255,255,255,.72);
    }
    .crumb .t{
      font-size:10px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:rgba(255,255,255,.60);
      max-width:220px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    .shelf{
      padding:10px;
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap:10px;
    }
    @media (max-width: 900px){
      .grid2{ grid-template-columns: 1fr; }
      .shelf{ grid-template-columns: 1fr; }
    }
    .card{
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      background:rgba(0,0,0,.42);
      padding:10px 10px 12px;
      cursor:pointer;
      transition: transform .08s ease, border-color .12s ease, background .12s ease;
    }
    .card:hover{
      transform: translateY(-1px);
      border-color: rgba(255,255,255,.28);
      background: rgba(0,0,0,.50);
    }
    .cardTop{
      display:flex; justify-content:space-between; align-items:flex-start;
      gap:10px;
    }
    .cardTitle{
      font-weight:900;
      letter-spacing:.12em;
      text-transform:uppercase;
      font-size:11px;
      color:rgba(255,255,255,.86);
      line-height:1.2;
    }
    .badge{
      font-size:10px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:rgba(255,255,255,.62);
      border:1px solid rgba(255,255,255,.18);
      padding:4px 8px;
      border-radius:999px;
      background:rgba(255,255,255,.03);
      white-space:nowrap;
    }
    .excerpt{
      margin-top:8px;
      font-size:12px;
      line-height:1.35;
      color:rgba(255,255,255,.78);
    }
    .tags{
      margin-top:10px;
      display:flex; flex-wrap:wrap; gap:6px;
    }
    .tag{
      font-size:10px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:rgba(255,255,255,.62);
      border:1px solid rgba(255,255,255,.14);
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.20);
    }

    .status{
      padding:10px;
      border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .mono{
      font-variant-numeric: tabular-nums;
      letter-spacing:.10em;
      text-transform:uppercase;
      font-size:10px;
      color:rgba(255,255,255,.70);
      line-height:1.35;
    }
    .bar{
      width:200px; height:10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.04);
      overflow:hidden;
    }
    .barFill{
      height:100%;
      width:40%;
      background:rgba(255,255,255,.55);
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="brand">KETADATA</div>
    <div class="sub">BORGES MODE · LABYRINTH INDEX · MIRRORS · FALSE DOORS · ARIADNE THREAD</div>
  </div>

  <div class="dock">
    <button class="btn" id="invert">INVERT</button>
    <button class="btn" id="pause">PAUSE</button>
    <button class="btn" id="detour">DETOUR</button>
    <button class="btn" id="cutThread">CUT THREAD</button>
    <button class="btn" id="reseed">RESEED</button>
    <button class="btn" id="reset">RESET</button>
  </div>

  <div class="panel" id="panel">
    <div class="panelHeader">
      <div class="title">LABYRINTH INDEX</div>
      <div class="hint">
        CLICK CARD = ENTER NODE · ALT+CLICK = MIRROR<br/>
        SHIFT+CLICK CARD = FALSE DOOR (REDIRECT)<br/>
        DRAG = PAN · SCROLL = ZOOM · [H] PANEL
      </div>
    </div>

    <div class="panelBody">
      <div class="block">
        <h3>Generator <span class="pill">parameters</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">time scale (slow-mo)</div>
            <input id="timeScale" type="range" min="0.000" max="2.000" step="0.001" value="0.45">
            <div class="val" id="timeScaleV">0.450</div>
          </div>
          <div class="row">
            <div class="label">branching factor</div>
            <input id="branch" type="range" min="2" max="10" step="1" value="6">
            <div class="val" id="branchV">6</div>
          </div>
          <div class="row">
            <div class="label">recursion depth</div>
            <input id="depth" type="range" min="1" max="9" step="1" value="4">
            <div class="val" id="depthV">4</div>
          </div>
          <div class="row">
            <div class="label">alias rate (mirrors)</div>
            <input id="alias" type="range" min="0" max="1" step="0.01" value="0.28">
            <div class="val" id="aliasV">0.28</div>
          </div>
          <div class="row">
            <div class="label">false doors (redirects)</div>
            <input id="falseDoor" type="range" min="0" max="1" step="0.01" value="0.18">
            <div class="val" id="falseDoorV">0.18</div>
          </div>
          <div class="row">
            <div class="label">entropy (index mess)</div>
            <input id="entropy" type="range" min="0" max="1" step="0.01" value="0.36">
            <div class="val" id="entropyV">0.36</div>
          </div>
          <div class="row">
            <div class="label">density (visual)</div>
            <input id="density" type="range" min="0.30" max="2.20" step="0.01" value="1.10">
            <div class="val" id="densityV">1.10</div>
          </div>
          <div class="row">
            <div class="label">trace (residue)</div>
            <input id="trace" type="range" min="0.000" max="0.22" step="0.001" value="0.050">
            <div class="val" id="traceV">0.050</div>
          </div>
        </div>

        <div class="searchRow">
          <input id="q" type="text" placeholder="SEARCH (query becomes a corridor) — ex: VAULT MIRROR INDEX / TEMPLE THREAD / CINEMA LOOP" />
          <button class="btn" id="searchBtn">SEARCH</button>
        </div>

        <div class="status">
          <div class="mono" id="statLeft">—</div>
          <div style="display:flex; align-items:center; gap:10px;">
            <div class="mono">LABYRINTH PRESSURE</div>
            <div class="bar"><div class="barFill" id="pressFill"></div></div>
            <div class="mono" id="pressVal">0%</div>
          </div>
        </div>
      </div>

      <div class="grid2">
        <div class="block">
          <h3>Ariadne Thread <span class="pill">breadcrumb</span></h3>
          <div class="thread" id="thread"></div>
        </div>

        <div class="block">
          <h3>Infinite Shelf <span class="pill">entries</span></h3>
          <div class="shelf" id="shelf"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha:false });

      let W=0, H=0, DPR=Math.min(2, window.devicePixelRatio||1);
      function resize(){
        W=innerWidth; H=innerHeight;
        canvas.width = Math.floor(W*DPR);
        canvas.height = Math.floor(H*DPR);
        canvas.style.width = W+'px';
        canvas.style.height = H+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize);
      resize();

      const $ = (id)=>document.getElementById(id);

      const ui = {
        timeScale: $('timeScale'),
        branch: $('branch'),
        depth: $('depth'),
        alias: $('alias'),
        falseDoor: $('falseDoor'),
        entropy: $('entropy'),
        density: $('density'),
        trace: $('trace'),
        q: $('q')
      };
      const vv = {
        timeScaleV: $('timeScaleV'),
        branchV: $('branchV'),
        depthV: $('depthV'),
        aliasV: $('aliasV'),
        falseDoorV: $('falseDoorV'),
        entropyV: $('entropyV'),
        densityV: $('densityV'),
        traceV: $('traceV')
      };

      function sync(){
        vv.timeScaleV.textContent = (+ui.timeScale.value).toFixed(3);
        vv.branchV.textContent = ui.branch.value;
        vv.depthV.textContent = ui.depth.value;
        vv.aliasV.textContent = (+ui.alias.value).toFixed(2);
        vv.falseDoorV.textContent = (+ui.falseDoor.value).toFixed(2);
        vv.entropyV.textContent = (+ui.entropy.value).toFixed(2);
        vv.densityV.textContent = (+ui.density.value).toFixed(2);
        vv.traceV.textContent = (+ui.trace.value).toFixed(3);
      }
      Object.values(ui).forEach(el=>{
        if (!el || !el.addEventListener) return;
        el.addEventListener('input', sync);
        el.addEventListener('change', sync);
      });
      sync();

      function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
      function lerp(a,b,t){ return a + (b-a)*t; }
      function hash32(n){
        n = (n ^ (n >>> 16)) >>> 0;
        n = Math.imul(n, 2246822519) >>> 0;
        n = (n ^ (n >>> 13)) >>> 0;
        n = Math.imul(n, 3266489917) >>> 0;
        n = (n ^ (n >>> 16)) >>> 0;
        return n >>> 0;
      }
      function rnd01(n){ return hash32(n) / 4294967295; }

      const st = {
        t:0,
        invert:false,
        paused:false,
        seed:(Math.random()*1e9)|0,
        ox:0, oy:0,
        drag:false,
        lx:0, ly:0,
        wheel:0,
        zoom:1.0,
        pressure:0.0,
        queryBias: "",
      };

      // ===== Labyrinth data model =====
      // Node: {id, title, tags[], excerpt, refs[], mirrorOf?, falseTo?}
      const TAGS = [
        "STUDIO","LAB","TEMPLE","VAULT","CINEMA","LIBRARY","OBSERVATORY","LOBBY","STORE","MAP","DEX","NOTES",
        "THREAD","MIRROR","CATALOG","INDEX","DOOR","CORRIDOR","ARCHIVE","ENGINE","RITUAL","GRID","SIGNAL"
      ];
      const TITLES = [
        "CATALOG OF UNNAMED ROOMS",
        "INDEX OF SHADOWED OBJECTS",
        "MIRROR OF A MIRROR",
        "THE HALLWAY THAT RETURNS",
        "FALSE DOOR TO A TRUE VAULT",
        "THREAD THROUGH THE CINEMA",
        "MAP OF THE MAP",
        "THE ARCHIVE THAT ARCHIVES ITSELF",
        "NOTES ON THE LABYRINTH'S SHAPE",
        "THE OBSERVATORY IN THE BASEMENT",
        "A LIST OF LISTS",
        "THE LIBRARY OF QUERIES",
        "THE DEX OF DUPLICATES",
        "THE TEMPLE OF SMALL RULES",
        "THE LOBBY THAT REWRITES YOU",
      ];
      const EXCERPTS = [
        "A shelf entry that seems to describe another shelf entry; the difference is only in the indexing.",
        "You find the same corridor again, but tagged with a new name, and therefore it is new.",
        "The catalog is not a record of objects; it is an engine that manufactures adjacency.",
        "A door labeled EXIT returns you to the beginning with additional annotations.",
        "A note insists the true map is the act of mapping; every line is a claim.",
        "A list of rooms that contains the room you are currently in, with a footnote that contradicts itself.",
        "The thread is not guidance; it is evidence. Cut it and the labyrinth changes character.",
        "An index of indices: each entry points to the tag that produced it.",
        "The mirror does not reflect; it aliases. The same object under a different filing system.",
        "A detour that becomes the main corridor by sheer repetition.",
      ];

      const graph = new Map(); // id -> node
      let currentId = "ROOT";
      let thread = []; // array of ids (Ariadne)
      let shelf = [];  // array of ids visible
      let redirects = new Map(); // false doors map id -> id

      function normalizeQuery(q){
        return (q||"").trim().toUpperCase().replace(/\s+/g," ");
      }

      function makeId(seed, salt){
        const n = hash32((seed ^ hash32(salt)) >>> 0);
        return "N" + n.toString(16).padStart(8,'0').toUpperCase();
      }

      function pick(arr, s){
        return arr[Math.floor(rnd01(s) * arr.length)];
      }

      function tagSet(seed, k, biasTokens){
        const out = new Set();
        const base = 2 + Math.floor(rnd01(seed^0xabc) * (k+1));
        for (let i=0;i<base;i++){
          out.add(pick(TAGS, seed + i*97));
        }
        // bias: if query contains tokens matching TAGS, inject them
        if (biasTokens && biasTokens.length){
          for (const t of biasTokens){
            if (TAGS.includes(t)) out.add(t);
          }
        }
        return [...out].slice(0, 7);
      }

      function buildNode(seed, depth, biasTokens){
        const id = makeId(seed, depth*131 + 17);
        if (graph.has(id)) return id;

        const title = pick(TITLES, seed + 11);
        const excerpt = pick(EXCERPTS, seed + 29);

        const tags = tagSet(seed, 5, biasTokens);

        const node = {
          id,
          title,
          excerpt,
          tags,
          refs: [],
          mirrorOf: null,
          falseTo: null,
          depth
        };
        graph.set(id, node);
        return id;
      }

      function pressureMetric(){
        // pressure increases with depth, branching, alias, false doors, entropy
        const d = +ui.depth.value / 9;
        const b = (+ui.branch.value - 2) / 8;
        const a = +ui.alias.value;
        const f = +ui.falseDoor.value;
        const e = +ui.entropy.value;
        const p = clamp(0.25*d + 0.20*b + 0.20*a + 0.15*f + 0.20*e, 0, 1);
        st.pressure = p;
        $('pressFill').style.width = Math.round(p*100) + "%";
        $('pressVal').textContent = Math.round(p*100) + "%";
        $('statLeft').textContent =
          `NODE ${currentId} · THREAD ${thread.length} · GRAPH ${graph.size} · REDIRECTS ${redirects.size}`;
      }

      function ensureNeighborhood(centerId){
        const center = graph.get(centerId);
        if (!center) return;

        const branch = (+ui.branch.value)|0;
        const depthLimit = (+ui.depth.value)|0;
        const aliasRate = +ui.alias.value;
        const falseRate = +ui.falseDoor.value;
        const entropy = +ui.entropy.value;

        const q = st.queryBias;
        const biasTokens = q ? q.split(" ").filter(Boolean).slice(0,4) : [];

        // create outgoing refs if missing or if entropy suggests mutation
        const want = branch;
        const mutate = rnd01(st.seed + hash32(centerId) + ((st.t*1000)|0)) < (entropy*0.08);

        if (center.refs.length < want || mutate){
          // (re)populate refs
          const refs = [];
          for (let i=0;i<want;i++){
            const s = hash32(st.seed + hash32(centerId) + i*997);
            const nextDepth = Math.min(depthLimit, (center.depth||0) + 1);

            // alias: point to an existing node sometimes
            const doAlias = graph.size > 6 && (rnd01(s^0x11) < aliasRate);
            let nid;
            if (doAlias){
              const arr = [...graph.keys()];
              nid = arr[Math.floor(rnd01(s^0x33)*arr.length)];
            } else {
              nid = buildNode(s, nextDepth, biasTokens);
            }

            // false doors: create a redirect mapping
            if (rnd01(s^0x55) < falseRate){
              // redirect to a different node
              const arr = [...graph.keys()];
              const target = arr[Math.floor(rnd01(s^0x77)*arr.length)];
              redirects.set(nid, target);
              const n = graph.get(nid);
              if (n) n.falseTo = target;
            }

            // mirror: create mirrorOf relation (aliasing semantics)
            if (rnd01(s^0x99) < aliasRate*0.8 && graph.size > 6){
              const arr = [...graph.keys()];
              const base = arr[Math.floor(rnd01(s^0xbb)*arr.length)];
              const n = graph.get(nid);
              if (n && base !== nid) n.mirrorOf = base;
            }

            refs.push(nid);
          }
          center.refs = refs;
        }

        // Expand one step further (lightweight) up to depth limit
        for (const rid of center.refs){
          const n = graph.get(rid);
          if (!n) continue;
          if ((n.depth||0) < depthLimit && n.refs.length === 0){
            // create minimal refs
            const mini = Math.max(2, Math.floor(branch*0.45));
            for (let k=0;k<mini;k++){
              const s = hash32(st.seed + hash32(rid) + k*313);
              const nid = buildNode(s, Math.min(depthLimit, (n.depth||0)+1), biasTokens);
              n.refs.push(nid);
            }
          }
        }
      }

      function renderThread(){
        const el = $('thread');
        el.innerHTML = "";
        for (let i=0;i<thread.length;i++){
          const id = thread[i];
          const node = graph.get(id);
          const c = document.createElement('div');
          c.className = 'crumb';
          const k = document.createElement('div');
          k.className = 'k';
          k.textContent = String(i+1).padStart(2,'0');
          const t = document.createElement('div');
          t.className = 't';
          t.textContent = node ? node.title : id;
          c.appendChild(k); c.appendChild(t);
          c.onclick = () => {
            // jump to this point (thread is navigation)
            currentId = id;
            thread = thread.slice(0, i+1);
            refreshShelf();
          };
          el.appendChild(c);
        }
      }

      function scoreNode(node, qTokens){
        // Simple scoring: tag/title/excerpt matches + mirror/false door spice
        if (!node) return 0;
        if (!qTokens || qTokens.length===0) return 0;
        const hay = (node.title + " " + node.excerpt + " " + node.tags.join(" ")).toUpperCase();
        let s=0;
        for (const t of qTokens){
          if (!t) continue;
          if (hay.includes(t)) s += 1.0;
        }
        if (node.mirrorOf) s += 0.15;
        if (node.falseTo) s += 0.10;
        return s;
      }

      function buildShelf(){
        const center = graph.get(currentId);
        if (!center) return [];

        const ids = [];
        // prioritize direct refs
        for (const r of center.refs) ids.push(r);

        // add nearby: refs of refs (for “library feel”)
        for (const r of center.refs){
          const n = graph.get(r);
          if (!n) continue;
          for (const rr of n.refs.slice(0,2)) ids.push(rr);
        }

        // dedupe
        const uniq = [];
        const seen = new Set();
        for (const id of ids){
          if (seen.has(id)) continue;
          seen.add(id);
          uniq.push(id);
        }

        // entropy injects “wrong shelf” items
        const e = +ui.entropy.value;
        const extra = Math.floor(lerp(0, 8, e));
        if (extra > 0 && graph.size > 10){
          const arr = [...graph.keys()];
          for (let i=0;i<extra;i++){
            uniq.push(arr[Math.floor(rnd01(st.seed + i*901)*arr.length)]);
          }
        }

        // query ranking
        const q = normalizeQuery(st.queryBias);
        const qt = q ? q.split(" ").filter(Boolean) : [];
        uniq.sort((a,b)=>{
          const A = graph.get(a), B = graph.get(b);
          return scoreNode(B, qt) - scoreNode(A, qt);
        });

        // cap
        const cap = Math.floor(lerp(8, 16, clamp(+ui.density.value/2.2,0,1)));
        return uniq.slice(0, cap);
      }

      function renderShelf(){
        const el = $('shelf');
        el.innerHTML = "";

        for (const id of shelf){
          const node = graph.get(id);
          if (!node) continue;

          const card = document.createElement('div');
          card.className = 'card';

          const top = document.createElement('div');
          top.className = 'cardTop';

          const title = document.createElement('div');
          title.className = 'cardTitle';
          title.textContent = node.title;

          const badge = document.createElement('div');
          badge.className = 'badge';
          if (node.falseTo) badge.textContent = "FALSE DOOR";
          else if (node.mirrorOf) badge.textContent = "MIRROR";
          else badge.textContent = "ENTRY";

          top.appendChild(title);
          top.appendChild(badge);

          const ex = document.createElement('div');
          ex.className = 'excerpt';
          ex.textContent = node.excerpt;

          const tags = document.createElement('div');
          tags.className = 'tags';
          for (const t of node.tags.slice(0,6)){
            const tg = document.createElement('div');
            tg.className = 'tag';
            tg.textContent = t;
            tags.appendChild(tg);
          }

          card.appendChild(top);
          card.appendChild(ex);
          card.appendChild(tags);

          card.onclick = (ev) => {
            // ALT+click: create mirror (alias)
            if (ev.altKey){
              // mirror current -> this (semantic)
              const cur = graph.get(currentId);
              if (cur) cur.mirrorOf = id;
              // also bias future generation by this title tokens
              st.queryBias = normalizeQuery(node.title);
              $('q').value = st.queryBias;
              refreshShelf();
              return;
            }

            // SHIFT+click: force false door redirect
            if (ev.shiftKey){
              const arr = [...graph.keys()];
              const target = arr[Math.floor(rnd01(st.seed + hash32(id))*arr.length)];
              redirects.set(id, target);
              node.falseTo = target;
              refreshShelf();
              return;
            }

            enterNode(id);
          };

          el.appendChild(card);
        }
      }

      function resolveRedirect(id){
        // Follow redirect chain at most 3 steps (keep it sane)
        let cur = id;
        for (let i=0;i<3;i++){
          const r = redirects.get(cur);
          if (!r) break;
          cur = r;
        }
        return cur;
      }

      function enterNode(id){
        const resolved = resolveRedirect(id);
        currentId = resolved;

        // update thread; if we revisit an earlier node, create a "loop" by truncating + re-appending
        const idx = thread.indexOf(resolved);
        if (idx !== -1 && idx < thread.length-1){
          // loop: keep the earlier portion and re-enter
          thread = thread.slice(0, idx+1);
        } else {
          thread.push(resolved);
        }

        ensureNeighborhood(resolved);
        refreshShelf();
      }

      function refreshShelf(){
        ensureNeighborhood(currentId);
        shelf = buildShelf();
        renderThread();
        renderShelf();
        pressureMetric();
      }

      // ===== Visual field (labyrinth graph) =====
      function draw(){
        const inv = st.invert;
        const bg = inv ? 255 : 0;
        const fg = inv ? 0 : 255;

        const trace = +ui.trace.value;
        if (trace > 0){
          ctx.fillStyle = `rgba(${bg},${bg},${bg},${clamp(trace,0,1)})`;
          ctx.fillRect(0,0,W,H);
        } else {
          ctx.fillStyle = `rgb(${bg},${bg},${bg})`;
          ctx.fillRect(0,0,W,H);
        }

        // In invert mode: keep source-over so black stays visible.
        ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';

        const density = +ui.density.value;
        const ent = +ui.entropy.value;

        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;
        const S = Math.min(W,H) * 0.58 * st.zoom;

        // compute positions deterministically from id (so graph is stable)
        function posFromId(id){
          const h = hash32(hash32(id.length) ^ hash32(parseInt(id.slice(1),16) || 0));
          const a = rnd01(h) * Math.PI*2 + st.t*0.06*ent;
          const rr = Math.sqrt(rnd01(h^0x9e37)) * 0.72;
          return { x: cx + Math.cos(a)*rr*S, y: cy + Math.sin(a)*rr*S };
        }

        // draw edges from current neighborhood
        const center = graph.get(currentId);
        if (center){
          const p0 = posFromId(center.id);

          // current node glow
          ctx.lineWidth = 1.4;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.55})`;
          ctx.beginPath();
          ctx.arc(p0.x, p0.y, 18, 0, Math.PI*2);
          ctx.stroke();

          // edges
          const refs = center.refs || [];
          for (let i=0;i<refs.length;i++){
            const rid = resolveRedirect(refs[i]);
            const n = graph.get(rid);
            if (!n) continue;
            const p1 = posFromId(rid);

            const a = clamp(0.06 + 0.16*density, 0, 0.45);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
            ctx.lineWidth = 1.0;

            // curve for labyrinth feel
            const mx = (p0.x+p1.x)*0.5 + Math.sin(st.t*0.7 + i)*18*ent;
            const my = (p0.y+p1.y)*0.5 + Math.cos(st.t*0.6 + i)*18*ent;
            ctx.beginPath();
            ctx.moveTo(p0.x,p0.y);
            ctx.quadraticCurveTo(mx,my,p1.x,p1.y);
            ctx.stroke();

            // node marker
            ctx.lineWidth = 1.2;
            const isMirror = !!n.mirrorOf;
            const isFalse = !!n.falseTo;
            const r = isFalse ? 10 : (isMirror ? 9 : 8);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.35 + 0.25*(isFalse||isMirror)})`;
            ctx.beginPath();
            ctx.arc(p1.x, p1.y, r, 0, Math.PI*2);
            ctx.stroke();

            // false door X
            if (isFalse){
              ctx.beginPath();
              ctx.moveTo(p1.x-r*0.6, p1.y-r*0.6);
              ctx.lineTo(p1.x+r*0.6, p1.y+r*0.6);
              ctx.moveTo(p1.x-r*0.6, p1.y+r*0.6);
              ctx.lineTo(p1.x+r*0.6, p1.y-r*0.6);
              ctx.stroke();
            }

            // mirror dash
            if (isMirror){
              ctx.beginPath();
              ctx.moveTo(p1.x-r*0.7, p1.y);
              ctx.lineTo(p1.x+r*0.7, p1.y);
              ctx.stroke();
            }

            // occasional micro-labels (keep light)
            if (density > 1.35 && (i%2===0)){
              ctx.globalCompositeOperation = 'source-over';
              ctx.font = '11px Arial';
              ctx.textBaseline = 'middle';
              ctx.fillStyle = inv ? 'rgba(0,0,0,0.80)' : 'rgba(255,255,255,0.74)';
              ctx.fillText(n.title.slice(0,22) + (n.title.length>22?'…':''), p1.x + 12, p1.y);
              ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';
            }
          }

          // Thread overlay (Ariadne): connect visited nodes in sequence
          if (thread.length > 1){
            ctx.lineWidth = 1.4;
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.28 + 0.25*st.pressure})`;
            ctx.beginPath();
            for (let i=0;i<thread.length;i++){
              const p = posFromId(thread[i]);
              if (i===0) ctx.moveTo(p.x,p.y);
              else ctx.lineTo(p.x,p.y);
            }
            ctx.stroke();
          }
        }

        // subtle “corridor rain” (infinite shelf feel)
        const rain = Math.floor(lerp(40, 160, clamp(density/2.2,0,1)));
        ctx.lineWidth = 1;
        const aRain = clamp(0.02 + 0.05*density + 0.06*ent, 0, 0.18);
        ctx.strokeStyle = `rgba(${fg},${fg},${fg},${aRain})`;
        for (let i=0;i<rain;i++){
          const r1 = rnd01(st.seed + i*31 + ((st.t*1000)|0));
          const r2 = rnd01(st.seed + i*79 + 1337);
          const x = r1*W;
          const y = r2*H;
          const len = lerp(10, 44, st.pressure) * (0.6 + 0.7*ent);
          ctx.beginPath();
          ctx.moveTo(x, y-len);
          ctx.lineTo(x, y+len);
          ctx.stroke();
        }

        ctx.globalCompositeOperation = 'source-over';
      }

      // ===== Interaction =====
      $('invert').onclick = ()=> st.invert = !st.invert;
      $('pause').onclick = ()=> st.paused = !st.paused;

      $('cutThread').onclick = ()=>{
        // keep current node only; thread cut is a structural act
        thread = [currentId];
        refreshShelf();
      };

      $('detour').onclick = ()=>{
        // choose a "wrong shelf" entry and enter it (detour as method)
        if (!shelf.length) return;
        const idx = Math.floor(rnd01(st.seed + ((st.t*1000)|0)) * shelf.length);
        enterNode(shelf[idx]);
      };

      $('reseed').onclick = ()=>{
        st.seed = (Math.random()*1e9)|0;
        graph.clear();
        redirects.clear();
        // rebuild root
        currentId = "ROOT";
        const root = { id:"ROOT", title:"THE INDEX OF KETADATA", excerpt:"The first entry is the rule that generates the others.", tags:["KETADATA","INDEX","THREAD"], refs:[], mirrorOf:null, falseTo:null, depth:0 };
        graph.set("ROOT", root);
        thread = ["ROOT"];
        st.queryBias = "";
        $('q').value = "";
        ensureNeighborhood("ROOT");
        refreshShelf();
      };

      $('reset').onclick = ()=>{
        st.t=0; st.invert=false; st.paused=false; st.ox=0; st.oy=0; st.wheel=0; st.zoom=1.0;
        ui.timeScale.value=0.45; ui.branch.value=6; ui.depth.value=4; ui.alias.value=0.28;
        ui.falseDoor.value=0.18; ui.entropy.value=0.36; ui.density.value=1.10; ui.trace.value=0.050;
        sync();
        $('reseed').click();
      };

      $('searchBtn').onclick = ()=>{
        st.queryBias = normalizeQuery(ui.q.value);
        refreshShelf();
      };
      ui.q.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter'){
          st.queryBias = normalizeQuery(ui.q.value);
          refreshShelf();
        }
      });

      addEventListener('keydown', (e)=>{
        if (e.key==='i' || e.key==='I') st.invert = !st.invert;
        if (e.key==='p' || e.key==='P') st.paused = !st.paused;
        if (e.key==='h' || e.key==='H'){
          const panel = document.getElementById('panel');
          panel.style.display = (panel.style.display === 'none') ? '' : 'none';
        }
      });

      addEventListener('wheel', (e)=>{
        const d = Math.max(-160, Math.min(160, e.deltaY));
        st.wheel += (-d/160) * 0.18;
        st.wheel = clamp(st.wheel, -0.85, 0.95);
      }, { passive:true });

      addEventListener('pointerdown', (e)=>{
        st.drag=true; st.lx=e.clientX; st.ly=e.clientY;
      });
      addEventListener('pointerup', ()=> st.drag=false);
      addEventListener('pointercancel', ()=> st.drag=false);
      addEventListener('pointermove', (e)=>{
        if (!st.drag) return;
        const dx = e.clientX - st.lx;
        const dy = e.clientY - st.ly;
        st.lx=e.clientX; st.ly=e.clientY;
        st.ox += dx;
        st.oy += dy;
        st.ox = clamp(st.ox, -W*0.60, W*0.60);
        st.oy = clamp(st.oy, -H*0.60, H*0.60);
      });

      // ===== Init graph =====
      function init(){
        graph.clear();
        redirects.clear();

        const root = {
          id:"ROOT",
          title:"THE INDEX OF KETADATA",
          excerpt:"The first entry is the rule that generates the others.",
          tags:["KETADATA","INDEX","THREAD","LABYRINTH"],
          refs:[],
          mirrorOf:null,
          falseTo:null,
          depth:0
        };
        graph.set("ROOT", root);
        currentId = "ROOT";
        thread = ["ROOT"];
        ensureNeighborhood("ROOT");
        refreshShelf();
      }
      init();

      // ===== Loop =====
      let last = performance.now();
      function frame(now){
        const rawDt = Math.min(0.033, (now-last)/1000);
        last = now;

        // zoom smoothing
        st.wheel *= 0.88;
        st.zoom += st.wheel;
        st.zoom = clamp(st.zoom, 0.55, 2.60);

        const dt = rawDt * (+ui.timeScale.value) * (0.55 + 1.25*(+ui.density.value/2.2));
        if (!st.paused){
          st.t += dt;

          // slight living mutation of neighborhood when entropy is high
          const e = +ui.entropy.value;
          if (e > 0.001 && rnd01(st.seed + ((st.t*1000)|0) + hash32(currentId)) < e*0.02){
            ensureNeighborhood(currentId);
            shelf = buildShelf();
            renderShelf();
            pressureMetric();
          }
        }

        draw();
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);

    })();
  </script>
</body>
</html>
