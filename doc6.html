<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA DOC — TABS + FORMAT + COLOR</title>
  <style>
    :root{
      /* KETADATA DEFAULT: BLACK */
      --bg:#0b0b0b;
      --fg:#f2f2f2;
      --muted:#9a9a9a;
      --line:#2f2f2f;
      --hud:rgba(255,255,255,0.03);
      --paper:#101010;
      --paperLine:#2a2a2a;
      --accent:#f2f2f2;

      --font:12px/1.15 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --pad:8px;
      --radius:10px;
      --sidebarW:270px;
      --toolbarH:40px;
    }

    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:var(--font);overflow:hidden;}
    *{box-sizing:border-box;}
    a{color:var(--fg);}

    /* INVERT MUST AFFECT WHOLE PAGE */
    html.invert #app{filter: invert(1) hue-rotate(180deg);}
    html.invert{background:#000;}

    /* NULL = fullscreen/quiet/no chrome */
    html.null #sidebar,
    html.null #toolbar,
    html.null #statusbar{display:none;}
    html.null #main{inset:0 !important;}
    html.null #paperWrap{padding:0 !important;}
    html.null #paper{border:none !important; border-radius:0 !important; width:100% !important; min-height:100% !important;}

    /* FULLSCREEN helper */
    body{user-select:none;}
    .ui{user-select:none;}
    .btn, .chip, input, select{font:var(--font);}

    #app{position:fixed;inset:0;display:block;}

    #sidebar{
      position:fixed;left:0;top:0;bottom:0;
      width:var(--sidebarW);
      border-right:1px solid var(--line);
      background:var(--bg);
      padding:var(--pad);
      overflow:auto;
    }

    #sideHead{
      display:flex;gap:6px;align-items:center;
      padding:6px;
      border:1px solid var(--line);
      background:var(--hud);
      border-radius:var(--radius);
      margin-bottom:8px;
    }
    #sideHead .label{color:var(--muted);}
    #sideHead .sp{flex:1;}
    #sideHead .btn{padding:4px 6px;border:1px solid var(--line);background:transparent;color:var(--fg);cursor:pointer;}
    #sideHead .btn:active{transform:translateY(1px);}

    #tabs{display:flex;flex-direction:column;gap:6px;}
    .tab{
      display:flex;gap:6px;align-items:center;
      padding:7px 8px;
      border:1px solid var(--line);
      background:transparent;
      color:var(--fg);
      border-radius:999px;
      cursor:pointer;
      min-height:34px;
    }
    .tab.active{background:var(--hud);}
    .tab .icon{
      width:16px;height:16px;border:1px solid var(--line);border-radius:3px;
      display:inline-block;
      background:transparent;
    }
    .tab .name{
      flex:1;min-width:0;
      overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
      opacity:0.95;
    }
    .tab .meta{color:var(--muted);opacity:0.9;}
    .tab .mini{
      display:none;
      padding:2px 6px;
      border:1px solid var(--line);
      background:transparent;
      color:var(--fg);
      cursor:pointer;
      border-radius:6px;
    }
    .editOn .tab .mini{display:inline-block;}
    .tab:hover .name{opacity:1;}

    #main{
      position:fixed;
      left:var(--sidebarW); right:0; top:0; bottom:0;
      display:flex; flex-direction:column;
      overflow:hidden;
      background:var(--bg);
    }

    #toolbar{
      height:var(--toolbarH);
      border-bottom:1px solid var(--line);
      padding:6px;
      display:flex; gap:6px; align-items:center; flex-wrap:nowrap;
      background:var(--bg);
    }
    #toolbar .btn, #toolbar .chip, #toolbar input[type="color"], #toolbar select{
      height:28px;
      padding:0 8px;
      border:1px solid var(--line);
      background:transparent;
      color:var(--fg);
      border-radius:8px;
      cursor:pointer;
    }
    #toolbar input[type="color"]{
      padding:0; width:34px;
      cursor:pointer;
    }
    #toolbar .chip{cursor:default;color:var(--muted);}
    #toolbar .sp{flex:1;}
    #toolbar .btn:active{transform:translateY(1px);}
    #toolbar .btn.on{background:var(--hud);}

    #paperWrap{
      position:relative;
      flex:1;
      overflow:auto;
      padding:14px;
    }

    #paper{
      width:min(980px, calc(100% - 24px));
      margin:0 auto;
      min-height:calc(100% - 2px);
      background:var(--paper);
      border:1px solid var(--paperLine);
      border-radius:14px;
      padding:16px;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.02) inset;
    }

    #docTitleRow{
      display:flex;gap:8px;align-items:center;
      border-bottom:1px dashed var(--paperLine);
      padding-bottom:10px;
      margin-bottom:10px;
    }
    #docTitleRow .tlabel{color:var(--muted);}
    #docTitle{
      flex:1;
      min-width:0;
      border:1px solid var(--paperLine);
      border-radius:10px;
      padding:6px 8px;
      background:transparent;
      color:var(--fg);
      outline:none;
    }
    #docTitle[contenteditable="true"]:focus{border-color:var(--line);}

    .sectionHead{
      display:flex;gap:6px;align-items:center;
      margin:10px 0 6px 0;
      padding:6px 8px;
      border:1px solid var(--paperLine);
      border-radius:12px;
      background:rgba(255,255,255,0.02);
    }
    .sectionHead .sname{
      flex:1;min-width:0;
      overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
      opacity:0.95;
    }
    .sectionHead .stag{color:var(--muted);}
    .sectionHead .mini{
      padding:2px 6px;border:1px solid var(--paperLine);
      border-radius:8px;background:transparent;color:var(--fg);
      cursor:pointer; display:none;
    }
    .editOn .sectionHead .mini{display:inline-block;}

    .editor{
      user-select:text;
      outline:none;
      border:1px solid var(--paperLine);
      border-radius:12px;
      padding:10px;
      min-height:260px;
      background:transparent;
      color:var(--fg);
      white-space:pre-wrap;
      word-break:break-word;
    }
    .editor:focus{border-color:var(--line);}
    .editor *{font-size:inherit; line-height:inherit;} /* uniform-size law */
    .editor h1,.editor h2,.editor h3{font-size:inherit; font-weight:700; margin:0;} /* prevent bloat */
    .editor p{margin:0 0 8px 0;}
    .editor ul,.editor ol{margin:0 0 8px 18px; padding:0;}
    .editor blockquote{
      margin:0 0 8px 0;
      padding:6px 10px;
      border-left:2px solid var(--paperLine);
      color:var(--muted);
    }
    .editor pre{
      margin:0 0 8px 0;
      padding:8px 10px;
      border:1px dashed var(--paperLine);
      border-radius:10px;
      background:rgba(0,0,0,0.18);
      overflow:auto;
      white-space:pre;
    }

    #statusbar{
      border-top:1px solid var(--line);
      padding:6px 8px;
      display:flex;gap:10px;align-items:center;
      color:var(--muted);
    }
    #statusbar .sp{flex:1;}
    #statusbar .pill{
      border:1px solid var(--line);
      padding:3px 6px;
      border-radius:999px;
    }

    /* small */
    @media (max-width: 900px){
      :root{--sidebarW:210px;}
      #toolbar{flex-wrap:wrap;height:auto}
    }
  </style>
</head>
<body>
<div id="app">
  <aside id="sidebar" class="ui">
    <div id="sideHead">
      <span class="label">Document tabs</span>
      <span class="sp"></span>
      <button class="btn" id="btnAddTab" title="Add section">+</button>
      <button class="btn" id="btnEdit" title="Edit tabs">EDIT</button>
    </div>
    <div id="tabs"></div>
  </aside>

  <main id="main">
    <div id="toolbar" class="ui">
      <button class="btn" id="bBold" title="Bold">B</button>
      <button class="btn" id="bItalic" title="Italic">I</button>
      <button class="btn" id="bUnder" title="Underline">U</button>
      <button class="btn" id="bStrike" title="Strike">S</button>

      <button class="btn" id="bUL" title="Bullets">•</button>
      <button class="btn" id="bOL" title="Numbered">1.</button>
      <button class="btn" id="bQuote" title="Quote">"</button>
      <button class="btn" id="bCode" title="Code block">{} </button>

      <button class="btn" id="bL" title="Align left">L</button>
      <button class="btn" id="bC" title="Align center">C</button>
      <button class="btn" id="bR" title="Align right">R</button>

      <span class="chip">TEXT</span>
      <input type="color" id="cText" title="Text color" value="#f2f2f2" />
      <span class="chip">HILITE</span>
      <input type="color" id="cHi" title="Highlight color" value="#2f2f2f" />
      <span class="chip">PAPER</span>
      <input type="color" id="cPaper" title="Paper color" value="#101010" />
      <span class="chip">BG</span>
      <input type="color" id="cBg" title="Background color" value="#0b0b0b" />

      <button class="btn" id="bClear" title="Remove formatting">CLR</button>
      <button class="btn" id="bLink" title="Create link">LINK</button>
      <button class="btn" id="bUnlink" title="Remove link">UNLINK</button>

      <span class="sp"></span>

      <button class="btn" id="bAll" title="Toggle ALL view">ALL</button>
      <button class="btn" id="bExport" title="Export JSON">EXPORT</button>
      <button class="btn" id="bImport" title="Import JSON">IMPORT</button>

      <button class="btn" id="bNull" title="NULL (SHIFT+N)">NULL</button>
      <button class="btn" id="bInvert" title="INVERT (SHIFT+I)">INVERT</button>
      <button class="btn" id="bFull" title="FULL (SHIFT+F)">FULL</button>
    </div>

    <div id="paperWrap">
      <div id="paper">
        <div id="docTitleRow">
          <span class="tlabel">DOC</span>
          <div id="docTitle" contenteditable="true" spellcheck="false"></div>
          <span class="tlabel" id="viewLabel">VIEW: TAB</span>
        </div>

        <div id="content"></div>
      </div>
    </div>

    <div id="statusbar" class="ui">
      <span class="pill" id="pillFile"></span>
      <span class="pill" id="pillSaved">SAVED</span>
      <span class="sp"></span>
      <span class="pill">SHIFT+I INVERT</span>
      <span class="pill">SHIFT+N NULL</span>
      <span class="pill">SHIFT+F FULL</span>
    </div>
  </main>
</div>

<input id="filePick" type="file" accept="application/json" style="display:none" />

<script>
(() => {
  const FILE_ID = "KD_DOC_TABS_FORMAT_COLOR_V1";
  const STORE_KEY = "KD_DOC__" + FILE_ID;

  const $ = (id) => document.getElementById(id);

  const tabsEl = $("tabs");
  const contentEl = $("content");
  const docTitleEl = $("docTitle");
  const viewLabelEl = $("viewLabel");
  const pillFile = $("pillFile");
  const pillSaved = $("pillSaved");
  const filePick = $("filePick");

  const btnAddTab = $("btnAddTab");
  const btnEdit = $("btnEdit");

  const bAll = $("bAll");
  const bExport = $("bExport");
  const bImport = $("bImport");

  const bNull = $("bNull");
  const bInvert = $("bInvert");
  const bFull = $("bFull");

  const cText = $("cText");
  const cHi = $("cHi");
  const cPaper = $("cPaper");
  const cBg = $("cBg");

  const stateDefault = () => ({
    meta: {
      fileId: FILE_ID,
      updatedAt: new Date().toISOString(),
      title: "KETADATA DOC",
    },
    ui: {
      editTabs: false,
      viewMode: "TAB", // TAB | ALL
      invert: false,
      nullMode: false,
      theme: {
        bg: "#0b0b0b",
        paper: "#101010",
      }
    },
    activeSectionId: null,
    sections: [
      { id: "s_" + Date.now(), title: "KETADATA V-I", html: "" },
      { id: "s_" + (Date.now()+1), title: "CONTENTS", html: "" }
    ]
  });

  let state = null;
  let lastFocusedEditor = null;
  let saveTimer = null;

  const setSaved = (isSaved) => {
    pillSaved.textContent = isSaved ? "SAVED" : "DIRTY";
  };

  const deepClone = (x) => JSON.parse(JSON.stringify(x));

  const load = () => {
    try {
      const raw = localStorage.getItem(STORE_KEY);
      if (!raw) return stateDefault();
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return stateDefault();

      // basic hardening (minimal)
      if (!Array.isArray(parsed.sections) || parsed.sections.length === 0) return stateDefault();
      if (!parsed.activeSectionId) parsed.activeSectionId = parsed.sections[0].id;
      if (!parsed.meta) parsed.meta = {};
      if (!parsed.ui) parsed.ui = {};
      if (!parsed.ui.theme) parsed.ui.theme = {};
      if (!parsed.ui.viewMode) parsed.ui.viewMode = "TAB";

      return parsed;
    } catch {
      return stateDefault();
    }
  };

  const save = () => {
    try {
      state.meta.updatedAt = new Date().toISOString();
      localStorage.setItem(STORE_KEY, JSON.stringify(state));
      setSaved(true);
    } catch {
      // ignore
    }
  };

  const scheduleSave = () => {
    setSaved(false);
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(save, 250);
  };

  const applyTheme = () => {
    document.documentElement.style.setProperty("--bg", state.ui.theme.bg || "#0b0b0b");
    document.documentElement.style.setProperty("--paper", state.ui.theme.paper || "#101010");
    cBg.value = normalizeHex(state.ui.theme.bg || "#0b0b0b");
    cPaper.value = normalizeHex(state.ui.theme.paper || "#101010");
  };

  const normalizeHex = (v) => {
    // best effort: if empty/invalid keep current
    if (typeof v !== "string") return "#000000";
    const s = v.trim();
    if (/^#[0-9a-fA-F]{6}$/.test(s)) return s;
    return "#000000";
  };

  const ensureActive = () => {
    if (!state.activeSectionId) state.activeSectionId = state.sections[0]?.id || null;
    if (!state.sections.find(s => s.id === state.activeSectionId)) state.activeSectionId = state.sections[0]?.id || null;
  };

  const setInvert = (v) => {
    state.ui.invert = !!v;
    document.documentElement.classList.toggle("invert", state.ui.invert);
    scheduleSave();
  };
  const setNull = (v) => {
    state.ui.nullMode = !!v;
    document.documentElement.classList.toggle("null", state.ui.nullMode);
    scheduleSave();
  };
  const toggleFull = () => {
    if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
  };

  const setViewMode = (mode) => {
    state.ui.viewMode = mode;
    viewLabelEl.textContent = "VIEW: " + mode;
    bAll.classList.toggle("on", mode === "ALL");
    renderContent();
    scheduleSave();
  };

  const renderTabs = () => {
    tabsEl.innerHTML = "";
    document.body.classList.toggle("editOn", !!state.ui.editTabs);

    for (let i = 0; i < state.sections.length; i++) {
      const s = state.sections[i];

      const el = document.createElement("div");
      el.className = "tab" + (s.id === state.activeSectionId ? " active" : "");
      el.title = s.title;

      const icon = document.createElement("span");
      icon.className = "icon";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = s.title;

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent = "";

      const bUp = document.createElement("button");
      bUp.className = "mini";
      bUp.textContent = "↑";
      bUp.title = "Move up";
      bUp.onclick = (ev) => {
        ev.stopPropagation();
        if (i <= 0) return;
        const tmp = state.sections[i-1];
        state.sections[i-1] = state.sections[i];
        state.sections[i] = tmp;
        renderTabs(); renderContent(); scheduleSave();
      };

      const bDown = document.createElement("button");
      bDown.className = "mini";
      bDown.textContent = "↓";
      bDown.title = "Move down";
      bDown.onclick = (ev) => {
        ev.stopPropagation();
        if (i >= state.sections.length - 1) return;
        const tmp = state.sections[i+1];
        state.sections[i+1] = state.sections[i];
        state.sections[i] = tmp;
        renderTabs(); renderContent(); scheduleSave();
      };

      const bRen = document.createElement("button");
      bRen.className = "mini";
      bRen.textContent = "REN";
      bRen.title = "Rename";
      bRen.onclick = (ev) => {
        ev.stopPropagation();
        const t = prompt("RENAME SECTION:", s.title);
        if (t === null) return;
        s.title = (t.trim() || s.title);
        renderTabs(); renderContent(); scheduleSave();
      };

      const bDel = document.createElement("button");
      bDel.className = "mini";
      bDel.textContent = "DEL";
      bDel.title = "Delete";
      bDel.onclick = (ev) => {
        ev.stopPropagation();
        if (state.sections.length <= 1) return;
        const ok = confirm("DELETE SECTION: " + s.title + " ?");
        if (!ok) return;
        state.sections = state.sections.filter(x => x.id !== s.id);
        ensureActive();
        renderTabs(); renderContent(); scheduleSave();
      };

      el.appendChild(icon);
      el.appendChild(name);
      el.appendChild(meta);
      el.appendChild(bUp);
      el.appendChild(bDown);
      el.appendChild(bRen);
      el.appendChild(bDel);

      el.onclick = () => {
        state.activeSectionId = s.id;
        renderTabs();
        if (state.ui.viewMode === "TAB") renderContent();
        scheduleSave();
      };

      tabsEl.appendChild(el);
    }
  };

  const makeEditor = (section) => {
    const ed = document.createElement("div");
    ed.className = "editor";
    ed.contentEditable = "true";
    ed.spellcheck = false;
    ed.dataset.sectionId = section.id;
    ed.innerHTML = section.html || "";

    ed.addEventListener("focus", () => { lastFocusedEditor = ed; });
    ed.addEventListener("mouseup", () => { lastFocusedEditor = ed; });
    ed.addEventListener("keyup", () => { lastFocusedEditor = ed; });

    ed.addEventListener("input", () => {
      section.html = ed.innerHTML;
      scheduleSave();
    });

    return ed;
  };

  const renderContent = () => {
    ensureActive();
    contentEl.innerHTML = "";

    // title
    if (typeof state.meta.title !== "string") state.meta.title = "KETADATA DOC";
    docTitleEl.textContent = state.meta.title;

    docTitleEl.oninput = () => {
      state.meta.title = (docTitleEl.textContent || "").trim() || "KETADATA DOC";
      scheduleSave();
    };

    if (state.ui.viewMode === "TAB") {
      const s = state.sections.find(x => x.id === state.activeSectionId) || state.sections[0];
      if (!s) return;

      const head = document.createElement("div");
      head.className = "sectionHead";
      const sname = document.createElement("div");
      sname.className = "sname";
      sname.textContent = s.title;
      const stag = document.createElement("div");
      stag.className = "stag";
      stag.textContent = "SECTION";

      const bRen = document.createElement("button");
      bRen.className = "mini";
      bRen.textContent = "REN";
      bRen.onclick = () => {
        const t = prompt("RENAME SECTION:", s.title);
        if (t === null) return;
        s.title = (t.trim() || s.title);
        renderTabs(); renderContent(); scheduleSave();
      };

      head.appendChild(sname);
      head.appendChild(stag);
      head.appendChild(bRen);

      const ed = makeEditor(s);

      contentEl.appendChild(head);
      contentEl.appendChild(ed);

      // focus editor
      setTimeout(() => { ed.focus(); lastFocusedEditor = ed; }, 0);

    } else { // ALL
      for (const s of state.sections) {
        const head = document.createElement("div");
        head.className = "sectionHead";
        const sname = document.createElement("div");
        sname.className = "sname";
        sname.textContent = s.title;
        const stag = document.createElement("div");
        stag.className = "stag";
        stag.textContent = "SECTION";
        const bRen = document.createElement("button");
        bRen.className = "mini";
        bRen.textContent = "REN";
        bRen.onclick = () => {
          const t = prompt("RENAME SECTION:", s.title);
          if (t === null) return;
          s.title = (t.trim() || s.title);
          renderTabs(); renderContent(); scheduleSave();
        };
        head.appendChild(sname);
        head.appendChild(stag);
        head.appendChild(bRen);

        const ed = makeEditor(s);

        contentEl.appendChild(head);
        contentEl.appendChild(ed);
      }
    }
  };

  // formatting commands (execCommand is still the most compatible for a single-file editor)
  const focusEditor = () => {
    const ed = lastFocusedEditor || document.querySelector(".editor");
    if (ed) ed.focus();
    return ed;
  };
  const cmd = (c, val=null) => {
    const ed = focusEditor();
    if (!ed) return;
    try {
      document.execCommand(c, false, val);
      // sync html back to state
      const sid = ed.dataset.sectionId;
      const sec = state.sections.find(s => s.id === sid);
      if (sec) sec.html = ed.innerHTML;
      scheduleSave();
    } catch {}
  };

  // toolbar actions
  $("bBold").onclick = () => cmd("bold");
  $("bItalic").onclick = () => cmd("italic");
  $("bUnder").onclick = () => cmd("underline");
  $("bStrike").onclick = () => cmd("strikeThrough");
  $("bUL").onclick = () => cmd("insertUnorderedList");
  $("bOL").onclick = () => cmd("insertOrderedList");
  $("bQuote").onclick = () => cmd("formatBlock", "blockquote");
  $("bCode").onclick = () => cmd("formatBlock", "pre");
  $("bL").onclick = () => cmd("justifyLeft");
  $("bC").onclick = () => cmd("justifyCenter");
  $("bR").onclick = () => cmd("justifyRight");

  $("bClear").onclick = () => cmd("removeFormat");

  $("bLink").onclick = () => {
    const ed = focusEditor();
    if (!ed) return;
    const url = prompt("LINK URL:");
    if (!url) return;
    cmd("createLink", url.trim());
  };
  $("bUnlink").onclick = () => cmd("unlink");

  cText.addEventListener("input", () => cmd("foreColor", cText.value));
  cHi.addEventListener("input", () => cmd("hiliteColor", cHi.value));

  cPaper.addEventListener("input", () => {
    state.ui.theme.paper = cPaper.value;
    applyTheme();
    scheduleSave();
  });
  cBg.addEventListener("input", () => {
    state.ui.theme.bg = cBg.value;
    applyTheme();
    scheduleSave();
  });

  bAll.onclick = () => setViewMode(state.ui.viewMode === "TAB" ? "ALL" : "TAB");

  btnAddTab.onclick = () => {
    const n = state.sections.length + 1;
    state.sections.push({ id: "s_" + Date.now() + "_" + Math.floor(Math.random()*1e6), title: "SECTION " + n, html: "" });
    state.activeSectionId = state.sections[state.sections.length - 1].id;
    renderTabs(); renderContent(); scheduleSave();
  };

  btnEdit.onclick = () => {
    state.ui.editTabs = !state.ui.editTabs;
    btnEdit.classList.toggle("on", state.ui.editTabs);
    renderTabs();
    scheduleSave();
  };

  // export/import (actual file download)
  const download = (filename, text) => {
    const blob = new Blob([text], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 800);
  };

  bExport.onclick = () => {
    const out = deepClone(state);
    out.meta.exportedAt = new Date().toISOString();
    download("KD_DOC_export.json", JSON.stringify(out, null, 2));
  };

  bImport.onclick = () => filePick.click();
  filePick.addEventListener("change", async () => {
    const f = filePick.files && filePick.files[0];
    if (!f) return;
    try {
      const parsed = JSON.parse(await f.text());
      if (parsed && Array.isArray(parsed.sections)) {
        state = parsed;
        ensureActive();
        applyTheme();
        setInvert(!!state.ui?.invert);
        setNull(!!state.ui?.nullMode);
        renderTabs();
        renderContent();
        setViewMode(state.ui.viewMode || "TAB");
        save();
      }
    } catch {}
    filePick.value = "";
  });

  bNull.onclick = () => setNull(!state.ui.nullMode);
  bInvert.onclick = () => setInvert(!state.ui.invert);
  bFull.onclick = () => toggleFull();

  // hotkeys (do not break typing)
  window.addEventListener("keydown", (e) => {
    const tag = (document.activeElement && document.activeElement.tagName || "").toLowerCase();
    const typing = (tag === "input" || tag === "textarea");
    // contenteditable should keep normal typing; only SHIFT hotkeys
    if (e.shiftKey && (e.key === "I" || e.key === "i")) { e.preventDefault(); setInvert(!state.ui.invert); }
    if (e.shiftKey && (e.key === "N" || e.key === "n")) { e.preventDefault(); setNull(!state.ui.nullMode); }
    if (e.shiftKey && (e.key === "F" || e.key === "f")) { e.preventDefault(); toggleFull(); }

    // optional: ESC closes NULL
    if (e.key === "Escape" && state.ui.nullMode) { setNull(false); }

    // TAB view quick toggle (SHIFT+A) without interfering with typing
    if (e.shiftKey && (e.key === "A" || e.key === "a")) { e.preventDefault(); setViewMode(state.ui.viewMode === "TAB" ? "ALL" : "TAB"); }
  });

  // init
  pillFile.textContent = "FILE_ID: " + FILE_ID;

  state = load();
  ensureActive();
  applyTheme();
  setInvert(!!state.ui.invert);
  setNull(!!state.ui.nullMode);

  btnEdit.classList.toggle("on", !!state.ui.editTabs);
  renderTabs();
  renderContent();
  setViewMode(state.ui.viewMode || "TAB");
  save();

})();
</script>

<!--
AE / EE / WB — KETADATA SERIALIZATION STAMP (MANDATORY)
AE: BLACK DEFAULT • UNIFORM TEXT SIZE (NO TYPO BLOAT) • BRUTAL / CLEAN • INVERT APPLIES TO WHOLE APP VIA FILTER
EE: LEFT “DOCUMENT TABS” SIDEBAR (ADD/EDIT/REORDER/RENAME/DELETE) • MULTI-SECTION DOC • TAB VIEW OR ALL VIEW • LOCAL-FIRST SAVE
WB: EXPORT/IMPORT JSON (REAL DOWNLOAD) • SHIFT+I INVERT • SHIFT+N NULL • SHIFT+F FULLSCREEN

FILE_ID: "KD_DOC_TABS_FORMAT_COLOR_V1"
ROOM_ID: "K_DOC"
VERSION_ID: "V1"
UPDATED_AT: "2026-01-04T00:00:00.000-05:00"
CHANGELOG:
- V1: DOC TABS + MULTI-SECTIONS + FORMAT BAR + COLOR CONTROLS + ALL VIEW + LOCAL-FIRST EXPORT/IMPORT
-->
</body>
</html>
