<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETA_MONO // GLASS TENNIS BALL</title>
<style>
:root{
  --bg:#000;
  --muted:rgba(255,255,255,.42);
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;

  /* glass */
  --glassA:.18;
  --rimA:.36;

  /* seam */
  --seamA:.92;
  --seamW:3.2;
  --seamGap:10.0;

  /* motion */
  --bounceT:1050; /* ms */
}

*{box-sizing:border-box}
html,body{height:100%; margin:0}
body{
  background:var(--bg);
  overflow:hidden;
  font:10px/1.3 var(--mono);
  color:var(--muted);
  user-select:none;
}
#c{position:fixed; inset:0; width:100%; height:100%}
#hud{
  position:fixed; left:12px; top:12px;
  padding:6px 8px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.25);
  backdrop-filter: blur(8px);
  opacity:.78;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">KETA_MONO // GLASS TENNIS BALL · CLICK/SPACE BOUNCE · MOUSE = ORBIT</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", {alpha:true});

let DPR=1, W=0, H=0;
function resize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  W = Math.floor(innerWidth*DPR);
  H = Math.floor(innerHeight*DPR);
  canvas.width=W; canvas.height=H;
}
addEventListener("resize", resize);
resize();

const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;

const STATE = {
  mx: 0.0, my: 0.0,
  orbitX: 0.0, orbitY: 0.0,
  bouncing: false,
  bStart: 0,
  bProg: 0,
  spin: 0,
};

addEventListener("mousemove",(e)=>{
  const nx = (e.clientX/innerWidth)*2-1;
  const ny = (e.clientY/innerHeight)*2-1;
  STATE.mx = nx; STATE.my = ny;
});

function easeInOutCubic(t){ return t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }
function pingpong(t){ return 1 - Math.abs(1 - 2*t); }

function bounceCurve(u){
  const z = easeInOutCubic(pingpong(u));
  const impact = Math.exp(-Math.pow((u-0.52)/0.055,2));
  const squash = 1 + 0.22*impact;
  const stretch = 1 - 0.16*impact;
  return { z, squash, stretch };
}

function fireBounce(){
  if(STATE.bouncing) return;
  STATE.bouncing = true;
  STATE.bStart = performance.now();
  STATE.bProg = 0;
}
addEventListener("click", fireBounce);
addEventListener("keydown",(e)=>{
  if(e.code==="Space"){ e.preventDefault(); fireBounce(); }
},{passive:false});

/* faux 3D sphere projection */
function rotY(p, a){
  const ca=Math.cos(a), sa=Math.sin(a);
  return { x:p.x*ca + p.z*sa, y:p.y, z:-p.x*sa + p.z*ca };
}
function rotX(p, a){
  const ca=Math.cos(a), sa=Math.sin(a);
  return { x:p.x, y:p.y*ca - p.z*sa, z:p.y*sa + p.z*ca };
}
function project(p, R){
  const k = 1 / (1 - p.z*0.55);
  return { x: p.x*R*k, y: p.y*R*k, z:p.z };
}

/* segmented stroke on sphere with silhouette fade */
function strokeOnSphere(f, t0, t1, steps, cx, cy, R, orbitX, orbitY, baseW, baseA){
  ctx.lineCap="round"; ctx.lineJoin="round";
  ctx.beginPath();
  let started=false;

  for(let i=0;i<=steps;i++){
    const t = lerp(t0,t1,i/steps);
    const q = f(t);
    const x=q.x, y=q.y;

    const zz = Math.sqrt(Math.max(0, 1 - x*x - y*y));
    let p = {x, y, z: zz};

    p = rotY(p, orbitX);
    p = rotX(p, orbitY);

    if(p.z < -0.08){ started=false; continue; }

    const pr = project(p, R);
    const sx = cx + pr.x;
    const sy = cy + pr.y;

    const edge = clamp((p.z - 0.05)/0.35, 0, 1);
    const a = baseA * (0.25 + 0.75*edge);

    if(!started){
      ctx.moveTo(sx, sy);
      started=true;
    } else {
      ctx.strokeStyle = `rgba(255,255,255,${a})`;
      ctx.lineWidth = baseW;
      ctx.lineTo(sx, sy);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(sx, sy);
    }
  }
}

/* tennis seams: two separated C-arcs; with inner channel gap */
function drawTennisSeams(cx, cy, R, orbitX, orbitY){
  const seamW = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--seamW"))||3.2) * DPR;
  const seamGap = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--seamGap"))||10.0) * DPR;
  const seamA = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--seamA"))||0.92);

  function arcCurve(y0, bulge, phase){
    return (t)=>{
      const u=t;
      const x = lerp(-0.78, 0.78, u);
      const y = y0 + bulge*Math.sin(u*Math.PI + phase);
      return {x, y};
    };
  }

  const top = arcCurve(-0.36, 0.10, 0.20);
  const bot = arcCurve( 0.36,-0.10, 0.20);

  // outer seam band (white)
  ctx.globalCompositeOperation="screen";
  strokeOnSphere(top, 0, 1, 220, cx, cy, R, orbitX, orbitY, seamW, seamA);
  strokeOnSphere(bot, 0, 1, 220, cx, cy, R, orbitX, orbitY, seamW, seamA);

  // inner channel (black) to create spacing inside seam
  ctx.globalCompositeOperation="source-over";
  function strokeChannel(f){
    ctx.beginPath();
    let started=false;
    const N=220;
    for(let i=0;i<=N;i++){
      const t=i/N;
      const q=f(t);
      const x=q.x, y=q.y;
      const zz = Math.sqrt(Math.max(0, 1 - x*x - y*y));
      let p={x,y,z:zz};
      p=rotY(p, orbitX); p=rotX(p, orbitY);
      if(p.z < -0.08){ started=false; continue; }
      const pr=project(p,R);
      const sx=cx+pr.x, sy=cy+pr.y;

      const edge = clamp((p.z - 0.05)/0.35, 0, 1);
      const a = (0.25 + 0.75*edge);
      const w = Math.max(1, (seamW - seamGap)) * (0.9 + 0.1*edge);

      if(!started){ ctx.moveTo(sx,sy); started=true; }
      else{
        ctx.strokeStyle = `rgba(0,0,0,${a})`;
        ctx.lineWidth = w;
        ctx.lineCap="round"; ctx.lineJoin="round";
        ctx.lineTo(sx,sy);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(sx,sy);
      }
    }
  }
  strokeChannel(top);
  strokeChannel(bot);

  ctx.globalCompositeOperation="source-over";
}

/* glass sphere WITHOUT highlight streaks / internal arcs */
function drawGlassBall(cx, cy, R, orbitX, orbitY){
  ctx.fillStyle="rgba(0,0,0,0.16)";
  ctx.fillRect(0,0,W,H);

  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, R, 0, Math.PI*2);
  ctx.clip();

  const glassA = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--glassA")) || 0.18;

  // refractive interior gradients only (no extra “inside spheres/arcs”)
  const hx = cx + R*(0.22 + orbitX*0.16);
  const hy = cy - R*(0.24 + orbitY*0.12);

  const g1 = ctx.createRadialGradient(hx, hy, R*0.06, cx, cy, R*1.18);
  g1.addColorStop(0, `rgba(255,255,255,${glassA})`);
  g1.addColorStop(0.40, `rgba(255,255,255,${glassA*0.40})`);
  g1.addColorStop(0.85, `rgba(255,255,255,${glassA*0.08})`);
  g1.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle=g1;
  ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.fill();

  // limb darkening (keeps it spherical, not a disc)
  const g2 = ctx.createRadialGradient(cx, cy, R*0.18, cx, cy, R*1.02);
  g2.addColorStop(0, "rgba(0,0,0,0)");
  g2.addColorStop(0.62, "rgba(0,0,0,0.10)");
  g2.addColorStop(0.86, "rgba(0,0,0,0.46)");
  g2.addColorStop(1, "rgba(0,0,0,0.70)");
  ctx.fillStyle=g2;
  ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.fill();

  // seams
  drawTennisSeams(cx, cy, R, orbitX, orbitY);

  ctx.restore();

  // rim
  const rimA = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--rimA")) || 0.36;
  ctx.strokeStyle=`rgba(255,255,255,${rimA})`;
  ctx.lineWidth=2.2*DPR;
  ctx.beginPath();
  ctx.arc(cx, cy, R-1.2*DPR, 0, Math.PI*2);
  ctx.stroke();
}

function render(now){
  // orbit smoothing
  const targetOX = STATE.mx*0.60;
  const targetOY = STATE.my*0.42;
  STATE.orbitX = lerp(STATE.orbitX, targetOX, 0.08);
  STATE.orbitY = lerp(STATE.orbitY, targetOY, 0.08);

  // gentle auto spin (keeps it alive without “effects”)
  STATE.spin += 0.010;
  const ox = STATE.orbitX + Math.sin(STATE.spin)*0.08;
  const oy = STATE.orbitY + Math.cos(STATE.spin*0.8)*0.06;

  // bounce progression
  if(STATE.bouncing){
    const T = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--bounceT")) || 1050;
    STATE.bProg = clamp((now - STATE.bStart)/T, 0, 1);
    if(STATE.bProg >= 1){
      STATE.bouncing = false;
      STATE.bProg = 0;
    }
  }

  const { z, squash, stretch } = bounceCurve(STATE.bouncing ? STATE.bProg : 0);

  const baseR = Math.min(W,H) * 0.24;
  const farScale = 0.12;
  const s = lerp(1.0, farScale, z);

  const sx = s * squash;
  const sy = s * stretch;

  ctx.clearRect(0,0,W,H);

  const cx = W/2;
  const cy = H/2;

  ctx.save();
  ctx.translate(cx, cy);
  ctx.scale(sx, sy);
  ctx.translate(-cx, -cy);

  drawGlassBall(cx, cy, baseR, ox, oy);

  ctx.restore();

  // minimal frame tick
  ctx.strokeStyle="rgba(255,255,255,0.06)";
  ctx.lineWidth=1*DPR;
  ctx.strokeRect(10*DPR,10*DPR, W-20*DPR, H-20*DPR);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>

<!--
AE: KETA_MONO_GLASS_TENNIS
EE: glass-sphere + tennis seams (non-intersect) + z-bounce + orbit
WB: single-file_html

FILE_ID: KETA-GLASS-TENNIS-002
ROOM_ID: BASE
VERSION: v1.0
UPDATED_AT: 2026-01-08
CHANGELOG:
- Removed specular highlight streaks
- Removed internal caustic arcs (“inside spheres”)
- Kept spherical read via limb darkening + rim
- Kept seams with inner channel gap
- Kept Z-axis bounce + impact squash/stretch + orbit
-->
</body>
</html>
