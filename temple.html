<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA // TEMPLE</title>
  <style>
    :root{
      --bg:#000;
      --ink:rgba(255,255,255,.90);
      --muted:rgba(255,255,255,.60);
      --line:rgba(255,255,255,.12);
      --panel:rgba(0,0,0,.55);

      --r:0px;
      --pad:12px;

      /* TEMPLE TYPE: keep it neutral */
      --font: Arial, Helvetica, sans-serif;
    }

    *{ box-sizing:border-box; margin:0; padding:0; }
    html,body{ width:100%; height:100%; overflow:hidden; background:var(--bg); }
    body{ font-family: var(--font); color: var(--ink); }

    canvas{
      display:block;
      width:100%;
      height:100%;
    }

    /* --- Temple HUD (minimal, not “slop”) --- */
    #hud{
      position:fixed;
      inset:0;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:space-between;
      padding:18px 18px;
      mix-blend-mode: screen;
    }

    #hudTop{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      text-align:center;
      font-size:11px;
      letter-spacing:.22em;
      text-transform:uppercase;
      opacity:.88;
    }

    #hudMid{
      text-align:center;
      font-size: clamp(14px, 1.8vw, 18px);
      text-transform:uppercase;
      letter-spacing:.22em;
      opacity:.78;
      max-width: min(980px, 92vw);
      line-height: 1.35;
    }

    #hudBot{
      text-align:center;
      font-size:10px;
      letter-spacing:.20em;
      text-transform:uppercase;
      opacity:.50;
    }

    .pill{
      display:inline-flex;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.16);
      background: radial-gradient(circle at top left, rgba(255,255,255,.16), rgba(0,0,0,.10));
      backdrop-filter: blur(8px);
    }

    /* --- Control panel (collapsible) --- */
    #panel{
      position:fixed;
      top:12px;
      left:12px;
      width: min(520px, calc(100vw - 24px));
      border:1px solid var(--line);
      background: rgba(0,0,0,.52);
      border-radius: var(--r);
      backdrop-filter: blur(8px);
      z-index:30;
      pointer-events:auto;
      box-shadow: 0 22px 90px rgba(0,0,0,.55);
    }

    #panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }

    #panelTitle{
      font-size:12px;
      letter-spacing:.18em;
      text-transform:uppercase;
      font-weight:700;
      color: rgba(255,255,255,.92);
      white-space:nowrap;
    }

    #panelStatus{
      font-size:11px;
      color: rgba(255,255,255,.60);
      letter-spacing:.02em;
      text-align:right;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width: 260px;
    }

    #panelBtns{ display:flex; gap:8px; align-items:center; }
    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      color: rgba(255,255,255,.90);
      padding:6px 8px;
      font-size:11px;
      cursor:pointer;
      text-transform:lowercase;
      border-radius: var(--r);
    }
    .btn:hover{ border-color: rgba(255,255,255,.22); }

    #controls{
      padding:12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .field{
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.02);
      padding:10px;
    }
    label{
      display:block;
      font-size:11px;
      color: rgba(255,255,255,.65);
      letter-spacing:.10em;
      text-transform:uppercase;
      margin-bottom:6px;
    }
    input[type="range"], select{ width:100%; }
    select{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.35);
      color: rgba(255,255,255,.92);
      padding:8px 10px;
      font-size:12px;
      outline:none;
    }

    .row{ grid-column: 1 / -1; display:flex; gap:8px; flex-wrap:wrap; }
    .row .btn{ padding:8px 10px; font-size:12px; text-transform:uppercase; letter-spacing:.12em; font-weight:700; }

    /* collapse behavior */
    body.panel-collapsed #controls{ display:none; }
    body.panel-hidden #panel{
      transform: translateX(calc(-100% - 18px));
      opacity:0;
      pointer-events:none;
    }

    /* Minimal hint */
    #hint{
      position:fixed;
      left:12px;
      bottom:12px;
      font-size:10px;
      letter-spacing:.18em;
      text-transform:uppercase;
      opacity:.38;
      pointer-events:none;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.40);
      padding:8px 10px;
      border-radius: var(--r);
      backdrop-filter: blur(6px);
    }

    @media (max-width: 820px){
      #controls{ grid-template-columns: 1fr; }
      #panelStatus{ max-width: 160px; }
    }

    @media (prefers-reduced-motion: reduce){
      canvas{ animation:none !important; }
    }
  </style>
</head>
<body>
  <canvas id="templeCanvas"></canvas>

  <!-- Temple overlay copy (reworked) -->
  <div id="hud" aria-hidden="true">
    <div id="hudTop">
      <span class="pill">KETADATA // TEMPLE</span>
      <span class="pill" id="modePill">FIELD: CALM</span>
    </div>

    <div id="hudMid">
      ENTER A STEADY FIELD<br/>
      REDUCE EDGE-NOISE · HOLD FORM · RELEASE SIGNAL
      <div style="margin-top:10px; font-size:9px; opacity:.75;">
        <span class="pill">NO ADVICE · NO PROMISES · JUST CALIBRATION</span>
      </div>
    </div>

    <div id="hudBot">
      TEMPLE ACTIVE · BREATH OPTIONAL · ATTENTION STABILIZED
    </div>
  </div>

  <!-- Collapsible control panel -->
  <div id="panel" role="region" aria-label="Temple Controls">
    <div id="panelHeader">
      <div>
        <div id="panelTitle">TEMPLE CONTROLS</div>
        <div id="panelStatus">calm · bands 36 · blobs 18 · grain 0.09</div>
      </div>
      <div id="panelBtns">
        <button class="btn" id="collapseBtn" title="H">collapse</button>
        <button class="btn" id="hideBtn" title="Shift+H">hide</button>
      </div>
    </div>

    <div id="controls">
      <div class="field" style="grid-column:1/-1">
        <label>field mode</label>
        <select id="mode">
          <option value="calm">calm</option>
          <option value="aura">aura</option>
          <option value="static">static</option>
          <option value="deep">deep</option>
        </select>
      </div>

      <div class="field">
        <label>bands</label>
        <input id="bands" type="range" min="8" max="72" value="36" />
      </div>

      <div class="field">
        <label>band drift</label>
        <input id="bandDrift" type="range" min="0" max="1" step="0.01" value="0.55" />
      </div>

      <div class="field">
        <label>blobs</label>
        <input id="blobCount" type="range" min="0" max="30" value="18" />
      </div>

      <div class="field">
        <label>blob intensity</label>
        <input id="blobIntensity" type="range" min="0" max="1" step="0.01" value="0.80" />
      </div>

      <div class="field">
        <label>grain</label>
        <input id="grain" type="range" min="0" max="0.25" step="0.005" value="0.09" />
      </div>

      <div class="field">
        <label>grain step</label>
        <input id="grainStep" type="range" min="2" max="10" step="1" value="4" />
      </div>

      <div class="field" style="grid-column:1/-1">
        <label>floating phrases</label>
        <select id="phrases">
          <option value="off">off</option>
          <option value="sparse">sparse</option>
          <option value="normal" selected>normal</option>
        </select>
      </div>

      <div class="row">
        <button class="btn" id="reseed">reseed</button>
        <button class="btn" id="toggleHud">toggle hud</button>
        <button class="btn" id="reset">reset</button>
      </div>
    </div>
  </div>

  <div id="hint">H collapse · Shift+H hide · Space toggle temple copy · R reseed</div>

  <script>
    // TEMPLE REMAKE derived from your SLOPSTREAM canvas engine (bands/blobs/grain/text). :contentReference[oaicite:1]{index=1}

    const canvas = document.getElementById("templeCanvas");
    const ctx = canvas.getContext("2d");

    function resize(){
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resize);
    resize();

    // UI nodes
    const modeEl = document.getElementById("mode");
    const bandsEl = document.getElementById("bands");
    const bandDriftEl = document.getElementById("bandDrift");
    const blobCountEl = document.getElementById("blobCount");
    const blobIntensityEl = document.getElementById("blobIntensity");
    const grainEl = document.getElementById("grain");
    const grainStepEl = document.getElementById("grainStep");
    const phrasesEl = document.getElementById("phrases");

    const reseedBtn = document.getElementById("reseed");
    const toggleHudBtn = document.getElementById("toggleHud");
    const resetBtn = document.getElementById("reset");

    const collapseBtn = document.getElementById("collapseBtn");
    const hideBtn = document.getElementById("hideBtn");

    const hud = document.getElementById("hud");
    const modePill = document.getElementById("modePill");
    const panelStatus = document.getElementById("panelStatus");

    // panel persistence
    const KEY_COLLAPSED = "ketadata_temple_panel_collapsed";
    const KEY_HIDDEN = "ketadata_temple_panel_hidden";

    function setCollapsed(on){
      document.body.classList.toggle("panel-collapsed", !!on);
      try{ localStorage.setItem(KEY_COLLAPSED, on ? "1" : "0"); }catch(_){}
    }
    function setHidden(on){
      document.body.classList.toggle("panel-hidden", !!on);
      try{ localStorage.setItem(KEY_HIDDEN, on ? "1" : "0"); }catch(_){}
    }
    (function loadPanelPrefs(){
      try{
        setCollapsed((localStorage.getItem(KEY_COLLAPSED) || "0") === "1");
        setHidden((localStorage.getItem(KEY_HIDDEN) || "0") === "1");
      }catch(_){}
    })();

    collapseBtn.addEventListener("click", () => setCollapsed(!document.body.classList.contains("panel-collapsed")));
    hideBtn.addEventListener("click", () => setHidden(!document.body.classList.contains("panel-hidden")));

    // Time base
    let t = 0;

    // RNG reseed
    function reseed(){
      initBlobs();
      floatingText.length = 0;
    }

    // Blobs
    const blobs = [];
    function initBlobs(){
      blobs.length = 0;
      const count = Number(blobCountEl.value);
      for (let i=0;i<count;i++){
        blobs.push({
          x: Math.random(),
          y: Math.random(),
          r: 90 + Math.random() * 260,
          speedX: (Math.random() - 0.5) * 0.0007,
          speedY: (Math.random() - 0.5) * 0.0007,
          phase: Math.random() * Math.PI * 2,
          hueShift: Math.random() * 360
        });
      }
    }

    // Temple phrases (not “slop”)
    const phrases = [
      "HOLD FORM WITHOUT FORCE",
      "REDUCE EDGE-NOISE",
      "LET SIGNAL SETTLE",
      "RELEASE EXCESS CONTROL",
      "STABILIZE THE FIELD",
      "SLOW THE INTERPRETER",
      "NO PERFORMANCE REQUIRED",
      "RETURN TO CENTER",
      "LET THE LAYER DROP",
      "ATTENTION WITHOUT GRIP",
      "SOFTEN THE OUTLINE",
      "KEEP THE CHANNEL CLEAR"
    ];

    const floatingText = [];
    const MAX_TEXT = 6;

    function spawnText(){
      if (floatingText.length >= MAX_TEXT) return;
      const text = phrases[Math.floor(Math.random() * phrases.length)];
      floatingText.push({
        text,
        x: Math.random(),
        y: Math.random(),
        life: 0,
        maxLife: 9000 + Math.random() * 9000,
        driftX: (Math.random() - 0.5) * 0.000035,
        driftY: (Math.random() - 0.5) * 0.000035,
        size: 14 + Math.random() * 10
      });
    }

    // Visibility
    let hudVisible = true;
    let phraseMode = "normal"; // off | sparse | normal

    // Noise helper (same structure as your original)
    function smoothNoise(x, y, seed){
      return (
        Math.sin(x * 1.7 + seed * 0.37 + Math.cos(y * 0.9 + seed * 0.53)) +
        Math.sin(x * 0.6 + seed * 1.23 + Math.sin(y * 1.4 + seed * 0.11))
      ) * 0.5;
    }

    // Mode palettes (Temple: restrained)
    function palette(mode){
      switch(mode){
        case "aura":
          return {
            bg0: "hsl(275, 55%, 6%)",
            bg1: "hsl(205, 70%, 4%)",
            hueBase: 210,
            hueSpan: 90,
            blobSat: 85,
            blobLum0: 74,
            blobLum1: 58,
            blobLum2: 44
          };
        case "static":
          return {
            bg0: "hsl(240, 25%, 5%)",
            bg1: "hsl(210, 25%, 4%)",
            hueBase: 190,
            hueSpan: 50,
            blobSat: 35,
            blobLum0: 70,
            blobLum1: 52,
            blobLum2: 40
          };
        case "deep":
          return {
            bg0: "hsl(260, 55%, 4%)",
            bg1: "hsl(200, 75%, 3%)",
            hueBase: 205,
            hueSpan: 70,
            blobSat: 90,
            blobLum0: 72,
            blobLum1: 54,
            blobLum2: 40
          };
        case "calm":
        default:
          return {
            bg0: "hsl(265, 45%, 5%)",
            bg1: "hsl(205, 60%, 4%)",
            hueBase: 205,
            hueSpan: 60,
            blobSat: 80,
            blobLum0: 70,
            blobLum1: 54,
            blobLum2: 40
          };
      }
    }

    function drawBackground(w, h){
      const p = palette(modeEl.value);
      const drift = Number(bandDriftEl.value);

      // base gradient
      const grad = ctx.createLinearGradient(0, 0, w, h);
      grad.addColorStop(0, p.bg0);
      grad.addColorStop(1, p.bg1);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);

      // bands
      const bands = Number(bandsEl.value);
      for (let i=0;i<bands;i++){
        const y = (h / bands) * i;
        const n = smoothNoise(i * 0.22, t * 0.0004 * (0.4 + drift), 7.3);
        const hue = p.hueBase + n * p.hueSpan + Math.sin(t * 0.00012 + i * 0.18) * (p.hueSpan * 0.35);
        const alpha = 0.08 + (n + 1) * 0.05;

        ctx.globalAlpha = alpha;
        const bandGrad = ctx.createLinearGradient(0, y, w, y + h / bands);
        bandGrad.addColorStop(0, `hsla(${hue}, 80%, 50%, 0.0)`);
        bandGrad.addColorStop(0.5, `hsla(${hue}, 85%, 58%, 0.40)`);
        bandGrad.addColorStop(1, `hsla(${hue + 28}, 90%, 64%, 0.0)`);

        ctx.fillStyle = bandGrad;
        ctx.fillRect(0, y - 40, w, h / bands + 80);
      }

      ctx.globalAlpha = 1;
    }

    function drawBlobs(w, h){
      const p = palette(modeEl.value);
      const inten = Number(blobIntensityEl.value);

      ctx.globalCompositeOperation = "screen";

      for (const b of blobs){
        b.x += b.speedX;
        b.y += b.speedY;
        b.phase += 0.00035;

        if (b.x < -0.2) b.x = 1.2;
        if (b.x > 1.2) b.x = -0.2;
        if (b.y < -0.2) b.y = 1.2;
        if (b.y > 1.2) b.y = -0.2;

        const cx = b.x * w;
        const cy = b.y * h;

        const pulse = 0.6 + Math.sin(b.phase + t * 0.00012) * 0.4;
        const radius = b.r * (0.80 + pulse * 0.50);

        const hueBase =
          p.hueBase +
          Math.sin(t * 0.00008 + b.hueShift) * (p.hueSpan * 0.65) +
          Math.sin(b.phase * 2.1) * (p.hueSpan * 0.35);

        const grad = ctx.createRadialGradient(cx, cy, radius * 0.1, cx, cy, radius);
        grad.addColorStop(0, `hsla(${hueBase}, ${p.blobSat}%, ${p.blobLum0}%, ${0.85*inten})`);
        grad.addColorStop(0.4, `hsla(${hueBase + 26}, ${p.blobSat}%, ${p.blobLum1}%, ${0.65*inten})`);
        grad.addColorStop(1, `hsla(${hueBase + 58}, ${p.blobSat}%, ${p.blobLum2}%, 0.0)`);

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.globalCompositeOperation = "source-over";
    }

    function drawGrain(w, h){
      const density = Number(grainEl.value);
      const step = Number(grainStepEl.value);

      if (density <= 0) return;

      ctx.fillStyle = "#000";
      for (let y=0;y<h;y+=step){
        for (let x=0;x<w;x+=step){
          if (Math.random() < density){
            const n = smoothNoise(x * 0.07, y * 0.07, t * 0.0007);
            ctx.globalAlpha = 0.05 + (n + 1) * 0.05;
            ctx.fillRect(x, y, step, step);
          }
        }
      }
      ctx.globalAlpha = 1;
    }

    function drawFloatingText(w, h, deltaMs){
      const mode = phrasesEl.value; // off | sparse | normal
      if (mode === "off") return;

      const spawnProb = (mode === "sparse") ? 0.0025 : 0.0065;
      if (Math.random() < spawnProb) spawnText();

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (let i=floatingText.length - 1; i>=0; i--){
        const item = floatingText[i];
        item.life += deltaMs;
        item.x += item.driftX * deltaMs;
        item.y += item.driftY * deltaMs;

        const lifeRatio = item.life / item.maxLife;
        const alpha = Math.sin(Math.PI * lifeRatio);

        if (lifeRatio >= 1){
          floatingText.splice(i, 1);
          continue;
        }

        const x = item.x * w;
        const y = item.y * h;

        ctx.save();
        ctx.translate(x, y);
        ctx.shadowBlur = 26;
        ctx.shadowColor = "rgba(0,0,0,0.85)";
        ctx.font = `700 ${item.size}px Arial, Helvetica, sans-serif`;

        // restrained split (Temple: subtle)
        ctx.globalAlpha = alpha * 0.25;
        ctx.fillStyle = "rgba(170,255,250,0.9)";
        ctx.fillText(item.text, 1, 1);

        ctx.globalAlpha = alpha * 0.25;
        ctx.fillStyle = "rgba(255,170,245,0.9)";
        ctx.fillText(item.text, -1, 0);

        ctx.globalAlpha = alpha * 0.85;
        ctx.fillStyle = "rgba(245,245,245,0.92)";
        ctx.fillText(item.text, 0, 0);

        ctx.restore();
      }
    }

    function updateStatus(){
      const m = modeEl.value;
      modePill.textContent = `FIELD: ${m.toUpperCase()}`;
      panelStatus.textContent =
        `${m} · bands ${bandsEl.value} · blobs ${blobCountEl.value} · grain ${grainEl.value}`;
    }

    function applyControls(){
      // Re-init blobs if count changed
      initBlobs();
      updateStatus();
    }

    // controls
    modeEl.addEventListener("change", updateStatus);
    bandsEl.addEventListener("input", updateStatus);
    bandDriftEl.addEventListener("input", updateStatus);

    blobCountEl.addEventListener("input", () => { initBlobs(); updateStatus(); });
    blobIntensityEl.addEventListener("input", updateStatus);

    grainEl.addEventListener("input", updateStatus);
    grainStepEl.addEventListener("input", updateStatus);

    phrasesEl.addEventListener("change", updateStatus);

    reseedBtn.addEventListener("click", () => { reseed(); updateStatus(); });
    resetBtn.addEventListener("click", () => {
      modeEl.value = "calm";
      bandsEl.value = "36";
      bandDriftEl.value = "0.55";
      blobCountEl.value = "18";
      blobIntensityEl.value = "0.80";
      grainEl.value = "0.09";
      grainStepEl.value = "4";
      phrasesEl.value = "normal";
      applyControls();
    });

    toggleHudBtn.addEventListener("click", () => {
      hudVisible = !hudVisible;
      hud.style.display = hudVisible ? "flex" : "none";
    });

    // init
    applyControls();

    // Animation loop
    let lastTime = performance.now();
    function loop(now){
      const deltaMs = now - lastTime;
      lastTime = now;
      t += deltaMs;

      const w = window.innerWidth;
      const h = window.innerHeight;

      drawBackground(w, h);
      drawBlobs(w, h);
      drawGrain(w, h);
      drawFloatingText(w, h, deltaMs);

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Keyboard
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();

      // Space toggles temple copy overlay
      if (e.code === "Space"){
        e.preventDefault();
        hudVisible = !hudVisible;
        hud.style.display = hudVisible ? "flex" : "none";
      }

      // R reseed
      if (k === "r"){
        reseed();
        updateStatus();
      }

      // H collapse panel; Shift+H hide panel
      if (k === "h" && !e.metaKey && !e.ctrlKey){
        e.preventDefault();
        if (e.shiftKey) setHidden(!document.body.classList.contains("panel-hidden"));
        else setCollapsed(!document.body.classList.contains("panel-collapsed"));
      }
    });
  </script>
</body>
</html>
