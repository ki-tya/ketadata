<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA ROUTER — TERRARIUM ORGANISM (BRUTAL / EASY)</title>
  <style>
    :root{
      --bg:#ffffff; --fg:#111111; --muted:#7a7a7a; --line:#cfcfcf;
      --panel:#f2f2f2;
      --font:12px/1.15 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:var(--font);overflow:hidden;}
    *{box-sizing:border-box;}

    /* whole-page invert */
    html.invert{
      --bg:#0b0b0b; --fg:#f2f2f2; --muted:#a0a0a0; --line:#3a3a3a;
      --panel:#111111;
    }

    /* NULL */
    html.null #hud, html.null #side, html.null #corner{display:none;}

    #canvas{position:fixed;inset:0;display:block;}

    /* HUD: lighter footprint, more easygoing */
    #hud{
      position:fixed;left:10px;top:10px;z-index:50;
      width:640px;max-width:calc(100vw - 20px);
      background:rgba(0,0,0,0.03);
      border:1px solid var(--line);
      padding:6px;
      backdrop-filter: blur(4px);
      user-select:none;
    }
    html.invert #hud{background:rgba(255,255,255,0.03);}
    #hud .row{display:flex;gap:6px;flex-wrap:wrap;align-items:center;}
    #hud .row + .row{margin-top:6px;}
    #hud button, #hud select, #hud input{
      font:var(--font);
      padding:4px 6px;
      background:transparent;
      border:1px solid var(--line);
      color:var(--fg);
    }
    #hud button{cursor:pointer;}
    #hud .pill{display:inline-block;padding:3px 6px;border:1px solid var(--line);background:transparent;color:var(--muted);}
    #hud .label{color:var(--muted);}
    #hud .sp{flex:1;}
    #hud input[type="range"]{padding:0;height:22px;}

    #side{
      position:fixed;right:10px;top:10px;z-index:60;
      width:390px;max-height:calc(100vh - 20px);
      background:rgba(0,0,0,0.03);
      border:1px solid var(--line);
      padding:8px;overflow:auto;display:none;
      backdrop-filter: blur(4px);
    }
    html.invert #side{background:rgba(255,255,255,0.03);}
    #side .t{color:var(--muted);}
    #side .a{color:var(--fg);word-break:break-all;}
    #side .btns{margin-top:6px;display:flex;gap:6px;flex-wrap:wrap;}
    #side button{font:var(--font);padding:4px 6px;background:transparent;border:1px solid var(--line);cursor:pointer;color:var(--fg);}

    #corner{position:fixed;left:10px;bottom:10px;z-index:40;color:var(--muted);user-select:none;}

    /* Terrarium glass: less “effect”, more brutal / subtle */
    #glass{
      position:fixed;inset:0;pointer-events:none;z-index:20;
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,.10),
        inset 0 0 120px rgba(0,0,0,.07),
        inset 0 0 260px rgba(0,0,0,.10);
      opacity:.55;
      mix-blend-mode:multiply;
    }
    html.invert #glass{
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.08),
        inset 0 0 120px rgba(255,255,255,.06),
        inset 0 0 260px rgba(255,255,255,.09);
      opacity:.45;
      mix-blend-mode:screen;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="glass"></div>

<div id="hud">
  <div class="row">
    <span class="pill">ROUTER / TERRARIUM ORGANISM</span>
    <span class="sp"></span>
    <span class="pill" id="pillRun">RUNNING</span>
    <span class="pill" id="pillSaved">LOCAL</span>
  </div>
  <div class="row">
    <button id="btnPause">PAUSE (SPACE)</button>
    <button id="btnRecenter">RECENTER</button>
    <button id="btnSettle">SETTLE</button>
    <span class="label">ZOOM</span>
    <button id="btnZoomOut">-</button>
    <button id="btnZoomIn">+</button>
    <span class="label">SPEED</span>
    <input id="speed" type="range" min="0" max="2" step="0.05" value="0.9" />
    <span class="label">DENSITY</span>
    <input id="density" type="range" min="0.3" max="1.8" step="0.05" value="0.95" />
    <span class="label">SOFT</span>
    <input id="soft" type="range" min="0" max="2" step="0.05" value="1.15" />
  </div>
  <div class="row">
    <span class="label">FILTER</span>
    <input id="q" type="text" placeholder="search filename..." />
    <span class="label">SHOW</span>
    <select id="visFilter">
      <option value="ALL">ALL</option>
      <option value="PUBLIC">PUBLIC</option>
      <option value="PRIVATE">PRIVATE</option>
      <option value="UNSET">UNSET</option>
    </select>
    <button id="btnExportPublic">EXPORT PUBLIC</button>
    <button id="btnExportAll">EXPORT VIS</button>
    <button id="btnImport">IMPORT</button>
    <button id="btnResetVis">RESET VIS</button>
    <button id="btnNull">NULL (SHIFT+N)</button>
    <button id="btnInvert">INVERT (SHIFT+I)</button>
    <button id="btnFull">FULL (SHIFT+F)</button>
  </div>
</div>

<div id="side">
  <div class="t">SELECTED</div>
  <div class="a" id="selTitle"></div>
  <div class="t" style="margin-top:6px;">TYPE</div>
  <div class="a" id="selType"></div>
  <div class="t" style="margin-top:6px;">URL</div>
  <div class="a" id="selUrl"></div>
  <div class="t" style="margin-top:6px;">VISIBILITY</div>
  <div class="a" id="selVis"></div>
  <div class="btns">
    <button id="openNew">OPEN</button>
    <button id="copyUrl">COPY</button>
    <button id="toggleVis">TOGGLE PUBLIC/PRIVATE</button>
    <button id="closeSide">CLOSE</button>
  </div>
</div>

<div id="corner">WHEEL=ZOOM • DRAG EMPTY=PAN • DRAG NODE=PULL • CLICK LINK TWICE=OPEN</div>
<input id="filePick" type="file" accept="application/json" style="display:none" />

<script>
(() => {
  const BASE_URL = "https://ki-tya.github.io/ketadata/";

  const CLUSTERS = [
    { name:"KETA-CORE", links:["based_diva9.html","elevator3.html","index.html","index013.html","index11.html","map.html","room.html"]},
    { name:"BLEAK-TECH", links:["ball.html","beatball.html","blacklotus2.html","bleak.html","chakra.html","memofesto.html"]},
    { name:"SCREENS", links:["cctv1.html","crunch1.html","darkroom1.html","kdtv1.html","obscura.html"]},
    { name:"EXPERIMENTS", links:[
      "003.html","aniversary1111.html","artaud.html","bataille1.html","borges.html","burroughs.html","capture.html",
      "capturegpt.html","capturegpt2.html","capturegpt3.html","capturegpt4.html","capturegpt5.html","capturegpt6.html",
      "capturegpt7.html","capturegpt8.html","christmas25.html","chroma.html","coffee.html","coffee1.html","cp1.html",
      "cube.html","cube1.html","debord.html","deleuze.html","dmt.html","dmt2.html","dmt3.html","dmt4.html","dmtzoom.html",
      "etal.html","funnel.html","funnel1.html","funnel2.html","funnel3.html","funnel4.html","goffman.html","gptsubject.html",
      "holzer.html","hyperstition.html","hyperstition1.html","hyperstition2.html","hyperstition3.html","hyperstition5.html",
      "index0.html","index001.html","index002.html","index003.html","index004.html","index005.html","index006.html","index007.html",
      "index008.html","index009.html","index01.html","index011.html","index012.html","index014.html","index015.html","index02.html",
      "index03.html","index04.html","index05.html","index06.html","index07.html","index08.html","index09.html","infinity.html","jung.html",
      "kitty.html","kmas.html","land.html","mandala.html","mandala2.html","mandala3.html","mandalagpt.html","mandalagpt2.html",
      "mandalagpt3.html","mandalagpt4.html","matrix.html","matryoshka.html","mcluhan.html","mdma.html","mdma2.html","mdmagpt.html",
      "mdmagpt2.html","misc.html","misc2.html","misc3.html","misc4.html","misc5.html","misc6.html","misc7.html","misc8.html",
      "molecule.html","newtrap.html","newtrap2.html","newtrap3.html","polka1.html","polka2.html","polkadot.html","pool.html","pool3.html",
      "pool4.html","pool5.html","pool6.html","release.html","release2.html","release3.html","release4.html","ripple.html","ripple2.html",
      "ripple3.html","ripplegpt.html","sg.html","sg1.html","slopstream2.html","slopstream3.html","slopstream4.html","slopstream6.html",
      "snakes.html","sovereignty.html","subgpt2.html","subgpt3.html","subgpt4.html","subgpt5.html","sublime.html","substance.html",
      "substrate.html","substrate1.html","substrate3.html","teleo.html","teleo1.html","temple.html","temple1.html"
    ]},
    { name:"CONCEPTUAL ALIGNMENT", links:["2812.html","claude_cl3.html","concept_cl4.html","cp.html","depth.html","drugprotocol.html","fivethirtysix.html","intra.html","reading.html","widefield.html"]},
    { name:"BASE", links:["based_diva3.html","based_diva8.html","based_diva98.html","based_diva98x.html","based_diva9a.html","based_diva9b.html","based_diva9c.html","based_diva9d.html","based_diva9e.html","based_diva9f.html","based_diva9g.html","based_diva9h.html","based_diva9i.html","based_diva9ii.html","based_diva9iii.html","bbd1.html","bbd2.html","bbd3.html","diva.html","divabased4.html","re_diva9.html","systemkill.html"]},
    { name:"SYSTEM", links:["backbone.html","backbone1.html","backbone2.html","backend.html","claude_mockup.html","claude.html","contract.html","memofesto1.html","memofesto2.html","mockups.html","mockups1.html","mockups2.html","nav.html","pads.html","page.html"]},
    { name:"SYS-UTIL", links:["arranger.html","bugtest.html","debug.html","diagnostic.html","inspector.html","inspector1.html","linklist.html","linkorg4.html","main3.html","manifest.html","master2.html","mastergpt.html","monitor.html","primitive.html","primitive1.html","primitive2.html","primitive3.html","pulse.html","quota.html","reg.html","regv3.html","regv4.html","screenplane.html","screenplane1.html","storage.html","storage1.html","storagemanager.html","system8.html","version.html","videomanager.html"]},
    { name:"SYS-PR", links:["cashapp1.html","cashapp3.html","funding.html","shop.html","submit.html"]},
    { name:"TESTERS", links:["anniversary1.html","anniversary11.html","anniversary111.html","concept_cl.html","concept_cl1.html","concept_cl2.html","darkroom.html","doc5.html","index_copy.html","index_prev1.html","index01_tester.html","lib_cl.html","mandala88.html","master.html","master1.html","redroom.html","to-do.html","to-do1.html","vape-drive.html","vault.html","video.html","video2.html"]},
    { name:"SECRET", links:["67.html","page2.html"]},
    { name:"CORE", links:["deprecated.html","design1.html","lab.html","lab1.html","labyrinth.html","lib_gpt.html","linksv3.html","main2.html","sensory3.html","studiofront.html","studiov2.html","studiov3.html","tester3.html","tester31.html"]},
    { name:"CORE-UTIL", links:["acid_doc.html","artifact.html","board.html","board1.html","board2.html","board3.html","calendar1.html","controller.html","controller1.html","controller2.html","controller3.html","display1.html","doc2.html","manifest5.html","modern.html","pdf2jpeg7.html","sheets.html","studio.html","to-do2.html"]},
    { name:"DESIGN-UTIL", links:["color1.html","color3.html","font.html"]},
    { name:"PHOTOG-UTIL", links:["editor.html","studiov1.html"]},
    { name:"DATA-UTIL", links:["pdf2jpeg8.html"]},
    { name:"META-COG", links:["circle.html","libra.html"]},
    { name:"LLM-UTIL", links:["compiler.html","contextifier.html","d2.html","prompt.html","prompt1.html","prompt3.html","prompter.html"]},
    { name:"HTML-UTIL", links:["classifier.html","classifier1.html","forge3.html","forge4.html","forge5.html","forge7.html","html.html","metadata.html","metadata1.html","unifier.html"]},
    { name:"UI-UTIL", links:["color5.html","interfacer.html","interfacer1.html","interfacer2.html","lab3.html","lab9.html","system6.html"]},
  ];

  const STORE_VIS = "KD_ROUTER_VIS_V1";

  function makeUrl(path){ return /^https?:\/\//i.test(path) ? path : (BASE_URL + path.replace(/^\//,'')); }
  function makeId(cluster, path){ return `${cluster}::${path}`; }
  function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  let vis = {};
  function loadVis(){
    try{
      const raw = localStorage.getItem(STORE_VIS);
      if(!raw) return;
      const parsed = JSON.parse(raw);
      if(parsed && parsed.vis && typeof parsed.vis === "object") vis = parsed.vis || {};
    }catch{}
  }
  function saveVis(){
    try{
      localStorage.setItem(STORE_VIS, JSON.stringify({ version:"KD_ROUTER_VIS_V1", updatedAt:new Date().toISOString(), vis }));
      pillSaved.textContent = "SAVED";
      setTimeout(()=>pillSaved.textContent="LOCAL", 650);
    }catch{}
  }
  function getVis(id){
    const v = vis[id];
    if(v==="PUBLIC" || v==="PRIVATE") return v;
    return "UNSET";
  }
  function toggleVis(id){
    const cur = getVis(id);
    vis[id] = (cur==="PUBLIC") ? "PRIVATE" : "PUBLIC";
    saveVis();
  }
  function resetVis(){ vis = {}; saveVis(); }

  // canvas
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  const cam = { x:0, y:0, z:1 };
  function screenToWorld(sx, sy){
    const cx = window.innerWidth/2, cy = window.innerHeight/2;
    return { x:(sx-cx)/cam.z+cam.x, y:(sy-cy)/cam.z+cam.y };
  }
  function worldToScreen(wx, wy){
    const cx = window.innerWidth/2, cy = window.innerHeight/2;
    return { x:(wx-cam.x)*cam.z+cx, y:(wy-cam.y)*cam.z+cy };
  }

  // graph
  const nodes = [];
  const edges = [];
  const nodeByKey = new Map();
  function addNode(n){ nodes.push(n); nodeByKey.set(n.key, n); return n; }
  function addEdge(a,b,rest){ edges.push({a,b,rest}); }

  function seeded(s){
    let h=2166136261>>>0;
    s=String(s);
    for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619)>>>0; }
    return (h%10000)/10000;
  }

  const CENTER_KEY="CENTER::KETADATA_ROUTER";
  addNode({ key:CENTER_KEY, type:"CENTER", label:"KETADATA ROUTER", url:"", x:0,y:0,vx:0,vy:0,r:22, pinned:true, seed:0.42 });

  // Layout: big “amoeba” loop with clusters along it (more organic, less rigid)
  const ring = [];
  const ringN = 20;
  for(let i=0;i<ringN;i++){
    const t = i/(ringN);
    const ang = t*Math.PI*2;
    ring.push({
      x: Math.cos(ang)*380 + Math.cos(ang*3)*90,
      y: Math.sin(ang)*260 + Math.sin(ang*2)*70
    });
  }

  CLUSTERS.forEach((c,i)=>{
    const s = seeded(c.name);
    const idx = Math.floor(s*(ringN-1));
    const a = ring[idx];
    const side = (seeded(c.name+"_side")>0.5)?1:-1;

    const cx = a.x + side*(180 + seeded(c.name+"_o")*240);
    const cy = a.y + (seeded(c.name+"_j")*2-1)*140;

    const cKey = `CLUSTER::${c.name}`;
    addNode({ key:cKey, type:"CLUSTER", label:c.name, url:"", x:cx,y:cy,vx:0,vy:0,r:16, seed:s });

    addEdge(CENTER_KEY, cKey, 280);

    c.links.forEach((p)=>{
      const id = makeId(c.name,p);
      const s2 = seeded(id);
      const k = `LINK::${id}`;

      const a2 = (s2*2-1)*2.2;
      const rr = 130 + s2*260;
      const lx = cx + Math.cos(a2)*rr + (seeded(id+"_x")*2-1)*50;
      const ly = cy + Math.sin(a2)*rr + (seeded(id+"_y")*2-1)*50;

      addNode({ key:k, type:"LINK", label:p, url:makeUrl(p), x:lx,y:ly,vx:0,vy:0,r:10, cluster:c.name, id, seed:s2 });
      addEdge(cKey, k, 160);
    });
  });

  // UI refs
  const pillRun=document.getElementById("pillRun");
  const pillSaved=document.getElementById("pillSaved");
  const btnPause=document.getElementById("btnPause");
  const btnRecenter=document.getElementById("btnRecenter");
  const btnSettle=document.getElementById("btnSettle");
  const btnZoomIn=document.getElementById("btnZoomIn");
  const btnZoomOut=document.getElementById("btnZoomOut");
  const speedEl=document.getElementById("speed");
  const densityEl=document.getElementById("density");
  const softEl=document.getElementById("soft");
  const btnExportPublic=document.getElementById("btnExportPublic");
  const btnExportAll=document.getElementById("btnExportAll");
  const btnImport=document.getElementById("btnImport");
  const btnResetVis=document.getElementById("btnResetVis");
  const btnNull=document.getElementById("btnNull");
  const btnInvert=document.getElementById("btnInvert");
  const btnFull=document.getElementById("btnFull");
  const filePick=document.getElementById("filePick");

  const side=document.getElementById("side");
  const selTitle=document.getElementById("selTitle");
  const selType=document.getElementById("selType");
  const selUrl=document.getElementById("selUrl");
  const selVis=document.getElementById("selVis");
  const openNew=document.getElementById("openNew");
  const copyUrl=document.getElementById("copyUrl");
  const toggleVisBtn=document.getElementById("toggleVis");
  const closeSide=document.getElementById("closeSide");

  let running=true;
  function setRunning(r){
    running=r;
    pillRun.textContent=r?"RUNNING":"PAUSED";
    btnPause.textContent=r?"PAUSE (SPACE)":"RUN (SPACE)";
  }

  function isVisibleByFilter(n){
    const q = qEl.value.trim().toLowerCase();
    const vf = visFilterEl.value;

    if(n.type==="LINK"){
      if(q && !n.label.toLowerCase().includes(q)) return false;
      const v = getVis(n.id);
      if(vf!=="ALL" && v!==vf) return false;
      return true;
    }
    if(q || vf!=="ALL"){
      if(n.type==="CLUSTER"){
        for(const e of edges){
          if(e.a===n.key){
            const child = nodeByKey.get(e.b);
            if(child && child.type==="LINK" && isVisibleByFilter(child)) return true;
          }
        }
        return false;
      }
      if(n.type==="CENTER") return true;
    }
    return true;
  }

  function filteredEdges(){
    return edges.filter(e=>{
      const A=nodeByKey.get(e.a), B=nodeByKey.get(e.b);
      return A && B && isVisibleByFilter(A) && isVisibleByFilter(B);
    });
  }

  // interaction
  let draggingCam=false;
  let draggingNode=null;
  let dragOff={x:0,y:0};
  let lastMouse={x:0,y:0};
  let hovered=null;
  let selected=null;

  function setSelected(n){
    selected=n;
    if(!n){ side.style.display="none"; return; }
    side.style.display="block";
    selTitle.textContent=n.label;
    selType.textContent=n.type;
    selUrl.textContent=n.url||"";
    if(n.type==="LINK"){
      selVis.textContent=getVis(n.id);
      toggleVisBtn.style.display="";
      openNew.style.display="";
      copyUrl.style.display="";
    }else{
      selVis.textContent="";
      toggleVisBtn.style.display="none";
      openNew.style.display="none";
      copyUrl.style.display="none";
    }
  }

  function nodeAt(sx,sy){
    const w=screenToWorld(sx,sy);
    let best=null, bestD=Infinity;
    for(const n of nodes){
      if(!isVisibleByFilter(n)) continue;
      const dx=w.x-n.x, dy=w.y-n.y;
      const d=Math.sqrt(dx*dx+dy*dy);
      const hitR=n.r+(n.type==="LINK"?9:11);
      if(d<hitR && d<bestD){ best=n; bestD=d; }
    }
    return best;
  }

  canvas.addEventListener("mousedown",(e)=>{
    const onHud = e.target && e.target.closest && e.target.closest("#hud");
    const onSide = e.target && e.target.closest && e.target.closest("#side");
    if(onHud||onSide) return;

    const hit=nodeAt(e.clientX,e.clientY);
    if(hit){
      draggingNode=hit;
      const w=screenToWorld(e.clientX,e.clientY);
      dragOff.x=w.x-hit.x; dragOff.y=w.y-hit.y;
      setSelected(hit);
    }else{
      draggingCam=true;
      lastMouse.x=e.clientX; lastMouse.y=e.clientY;
      setSelected(null);
    }
  });

  window.addEventListener("mousemove",(e)=>{
    hovered=nodeAt(e.clientX,e.clientY);
    if(draggingNode){
      const w=screenToWorld(e.clientX,e.clientY);
      draggingNode.x=w.x-dragOff.x; draggingNode.y=w.y-dragOff.y;
      draggingNode.vx*=0.25; draggingNode.vy*=0.25;
    }else if(draggingCam){
      const dx=(e.clientX-lastMouse.x)/cam.z;
      const dy=(e.clientY-lastMouse.y)/cam.z;
      cam.x-=dx; cam.y-=dy;
      lastMouse.x=e.clientX; lastMouse.y=e.clientY;
    }
  });

  window.addEventListener("mouseup",()=>{ draggingCam=false; draggingNode=null; });

  canvas.addEventListener("click",(e)=>{
    const onHud = e.target && e.target.closest && e.target.closest("#hud");
    const onSide = e.target && e.target.closest && e.target.closest("#side");
    if(onHud||onSide) return;

    const hit=nodeAt(e.clientX,e.clientY);
    if(hit && hit.type==="LINK"){
      if(selected && selected.key===hit.key){
        window.open(hit.url,"_blank","noopener,noreferrer");
      }
    }
  });

  canvas.addEventListener("wheel",(e)=>{
    const onHud = e.target && e.target.closest && e.target.closest("#hud");
    const onSide = e.target && e.target.closest && e.target.closest("#side");
    if(onHud||onSide) return;
    e.preventDefault();

    const before=screenToWorld(e.clientX,e.clientY);
    const zoom=Math.exp(-e.deltaY*0.0012);
    cam.z=Math.max(0.15,Math.min(3.5,cam.z*zoom));
    const after=screenToWorld(e.clientX,e.clientY);
    cam.x+=(before.x-after.x);
    cam.y+=(before.y-after.y);
  },{passive:false});

  // physics: more “easygoing” means more damping + less aggressive repulsion + softer springs
  function step(dt){
    const speed=parseFloat(speedEl.value||"1");
    const density=parseFloat(densityEl.value||"1");
    const soft=parseFloat(softEl.value||"1");
    const t=performance.now()*0.001;

    const eList=filteredEdges();

    const repulse = 1400 * density * (1.25/soft);
    const springK = 0.0085 * density * (1/soft);
    const damp = 0.94 - Math.min(0.06, (soft-1)*0.03);

    // repulsion (gentler)
    for(let i=0;i<nodes.length;i++){
      const A=nodes[i];
      if(!isVisibleByFilter(A)) continue;
      if(A.pinned){ A.vx=0; A.vy=0; continue; }
      for(let j=i+1;j<nodes.length;j++){
        const B=nodes[j];
        if(!isVisibleByFilter(B)) continue;
        if(B.pinned) continue;

        const dx=B.x-A.x, dy=B.y-A.y;
        const d2=dx*dx+dy*dy+0.001;
        const d=Math.sqrt(d2);
        const minD=(A.r+B.r+20);
        const squeeze = d<minD ? 2.0 : 1.0;
        const f=(repulse/d2)*squeeze;
        const ux=dx/d, uy=dy/d;

        A.vx-=ux*f*0.002;
        A.vy-=uy*f*0.002;
        B.vx+=ux*f*0.002;
        B.vy+=uy*f*0.002;
      }
    }

    // tendons (sine tension)
    for(const e of eList){
      const A=nodeByKey.get(e.a), B=nodeByKey.get(e.b);
      const dx=B.x-A.x, dy=B.y-A.y;
      const d=Math.sqrt(dx*dx+dy*dy)+0.001;
      const diff=d-e.rest;
      const ux=dx/d, uy=dy/d;

      const pulse = 1 + Math.sin(t*0.95 + (A.seed||0)*7 + (B.seed||0)*9) * (0.09 * soft);
      const f = diff * springK * pulse;

      if(!A.pinned && draggingNode!==A){ A.vx+=ux*f; A.vy+=uy*f; }
      if(!B.pinned && draggingNode!==B){ B.vx-=ux*f; B.vy-=uy*f; }
    }

    // organism drift (more easygoing: slower, smoother)
    for(const n of nodes){
      if(!isVisibleByFilter(n)) continue;
      if(n.pinned) continue;
      if(draggingNode===n) continue;

      const s=n.seed||0.5;

      if(n.type==="CLUSTER"){
        n.vx += Math.sin(t*0.55 + s*7) * 0.05 * speed * soft;
        n.vy += Math.cos(t*0.50 + s*9) * 0.05 * speed * soft;
      }
      if(n.type==="LINK"){
        n.vx += Math.sin(t*0.95 + s*17) * 0.022 * speed * soft;
        n.vy += Math.cos(t*0.88 + s*19) * 0.022 * speed * soft;
      }
    }

    // integrate
    for(const n of nodes){
      if(!isVisibleByFilter(n)) continue;
      if(n.pinned) continue;
      if(draggingNode===n) continue;

      n.vx*=damp;
      n.vy*=damp;

      n.x += n.vx*(dt/16)*speed;
      n.y += n.vy*(dt/16)*speed;
    }
  }

  // drawing: more organic brutalism
  function draw(){
    const W=window.innerWidth, H=window.innerHeight;
    ctx.clearRect(0,0,W,H);

    const bg=cssVar("--bg");
    const fg=cssVar("--fg");
    const muted=cssVar("--muted");
    const line=cssVar("--line");
    const soft=parseFloat(softEl.value||"1");
    const t=performance.now()*0.001;

    // brutal grid (less loud)
    ctx.save();
    ctx.globalAlpha=0.14;
    ctx.strokeStyle=line;
    ctx.lineWidth=1;
    ctx.beginPath();
    const g=72;
    for(let x=0;x<=W;x+=g){ ctx.moveTo(x,0); ctx.lineTo(x,H); }
    for(let y=0;y<=H;y+=g){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
    ctx.stroke();
    ctx.restore();

    // terrarium “air” (subtle)
    ctx.save();
    ctx.globalAlpha=0.10;
    ctx.strokeStyle=line;
    ctx.lineWidth=1;
    for(let i=0;i<10;i++){
      const y=(i/9)*H;
      ctx.beginPath();
      for(let x=0;x<=W;x+=32){
        const yy=y + Math.sin(x*0.01 + i*0.9 + t*0.35) * (6 + i*0.2);
        if(x===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
      }
      ctx.stroke();
    }
    ctx.restore();

    // membrane blobs (organic but monochrome)
    const visible = nodes.filter(n=>isVisibleByFilter(n));
    ctx.save();
    ctx.globalAlpha=0.20 + (soft-1)*0.05;
    ctx.fillStyle=line;
    ctx.filter = `blur(${Math.max(8, 20*cam.z)}px)`;
    for(const n of visible){
      const p=worldToScreen(n.x,n.y);
      const baseR = (n.type==="CENTER")?36:(n.type==="CLUSTER"?26:15);
      const wob = 1 + Math.sin(t*0.9 + (n.seed||0)*9) * 0.10;
      ctx.beginPath();
      ctx.arc(p.x,p.y, baseR*wob, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.filter="none";
    ctx.restore();

    // edges as cords: one line, thicker, calmer
    const eList = filteredEdges();
    ctx.save();
    ctx.globalAlpha=0.95;
    ctx.strokeStyle=line;
    ctx.lineWidth=1.25;
    for(const e of eList){
      const A=nodeByKey.get(e.a), B=nodeByKey.get(e.b);
      const a=worldToScreen(A.x,A.y);
      const b=worldToScreen(B.x,B.y);

      const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
      const nx=-(b.y-a.y), ny=(b.x-a.x);
      const nd=Math.sqrt(nx*nx+ny*ny)+0.001;
      const ux=nx/nd, uy=ny/nd;

      const phase=(A.seed||0)*7+(B.seed||0)*9;
      const bend = (10 + soft*8) * Math.sin(t*0.8 + phase);

      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.quadraticCurveTo(mx+ux*bend, my+uy*bend, b.x,b.y);
      ctx.stroke();
    }
    ctx.restore();

    // nodes
    for(const n of visible){
      const p=worldToScreen(n.x,n.y);
      const isHover=hovered && hovered.key===n.key;
      const isSel=selected && selected.key===n.key;

      const r=n.r;

      // halo (chunky but soft)
      ctx.save();
      ctx.globalAlpha=0.18 + (isSel?0.18:0) + (isHover?0.10:0);
      ctx.fillStyle=line;
      ctx.beginPath();
      ctx.arc(p.x,p.y, r+10, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // core
      ctx.save();
      ctx.fillStyle=bg;
      ctx.strokeStyle=line;
      ctx.lineWidth=(isSel||isHover)?2:1;
      ctx.beginPath();
      ctx.arc(p.x,p.y, r, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // link nucleus
      if(n.type==="LINK"){
        const v=getVis(n.id);
        ctx.save();
        ctx.globalAlpha=0.85;
        ctx.fillStyle=(v==="PUBLIC")?fg:(v==="PRIVATE"?muted:line);
        ctx.beginPath();
        ctx.arc(p.x,p.y,3.2,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // label (uniform size, brutal)
      ctx.save();
      ctx.font="12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\",\"Courier New\", monospace";
      ctx.textBaseline="middle";
      const text=(n.type==="CENTER")?"KETADATA":n.label;
      const maxChars=(n.type==="LINK")?26:18;
      const label=text.length>maxChars?text.slice(0,maxChars-1)+"…":text;

      const offX=(n.type==="CENTER")?0:(r+9);
      const offY=(n.type==="CENTER")?(r+14):0;
      const tx=p.x+offX, ty=p.y+offY;

      ctx.textAlign=(n.type==="CENTER")?"center":"left";
      const w=ctx.measureText(label).width;
      const pad=3;

      ctx.globalAlpha=0.82;
      ctx.fillStyle=bg;
      ctx.fillRect(tx-(n.type==="CENTER"?w/2:0)-pad, ty-8, w+pad*2, 16);

      ctx.globalAlpha=1;
      ctx.fillStyle=(n.type==="LINK")?muted:fg;
      ctx.fillText(label, tx, ty);
      ctx.restore();
    }

    // terrarium depth vignette (gentle)
    ctx.save();
    const grad=ctx.createRadialGradient(W/2,H/2, Math.min(W,H)*0.20, W/2,H/2, Math.min(W,H)*0.78);
    grad.addColorStop(0,"rgba(0,0,0,0)");
    grad.addColorStop(1,"rgba(0,0,0,"+(document.documentElement.classList.contains("invert")?"0.16":"0.10")+")");
    ctx.fillStyle=grad;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  // downloads/import
  function download(filename, text){
    const blob=new Blob([text],{type:"application/json"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a");
    a.href=url; a.download=filename;
    document.body.appendChild(a);
    a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),800);
  }
  function importJSON(text){
    let parsed;
    try{ parsed=JSON.parse(text); }catch{ return; }
    if(!parsed || typeof parsed!=="object") return;
    if(parsed.vis && typeof parsed.vis==="object"){
      const next={};
      for(const k in parsed.vis){
        const v=parsed.vis[k];
        if(v==="PUBLIC"||v==="PRIVATE") next[k]=v;
      }
      vis=next; saveVis();
      if(selected && selected.type==="LINK") selVis.textContent=getVis(selected.id);
      return;
    }
    if(parsed.clusters && typeof parsed.clusters==="object"){
      const next={};
      for(const cname in parsed.clusters){
        const arr=parsed.clusters[cname];
        if(!Array.isArray(arr)) continue;
        arr.forEach(it=>{
          const p=it?.path, v=it?.visibility;
          if(typeof p!=="string") return;
          const id=makeId(cname,p);
          if(v==="PUBLIC"||v==="PRIVATE") next[id]=v;
        });
      }
      vis=next; saveVis();
      if(selected && selected.type==="LINK") selVis.textContent=getVis(selected.id);
    }
  }

  // controls
  btnPause.onclick=()=>setRunning(!running);
  btnRecenter.onclick=()=>{ cam.x=0; cam.y=0; cam.z=1; };
  btnSettle.onclick=()=>{
    // easygoing settle: bleed velocity + nudge toward stable
    for(const n of nodes){
      if(n.pinned) continue;
      n.vx*=0.25; n.vy*=0.25;
    }
  };
  btnZoomIn.onclick=()=>cam.z=Math.min(3.5, cam.z*1.15);
  btnZoomOut.onclick=()=>cam.z=Math.max(0.15, cam.z/1.15);

  openNew.onclick=()=>{ if(selected && selected.type==="LINK") window.open(selected.url,"_blank","noopener,noreferrer"); };
  copyUrl.onclick=async()=>{ if(!(selected && selected.type==="LINK")) return; try{ await navigator.clipboard.writeText(selected.url); }catch{} };
  toggleVisBtn.onclick=()=>{ if(!(selected && selected.type==="LINK")) return; toggleVis(selected.id); selVis.textContent=getVis(selected.id); };
  closeSide.onclick=()=>setSelected(null);

  btnExportPublic.onclick=()=>{
    const out={ fileId:"KETADATA_PUBLIC_LINKS_V1", updatedAt:new Date().toISOString(), baseUrl:BASE_URL, clusters:{} };
    CLUSTERS.forEach(c=>{
      out.clusters[c.name]=c.links.map(p=>({ path:p, url:makeUrl(p), visibility:getVis(makeId(c.name,p)) }))
        .filter(x=>x.visibility==="PUBLIC");
    });
    download("KD_public_links.json", JSON.stringify(out,null,2));
  };
  btnExportAll.onclick=()=>download("KD_visibility_map.json", JSON.stringify({ version:"KD_ROUTER_VIS_V1", updatedAt:new Date().toISOString(), vis }, null, 2));
  btnImport.onclick=()=>filePick.click();
  filePick.addEventListener("change", async ()=>{
    const f=filePick.files && filePick.files[0];
    if(!f) return;
    const text=await f.text();
    importJSON(text);
    filePick.value="";
  });
  btnResetVis.onclick=()=>{ resetVis(); if(selected && selected.type==="LINK") selVis.textContent=getVis(selected.id); };

  // system universals
  function toggleNull(){ document.documentElement.classList.toggle("null"); }
  function toggleInvert(){ document.documentElement.classList.toggle("invert"); }
  function toggleFull(){
    if(!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
  }
  btnNull.onclick=toggleNull;
  btnInvert.onclick=toggleInvert;
  btnFull.onclick=toggleFull;

  window.addEventListener("keydown",(e)=>{
    const tag=(document.activeElement && document.activeElement.tagName)?document.activeElement.tagName.toLowerCase():"";
    const typing=(tag==="input"||tag==="textarea");

    if(e.key===" " && !typing){ e.preventDefault(); setRunning(!running); return; }
    if(e.shiftKey && (e.key==="I"||e.key==="i")){ e.preventDefault(); toggleInvert(); return; }
    if(e.shiftKey && (e.key==="N"||e.key==="n")){ e.preventDefault(); toggleNull(); return; }
    if(e.shiftKey && (e.key==="F"||e.key==="f")){ e.preventDefault(); toggleFull(); return; }
    if(e.key==="Escape"){ setSelected(null); }
  });

  // visibility state init
  loadVis();

  // loop
  let last=performance.now();
  function loop(now){
    const dt=Math.min(40, now-last);
    last=now;
    if(running) step(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>

<!--
AE / EE / WB — KETADATA SERIALIZATION STAMP (MANDATORY)
AE: ORGANIC BRUTALIST TERRARIUM — AMOEBA LOOP LAYOUT, MEMBRANE BLOBS, TENDON CORDS, MONOCHROME, UNIFORM TEXT, LOW-FRICTION HUD
EE: ZOOM/PAN, DRAG NODES, PAUSE/RESUME, SETTLE, FILTER + VISIBILITY, CLICK TWICE TO OPEN, EXPORT/IMPORT VISIBILITY MAP
WB: LOCAL-FIRST VISIBILITY (localStorage), WHOLE-PAGE INVERT, NULL/FULL HOTKEYS

FILE_ID: "KETADATA_ROUTER_TERRARIUM_ORGANISM_BRUTAL_EASY"
ROOM_ID: "K_ROUTER"
VERSION_ID: "V3"
UPDATED_AT: "2026-01-04T00:00:00.000-05:00"
CHANGELOG:
- V3: MORE ORGANIC (AMOEBA LOOP), MORE BRUTAL (CHUNKIER HALOS / CORDS), MORE EASYGOING (SOFT CONTROL, SETTLE, LIGHT HUD)
-->
</body>
</html>
