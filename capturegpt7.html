<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Diamond White Organism – Continuous Trap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: Arial, sans-serif;
      color: #ffffff;
    }
    #canvas {
      display: block;
      image-rendering: crisp-edges;
    }
    #instructions {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-size: 13px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-align: center;
      pointer-events: none;
      z-index: 10;
      transition: opacity 1s ease;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="instructions">SPACE — TOGGLE • CLICK — OVERLOAD • MOVE — IT FOLLOWS</div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    let w = canvas.width = window.innerWidth;
    let h = canvas.height = window.innerHeight;

    let running = false;
    let frameId = null;
    let t = 0;

    // 4-phase trap cycle mapped onto 0–1
    const CYCLE_FRAMES = 800;

    // camera
    let camZoom = 1;
    let camZoomTarget = 1;
    let camOffsetX = 0;
    let camOffsetY = 0;
    let camOffsetTargetX = 0;
    let camOffsetTargetY = 0;

    // core pulse
    let pulseAmp = 1;
    let pulseTarget = 1.2;

    // flashes
    let flashAlpha = 0;
    let microStrobe = 0;

    // mouse “gaze”
    let mouseX = w / 2;
    let mouseY = h / 2;

    // filament settings – lighter than before
    const MAX_BRANCHES = 36;
    const MAX_POINTS = 22;

    class Branch {
      constructor(x, y, angle, strength = 1) {
        this.points = [{ x, y }];
        this.angle = angle;
        this.strength = strength;
        this.life = 0;
        this.maxLife = 480;
      }
      update(intensity) {
        this.life++;
        const last = this.points[this.points.length - 1];

        const jitter = (Math.random() - 0.5) * 0.25 * intensity * this.strength;
        this.angle += jitter;

        const step = (4 + Math.random() * 3.5) * (0.8 + 0.5 * intensity);
        const nx = last.x + Math.cos(this.angle) * step;
        const ny = last.y + Math.sin(this.angle) * step;

        this.points.push({ x: nx, y: ny });
        if (this.points.length > MAX_POINTS) {
          this.points.shift();
        }

        if (this.life > this.maxLife) {
          const cx = w / 2;
          const cy = h / 2;
          this.points = [{ x: cx, y: cy }];
          this.life = 0;
          this.angle = Math.random() * Math.PI * 2;
        }
      }
      draw(intensity) {
        if (this.points.length < 2) return;

        const lifeFrac = this.life / this.maxLife;
        const alpha = 0.10 + 0.25 * intensity * this.strength * (1 - lifeFrac * 0.6);
        const width = 0.9 + 0.9 * intensity * this.strength;

        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        for (let i = 1; i < this.points.length; i++) {
          const p = this.points[i];
          ctx.lineTo(p.x, p.y);
        }

        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
        ctx.lineWidth = width;
        ctx.shadowBlur = 14 * intensity * this.strength;
        ctx.shadowColor = `rgba(255,255,255,${alpha * 0.8})`;
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    }

    let branches = [];

    function initBranches() {
      branches = [];
      const cx = w / 2;
      const cy = h / 2;
      for (let i = 0; i < MAX_BRANCHES; i++) {
        const angle = Math.random() * Math.PI * 2;
        const strength = 0.7 + Math.random() * 0.5;
        branches.push(new Branch(cx, cy, angle, strength));
      }
    }

    function resize() {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight;
      initBranches();
    }
    window.addEventListener("resize", resize);

    function lerp(a, b, f) {
      return a + (b - a) * f;
    }

    function softStep(edge0, edge1, x) {
      const t = Math.min(1, Math.max(0, (x - edge0) / (edge1 - edge0)));
      return t * t * (3 - 2 * t);
    }

    function getPhaseWeights(norm) {
      // 0–0.25 LURE, 0.25–0.5 SYNC, 0.5–0.75 BREAK, 0.75–1 DOMINATE
      const lure = 1 - softStep(0.18, 0.3, norm);
      const sync = Math.min(
        softStep(0.18, 0.3, norm),
        1 - softStep(0.45, 0.55, norm)
      );
      const brk = Math.min(
        softStep(0.45, 0.55, norm),
        1 - softStep(0.7, 0.8, norm)
      );
      const dom = softStep(0.7, 0.86, norm);
      const sum = lure + sync + brk + dom || 1;
      return {
        lure: lure / sum,
        sync: sync / sum,
        brk: brk / sum,
        dom: dom / sum,
      };
    }

    // geometric “diamond” lattice around the core
    function drawDiamondHalo(time, weights) {
      const cx = w / 2;
      const cy = h / 2;

      const baseR = Math.min(w, h) * 0.45;
      const layers = 4;

      for (let i = 0; i < layers; i++) {
        const depth = i / (layers - 1 || 1);
        const r =
          baseR *
          (0.25 + depth * 0.75) *
          (1 + 0.03 * Math.sin(time * 0.004 + depth * 4));

        // asymmetry in facet count: 8 → 6 → 7 → 6
        const sidesBase = 8 * weights.lure + 6 * weights.sync + 7 * weights.brk + 6 * weights.dom;
        const sides = Math.max(4, Math.round(sidesBase));

        const lineAlpha =
          0.06 +
          0.08 * (1 - depth) +
          0.05 * (weights.brk + weights.dom);
        const width = 0.8 + 1.1 * (1 - depth);

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(time * 0.0012 * (i % 2 === 0 ? 1 : -1));
        ctx.beginPath();
        for (let s = 0; s < sides; s++) {
          const ang = (Math.PI * 2 * s) / sides;
          const x = Math.cos(ang) * r;
          const y = Math.sin(ang) * r;
          if (s === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.strokeStyle = `rgba(255,255,255,${lineAlpha})`;
        ctx.lineWidth = width;
        ctx.shadowBlur = 14 * (1 - depth);
        ctx.shadowColor = `rgba(255,255,255,${lineAlpha})`;
        ctx.stroke();

        // inner diamond spokes for more “faceting”
        if (i >= 1) {
          ctx.beginPath();
          for (let s = 0; s < sides; s++) {
            const ang = (Math.PI * 2 * s) / sides;
            const x = Math.cos(ang) * r;
            const y = Math.sin(ang) * r;
            ctx.moveTo(0, 0);
            ctx.lineTo(x, y);
          }
          ctx.strokeStyle = `rgba(255,255,255,${lineAlpha * 0.7})`;
          ctx.lineWidth = 0.6;
          ctx.shadowBlur = 8;
          ctx.shadowColor = `rgba(255,255,255,${lineAlpha * 0.7})`;
          ctx.stroke();
        }

        ctx.restore();
      }
      ctx.shadowBlur = 0;
    }

    function drawCore(time, breath, weights) {
      const cx = w / 2;
      const cy = h / 2;

      const targetX = lerp(cx, mouseX, 0.2);
      const targetY = lerp(cy, mouseY, 0.2);

      const baseR = Math.min(w, h) * 0.08;
      const coreR =
        baseR *
        (1 + breath * 0.25) *
        pulseAmp;

      const spikeBase = 60;
      const spikeCount =
        spikeBase +
        Math.floor(
          20 * weights.sync +
          30 * weights.brk +
          40 * weights.dom
        );

      const spinBase =
        0.0023 +
        0.0012 * weights.sync +
        0.002 * weights.brk +
        0.003 * weights.dom;
      const spin = time * spinBase;

      for (let i = 0; i < spikeCount; i++) {
        const frac = i / spikeCount;
        const jitter =
          (weights.brk + weights.dom) *
          Math.sin(time * 0.004 + i * 0.32) *
          0.35;
        const angle =
          frac * Math.PI * 2 +
          spin +
          (weights.lure * 0.1 + weights.sync * 0.2) *
            Math.sin(time * 0.0025 + i * 0.18) +
          jitter;

        const innerR =
          coreR * (0.7 + 0.12 * Math.sin(time * 0.013 + i));
        const outerR =
          coreR *
          (1.7 +
            (0.6 + 0.4 * (weights.brk + weights.dom)) *
              Math.sin(time * 0.019 + i * 0.29));

        const ix = cx + Math.cos(angle) * innerR;
        const iy = cy + Math.sin(angle) * innerR;
        const ox = cx + Math.cos(angle) * outerR;
        const oy = cy + Math.sin(angle) * outerR;

        const alphaBase =
          0.12 +
          0.06 * weights.sync +
          0.12 * weights.brk +
          0.16 * weights.dom;
        const alpha = alphaBase + Math.random() * 0.35;
        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
        ctx.lineWidth =
          0.7 +
          (1.0 + 0.6 * weights.dom) *
            (0.3 + 0.7 * Math.random());
        ctx.shadowBlur = 16;
        ctx.shadowColor = `rgba(255,255,255,${alpha})`;
        ctx.beginPath();
        ctx.moveTo(ix, iy);
        ctx.lineTo(ox, oy);
        ctx.stroke();
      }

      // crystalline core
      ctx.shadowBlur =
        50 * pulseAmp * (1 + 0.3 * (weights.brk + weights.dom));
      ctx.shadowColor = "rgba(255,255,255,0.98)";
      ctx.fillStyle = "rgba(255,255,255,0.99)";
      ctx.beginPath();
      ctx.arc(cx, cy, coreR, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // subtle inner diamond (hard edge feel)
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(time * 0.0015);
      ctx.beginPath();
      for (let i = 0; i < 4; i++) {
        const ang = (Math.PI / 2) * i + Math.PI / 4;
        const x = Math.cos(ang) * coreR * 0.7;
        const y = Math.sin(ang) * coreR * 0.7;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.strokeStyle = "rgba(230,230,230,0.7)";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();

      // pupil that “tracks” you
      const dx = targetX - cx;
      const dy = targetY - cy;
      const angleToMouse = Math.atan2(dy, dx);
      const pupilOffset = coreR * 0.23;

      const pupilCx = cx + Math.cos(angleToMouse) * pupilOffset;
      const pupilCy = cy + Math.sin(angleToMouse) * pupilOffset;

      const pupilR =
        coreR *
        (0.24 +
          0.08 * Math.sin(time * 0.035 + 0.7) +
          0.05 * (weights.brk + weights.dom) *
            Math.sin(time * 0.07));

      ctx.fillStyle = "rgba(0,0,0,0.97)";
      ctx.beginPath();
      ctx.arc(pupilCx, pupilCy, pupilR, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "rgba(255,255,255,0.65)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(cx, cy, coreR * 1.45, 0, Math.PI * 2);
      ctx.stroke();
    }

    function drawBackgroundSparkle(weights) {
      const baseCount =
        12 +
        Math.floor(
          9 * weights.lure +
          14 * weights.sync +
          18 * weights.brk +
          24 * weights.dom
        );

      for (let i = 0; i < baseCount; i++) {
        const x = Math.random() * w;
        const y = Math.random() * h;
        const alpha =
          0.02 +
          0.03 * (weights.brk + weights.dom) +
          Math.random() * 0.03;
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.fillRect(x, y, 1, 1);
      }
    }

    function animate() {
      t++;

      const cyclePos = (t % CYCLE_FRAMES) / CYCLE_FRAMES;
      const weights = getPhaseWeights(cyclePos);

      // 6 breaths / minute
      const breath = Math.sin((Math.PI * 2 * t) / 600);

      const fadeBase =
        0.12 +
        0.04 * weights.sync +
        0.07 * weights.brk +
        0.09 * weights.dom;
      const trailFade = fadeBase + 0.02 * Math.sin(t * 0.01);
      ctx.fillStyle = `rgba(0,0,0,${trailFade})`;
      ctx.fillRect(0, 0, w, h);

      pulseAmp = lerp(pulseAmp, pulseTarget, 0.045);
      camZoom = lerp(camZoom, camZoomTarget, 0.035);
      camOffsetX = lerp(camOffsetX, camOffsetTargetX, 0.035);
      camOffsetY = lerp(camOffsetY, camOffsetTargetY, 0.035);

      if (Math.abs(camOffsetX - camOffsetTargetX) < 0.4) camOffsetTargetX *= 0.6;
      if (Math.abs(camOffsetY - camOffsetTargetY) < 0.4) camOffsetTargetY *= 0.6;

      const driftChance =
        0.002 +
        0.003 * weights.sync +
        0.005 * weights.brk +
        0.007 * weights.dom;
      if (Math.random() < driftChance) {
        const spread = 40 + 70 * (weights.brk + weights.dom);
        camOffsetTargetX = (Math.random() - 0.5) * spread;
        camOffsetTargetY = (Math.random() - 0.5) * spread;
      }

      camZoomTarget =
        1.04 +
        0.03 * breath * (weights.lure + weights.sync) +
        0.06 * Math.sin(t * 0.018) *
          (weights.brk + weights.dom);

      pulseTarget =
        1.2 +
        0.25 * ((breath + 1) / 2) * (weights.lure + weights.sync) +
        0.35 * Math.sin(t * 0.022) *
          (weights.brk + weights.dom);

      if (weights.brk + weights.dom > 0.2 && Math.random() < 0.004) {
        flashAlpha = 0.4 + 0.35 * (weights.dom + weights.brk);
      }
      flashAlpha = Math.max(0, flashAlpha - 0.02);

      microStrobe = Math.max(0, microStrobe - 0.14);
      if (weights.sync > 0.25) {
        if (breath > 0.97 && t % 10 === 0) microStrobe = 0.22;
      }
      if (weights.brk > 0.2 && Math.random() < 0.04) microStrobe = 0.4;
      if (weights.dom > 0.2 && Math.random() < 0.06) microStrobe = 0.6;

      const intensity =
        0.4 * weights.lure +
        0.7 * weights.sync +
        0.95 * weights.brk +
        1.1 * weights.dom;

      ctx.save();
      ctx.translate(w / 2, h / 2);
      ctx.scale(camZoom, camZoom);
      ctx.translate(-w / 2 + camOffsetX, -h / 2 + camOffsetY);

      drawBackgroundSparkle(weights);
      drawDiamondHalo(t, weights);
      drawCore(t, breath, weights);

      branches.forEach(b => {
        b.update(intensity);
        b.draw(intensity);
      });

      ctx.restore();

      if (flashAlpha > 0) {
        ctx.globalAlpha = flashAlpha * 0.55;
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
      }

      if (microStrobe > 0) {
        ctx.globalAlpha = microStrobe * 0.35;
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
      }

      if (running) frameId = requestAnimationFrame(animate);
    }

    function start() {
      if (running) return;
      running = true;
      document.getElementById("instructions").style.opacity = "0.3";
      animate();
    }

    function stop() {
      running = false;
      if (frameId) cancelAnimationFrame(frameId);
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, w, h);
      document.getElementById("instructions").style.opacity = "0.9";

      pulseAmp = 1;
      pulseTarget = 1.2;
      camZoom = 1;
      camZoomTarget = 1;
      camOffsetX = camOffsetY = 0;
      camOffsetTargetX = camOffsetTargetY = 0;
      flashAlpha = 0;
      microStrobe = 0;
      t = 0;
      initBranches();
    }

    document.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        running ? stop() : start();
      }
    });

    canvas.addEventListener("click", () => {
      // overload spike – but still smooth due to lerp
      pulseTarget += 0.7;
      camZoomTarget += 0.16;
      flashAlpha = Math.min(1, flashAlpha + 0.6);
      microStrobe = Math.max(microStrobe, 0.55);

      setTimeout(() => {
        pulseTarget = 1.4;
        camZoomTarget = 1.08;
      }, 420);
    });

    canvas.addEventListener("mousemove", (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    // init
    initBranches();
    ctx.fillStyle = "#000000";
    ctx.fillRect(0, 0, w, h);
  </script>
</body>
</html>
