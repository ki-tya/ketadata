<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>mdma-trip</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #05030a;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    #canvas {
      display: block;
      image-rendering: crisp-edges;
    }
    #instructions {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-family: Arial, sans-serif;
      font-size: 14px;
      text-align: center;
      z-index: 10;
      pointer-events: none;
      transition: opacity 1s;
    }
    #instructions span {
      display: block;
      font-size: 11px;
      opacity: 0.6;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="instructions">
    Press SPACE to start / stop
    <span>Visual abstraction of MDMA states – may contain soft pulsing light</span>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    let isAnimating = false;
    let animationFrame;
    let time = 0;

    // Phase cycle: 0–1 come-up, 1–2 peak, 2–3 plateau, 3–4 comedown, then loop
    function getPhase(t) {
      const phase = (t / 900) % 4; // tweak denominator for overall cycle speed
      return phase;
    }

    function drawBackground(t, phase) {
      const w = canvas.width;
      const h = canvas.height;

      const centerX = w / 2;
      const centerY = h / 2;

      const grd = ctx.createRadialGradient(
        centerX, centerY, 0,
        centerX, centerY, Math.max(w, h) * 0.75
      );

      // Color stops morph by phase
      const soft = (x) => Math.max(0, Math.min(1, x));

      const warmMix = soft(Math.sin(t * 0.0008) * 0.4 + 0.7);
      const coolMix = 1 - warmMix;

      // Base palettes
      const warmCenter = {
        r: 255,
        g: 160 + 60 * warmMix,
        b: 220 - 20 * coolMix
      };
      const edgeCool = {
        r: 10 + 30 * coolMix,
        g: 5 + 40 * coolMix,
        b: 40 + 80 * coolMix
      };

      const centerAlpha = phase < 3 ? 1 : 0.9; // slightly dimmer on comedown

      grd.addColorStop(
        0,
        `rgba(${warmCenter.r}, ${warmCenter.g}, ${warmCenter.b}, ${centerAlpha})`
      );
      grd.addColorStop(
        0.45,
        `rgba(${warmCenter.r - 40}, ${warmCenter.g - 40}, ${warmCenter.b}, 0.85)`
      );
      grd.addColorStop(
        1,
        `rgba(${edgeCool.r}, ${edgeCool.g}, ${edgeCool.b}, 1)`
      );

      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, w, h);
    }

    function drawWaves(t, phase) {
      const w = canvas.width;
      const h = canvas.height;

      const layers = 4;
      for (let i = 0; i < layers; i++) {
        const offset = i * 90;
        const localPhase = t * 0.001 + offset * 0.01;

        // Speed changes subtly per phase
        const speedFactor =
          phase < 1 ? 0.8 :
          phase < 2 ? 1.4 :
          phase < 3 ? 1.0 : 0.6;

        const amplitude = (h * 0.06) * (0.8 + 0.4 * Math.sin(t * 0.0007 + i));
        const baseY = h * 0.3 + i * (h * 0.12);

        ctx.beginPath();
        for (let x = 0; x <= w; x += 8) {
          const y =
            baseY +
            Math.sin((x * 0.008) + localPhase * speedFactor) * amplitude *
            (0.7 + 0.3 * Math.sin(t * 0.0009 + i));
          if (x === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }

        const alpha =
          phase < 1 ? 0.4 + 0.2 * i / layers :
          phase < 2 ? 0.6 + 0.3 * i / layers :
          phase < 3 ? 0.5 + 0.25 * i / layers :
                       0.35 + 0.2 * i / layers;

        const colorShift = 40 * Math.sin(t * 0.0005 + i);
        ctx.strokeStyle = `rgba(${220 + colorShift}, ${150 + colorShift / 2}, 255, ${alpha})`;
        ctx.lineWidth = 4 - i * 0.5;
        ctx.shadowBlur = 18 + i * 4;
        ctx.shadowColor = `rgba(255, 210, 255, ${alpha})`;
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
    }

    function drawConnectionParticles(t, phase) {
      const w = canvas.width;
      const h = canvas.height;
      const cx = w / 2;
      const cy = h / 2;

      // More particles on peak, fewer on comedown
      const baseCount = 80;
      const phaseFactor =
        phase < 1 ? 0.7 :
        phase < 2 ? 1.3 :
        phase < 3 ? 1.0 : 0.5;
      const count = Math.floor(baseCount * phaseFactor);

      const radiusBase = Math.min(w, h) * 0.18;
      const radiusSpread = Math.min(w, h) * 0.35;

      for (let i = 0; i < count; i++) {
        const seed = i * 97.13;
        const angle = t * 0.0007 + seed * 0.13;
        const swirl = Math.sin(t * 0.0003 + seed) * 0.7;
        const r =
          radiusBase +
          radiusSpread * (0.3 + 0.7 * (0.5 + 0.5 * Math.sin(seed * 3.1 + t * 0.0006)));

        const x = cx + Math.cos(angle + swirl) * r;
        const y = cy + Math.sin(angle + swirl) * r * 0.7;

        const size = 2.2 + 2.4 * (0.5 + 0.5 * Math.sin(seed + t * 0.0012));
        const connectionChance = phase < 2 ? 0.38 : 0.22;

        const brightness =
          0.6 + 0.4 * (0.5 + 0.5 * Math.sin(seed + t * 0.001));
        const rCol = Math.floor(230 + 20 * brightness);
        const gCol = Math.floor(160 + 40 * brightness);
        const bCol = Math.floor(240 + 15 * brightness);

        ctx.fillStyle = `rgba(${rCol}, ${gCol}, ${bCol}, ${brightness})`;
        ctx.shadowBlur = 12 + 10 * brightness;
        ctx.shadowColor = `rgba(${rCol}, ${gCol}, ${bCol}, ${brightness})`;

        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();

        // Occasional links = feeling of connection
        if (Math.random() < connectionChance) {
          ctx.shadowBlur = 8;
          ctx.strokeStyle = `rgba(${rCol}, ${gCol}, ${bCol}, ${brightness * 0.8})`;
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          const linkAngle = angle + Math.PI / 3;
          const linkR = r * 0.75;
          ctx.lineTo(
            cx + Math.cos(linkAngle) * linkR,
            cy + Math.sin(linkAngle) * linkR * 0.7
          );
          ctx.stroke();
        }
      }
      ctx.shadowBlur = 0;
    }

    function drawHeartCore(t, phase) {
      const w = canvas.width;
      const h = canvas.height;
      const cx = w / 2;
      const cy = h / 2;

      const baseRadius = Math.min(w, h) * 0.10;
      const breath = Math.sin(t * 0.002);
      const pulse =
        phase < 1 ? Math.sin(t * 0.004) :
        phase < 2 ? Math.sin(t * 0.006) :
        phase < 3 ? Math.sin(t * 0.0045) :
                    Math.sin(t * 0.0025);

      const radius = baseRadius * (1.0 + 0.25 * breath + 0.18 * pulse);

      ctx.save();
      ctx.translate(cx, cy);

      // Outer glow
      ctx.beginPath();
      ctx.arc(0, 0, radius * 2.4, 0, Math.PI * 2);
      const outerAlpha =
        phase < 1 ? 0.4 :
        phase < 2 ? 0.75 :
        phase < 3 ? 0.6 : 0.25;
      ctx.fillStyle = `rgba(255, 160, 255, ${outerAlpha})`;
      ctx.shadowBlur = 60;
      ctx.shadowColor = `rgba(255, 190, 255, ${outerAlpha})`;
      ctx.fill();

      // Inner “heart-sun”
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      const coreAlpha =
        phase < 1 ? 0.8 :
        phase < 2 ? 1.0 :
        phase < 3 ? 0.9 : 0.7;
      ctx.fillStyle = `rgba(255, 210, 240, ${coreAlpha})`;
      ctx.shadowBlur = 90;
      ctx.shadowColor = `rgba(255, 230, 255, ${coreAlpha})`;
      ctx.fill();

      // Soft “heartbeat rings”
      const rings = 4;
      for (let i = 1; i <= rings; i++) {
        const ringRadius = radius * (1.5 + i * 0.8 + 0.2 * pulse);
        ctx.beginPath();
        ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
        const a = 0.18 * (1 - i / (rings + 1));
        ctx.strokeStyle = `rgba(255, 230, 255, ${a})`;
        ctx.lineWidth = 1.4;
        ctx.shadowBlur = 25;
        ctx.shadowColor = `rgba(255, 230, 255, ${a})`;
        ctx.stroke();
      }

      ctx.restore();
      ctx.shadowBlur = 0;
    }

    function drawPhaseHalo(t, phase) {
      const w = canvas.width;
      const h = canvas.height;
      const cx = w / 2;
      const cy = h / 2;

      const radius = Math.min(w, h) * 0.37;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(t * 0.0004);

      const segments = 32;
      for (let i = 0; i < segments; i++) {
        const angle = (Math.PI * 2 / segments) * i;
        const phaseOffset = (phase + i / segments) % 1;

        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;

        const brightness =
          0.25 +
          0.75 * (0.5 + 0.5 * Math.sin(t * 0.001 + i * 0.4));

        let rCol, gCol, bCol;
        if (phase < 1) { // come-up – cool to warm
          rCol = 200 + 55 * phaseOffset;
          gCol = 150 + 40 * phaseOffset;
          bCol = 255;
        } else if (phase < 2) { // peak – full candy spectrum
          rCol = 240;
          gCol = 160 + 60 * Math.sin(angle * 2);
          bCol = 255 - 40 * Math.cos(angle * 1.5);
        } else if (phase < 3) { // plateau – smooth harmony
          rCol = 220;
          gCol = 180;
          bCol = 255;
        } else { // comedown – cooler, softer
          rCol = 190;
          gCol = 150;
          bCol = 230;
        }

        const alpha =
          phase < 2 ? 0.5 + 0.3 * brightness :
                       0.35 + 0.25 * brightness;

        ctx.beginPath();
        ctx.arc(x, y, 5 + 4 * brightness, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${rCol}, ${gCol}, ${bCol}, ${alpha})`;
        ctx.shadowBlur = 20 + 20 * brightness;
        ctx.shadowColor = `rgba(${rCol}, ${gCol}, ${bCol}, ${alpha})`;
        ctx.fill();
      }

      ctx.restore();
      ctx.shadowBlur = 0;
    }

    function animate() {
      time++;

      const phase = getPhase(time);

      // Slight global fade to keep trails soft
      ctx.globalAlpha = 1;
      drawBackground(time, phase);

      // Layers stacked to feel like an inner and outer world
      drawWaves(time, phase);
      drawConnectionParticles(time, phase);
      drawPhaseHalo(time, phase);
      drawHeartCore(time, phase);

      animationFrame = requestAnimationFrame(animate);
    }

    function start() {
      document.getElementById('instructions').style.opacity = '0';
      if (!isAnimating) {
        animationFrame = requestAnimationFrame(animate);
        isAnimating = true;
      }
    }

    function stop() {
      cancelAnimationFrame(animationFrame);
      isAnimating = false;
      time = 0;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground(0, 0);
      document.getElementById('instructions').style.opacity = '0.8';
    }

    document.addEventListener('keydown', (event) => {
      if (event.key === ' ' || event.code === 'Space') {
        event.preventDefault();
        if (isAnimating) {
          stop();
        } else {
          start();
        }
      }
    });

    // initial still frame
    drawBackground(0, 0);
  </script>
</body>
</html>

