<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA // CASE BOARD</title>
<style>
:root{
  --bg:#000;
  --fg:rgba(255,255,255,.86);
  --muted:rgba(255,255,255,.52);
  --line:rgba(255,255,255,.14);
  --line2:rgba(255,255,255,.22);
  --panel:rgba(0,0,0,.92);
  --panel2:rgba(255,255,255,.03);
  --hit:rgba(255,255,255,.08);

  --t:44px;
  --leftW:320px;
  --rightW:320px;
  --bottomH:200px;

  --font:12px;
  --sans: Arial, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;

  --zTop:1000;
  --zPanel:900;
  --zNote:1200;

  --zoomMin:.25;
  --zoomMax:3.0;
}

*{ box-sizing:border-box; }
html,body{ height:100%; margin:0; background:var(--bg); color:var(--fg); overflow:hidden; }
body{ font-family:var(--sans); font-size:var(--font); }

#root{ position:fixed; inset:0; background:var(--bg); }
#root.invert{ filter: invert(1) hue-rotate(180deg); }

.topbar{
  position:fixed; left:0; right:0; top:0; height:var(--t);
  display:flex; align-items:center; justify-content:space-between;
  padding:0 10px;
  border-bottom:1px solid var(--line);
  background:var(--panel);
  z-index:var(--zTop);
}
.brand{
  color:var(--muted);
  letter-spacing:1px;
  user-select:none;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.actions{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }

button, input[type="text"], input[type="file"], textarea, select{
  background:var(--panel2);
  border:1px solid var(--line2);
  color:var(--fg);
  padding:7px 9px;
  border-radius:0;
  font-size:var(--font);
  outline:none;
  font-family:var(--sans);
}
textarea{ font-family:var(--mono); line-height:1.25; }
button{ cursor:pointer; }
button:hover{ border-color:rgba(255,255,255,.34); }
button.ghost{ border-color:rgba(255,255,255,.10); color:rgba(255,255,255,.62); }
button.danger:hover{ border-color:rgba(255,140,140,.55); }

.shell{
  position:absolute;
  top:var(--t); left:0; right:0; bottom:0;
  display:grid;
  grid-template-columns: var(--leftW) 6px 1fr 6px var(--rightW);
  grid-template-rows: 1fr 6px var(--bottomH);
  grid-template-areas:
    "left v1 stage v2 right"
    "left v1 stage v2 right"
    "bottom bottom bottom bottom bottom";
}

.resizer{ background:rgba(255,255,255,.06); z-index:var(--zPanel); }
.resizer:hover{ background:rgba(255,255,255,.10); }
.v1{ grid-area:v1; cursor:col-resize; }
.v2{ grid-area:v2; cursor:col-resize; }
.h1{
  grid-area:bottom;
  border-top:1px solid var(--line);
  position:relative;
}
.hSizer{
  position:absolute; left:0; right:0; top:-6px; height:6px;
  cursor:row-resize;
  background:rgba(255,255,255,.06);
}
.hSizer:hover{ background:rgba(255,255,255,.10); }

.panel{
  min-width:0; min-height:0;
  background:var(--panel);
  overflow:hidden;
  display:flex;
  flex-direction:column;
  z-index:var(--zPanel);
}
.panel.left{ grid-area:left; border-right:1px solid var(--line); }
.panel.right{ grid-area:right; border-left:1px solid var(--line); }
.panel.bottom{
  grid-area:bottom;
  border-top:1px solid var(--line);
}

.pHead{
  height:36px;
  display:flex; align-items:center; justify-content:space-between;
  padding:0 10px;
  border-bottom:1px solid var(--line);
  user-select:none;
  color:var(--muted);
}
.pHead .left{ display:flex; gap:8px; align-items:center; }
.pHead .right{ display:flex; gap:8px; align-items:center; }
.pBody{ flex:1; min-height:0; overflow:auto; padding:10px; }

.tabbar{ display:flex; gap:6px; padding:8px 10px; border-bottom:1px solid var(--line); overflow:auto; }
.tab{
  padding:6px 8px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.02);
  color:rgba(255,255,255,.62);
  cursor:pointer;
  white-space:nowrap;
  user-select:none;
}
.tab.active{ border-color:rgba(255,255,255,.26); color:rgba(255,255,255,.84); background:rgba(255,255,255,.04); }

.kv{
  display:grid;
  grid-template-columns: 92px 1fr;
  gap:8px;
  align-items:center;
}
.k{ color:rgba(255,255,255,.50); }
.v{ min-width:0; }
.v input,.v select,.v textarea{ width:100%; }

.row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
.row .grow{ flex:1 1 auto; min-width:0; }

.small{ color:rgba(255,255,255,.52); }

.hidden{ display:none !important; }
.collapsed{ display:none !important; }

/* Stage */
#stage{
  grid-area:stage;
  position:relative;
  overflow:hidden;
  background:var(--bg);
  touch-action:none;
}
#viewport{
  position:absolute; inset:0;
  transform-origin:0 0;
}
#linkLayer{ position:absolute; inset:0; pointer-events:auto; }
#linkSvg{ width:100%; height:100%; display:block; }
.edge{ stroke: rgba(255,255,255,.18); stroke-width:1; }
.edge.selected{ stroke: rgba(255,255,255,.46); stroke-width:2; }
.edgeHit{ stroke: rgba(255,255,255,0); stroke-width:12; cursor:pointer; }
.edgeLabel{ fill: rgba(255,255,255,.62); font-size:var(--font); user-select:none; font-family:var(--sans); }

#board{ position:absolute; inset:0; }

.item{
  position:absolute;
  border:1px solid transparent;
  user-select:none;
  transform-origin:center center;
}
.item.selected{ border-color:rgba(255,255,255,.22); }

.card{
  width:100%; height:100%;
  background:rgba(255,255,255,.02);
  border:1px solid rgba(255,255,255,.10);
  overflow:hidden;
}
.cardHead{
  height:26px;
  display:flex; align-items:center; justify-content:space-between;
  padding:0 8px;
  border-bottom:1px solid rgba(255,255,255,.08);
  background:rgba(0,0,0,.20);
  cursor:move;
  color:rgba(255,255,255,.68);
}
.cardHead .meta{
  opacity:.70;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  max-width:60%;
}
.cardBody{
  height:calc(100% - 26px);
  padding:8px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.cardField{
  width:100%;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.18);
  color:rgba(255,255,255,.86);
  padding:6px 7px;
  outline:none;
  font-size:var(--font);
}
.cardNote{
  flex:1;
  width:100%;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.18);
  color:rgba(255,255,255,.86);
  padding:7px;
  outline:none;
  resize:none;
  font-family:var(--mono);
  font-size:var(--font);
  line-height:1.25;
}
.cardKV{
  display:grid;
  grid-template-columns: 92px 1fr;
  gap:6px;
}
.cardKV .k{ color:rgba(255,255,255,.48); }

.evidenceImg{
  width:100%; height:100%;
  object-fit:contain;
  display:block;
  background:#000;
  pointer-events:none;
}
.evidenceCap{
  position:absolute; left:0; right:0; bottom:0;
  padding:6px 8px;
  border-top:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.72);
  color:rgba(255,255,255,.70);
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}

.handle{
  position:absolute;
  width:16px; height:16px;
  border:1px solid rgba(255,255,255,.40);
  background:rgba(0,0,0,.80);
}
.h-nw{ left:-9px; top:-9px; cursor:nwse-resize; }
.h-ne{ right:-9px; top:-9px; cursor:nesw-resize; }
.h-sw{ left:-9px; bottom:-9px; cursor:nesw-resize; }
.h-se{ right:-9px; bottom:-9px; cursor:nwse-resize; }
.rot{
  position:absolute; left:50%; top:-30px; transform:translateX(-50%);
  width:16px; height:16px; border-radius:50%;
  border:1px solid rgba(255,255,255,.40);
  background:rgba(0,0,0,.82);
  cursor:grab;
}

/* Timeline list */
.tlist{ display:flex; flex-direction:column; gap:6px; }
.trow{
  display:grid;
  grid-template-columns: 84px 1fr;
  gap:8px;
  padding:6px 8px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.02);
  cursor:pointer;
}
.trow:hover{ border-color:rgba(255,255,255,.24); }
.tdate{ font-family:var(--mono); color:rgba(255,255,255,.70); }
.ttitle{ color:rgba(255,255,255,.86); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

/* KetaNote square + pad */
.ketaSquare{
  position:fixed;
  right:10px;
  top:10px;
  width:22px;
  height:22px;
  background:#fff;
  border:1px solid rgba(0,0,0,.35);
  z-index:var(--zNote);
  cursor:pointer;
}
.ketaPad{
  position:fixed;
  right:10px;
  top:44px;
  width:360px;
  height:320px;
  background:rgba(0,0,0,.92);
  border:1px solid rgba(255,255,255,.14);
  z-index:var(--zNote);
  display:none;
  overflow:hidden;
  resize:both;
  min-width:260px;
  min-height:220px;
}
.ketaPad.open{ display:block; }
.ketaHead{
  height:34px;
  display:flex; align-items:center; justify-content:space-between;
  padding:0 10px;
  border-bottom:1px solid rgba(255,255,255,.10);
  cursor:move;
  user-select:none;
  color:rgba(255,255,255,.62);
}
.ketaBody{ height:calc(100% - 34px); padding:10px; }
.ketaText{
  width:100%; height:100%;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.02);
  color:rgba(255,255,255,.86);
  padding:10px;
  outline:none;
  resize:none;
  font-family:var(--mono);
  font-size:var(--font);
  line-height:1.25;
}
.ketaBtns{ display:flex; gap:8px; align-items:center; }
.ketaBtns button{ padding:6px 8px; }

#toast{
  position:fixed; left:50%; bottom:12px; transform:translateX(-50%);
  padding:7px 9px;
  border:1px solid rgba(255,255,255,.16);
  background:rgba(0,0,0,.92);
  color:rgba(255,255,255,.72);
  display:none;
  z-index:2000;
}
#toast.show{ display:block; }

/* Minimal from outset: hide empty sections */
.emptyHint{
  color:rgba(255,255,255,.42);
  border:1px dashed rgba(255,255,255,.10);
  padding:10px;
  background:rgba(255,255,255,.01);
}
</style>
</head>
<body>
<div id="root">
  <div class="topbar">
    <div class="brand">KETADATA</div>
    <div class="actions">
      <button id="btnInvert" class="ghost">Invert</button>
      <button id="btnExportAll" class="ghost">Export</button>
      <label style="display:inline-flex;gap:8px;align-items:center;">
        <input id="importFile" type="file" accept="application/json" style="width:170px;"/>
      </label>
      <button id="btnSaveLocal" class="ghost">Save</button>
      <button id="btnLoadLocal" class="ghost">Load</button>
      <button id="btnClear" class="ghost danger">Clear</button>
    </div>
  </div>

  <div id="ketaSquare" class="ketaSquare" title="KETA_NOTE"></div>
  <div id="ketaPad" class="ketaPad">
    <div id="ketaHead" class="ketaHead">
      <div>KETA_NOTE</div>
      <div class="ketaBtns">
        <button id="ketaCopy" class="ghost">Copy</button>
        <button id="ketaExport" class="ghost">Export</button>
        <button id="ketaClose" class="ghost">X</button>
      </div>
    </div>
    <div class="ketaBody">
      <textarea id="ketaText" class="ketaText" placeholder=""></textarea>
    </div>
  </div>

  <div class="shell" id="shell">
    <!-- LEFT -->
    <aside class="panel left" id="leftPanel">
      <div class="pHead">
        <div class="left">Input</div>
        <div class="right">
          <button id="leftCollapse" class="ghost">–</button>
        </div>
      </div>

      <div class="tabbar">
        <div class="tab active" data-lefttab="create">Create</div>
        <div class="tab" data-lefttab="edit">Edit</div>
      </div>

      <div class="pBody">
        <!-- CREATE -->
        <div id="left_create">
          <div class="kv">
            <div class="k">Type</div>
            <div class="v">
              <select id="newType">
                <option value="person">person</option>
                <option value="place">place</option>
                <option value="event">event</option>
                <option value="item">item</option>
                <option value="note">note</option>
              </select>
            </div>

            <div class="k">Name</div>
            <div class="v"><input id="newName" type="text" placeholder=""/></div>

            <div class="k">Date</div>
            <div class="v"><input id="newDate" type="text" placeholder="YYYY-MM-DD (events only)"/></div>

            <div class="k">Label</div>
            <div class="v"><input id="newLabel" type="text" placeholder="optional"/></div>

            <div class="k">Notes</div>
            <div class="v"><textarea id="newNotes" placeholder=""></textarea></div>
          </div>

          <div style="height:10px"></div>
          <div class="row">
            <button id="btnAddToBoard">Add to board</button>
            <label style="display:inline-flex;gap:8px;align-items:center;">
              <input id="imgInput" type="file" accept="image/*" multiple style="width:220px;"/>
            </label>
          </div>
          <div style="height:10px"></div>
          <div class="small">Add creates a board card. Edit later in Edit tab. Images import as evidence.</div>
        </div>

        <!-- EDIT -->
        <div id="left_edit" class="hidden">
          <div id="editEmpty" class="emptyHint">No selection.</div>

          <div id="editForm" class="hidden">
            <div class="kv">
              <div class="k">ID</div><div class="v" id="selId">—</div>
              <div class="k">Type</div>
              <div class="v">
                <select id="selType">
                  <option value="person">person</option>
                  <option value="place">place</option>
                  <option value="event">event</option>
                  <option value="item">item</option>
                  <option value="note">note</option>
                  <option value="evidence">evidence</option>
                </select>
              </div>
              <div class="k">Name</div><div class="v"><input id="selName" type="text"/></div>
              <div class="k">Date</div><div class="v"><input id="selDate" type="text" placeholder="YYYY-MM-DD"/></div>
              <div class="k">Label</div><div class="v"><input id="selLabel" type="text"/></div>
              <div class="k">Opacity</div>
              <div class="v"><input id="selOpacity" type="range" min="10" max="100" step="1" value="100"/></div>
            </div>

            <div style="height:10px"></div>

            <div class="kv">
              <div class="k">Add field</div>
              <div class="v">
                <div class="row" style="gap:6px">
                  <input id="fieldKey" type="text" placeholder="key" style="width:120px"/>
                  <input id="fieldVal" type="text" placeholder="value" class="grow"/>
                  <button id="btnAddField" class="ghost">Add</button>
                </div>
              </div>
              <div class="k">Fields</div>
              <div class="v"><div id="fieldsList"></div></div>
            </div>

            <div style="height:10px"></div>
            <div class="kv">
              <div class="k">Notes</div>
              <div class="v"><textarea id="selNotes" placeholder=""></textarea></div>
            </div>

            <div style="height:10px"></div>
            <div class="row">
              <button id="btnFront" class="ghost">Front</button>
              <button id="btnBack" class="ghost">Back</button>
              <button id="btnDelete" class="ghost danger">Delete</button>
            </div>
          </div>
        </div>
      </div>
    </aside>

    <div class="resizer v1" id="resV1"></div>

    <!-- STAGE -->
    <main id="stage">
      <div id="viewport">
        <div id="linkLayer"><svg id="linkSvg" xmlns="http://www.w3.org/2000/svg"></svg></div>
        <div id="board"></div>
      </div>
    </main>

    <div class="resizer v2" id="resV2"></div>

    <!-- RIGHT -->
    <aside class="panel right" id="rightPanel">
      <div class="pHead">
        <div class="left">Timeline</div>
        <div class="right">
          <button id="btnExportTimeline" class="ghost">Export</button>
          <button id="rightCollapse" class="ghost">–</button>
        </div>
      </div>
      <div class="pBody">
        <div id="timelineEmpty" class="emptyHint">No events.</div>
        <div id="timelineList" class="tlist hidden"></div>
      </div>
    </aside>

    <!-- BOTTOM -->
    <section class="panel bottom" id="bottomPanel">
      <div class="hSizer" id="resH"></div>
      <div class="pHead">
        <div class="left">Connections</div>
        <div class="right">
          <button id="btnLinkMode" class="ghost">Link: Off</button>
          <button id="btnLinksVis" class="ghost">Links: On</button>
          <button id="bottomCollapse" class="ghost">–</button>
        </div>
      </div>
      <div class="pBody">
        <div class="row">
          <input id="edgeLabel" class="grow" type="text" placeholder="edge label (selected edge)"/>
          <button id="btnDelEdge" class="ghost danger">Delete edge</button>
        </div>
        <div style="height:8px"></div>
        <textarea id="edgeNote" style="width:100%;height:90px;" placeholder="edge note (selected edge)"></textarea>
        <div style="height:10px"></div>
        <div id="edgesEmpty" class="emptyHint">No connections.</div>
        <div id="edgesList" class="hidden"></div>
        <div style="height:10px"></div>
        <div class="small">Space = pan. Wheel = zoom. Delete = remove selection. Esc = cancel link selection. Shift+I = invert.</div>
      </div>
    </section>
  </div>

  <div id="toast"></div>
</div>

<script>
(() => {
  const FILE_ID = "KETADATA_CASE_BOARD_v2";
  const ROOM_ID = "CASE_BOARD";
  const VERSION = "2.0.0";
  const KEY_LOCAL = "ketadata_case_board_local_v2";
  const KEY_NOTE = "ketadata_keta_note_v2";
  const KEY_NOTE_POS = "ketadata_keta_note_pos_v2";

  const $ = (id)=>document.getElementById(id);
  const root = $("root");

  const shell = $("shell");
  const stage = $("stage");
  const viewport = $("viewport");
  const board = $("board");
  const linkSvg = $("linkSvg");

  const toast = $("toast");
  function showToast(msg){
    toast.textContent = msg;
    toast.className = "show";
    setTimeout(()=>toast.className="", 900);
  }

  function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }
  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }

  // Tabs (left)
  function bindTabs(selector, bodies, key){
    document.querySelectorAll(selector).forEach(tab=>{
      tab.addEventListener("click", ()=>{
        tab.parentElement.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
        tab.classList.add("active");
        const val = tab.dataset[key];
        for(const [id,wants] of Object.entries(bodies)){
          const el = $(id);
          el.classList.toggle("hidden", wants !== val);
        }
      });
    });
  }
  bindTabs("[data-lefttab]", { left_create:"create", left_edit:"edit" }, "lefttab");

  // Layout (resizable + collapsible)
  let layout = { leftW:320, rightW:320, bottomH:200, leftCollapsed:false, rightCollapsed:false, bottomCollapsed:false };

  const resV1 = $("resV1");
  const resV2 = $("resV2");
  const resH = $("resH");

  const leftPanel = $("leftPanel");
  const rightPanel = $("rightPanel");
  const bottomPanel = $("bottomPanel");

  function applyLayout(){
    document.documentElement.style.setProperty("--leftW", layout.leftCollapsed ? "0px" : layout.leftW+"px");
    document.documentElement.style.setProperty("--rightW", layout.rightCollapsed ? "0px" : layout.rightW+"px");
    document.documentElement.style.setProperty("--bottomH", layout.bottomCollapsed ? "0px" : layout.bottomH+"px");

    leftPanel.classList.toggle("collapsed", layout.leftCollapsed);
    rightPanel.classList.toggle("collapsed", layout.rightCollapsed);
    bottomPanel.classList.toggle("collapsed", layout.bottomCollapsed);

    resV1.classList.toggle("collapsed", layout.leftCollapsed);
    resV2.classList.toggle("collapsed", layout.rightCollapsed);
    // bottom resizer is inside bottom panel; hide via collapse
  }

  function startResizer(kind, e){
    e.preventDefault();
    const sx=e.clientX, sy=e.clientY;
    const start={...layout};
    const onMove=(ev)=>{
      if(kind==="left"){
        layout.leftW = clamp(start.leftW + (ev.clientX - sx), 240, 560);
      } else if(kind==="right"){
        layout.rightW = clamp(start.rightW - (ev.clientX - sx), 240, 560);
      } else if(kind==="bottom"){
        layout.bottomH = clamp(start.bottomH - (ev.clientY - sy), 140, 420);
      }
      applyLayout();
    };
    const onUp=()=>{
      window.removeEventListener("mousemove", onMove);
      window.removeEventListener("mouseup", onUp);
      autosave(false);
    };
    window.addEventListener("mousemove", onMove);
    window.addEventListener("mouseup", onUp);
  }

  resV1.addEventListener("mousedown", (e)=>startResizer("left", e));
  resV2.addEventListener("mousedown", (e)=>startResizer("right", e));
  resH.addEventListener("mousedown", (e)=>startResizer("bottom", e));

  $("leftCollapse").addEventListener("click", ()=>{ layout.leftCollapsed=!layout.leftCollapsed; applyLayout(); autosave(false); });
  $("rightCollapse").addEventListener("click", ()=>{ layout.rightCollapsed=!layout.rightCollapsed; applyLayout(); autosave(false); });
  $("bottomCollapse").addEventListener("click", ()=>{ layout.bottomCollapsed=!layout.bottomCollapsed; applyLayout(); autosave(false); });

  // View (pan/zoom)
  let view = { scale:1, panX:0, panY:0 };
  let spaceDown=false;

  function cssVar(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

  function applyView(){
    viewport.style.transform = `translate(${view.panX}px, ${view.panY}px) scale(${view.scale})`;
    renderLinks();
  }

  function screenToWorld(clientX, clientY){
    const r=stage.getBoundingClientRect();
    const sx=clientX-r.left;
    const sy=clientY-r.top;
    return { x:(sx-view.panX)/view.scale, y:(sy-view.panY)/view.scale, sx, sy };
  }

  document.addEventListener("keydown", (e)=>{
    if(e.code==="Space") spaceDown=true;
    if(e.shiftKey && e.key.toLowerCase()==="i") toggleInvert();
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==="s"){ e.preventDefault(); autosave(true); }
  });
  document.addEventListener("keyup", (e)=>{ if(e.code==="Space") spaceDown=false; });

  stage.addEventListener("wheel", (e)=>{
    e.preventDefault();
    const delta = -Math.sign(e.deltaY) * 0.10;
    const before = screenToWorld(e.clientX, e.clientY);
    const next = clamp(view.scale*(1+delta), parseFloat(cssVar("--zoomMin")), parseFloat(cssVar("--zoomMax")));
    view.scale = next;
    const after = screenToWorld(e.clientX, e.clientY);
    view.panX += (after.sx - before.sx);
    view.panY += (after.sy - before.sy);
    applyView();
  }, {passive:false});

  let dragView=null;
  stage.addEventListener("mousedown", (e)=>{
    const onItem = e.target.closest && e.target.closest(".item");
    if(onItem) return;
    if(spaceDown){
      dragView={ sx:e.clientX, sy:e.clientY, px:view.panX, py:view.panY };
      return;
    }
    if(!linkMode || !linkFromId){
      selectItem(null);
      selectEdge(null);
    }
  });
  window.addEventListener("mousemove", (e)=>{
    if(!dragView) return;
    view.panX = dragView.px + (e.clientX - dragView.sx);
    view.panY = dragView.py + (e.clientY - dragView.sy);
    applyView();
  });
  window.addEventListener("mouseup", ()=>dragView=null);

  // Data model
  // items: {id,type,name,label,date,notes,fields:{k:v}, x,y,w,h,r,opacity,z, evidence?:{dataUrl,caption}}
  // edges: {id,from,to,label,note}
  let items=[];
  let edges=[];
  let selectedId=null;
  let selectedEdgeId=null;

  let linkMode=false;
  let linkFromId=null;
  let linksVisible=true;

  const elById = new Map(); // itemId -> DOM element

  function nextZ(){ return items.reduce((m,it)=>Math.max(m,it.z||0),0)+1; }
  function getItem(id){ return items.find(it=>it.id===id)||null; }
  function itemCenter(it){ return { x: it.x + it.w/2, y: it.y + it.h/2 }; }

  // Minimal placement (spiral)
  const GOLDEN = 2.399963229728653;
  const STEP = 92;
  function spiralPos(n, cx, cy){
    const r = STEP*Math.sqrt(Math.max(0,n));
    const t = n*GOLDEN;
    return { x: cx + r*Math.cos(t), y: cy + r*Math.sin(t) };
  }

  // Render items (update-in-place for smoothness)
  function ensureItemEl(it){
    let el = elById.get(it.id);
    if(el) return el;

    el = document.createElement("div");
    el.className = "item";
    el.dataset.id = it.id;

    if(it.type==="evidence"){
      const img = document.createElement("img");
      img.className = "evidenceImg";
      img.src = it.evidence?.dataUrl || "";
      el.appendChild(img);

      const cap = document.createElement("div");
      cap.className = "evidenceCap";
      cap.textContent = it.evidence?.caption || it.label || "evidence";
      el.appendChild(cap);
    } else {
      const card = document.createElement("div");
      card.className = "card";

      const head = document.createElement("div");
      head.className = "cardHead";
      head.innerHTML = `<div>${(it.type||"item").toUpperCase()}</div><div class="meta"></div>`;
      const meta = head.querySelector(".meta");

      const body = document.createElement("div");
      body.className = "cardBody";

      const name = document.createElement("input");
      name.className = "cardField";
      name.placeholder = "";
      name.value = it.name || "";
      name.addEventListener("input", ()=>{
        const x=getItem(it.id); if(!x) return;
        x.name = name.value;
        if(!x.label) x.label = x.name;
        refreshCardMeta(x);
        renderTimeline();
        autosave(false);
      });
      name.addEventListener("mousedown",(ev)=>ev.stopPropagation());

      const note = document.createElement("textarea");
      note.className = "cardNote";
      note.value = it.notes || "";
      note.placeholder = "";
      note.addEventListener("input", ()=>{
        const x=getItem(it.id); if(!x) return;
        x.notes = note.value;
        autosave(false);
      });
      note.addEventListener("mousedown",(ev)=>ev.stopPropagation());

      body.appendChild(name);

      // compact meta fields: only show when present
      const kv = document.createElement("div");
      kv.className = "cardKV";
      kv.dataset.kv = "1";
      body.appendChild(kv);

      body.appendChild(note);

      card.appendChild(head);
      card.appendChild(body);
      el.appendChild(card);

      // head drag affordance
      head.addEventListener("mousedown",(ev)=>{
        ev.stopPropagation();
        onItemDown(ev, true);
      });
    }

    el.addEventListener("mousedown",(e)=>onItemDown(e,false));
    board.appendChild(el);
    elById.set(it.id, el);
    refreshCardMeta(it);
    return el;
  }

  function refreshCardMeta(it){
    const el = elById.get(it.id);
    if(!el || it.type==="evidence") return;

    const meta = el.querySelector(".cardHead .meta");
    const bits = [];
    if(it.type==="event" && (it.date||"").trim()) bits.push(it.date.trim());
    if((it.label||"").trim() && (it.label.trim() !== (it.name||"").trim())) bits.push(it.label.trim());
    meta.textContent = bits.join(" • ");

    const kv = el.querySelector('[data-kv="1"]');
    if(!kv) return;
    kv.innerHTML = "";

    const f = it.fields || {};
    const show = [];
    if(it.type==="event" && (it.date||"").trim()) show.push(["date", it.date.trim()]);
    // only show user-added fields; do not show placeholders
    for(const [k,v] of Object.entries(f)){
      if(String(v||"").trim()==="") continue;
      show.push([k, String(v)]);
    }
    if(!show.length){
      kv.style.display="none";
      return;
    }
    kv.style.display="grid";
    for(const [k,v] of show.slice(0,6)){
      const kdiv=document.createElement("div");
      kdiv.className="k";
      kdiv.textContent=k;
      const vdiv=document.createElement("div");
      vdiv.textContent=v;
      kv.appendChild(kdiv);
      kv.appendChild(vdiv);
    }
  }

  function updateItemEl(it){
    const el = ensureItemEl(it);
    el.classList.toggle("selected", it.id===selectedId);
    el.style.left = it.x+"px";
    el.style.top = it.y+"px";
    el.style.width = it.w+"px";
    el.style.height = it.h+"px";
    el.style.opacity = String(it.opacity ?? 1);
    el.style.transform = `rotate(${it.r||0}deg)`;
    el.style.zIndex = String(it.z||0);

    if(it.type==="evidence"){
      const img=el.querySelector("img");
      if(img && it.evidence?.dataUrl) img.src = it.evidence.dataUrl;
      const cap=el.querySelector(".evidenceCap");
      if(cap) cap.textContent = it.evidence?.caption || it.label || "evidence";
    }
  }

  function removeItemEl(id){
    const el = elById.get(id);
    if(el){ el.remove(); elById.delete(id); }
  }

  function renderAllItems(){
    // ensure all exist
    for(const it of items) ensureItemEl(it);
    // remove stray
    for(const [id] of elById.entries()){
      if(!items.some(x=>x.id===id)) removeItemEl(id);
    }
    // update order/pos
    const sorted=[...items].sort((a,b)=>(a.z||0)-(b.z||0));
    for(const it of sorted) updateItemEl(it);
    // handles
    document.querySelectorAll(".handle,.rot").forEach(n=>n.remove());
    if(selectedId){
      const el = elById.get(selectedId);
      if(el){
        ["nw","ne","sw","se"].forEach(pos=>{
          const h=document.createElement("div");
          h.className=`handle h-${pos}`;
          h.dataset.handle=pos;
          el.appendChild(h);
        });
        const rot=document.createElement("div");
        rot.className="rot";
        rot.dataset.handle="rot";
        el.appendChild(rot);
      }
    }
    renderLinks();
  }

  function renderLinks(){
    linkSvg.innerHTML="";
    if(!linksVisible) return;

    for(const e of edges){
      const a=getItem(e.from), b=getItem(e.to);
      if(!a||!b) continue;
      const ca=itemCenter(a), cb=itemCenter(b);
      const midx=(ca.x+cb.x)/2, midy=(ca.y+cb.y)/2;
      const isSel = e.id===selectedEdgeId;

      const line=document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute("x1", ca.x); line.setAttribute("y1", ca.y);
      line.setAttribute("x2", cb.x); line.setAttribute("y2", cb.y);
      line.setAttribute("class", "edge"+(isSel?" selected":""));
      linkSvg.appendChild(line);

      const hit=document.createElementNS("http://www.w3.org/2000/svg","line");
      hit.setAttribute("x1", ca.x); hit.setAttribute("y1", ca.y);
      hit.setAttribute("x2", cb.x); hit.setAttribute("y2", cb.y);
      hit.setAttribute("class","edgeHit");
      hit.addEventListener("mousedown",(ev)=>{
        ev.stopPropagation();
        selectEdge(e.id);
      });
      linkSvg.appendChild(hit);

      const lbl=(e.label||"").trim();
      if(lbl){
        const t=document.createElementNS("http://www.w3.org/2000/svg","text");
        t.setAttribute("x", midx+6);
        t.setAttribute("y", midy-6);
        t.setAttribute("class","edgeLabel");
        t.textContent=lbl;
        linkSvg.appendChild(t);
      }
    }
  }

  // Selection
  function selectItem(id){
    selectedId=id;
    if(id!==null) selectedEdgeId=null;
    syncEditPanel();
    syncEdgePanel();
    renderAllItems();
  }
  function selectEdge(id){
    selectedEdgeId=id;
    if(id!==null) selectedId=null;
    syncEditPanel();
    syncEdgePanel();
    renderLinks();
  }

  // Drag/resize/rotate + link creation
  let drag=null;

  function onItemDown(e, fromHead){
    const el = e.currentTarget.closest(".item") || e.target.closest(".item");
    if(!el) return;
    const id = el.dataset.id;

    if(linkMode){
      e.preventDefault();
      e.stopPropagation();
      if(!linkFromId){
        linkFromId=id;
        selectItem(id);
        showToast("select target");
        return;
      }
      if(linkFromId===id){
        linkFromId=null;
        showToast("cancel");
        return;
      }
      const ne={ id:uid(), from:linkFromId, to:id, label:"", note:"" };
      edges.push(ne);
      linkFromId=null;
      selectEdge(ne.id);
      renderEdgesList();
      autosave(false);
      showToast("linked");
      return;
    }

    selectItem(id);
    const it=getItem(id); if(!it) return;

    const handle = e.target.dataset && e.target.dataset.handle;
    const pt = screenToWorld(e.clientX, e.clientY);

    if(handle==="rot"){
      const cx=it.x+it.w/2, cy=it.y+it.h/2;
      const ang0=Math.atan2(pt.y-cy, pt.x-cx);
      drag={ mode:"rot", id, cx, cy, ang0, r0:it.r||0 };
      bindDrag();
      return;
    }

    if(handle){
      drag={ mode:"resize", id, handle, x0:it.x,y0:it.y,w0:it.w,h0:it.h, p0:pt };
      bindDrag();
      return;
    }

    // move
    drag={ mode:"move", id, x0:it.x,y0:it.y, p0:pt };
    bindDrag();
  }

  function bindDrag(){
    window.addEventListener("mousemove", onDragMove);
    window.addEventListener("mouseup", onDragUp);
  }

  function onDragMove(e){
    if(!drag) return;
    const it=getItem(drag.id); if(!it) return;
    const pt=screenToWorld(e.clientX, e.clientY);

    if(drag.mode==="move"){
      it.x = drag.x0 + (pt.x - drag.p0.x);
      it.y = drag.y0 + (pt.y - drag.p0.y);
      updateItemEl(it);
      renderLinks();
      return;
    }

    if(drag.mode==="resize"){
      const dx=pt.x-drag.p0.x, dy=pt.y-drag.p0.y;
      let x=drag.x0, y=drag.y0, w=drag.w0, h=drag.h0;

      if(drag.handle==="se"){ w=drag.w0+dx; h=drag.h0+dy; }
      if(drag.handle==="sw"){ x=drag.x0+dx; w=drag.w0-dx; h=drag.h0+dy; }
      if(drag.handle==="ne"){ y=drag.y0+dy; w=drag.w0+dx; h=drag.h0-dy; }
      if(drag.handle==="nw"){ x=drag.x0+dx; y=drag.y0+dy; w=drag.w0-dx; h=drag.h0-dy; }

      it.x=x; it.y=y;
      it.w=clamp(w, 160, 5000);
      it.h=clamp(h, 140, 5000);
      updateItemEl(it);
      renderLinks();
      return;
    }

    if(drag.mode==="rot"){
      const ang=Math.atan2(pt.y-drag.cy, pt.x-drag.cx);
      it.r = drag.r0 + (ang-drag.ang0)*180/Math.PI;
      updateItemEl(it);
      return;
    }
  }

  function onDragUp(){
    if(!drag) return;
    drag=null;
    window.removeEventListener("mousemove", onDragMove);
    window.removeEventListener("mouseup", onDragUp);
    autosave(false);
    renderAllItems(); // re-add handles cleanly
  }

  // Left Create -> board
  const newType=$("newType"), newName=$("newName"), newDate=$("newDate"), newLabel=$("newLabel"), newNotes=$("newNotes");

  function addToBoard(payload){
    const rect=stage.getBoundingClientRect();
    const c=screenToWorld(rect.left+rect.width/2, rect.top+rect.height/2);
    const n=items.length;
    const p=spiralPos(n, c.x, c.y);

    const it = {
      id: uid(),
      type: payload.type,
      name: payload.name||"",
      label: payload.label||"",
      date: payload.date||"",
      notes: payload.notes||"",
      fields: payload.fields || {},
      x: p.x - 220,
      y: p.y - 120,
      w: payload.type==="evidence" ? 420 : 440,
      h: payload.type==="evidence" ? 270 : 260,
      r: 0,
      opacity: 1,
      z: nextZ()
    };
    if(payload.type==="evidence"){
      it.evidence = payload.evidence;
    }
    items.push(it);
    ensureItemEl(it);
    updateItemEl(it);
    selectItem(it.id);
    renderTimeline();
    renderEdgesList();
    autosave(false);
  }

  $("btnAddToBoard").addEventListener("click", ()=>{
    const type = newType.value;
    const name = (newName.value||"").trim();
    const date = (newDate.value||"").trim();
    const label = (newLabel.value||"").trim();
    const notes = (newNotes.value||"").trim();

    const it = {
      type,
      name,
      date: (type==="event" ? date : ""),
      label,
      notes,
      fields:{}
    };
    addToBoard(it);

    newName.value=""; newDate.value=""; newLabel.value=""; newNotes.value="";
    showToast("added");
  });

  // Evidence import
  function readAsDataURL(file){
    return new Promise((res, rej)=>{
      const fr=new FileReader();
      fr.onload=()=>res(fr.result);
      fr.onerror=rej;
      fr.readAsDataURL(file);
    });
  }

  $("imgInput").addEventListener("change", async (ev)=>{
    const files=[...(ev.target.files||[])];
    if(!files.length) return;

    for(const f of files){
      const dataUrl = await readAsDataURL(f);
      addToBoard({
        type:"evidence",
        name:"",
        label:f.name,
        date:"",
        notes:"",
        fields:{},
        evidence:{ dataUrl, caption:f.name }
      });
    }
    ev.target.value="";
    showToast("imported");
  });

  // Edit panel (selected item)
  const editEmpty=$("editEmpty");
  const editForm=$("editForm");
  const selId=$("selId");
  const selType=$("selType");
  const selName=$("selName");
  const selDate=$("selDate");
  const selLabel=$("selLabel");
  const selNotes=$("selNotes");
  const selOpacity=$("selOpacity");
  const fieldsList=$("fieldsList");
  const fieldKey=$("fieldKey");
  const fieldVal=$("fieldVal");

  function syncEditPanel(){
    const it=getItem(selectedId);
    const isLeftEdit = document.querySelector('[data-lefttab="edit"]').classList.contains("active");

    if(!it){
      editEmpty.classList.remove("hidden");
      editForm.classList.add("hidden");
      return;
    }
    editEmpty.classList.add("hidden");
    editForm.classList.remove("hidden");

    selId.textContent = it.id;
    selType.value = it.type;
    selName.value = it.name || "";
    selDate.value = it.date || "";
    selLabel.value = it.label || "";
    selNotes.value = it.notes || "";
    selOpacity.value = String(Math.round((it.opacity??1)*100));

    // date only meaningful for event
    selDate.disabled = (it.type!=="event");

    // fields list
    renderFieldsList(it);
  }

  function renderFieldsList(it){
    fieldsList.innerHTML="";
    const f=it.fields||{};
    const keys=Object.keys(f);
    if(!keys.length){
      const d=document.createElement("div");
      d.className="small";
      d.textContent="";
      fieldsList.appendChild(d);
      return;
    }
    for(const k of keys){
      const row=document.createElement("div");
      row.style.display="grid";
      row.style.gridTemplateColumns="120px 1fr 60px";
      row.style.gap="6px";
      row.style.marginBottom="6px";

      const kIn=document.createElement("input");
      kIn.type="text";
      kIn.value=k;

      const vIn=document.createElement("input");
      vIn.type="text";
      vIn.value=String(f[k] ?? "");

      const del=document.createElement("button");
      del.className="ghost danger";
      del.textContent="Del";

      kIn.addEventListener("input", ()=>{
        const cur=getItem(it.id); if(!cur) return;
        const nextKey=(kIn.value||"").trim();
        if(!nextKey) return;
        if(nextKey===k) return;
        cur.fields = cur.fields || {};
        if(cur.fields[nextKey]===undefined){
          cur.fields[nextKey]=cur.fields[k];
          delete cur.fields[k];
          renderFieldsList(cur);
          refreshCardMeta(cur);
          autosave(false);
        }
      });

      vIn.addEventListener("input", ()=>{
        const cur=getItem(it.id); if(!cur) return;
        cur.fields = cur.fields || {};
        cur.fields[(kIn.value||k).trim() || k] = vIn.value;
        refreshCardMeta(cur);
        autosave(false);
      });

      del.addEventListener("click", ()=>{
        const cur=getItem(it.id); if(!cur) return;
        cur.fields = cur.fields || {};
        const key=(kIn.value||k).trim() || k;
        delete cur.fields[key];
        renderFieldsList(cur);
        refreshCardMeta(cur);
        autosave(false);
      });

      row.appendChild(kIn);
      row.appendChild(vIn);
      row.appendChild(del);
      fieldsList.appendChild(row);
    }
  }

  selType.addEventListener("change", ()=>{
    const it=getItem(selectedId); if(!it) return;
    const next=selType.value;

    // keep evidence as evidence (don’t convert images into text cards silently)
    if(it.type==="evidence" && next!=="evidence"){
      selType.value="evidence";
      return;
    }

    it.type=next;
    if(next!=="event") it.date="";
    selDate.disabled = (next!=="event");
    refreshCardMeta(it);
    renderAllItems();
    renderTimeline();
    autosave(false);
  });

  selName.addEventListener("input", ()=>{
    const it=getItem(selectedId); if(!it) return;
    it.name=selName.value;
    if(!it.label) it.label=it.name;
    refreshCardMeta(it);
    autosave(false);
  });

  selDate.addEventListener("input", ()=>{
    const it=getItem(selectedId); if(!it) return;
    if(it.type!=="event") return;
    it.date=selDate.value.trim();
    refreshCardMeta(it);
    renderTimeline();
    autosave(false);
  });

  selLabel.addEventListener("input", ()=>{
    const it=getItem(selectedId); if(!it) return;
    it.label=selLabel.value;
    refreshCardMeta(it);
    renderAllItems();
    autosave(false);
  });

  selNotes.addEventListener("input", ()=>{
    const it=getItem(selectedId); if(!it) return;
    it.notes=selNotes.value;
    autosave(false);
  });

  selOpacity.addEventListener("input", ()=>{
    const it=getItem(selectedId); if(!it) return;
    it.opacity = clamp(Number(selOpacity.value)/100, .10, 1);
    updateItemEl(it);
    autosave(false);
  });

  $("btnAddField").addEventListener("click", ()=>{
    const it=getItem(selectedId); if(!it) return;
    const k=(fieldKey.value||"").trim();
    const v=(fieldVal.value||"").trim();
    if(!k) return;
    it.fields = it.fields || {};
    it.fields[k]=v;
    fieldKey.value=""; fieldVal.value="";
    renderFieldsList(it);
    refreshCardMeta(it);
    autosave(false);
  });

  $("btnFront").addEventListener("click", ()=>{
    const it=getItem(selectedId); if(!it) return;
    it.z=nextZ();
    renderAllItems();
    autosave(false);
  });

  $("btnBack").addEventListener("click", ()=>{
    const it=getItem(selectedId); if(!it) return;
    it.z=0;
    renderAllItems();
    autosave(false);
  });

  $("btnDelete").addEventListener("click", ()=>{
    if(!selectedId) return;
    const id=selectedId;
    items=items.filter(x=>x.id!==id);
    edges=edges.filter(e=>e.from!==id && e.to!==id);
    removeItemEl(id);
    selectedId=null;
    selectedEdgeId=null;
    linkFromId=null;
    renderAllItems();
    renderTimeline();
    renderEdgesList();
    syncEditPanel();
    syncEdgePanel();
    autosave(false);
    showToast("deleted");
  });

  // Bottom connections manager
  const edgeLabel=$("edgeLabel");
  const edgeNote=$("edgeNote");
  const btnDelEdge=$("btnDelEdge");
  const edgesEmpty=$("edgesEmpty");
  const edgesList=$("edgesList");

  function syncEdgePanel(){
    const ed = edges.find(x=>x.id===selectedEdgeId) || null;
    if(!ed){
      edgeLabel.value="";
      edgeNote.value="";
      return;
    }
    edgeLabel.value=ed.label||"";
    edgeNote.value=ed.note||"";
  }

  edgeLabel.addEventListener("input", ()=>{
    const ed=edges.find(x=>x.id===selectedEdgeId); if(!ed) return;
    ed.label=edgeLabel.value;
    renderLinks();
    renderEdgesList();
    autosave(false);
  });

  edgeNote.addEventListener("input", ()=>{
    const ed=edges.find(x=>x.id===selectedEdgeId); if(!ed) return;
    ed.note=edgeNote.value;
    autosave(false);
  });

  btnDelEdge.addEventListener("click", ()=>{
    if(!selectedEdgeId) return;
    edges=edges.filter(x=>x.id!==selectedEdgeId);
    selectedEdgeId=null;
    renderLinks();
    renderEdgesList();
    syncEdgePanel();
    autosave(false);
    showToast("edge deleted");
  });

  function renderEdgesList(){
    if(!edges.length){
      edgesEmpty.classList.remove("hidden");
      edgesList.classList.add("hidden");
      edgesList.innerHTML="";
      return;
    }
    edgesEmpty.classList.add("hidden");
    edgesList.classList.remove("hidden");
    edgesList.innerHTML="";

    for(const e of edges){
      const a=getItem(e.from), b=getItem(e.to);
      const row=document.createElement("div");
      row.style.display="grid";
      row.style.gridTemplateColumns="1fr 1fr 1fr";
      row.style.gap="8px";
      row.style.padding="6px 8px";
      row.style.border="1px solid rgba(255,255,255,.10)";
      row.style.background="rgba(255,255,255,.02)";
      row.style.cursor="pointer";
      row.style.marginBottom="6px";
      row.style.borderColor = (e.id===selectedEdgeId) ? "rgba(255,255,255,.26)" : "rgba(255,255,255,.10)";

      const c1=document.createElement("div"); c1.textContent=(a?.name||a?.label||"—");
      const c2=document.createElement("div"); c2.textContent=(e.label||""); c2.style.color="rgba(255,255,255,.62)";
      const c3=document.createElement("div"); c3.textContent=(b?.name||b?.label||"—"); c3.style.textAlign="right";

      row.appendChild(c1); row.appendChild(c2); row.appendChild(c3);
      row.addEventListener("click", ()=>{
        selectEdge(e.id);
      });

      edgesList.appendChild(row);
    }
  }

  // Link mode + links visible
  $("btnLinkMode").addEventListener("click", ()=>{
    linkMode=!linkMode;
    linkFromId=null;
    $("btnLinkMode").textContent = "Link: " + (linkMode ? "On" : "Off");
    showToast(linkMode ? "link on" : "link off");
  });

  $("btnLinksVis").addEventListener("click", ()=>{
    linksVisible=!linksVisible;
    $("btnLinksVis").textContent = "Links: " + (linksVisible ? "On" : "Off");
    renderLinks();
    autosave(false);
  });

  // Timeline (right panel)
  const timelineEmpty=$("timelineEmpty");
  const timelineList=$("timelineList");

  function renderTimeline(){
    const evs = items
      .filter(it=>it.type==="event")
      .map(it=>({
        id: it.id,
        date: (it.date||"").trim(),
        title: (it.name||it.label||"").trim() || "event"
      }))
      .sort((a,b)=>{
        if(!a.date && !b.date) return a.title.localeCompare(b.title);
        if(!a.date) return 1;
        if(!b.date) return -1;
        return a.date.localeCompare(b.date);
      });

    if(!evs.length){
      timelineEmpty.classList.remove("hidden");
      timelineList.classList.add("hidden");
      timelineList.innerHTML="";
      return;
    }

    timelineEmpty.classList.add("hidden");
    timelineList.classList.remove("hidden");
    timelineList.innerHTML="";

    for(const e of evs){
      const row=document.createElement("div");
      row.className="trow";
      row.style.borderColor = (e.id===selectedId) ? "rgba(255,255,255,.26)" : "rgba(255,255,255,.10)";
      const d=document.createElement("div"); d.className="tdate"; d.textContent=e.date||"—";
      const t=document.createElement("div"); t.className="ttitle"; t.textContent=e.title;
      row.appendChild(d); row.appendChild(t);
      row.addEventListener("click", ()=>{
        selectItem(e.id);
        focusOnItem(e.id);
      });
      timelineList.appendChild(row);
    }
  }

  function focusOnItem(id){
    const it=getItem(id); if(!it) return;
    const rect=stage.getBoundingClientRect();
    const cx=rect.width/2, cy=rect.height/2;
    const tx = -it.x - it.w/2;
    const ty = -it.y - it.h/2;
    view.panX = cx + tx*view.scale;
    view.panY = cy + ty*view.scale;
    applyView();
  }

  // Keyboard: delete / esc cancel link
  document.addEventListener("keydown", (e)=>{
    if(e.key==="Escape"){
      linkFromId=null;
      if(linkMode) showToast("cancel");
      return;
    }
    if(e.key==="Delete" || e.key==="Backspace"){
      const active=document.activeElement;
      if(active && (active.tagName==="INPUT" || active.tagName==="TEXTAREA" || active.isContentEditable)) return;

      if(selectedEdgeId){
        edges=edges.filter(x=>x.id!==selectedEdgeId);
        selectedEdgeId=null;
        renderLinks();
        renderEdgesList();
        syncEdgePanel();
        autosave(false);
        showToast("edge deleted");
        return;
      }
      if(selectedId){
        const id=selectedId;
        items=items.filter(x=>x.id!==id);
        edges=edges.filter(e=>e.from!==id && e.to!==id);
        removeItemEl(id);
        selectedId=null;
        renderAllItems();
        renderTimeline();
        renderEdgesList();
        syncEditPanel();
        autosave(false);
        showToast("deleted");
      }
    }
  });

  // Invert
  function toggleInvert(){
    root.classList.toggle("invert");
    autosave(false);
  }
  $("btnInvert").addEventListener("click", toggleInvert);

  // Export/import/save/load
  function buildPayload(){
    return {
      file_id: FILE_ID,
      room_id: ROOM_ID,
      version: VERSION,
      updated_at: new Date().toISOString(),
      layout, view,
      items, edges,
      linksVisible,
      invert: root.classList.contains("invert")
    };
  }

  function download(filename, textOrBlob){
    const blob = (textOrBlob instanceof Blob) ? textOrBlob : new Blob([textOrBlob], {type:"application/octet-stream"});
    const url = URL.createObjectURL(blob);
    const a=document.createElement("a");
    a.href=url; a.download=filename; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 250);
  }

  function autosave(withToast){
    localStorage.setItem(KEY_LOCAL, JSON.stringify(buildPayload()));
    if(withToast) showToast("saved");
  }

  function applyPayload(p){
    layout = p.layout || layout;
    view = p.view || view;
    items = p.items || [];
    edges = p.edges || [];
    linksVisible = (p.linksVisible!==undefined) ? p.linksVisible : true;
    root.classList.toggle("invert", !!p.invert);

    // reset DOM map
    for(const [id] of elById.entries()) removeItemEl(id);

    applyLayout();
    applyView();

    // restore content
    renderAllItems();
    renderLinks();
    renderTimeline();
    renderEdgesList();

    selectedId=null; selectedEdgeId=null; linkFromId=null;
    syncEditPanel();
    syncEdgePanel();

    $("btnLinksVis").textContent = "Links: " + (linksVisible ? "On" : "Off");
    $("btnLinkMode").textContent = "Link: " + (linkMode ? "On" : "Off");
  }

  $("btnExportAll").addEventListener("click", ()=>{
    const name = `case_board__${new Date().toISOString().slice(0,19).replace(/[:T]/g,"-")}.json`;
    download(name, JSON.stringify(buildPayload(), null, 2));
    showToast("exported");
  });

  $("importFile").addEventListener("change", async (ev)=>{
    const f=(ev.target.files||[])[0];
    if(!f) return;
    try{
      const text=await f.text();
      applyPayload(JSON.parse(text));
      autosave(false);
      showToast("imported");
    }catch{
      showToast("import fail");
    }finally{
      ev.target.value="";
    }
  });

  $("btnSaveLocal").addEventListener("click", ()=>autosave(true));
  $("btnLoadLocal").addEventListener("click", ()=>{
    const raw=localStorage.getItem(KEY_LOCAL);
    if(!raw){ showToast("no save"); return; }
    try{ applyPayload(JSON.parse(raw)); showToast("loaded"); }
    catch{ showToast("load fail"); }
  });

  $("btnClear").addEventListener("click", ()=>{
    if(!confirm("clear all?")) return;
    items=[]; edges=[];
    selectedId=null; selectedEdgeId=null; linkFromId=null;
    for(const [id] of elById.entries()) removeItemEl(id);
    renderLinks();
    renderTimeline();
    renderEdgesList();
    syncEditPanel();
    syncEdgePanel();
    autosave(false);
    showToast("cleared");
  });

  // Timeline export (right panel)
  $("btnExportTimeline").addEventListener("click", ()=>{
    const evs = items
      .filter(it=>it.type==="event")
      .map(it=>({
        id: it.id,
        date: (it.date||"").trim(),
        name: (it.name||"").trim(),
        label: (it.label||"").trim(),
        notes: (it.notes||"").trim()
      }))
      .sort((a,b)=>{
        if(!a.date && !b.date) return (a.name||"").localeCompare(b.name||"");
        if(!a.date) return 1;
        if(!b.date) return -1;
        return a.date.localeCompare(b.date);
      });

    const name = `timeline__${new Date().toISOString().slice(0,19).replace(/[:T]/g,"-")}.json`;
    download(name, JSON.stringify({ timeline: evs }, null, 2));
    showToast("timeline exported");
  });

  // KETA_NOTE (white square + pad)
  const ketaSquare=$("ketaSquare");
  const ketaPad=$("ketaPad");
  const ketaHead=$("ketaHead");
  const ketaText=$("ketaText");

  function openNote(){ ketaPad.classList.add("open"); }
  function closeNote(){ ketaPad.classList.remove("open"); }

  ketaSquare.addEventListener("click", ()=>{
    if(ketaPad.classList.contains("open")) closeNote();
    else openNote();
  });
  $("ketaClose").addEventListener("click", closeNote);

  ketaText.value = localStorage.getItem(KEY_NOTE) || "";
  ketaText.addEventListener("input", ()=> localStorage.setItem(KEY_NOTE, ketaText.value));

  $("ketaCopy").addEventListener("click", async ()=>{
    try{ await navigator.clipboard.writeText(ketaText.value||""); showToast("copied"); }
    catch{ showToast("copy fail"); }
  });

  $("ketaExport").addEventListener("click", ()=>{
    download("keta_note.txt", new Blob([ketaText.value||""], {type:"text/plain;charset=utf-8"}));
    showToast("exported");
  });

  // draggable note + remember position
  function setNotePos(x,y){
    ketaPad.style.left = x+"px";
    ketaPad.style.top = y+"px";
    ketaPad.style.right = "auto";
    localStorage.setItem(KEY_NOTE_POS, JSON.stringify({x,y}));
  }
  const np = localStorage.getItem(KEY_NOTE_POS);
  if(np){
    try{
      const {x,y}=JSON.parse(np);
      setNotePos(x,y);
    }catch{}
  }
  let noteDrag=null;
  ketaHead.addEventListener("mousedown", (e)=>{
    if(e.target.closest("button")) return;
    const r=ketaPad.getBoundingClientRect();
    noteDrag={ dx:e.clientX-r.left, dy:e.clientY-r.top };
    e.preventDefault();
  });
  window.addEventListener("mousemove", (e)=>{
    if(!noteDrag) return;
    const x=clamp(e.clientX-noteDrag.dx, 0, window.innerWidth-120);
    const y=clamp(e.clientY-noteDrag.dy, 44, window.innerHeight-80);
    setNotePos(x,y);
  });
  window.addEventListener("mouseup", ()=>noteDrag=null);

  // Bottom edges list init sync
  function syncEdgesVisibility(){
    $("btnLinksVis").textContent = "Links: " + (linksVisible ? "On" : "Off");
  }

  // INIT
  applyLayout();
  applyView();

  // restore local state if present
  const raw=localStorage.getItem(KEY_LOCAL);
  if(raw){
    try{ applyPayload(JSON.parse(raw)); }
    catch{
      // if broken, start empty
      items=[]; edges=[];
      renderAllItems(); renderTimeline(); renderEdgesList();
    }
  } else {
    // start empty (not busy)
    items=[]; edges=[];
    renderAllItems();
    renderTimeline();
    renderEdgesList();
    syncEditPanel();
    syncEdgePanel();
  }

  // If user clicks stage when link mode is active and waiting, keep quiet.
})();
</script>

<!--
AE: hypoallergenic industrial minimal; empty state shows nothing loud; uniform text size; black void.
EE: left input -> creates items; items editable later; fields accumulate; draggable/resizable/rotatable; pan/zoom; bottom manages edges; right timeline from events with export; import/export + local save; invert; KETA_NOTE square+pad.
WB: state wiring between panels + board + timeline + edges; localStorage persistence; file download import/export.
FILE_ID: KETADATA_CASE_BOARD_v2
ROOM_ID: CASE_BOARD
VERSION: 2.0.0
UPDATED_AT: 2026-02-06
CHANGELOG:
- v2.0.0: three-panel layout (left input/edit, right timeline, bottom connections); keta_note square; minimal empty state; smooth update-in-place rendering.
-->
</body>
</html>
