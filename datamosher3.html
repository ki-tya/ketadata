<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA // LIVE MOSH (SOUND REACTIVE)</title>
<style>
:root{
  --bg:#000;
  --fg:rgba(255,255,255,.86);
  --muted:rgba(255,255,255,.52);
  --line:rgba(255,255,255,.10);
  --line2:rgba(255,255,255,.18);
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;

  --top:40px;
  --bot:28px;
  --ctlH:24px;
  --padX:10px;
  --gap:8px;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:var(--mono);overflow:hidden}
#root{position:fixed;inset:0;background:var(--bg)}
#root.invert{filter:invert(1)}
#root.null #top,#root.null #bot,#root.null #drawer{display:none !important;}
#root.null #view{top:0;bottom:0;}

#top{
  position:fixed;left:0;right:0;top:0;height:var(--top);
  display:grid;grid-template-columns:auto 1fr auto;
  align-items:center;padding:0 var(--padX);
  border-bottom:1px solid var(--line);
  background:rgba(0,0,0,.34);
  backdrop-filter: blur(6px);
  user-select:none;z-index:50;gap:var(--gap);
}
#brand{letter-spacing:.14em;white-space:nowrap;opacity:.88}

#mid{
  display:flex;align-items:center;gap:var(--gap);min-width:0;
}
.pill{
  height:var(--ctlH);
  display:flex;align-items:center;gap:var(--gap);
  padding:0 8px;border:1px solid var(--line);
  background:rgba(255,255,255,.02);
}
#modeName{color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:36ch}
#btnRow{display:flex;align-items:center;gap:var(--gap);justify-content:flex-end;flex-wrap:nowrap}

button,select{
  font:inherit;height:var(--ctlH);padding:0 8px;
  color:var(--fg);background:transparent;border:1px solid var(--line);
}
button{cursor:pointer}
button:hover,select:hover{border-color:var(--line2)}
select{cursor:pointer}
option{background:#000;color:#fff}

#view{position:fixed;left:0;right:0;top:var(--top);bottom:var(--bot);background:#000}
canvas{width:100%;height:100%;display:block}

#bot{
  position:fixed;left:0;right:0;bottom:0;height:var(--bot);
  display:grid;grid-template-columns:1fr auto;
  align-items:center;padding:0 var(--padX);
  border-top:1px solid var(--line);
  background:rgba(0,0,0,.26);
  backdrop-filter: blur(6px);
  user-select:none;z-index:50;gap:var(--gap);
}
#hint{color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;opacity:.85}
#sig{color:var(--muted);opacity:.70;white-space:nowrap}

#drawer{
  position:fixed;left:var(--padX);top:calc(var(--top) + var(--padX));
  width:min(560px, calc(100vw - (2*var(--padX))));
  border:1px solid var(--line);
  background:rgba(0,0,0,.40);
  backdrop-filter: blur(8px);
  padding:10px;z-index:60;display:none;
}
#drawer.open{display:block}
.row{display:grid;grid-template-columns:128px 1fr 72px;gap:var(--gap);align-items:center;margin:8px 0}
.row label{opacity:.80}
input[type="range"]{width:100%}
.val{text-align:right;opacity:.76}
.thin{color:var(--muted);line-height:1.35;opacity:.85}
.sep{height:1px;background:var(--line);margin:10px 0}
</style>
</head>
<body>
<div id="root">
  <div id="top">
    <div id="brand">KETADATA // MOSH+SND</div>

    <div id="mid">
      <button id="startCamBtn">CAM</button>
      <button id="startAudBtn">AUDIO</button>
      <div class="pill"><span>MODE</span><span id="modeName">codec hell</span></div>
      <select id="modeSel" aria-label="Mode">
        <option value="codec">codec hell</option>
        <option value="brutal">brutal</option>
        <option value="liquid">liquid</option>
        <option value="ghost">ghost smear</option>
        <option value="vhs">vhs</option>
        <option value="cyber">cyber</option>
        <option value="pure">pure hold</option>
      </select>
      <button id="drawerBtn">SYS</button>
    </div>

    <div id="btnRow">
      <button id="keyBtn">KEY</button>
      <button id="moshBtn">MOSH <span id="moshLabel">ON</span></button>
      <button id="sndBtn">SND <span id="sndLabel">OFF</span></button>
      <button id="recBtn">REC <span id="recLabel">OFF</span></button>
      <button id="fsBtn">FULL</button>
      <button id="nullBtn">NULL</button>
    </div>
  </div>

  <div id="drawer">
    <div class="row"><label>KEY Hz</label><input id="keyHz" type="range" min="0" max="4" step="0.01"/><div class="val" id="keyHzV"></div></div>
    <div class="row"><label>FDBK</label><input id="feedback" type="range" min="0.80" max="0.999" step="0.001"/><div class="val" id="feedbackV"></div></div>
    <div class="row"><label>DISP</label><input id="disp" type="range" min="0" max="180" step="1"/><div class="val" id="dispV"></div></div>
    <div class="row"><label>GLCH</label><input id="glitch" type="range" min="0" max="1" step="0.01"/><div class="val" id="glitchV"></div></div>

    <div class="row"><label>BLK</label><input id="block" type="range" min="4" max="56" step="1"/><div class="val" id="blockV"></div></div>
    <div class="row"><label>RFRSH</label><input id="refresh" type="range" min="0" max="1" step="0.01"/><div class="val" id="refreshV"></div></div>
    <div class="row"><label>JIT</label><input id="jitter" type="range" min="0" max="1" step="0.01"/><div class="val" id="jitterV"></div></div>

    <div class="row"><label>MBIAS</label><input id="mbias" type="range" min="0" max="1" step="0.01"/><div class="val" id="mbiasV"></div></div>
    <div class="row"><label>MTHR</label><input id="mthr" type="range" min="0" max="1" step="0.01"/><div class="val" id="mthrV"></div></div>

    <div class="row"><label>C420</label><input id="c420" type="range" min="0" max="1" step="1"/><div class="val" id="c420V"></div></div>
    <div class="row"><label>CHRM</label><input id="chroma" type="range" min="0" max="1" step="0.01"/><div class="val" id="chromaV"></div></div>
    <div class="row"><label>QNT</label><input id="quant" type="range" min="0" max="1" step="0.01"/><div class="val" id="quantV"></div></div>
    <div class="row"><label>PSTR</label><input id="poster" type="range" min="0" max="1" step="0.01"/><div class="val" id="posterV"></div></div>
    <div class="row"><label>GRN</label><input id="grain" type="range" min="0" max="1" step="0.01"/><div class="val" id="grainV"></div></div>

    <div class="row"><label>SCN</label><input id="scan" type="range" min="0" max="1" step="0.01"/><div class="val" id="scanV"></div></div>
    <div class="row"><label>WRP</label><input id="warp" type="range" min="0" max="1" step="0.01"/><div class="val" id="warpV"></div></div>
    <div class="row"><label>EDGE</label><input id="edge" type="range" min="0" max="1" step="0.01"/><div class="val" id="edgeV"></div></div>

    <div class="sep"></div>

    <div class="row"><label>SND GAIN</label><input id="sndGain" type="range" min="0" max="3" step="0.01"/><div class="val" id="sndGainV"></div></div>
    <div class="row"><label>SND SMOOTH</label><input id="sndSmooth" type="range" min="0" max="0.98" step="0.01"/><div class="val" id="sndSmoothV"></div></div>
    <div class="row"><label>SND FLOOR</label><input id="sndFloor" type="range" min="0" max="0.3" step="0.005"/><div class="val" id="sndFloorV"></div></div>
    <div class="row"><label>SND PEAK</label><input id="sndPeak" type="range" min="0.1" max="1" step="0.01"/><div class="val" id="sndPeakV"></div></div>

    <div class="row"><label>MAP AMT</label><input id="mapAmt" type="range" min="0" max="1" step="0.01"/><div class="val" id="mapAmtV"></div></div>
    <div class="row"><label>MAP SEL</label>
      <select id="mapSel">
        <option value="club">club (balanced)</option>
        <option value="bass">bass (throb/warp)</option>
        <option value="hi">hi-hats (glitch/chroma)</option>
        <option value="voice">voice (refresh/ghost)</option>
        <option value="mad">mad (all)</option>
      </select>
      <div class="val"></div>
    </div>

    <div class="row"><label>INV</label><button id="invBtn">TOG</button><div class="val">SHIFT+I</div></div>
    <div class="row"><label>RESET</label><button id="resetBtn">APPLY</button><div class="val">R</div></div>

    <div class="thin">Sound-reactive modulates MOSH parameters in real time. Use SND toggle to arm/disarm.</div>
  </div>

  <div id="view"><canvas id="c"></canvas></div>

  <div id="bot">
    <div id="hint">CAM+ AUDIO buttons · SPACE MOSH · S sound · D sys · K key · R reset · SHIFT+F full · SHIFT+N null</div>
    <div id="sig"></div>
  </div>

  <video id="v" playsinline muted autoplay style="display:none"></video>
</div>

<script>
(() => {
  const $=id=>document.getElementById(id);
  const root=$("root");
  const canvas=$("c");
  const out=canvas.getContext("2d",{alpha:false,desynchronized:true});
  const v=$("v");

  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const now=()=>performance.now();

  const STATE={
    ui:{
      drawer:false,null:false,invert:false,
      camOn:false,audOn:false,
      mode:"codec",
      mosh:true,
      snd:false,

      // core
      keyHz:0.25,
      feedback:0.993,
      disp:38,
      glitch:0.70,

      block:16,
      refresh:0.16,
      jitter:0.20,

      mbias:0.85,
      mthr:0.18,

      c420:1,
      chroma:0.32,
      quant:0.55,
      poster:0.16,
      grain:0.14,

      scan:0.10,
      warp:0.00,
      edge:0.00,

      texEvery:2,

      // sound
      sndGain:1.25,
      sndSmooth:0.82,
      sndFloor:0.03,
      sndPeak:0.80,
      mapAmt:0.75,
      mapSel:"club"
    },
    base:{}, // stored preset baseline for sound modulation
    internal:{
      ready:false,
      lastKeyAt:0,
      frame:0,

      srcC:null,srcX:null,
      prevC:null,prevX:null,
      pbC:null,pbX:null,

      wts:null,wtsSum:0,blocksX:0,blocksY:0,

      rec:null, recChunks:[], recOn:false,

      // audio
      ac:null, an:null, data:null,
      level:0, bass:0, mid:0, tre:0, // smoothed
      lvlRaw:0
    }
  };

  const MODES={
    codec:{ keyHz:0.25, feedback:0.993, glitch:0.70, disp:38, block:16, refresh:0.16, jitter:0.20, mbias:0.85, mthr:0.18, c420:1, chroma:0.30, quant:0.55, poster:0.16, grain:0.14, scan:0.10, warp:0.00, edge:0.00, texEvery:2 },
    brutal:{ keyHz:0.18, feedback:0.996, glitch:0.82, disp:70, block:20, refresh:0.10, jitter:0.28, mbias:0.92, mthr:0.14, c420:1, chroma:0.20, quant:0.72, poster:0.26, grain:0.18, scan:0.14, warp:0.00, edge:0.10, texEvery:2 },
    liquid:{ keyHz:0.32, feedback:0.990, glitch:0.55, disp:28, block:12, refresh:0.22, jitter:0.35, mbias:0.70, mthr:0.12, c420:1, chroma:0.18, quant:0.35, poster:0.10, grain:0.10, scan:0.06, warp:0.22, edge:0.00, texEvery:3 },
    ghost:{ keyHz:0.10, feedback:0.997, glitch:0.35, disp:18, block:24, refresh:0.06, jitter:0.10, mbias:0.95, mthr:0.22, c420:1, chroma:0.08, quant:0.30, poster:0.06, grain:0.08, scan:0.04, warp:0.06, edge:0.00, texEvery:3 },
    vhs:{ keyHz:0.22, feedback:0.994, glitch:0.62, disp:42, block:18, refresh:0.14, jitter:0.18, mbias:0.78, mthr:0.18, c420:1, chroma:0.22, quant:0.48, poster:0.12, grain:0.22, scan:0.22, warp:0.40, edge:0.06, texEvery:2 },
    cyber:{ keyHz:0.30, feedback:0.992, glitch:0.58, disp:34, block:14, refresh:0.20, jitter:0.22, mbias:0.88, mthr:0.14, c420:0, chroma:0.55, quant:0.22, poster:0.18, grain:0.08, scan:0.08, warp:0.08, edge:0.55, texEvery:2 },
    pure:{ keyHz:0.00, feedback:0.999, glitch:0.00, disp:0, block:28, refresh:0.04, jitter:0.00, mbias:0.95, mthr:0.22, c420:1, chroma:0.00, quant:0.10, poster:0.00, grain:0.00, scan:0.00, warp:0.00, edge:0.00, texEvery:4 }
  };

  function modeLabel(name){
    return ({codec:"codec hell", brutal:"brutal", liquid:"liquid", ghost:"ghost smear", vhs:"vhs", cyber:"cyber", pure:"pure hold"})[name] || "codec hell";
  }

  function snapshotBase(){
    // baseline parameters that audio will modulate around
    const k = ["keyHz","feedback","disp","glitch","block","refresh","jitter","mbias","mthr","c420","chroma","quant","poster","grain","scan","warp","edge","texEvery"];
    const b={};
    for(const kk of k) b[kk]=STATE.ui[kk];
    STATE.base=b;
  }

  function applyMode(name){
    const m=MODES[name]||MODES.codec;
    STATE.ui.mode=name;
    for(const k in m) STATE.ui[k]=m[k];
    $("modeName").textContent = modeLabel(name);
    rebuildMotionGrid();
    snapshotBase();
    render();
  }

  function allocOffscreens(w,h){
    const I=STATE.internal;
    I.srcC=new OffscreenCanvas(w,h);   I.srcX=I.srcC.getContext("2d",{alpha:false});
    I.prevC=new OffscreenCanvas(w,h); I.prevX=I.prevC.getContext("2d",{alpha:false});
    I.pbC=new OffscreenCanvas(w,h);   I.pbX=I.pbC.getContext("2d",{alpha:false});
    for(const cx of [I.srcX,I.prevX,I.pbX]){
      cx.globalCompositeOperation="source-over"; cx.globalAlpha=1;
      cx.fillStyle="#000"; cx.fillRect(0,0,w,h);
    }
  }

  function fitCanvas(){
    const dpr=Math.max(1,Math.min(2,window.devicePixelRatio||1));
    const r=canvas.getBoundingClientRect();
    const w=Math.max(2,Math.floor(r.width*dpr));
    const h=Math.max(2,Math.floor(r.height*dpr));
    if(canvas.width!==w||canvas.height!==h){
      canvas.width=w; canvas.height=h;
      allocOffscreens(w,h);
      rebuildMotionGrid();
    }
  }

  function rebuildMotionGrid(){
    const W=canvas.width,H=canvas.height;
    const bs=Math.max(2,STATE.ui.block|0);
    const bx=Math.ceil(W/bs), by=Math.ceil(H/bs);
    const n=bx*by;
    STATE.internal.blocksX=bx; STATE.internal.blocksY=by;
    STATE.internal.wts=new Float32Array(n);
    STATE.internal.wtsSum=0;
  }

  function drawCamCover(ctx){
    const W=canvas.width,H=canvas.height;
    const vw=v.videoWidth||1,vh=v.videoHeight||1;
    const s=Math.max(W/vw,H/vh);
    const w=vw*s,h=vh*s;
    ctx.drawImage(v,(W-w)/2,(H-h)/2,w,h);
  }

  function renderSrc(){
    const I=STATE.internal;
    I.prevX.globalCompositeOperation="source-over"; I.prevX.globalAlpha=1;
    I.prevX.drawImage(I.srcC,0,0);

    I.srcX.setTransform(1,0,0,1,0,0);
    I.srcX.globalAlpha=1; I.srcX.globalCompositeOperation="source-over";
    I.srcX.fillStyle="#000"; I.srcX.fillRect(0,0,canvas.width,canvas.height);
    drawCamCover(I.srcX);
  }

  function keyframeNow(){
    STATE.internal.lastKeyAt=now();
    if(!STATE.ui.camOn) return;
    renderSrc();
    const pb=STATE.internal.pbX;
    pb.setTransform(1,0,0,1,0,0);
    pb.globalAlpha=1; pb.globalCompositeOperation="source-over";
    pb.drawImage(STATE.internal.srcC,0,0);
  }

  function computeMotionWeights(){
    const W=canvas.width,H=canvas.height;
    const bs=Math.max(2,STATE.ui.block|0);
    const bxN=Math.ceil(W/bs), byN=Math.ceil(H/bs);
    const n=bxN*byN;
    if(!STATE.internal.wts || STATE.internal.wts.length!==n) rebuildMotionGrid();

    const thr=clamp(STATE.ui.mthr,0,1);
    const thrAbs=thr*64;

    const a=STATE.internal.srcX.getImageData(0,0,W,H).data;
    const b=STATE.internal.prevX.getImageData(0,0,W,H).data;

    let sum=0, idx=0;
    const offs=[[0.25,0.25],[0.75,0.25],[0.25,0.75],[0.75,0.75],[0.50,0.50]];
    for(let by=0;by<byN;by++){
      const y0=by*bs;
      for(let bx=0;bx<bxN;bx++){
        const x0=bx*bs;
        let e=0;
        for(let s=0;s<5;s++){
          const sx=Math.min(W-1,Math.max(0,(x0+offs[s][0]*bs)|0));
          const sy=Math.min(H-1,Math.max(0,(y0+offs[s][1]*bs)|0));
          const p=(sy*W+sx)*4;
          const r1=a[p],g1=a[p+1],b1=a[p+2];
          const r0=b[p],g0=b[p+1],b0=b[p+2];
          const y1=(r1*3+g1*4+b1)>>3;
          const y0l=(r0*3+g0*4+b0)>>3;
          e+=Math.abs(y1-y0l);
        }
        e/=5;
        let w = e<=thrAbs ? 0.0005 : (e-thrAbs);
        w = w*w + 0.0005;
        STATE.internal.wts[idx++]=w;
        sum+=w;
      }
    }
    STATE.internal.wtsSum=sum;
  }

  function pickMotionBlock(){
    const wts=STATE.internal.wts;
    const sum=STATE.internal.wtsSum;
    if(!wts || sum<=0) return (Math.random()*wts.length)|0;
    let r=Math.random()*sum;
    for(let i=0;i<wts.length;i++){ r-=wts[i]; if(r<=0) return i; }
    return wts.length-1;
  }

  function selectiveRefreshPB(){
    const W=canvas.width,H=canvas.height;
    const pb=STATE.internal.pbX;
    const src=STATE.internal.srcC;

    const bs=Math.max(2,STATE.ui.block|0);
    const refresh=clamp(STATE.ui.refresh,0,1);
    const jitter=clamp(STATE.ui.jitter,0,1);

    const blocksX=Math.ceil(W/bs), blocksY=Math.ceil(H/bs);
    const total=blocksX*blocksY;
    const cap=900;
    const count=Math.min(cap, Math.floor(total*refresh));
    if(count<=0) return;

    const mbias=clamp(STATE.ui.mbias,0,1);
    if(mbias>0 && STATE.ui.mosh) computeMotionWeights();

    pb.globalAlpha=1; pb.globalCompositeOperation="source-over";
    for(let i=0;i<count;i++){
      let idx;
      if(mbias<=0 || !STATE.ui.mosh || Math.random()>mbias){
        idx=(Math.random()*total)|0;
      }else{
        idx=pickMotionBlock();
      }
      const bx=idx%blocksX, by=(idx/blocksX)|0;
      const x=bx*bs, y=by*bs;
      const w=Math.min(bs,W-x), h=Math.min(bs,H-y);

      const j=jitter*(bs*0.80);
      const sx=clamp(((x + (Math.random()*2-1)*j)|0), 0, W-w);
      const sy=clamp(((y + (Math.random()*2-1)*j)|0), 0, H-h);

      pb.drawImage(src, sx,sy,w,h, x,y,w,h);
    }
  }

  function applyChroma420(pb,W,H){
    const id=pb.getImageData(0,0,W,H);
    const d=id.data;
    for(let y=0;y<H;y+=2){
      for(let x=0;x<W;x+=2){
        let sumU=0,sumV=0,n=0;
        const pts=[[x,y],[x+1,y],[x,y+1],[x+1,y+1]];
        for(const [px,py] of pts){
          if(px>=W||py>=H) continue;
          const i=(py*W+px)*4;
          const r=d[i],g=d[i+1],b=d[i+2];
          const yv=(r*3+g*4+b)>>3;
          sumU+=(b-yv); sumV+=(r-yv); n++;
        }
        sumU/=n; sumV/=n;
        for(const [px,py] of pts){
          if(px>=W||py>=H) continue;
          const i=(py*W+px)*4;
          const r=d[i],g=d[i+1],b=d[i+2];
          const yv=(r*3+g*4+b)>>3;
          let nr=yv+sumV, nb=yv+sumU;
          let ng=((yv<<3)-(3*nr)-(1*nb))/4;
          d[i]=clamp(nr,0,255);
          d[i+1]=clamp(ng,0,255);
          d[i+2]=clamp(nb,0,255);
        }
      }
    }
    pb.putImageData(id,0,0);
  }

  function applyTexture(pb,W,H){
    const bs=Math.max(2,STATE.ui.block|0);
    const q=clamp(STATE.ui.quant,0,1);
    const chr=clamp(STATE.ui.chroma,0,1);
    const poster=clamp(STATE.ui.poster,0,1);
    const grain=clamp(STATE.ui.grain,0,1);
    const edge=clamp(STATE.ui.edge,0,1);
    if(q<=0 && chr<=0 && poster<=0 && grain<=0 && edge<=0) return;

    const id=pb.getImageData(0,0,W,H);
    const data=id.data;

    const step=Math.max(1,Math.floor(1+q*63));
    const posterStep=poster<=0?0:Math.max(2,Math.floor(2+poster*30));

    if(q>0 || posterStep>0){
      for(let by=0;by<H;by+=bs){
        for(let bx=0;bx<W;bx+=bs){
          const x2=Math.min(W,bx+bs), y2=Math.min(H,by+bs);
          let sum=0,n=0;
          for(let y=by;y<y2;y++){
            let p=(y*W+bx)*4;
            for(let x=bx;x<x2;x++){
              const r=data[p],g=data[p+1],b=data[p+2];
              sum+=(r*3+g*4+b)>>3; n++; p+=4;
            }
          }
          const avg=n?(sum/n):0;
          const base=Math.round(avg/step)*step;
          const k=q*0.85;
          for(let y=by;y<y2;y++){
            let p=(y*W+bx)*4;
            for(let x=bx;x<x2;x++){
              let r=data[p],g=data[p+1],b=data[p+2];
              const lum=(r*3+g*4+b)>>3;
              const dl=base-lum;
              r=clamp(r+dl*k,0,255);
              g=clamp(g+dl*k,0,255);
              b=clamp(b+dl*k,0,255);
              if(posterStep>0){
                r=Math.round(r/posterStep)*posterStep;
                g=Math.round(g/posterStep)*posterStep;
                b=Math.round(b/posterStep)*posterStep;
              }
              data[p]=r; data[p+1]=g; data[p+2]=b;
              p+=4;
            }
          }
        }
      }
    }

    if(chr>0){
      const cShift=Math.floor(chr*(2+bs*0.35));
      const cShiftY=Math.floor(chr*(1+bs*0.20));
      if(cShift||cShiftY){
        const tmp=new Uint8ClampedArray(data);
        for(let y=0;y<H;y++){
          for(let x=0;x<W;x++){
            const i=(y*W+x)*4;
            const xr=clamp(x+cShift,0,W-1);
            const yr=clamp(y-cShiftY,0,H-1);
            const ir=(yr*W+xr)*4;
            const xb=clamp(x-cShift,0,W-1);
            const yb=clamp(y+cShiftY,0,H-1);
            const ib=(yb*W+xb)*4;
            data[i]=tmp[ir];
            data[i+2]=tmp[ib+2];
          }
        }
      }
    }

    if(edge>0){
      const tmp=new Uint8ClampedArray(data);
      const a=edge*1.2;
      for(let y=1;y<H-1;y++){
        for(let x=1;x<W-1;x++){
          const i=(y*W+x)*4;
          const pR=i+4, pD=i+(W*4);
          const lum =(tmp[i]*3 + tmp[i+1]*4 + tmp[i+2])>>3;
          const lumR=(tmp[pR]*3+tmp[pR+1]*4+tmp[pR+2])>>3;
          const lumD=(tmp[pD]*3+tmp[pD+1]*4 + tmp[pD+2])>>3;
          const e=Math.abs(lum-lumR)+Math.abs(lum-lumD);
          if(e>36){
            data[i]=clamp(data[i]+e*a,0,255);
            data[i+1]=clamp(data[i+1]+e*a,0,255);
            data[i+2]=clamp(data[i+2]+e*a,0,255);
          }
        }
      }
    }

    if(grain>0){
      const amp=28*grain;
      for(let i=0;i<data.length;i+=4){
        const n=((i*1103515245+12345)>>>16)&255;
        const g=(n-128)*(amp/128);
        data[i]=clamp(data[i]+g,0,255);
        data[i+1]=clamp(data[i+1]+g,0,255);
        data[i+2]=clamp(data[i+2]+g,0,255);
      }
    }

    pb.putImageData(id,0,0);
  }

  function scanTearOverlay(){
    const scan=clamp(STATE.ui.scan,0,1);
    if(scan<=0) return;
    const W=canvas.width,H=canvas.height;
    out.globalCompositeOperation="source-over";
    const lines=4+Math.floor(scan*40);
    for(let i=0;i<lines;i++){
      const y=(Math.random()*H)|0;
      const h=1+((Math.random()*(2+scan*8))|0);
      const a=0.02+Math.random()*0.10*scan;
      out.globalAlpha=a;
      out.fillStyle="rgba(255,255,255,1)";
      out.fillRect(0,y,W,h);
      if(Math.random()<scan*0.60){
        const sh=8+((Math.random()*54)|0);
        const sy=(Math.random()*Math.max(1,H-sh))|0;
        const dx=((Math.random()*2-1)*(10+scan*60))|0;
        out.globalAlpha=0.16*scan;
        out.drawImage(canvas, 0,sy,W,sh, dx,sy,W,sh);
      }
    }
    out.globalAlpha=1;
  }

  function applyVHSWarpToOutput(){
    const warp=clamp(STATE.ui.warp,0,1);
    if(warp<=0) return;
    const W=canvas.width,H=canvas.height;
    const strips=36+((warp*96)|0);
    const sh=Math.max(2,(H/strips)|0);
    out.globalCompositeOperation="source-over";
    out.globalAlpha=1;
    for(let y=0;y<H;y+=sh){
      const amp=(2+warp*26);
      const dx=Math.sin((y/H)*Math.PI*2 + (STATE.internal.frame*0.02))*amp
             + Math.sin((y/H)*Math.PI*8 + (STATE.internal.frame*0.06))*amp*0.30;
      out.drawImage(canvas,0,y,W,sh, dx,y,W,sh);
    }
  }

  // ---- AUDIO: analyser + 3-band energy + level
  function computeAudio(){
    const I=STATE.internal;
    if(!I.an || !I.data) return;

    I.an.getByteFrequencyData(I.data);
    const n=I.data.length;

    // crude bands: bass 0-12%, mid 12-42%, treble 42-100%
    const b0=0, b1=Math.floor(n*0.12);
    const m1=Math.floor(n*0.42);

    let bass=0, mid=0, tre=0;
    for(let i=b0;i<b1;i++) bass+=I.data[i];
    for(let i=b1;i<m1;i++) mid+=I.data[i];
    for(let i=m1;i<n;i++) tre+=I.data[i];

    bass/=Math.max(1,(b1-b0));
    mid/=Math.max(1,(m1-b1));
    tre/=Math.max(1,(n-m1));

    // normalize 0..1 with gain, floor/peak
    const gain=STATE.ui.sndGain;
    const floor=STATE.ui.sndFloor;
    const peak=STATE.ui.sndPeak;

    function norm(x){
      let v=(x/255)*gain;
      v=(v-floor)/(peak-floor);
      return clamp(v,0,1);
    }

    const lvl=norm((bass+mid+tre)/3);
    const b=norm(bass), m=norm(mid), t=norm(tre);

    // smoothing
    const s=clamp(STATE.ui.sndSmooth,0,0.98);
    I.level = I.level*s + lvl*(1-s);
    I.bass  = I.bass*s  + b*(1-s);
    I.mid   = I.mid*s   + m*(1-s);
    I.tre   = I.tre*s   + t*(1-s);
    I.lvlRaw = lvl;
  }

  function applySoundMod(){
    // sound modulates around the stored BASE (snapshotBase)
    if(!STATE.ui.snd || !STATE.ui.audOn) return;
    if(!STATE.base || !Object.keys(STATE.base).length) snapshotBase();

    const A=clamp(STATE.ui.mapAmt,0,1);
    const I=STATE.internal;
    const lvl=I.level, bass=I.bass, mid=I.mid, tre=I.tre;

    // map profiles: choose which band drives which parameter
    const map=STATE.ui.mapSel;

    // helpers to push parameters toward (base + delta*lvl) without drifting
    const B=STATE.base;
    const push=(key, target)=>{ STATE.ui[key]=target; };

    // common “impact” scalars (tuned to feel like “real texture” rather than UI wobble)
    const punch = lvl*lvl;         // overall energy
    const throb = bass*bass;       // low end
    const chatter = tre*tre;       // hi end
    const voice = mid*mid;         // mid band

    // compute deltas per map
    let dGlitch=0,dDisp=0,dRefresh=0,dWarp=0,dScan=0,dChroma=0,dQuant=0,dPoster=0,dGrain=0,dEdge=0;

    if(map==="club"){
      dGlitch = 0.55*chatter + 0.25*punch;
      dDisp   = 90*throb     + 35*punch;
      dRefresh= 0.25*punch   + 0.12*voice;
      dWarp   = 0.35*throb;
      dScan   = 0.20*chatter + 0.10*punch;
      dChroma = 0.30*chatter;
      dQuant  = 0.22*punch;
      dPoster = 0.18*voice;
      dGrain  = 0.22*punch;
      dEdge   = 0.18*chatter;
    } else if(map==="bass"){
      dGlitch = 0.25*punch;
      dDisp   = 130*throb + 25*punch;
      dRefresh= 0.18*punch;
      dWarp   = 0.60*throb + 0.15*punch;
      dScan   = 0.12*punch;
      dChroma = 0.10*punch;
      dQuant  = 0.12*punch;
      dPoster = 0.10*punch;
      dGrain  = 0.16*punch;
      dEdge   = 0.08*punch;
    } else if(map==="hi"){
      dGlitch = 0.78*chatter + 0.18*punch;
      dDisp   = 40*chatter + 18*punch;
      dRefresh= 0.20*chatter + 0.10*punch;
      dWarp   = 0.15*chatter;
      dScan   = 0.35*chatter + 0.10*punch;
      dChroma = 0.55*chatter;
      dQuant  = 0.20*chatter;
      dPoster = 0.18*chatter;
      dGrain  = 0.18*punch;
      dEdge   = 0.35*chatter;
    } else if(map==="voice"){
      dGlitch = 0.30*voice + 0.10*punch;
      dDisp   = 55*voice + 18*punch;
      dRefresh= 0.30*voice + 0.10*punch;
      dWarp   = 0.12*voice;
      dScan   = 0.18*voice;
      dChroma = 0.18*voice;
      dQuant  = 0.12*voice;
      dPoster = 0.25*voice;
      dGrain  = 0.16*voice;
      dEdge   = 0.10*voice;
    } else { // mad
      dGlitch = 0.60*chatter + 0.40*punch;
      dDisp   = 110*throb + 40*punch + 20*voice;
      dRefresh= 0.30*punch + 0.12*voice;
      dWarp   = 0.45*throb + 0.18*punch;
      dScan   = 0.28*chatter + 0.14*punch;
      dChroma = 0.45*chatter + 0.14*punch;
      dQuant  = 0.32*punch;
      dPoster = 0.26*voice;
      dGrain  = 0.28*punch;
      dEdge   = 0.42*chatter;
    }

    // apply with amplitude
    const a=A;

    push("glitch",  clamp(B.glitch  + dGlitch*a, 0,1));
    push("disp",    clamp(B.disp    + dDisp*a,   0,180));
    push("refresh", clamp(B.refresh + dRefresh*a,0,1));
    push("warp",    clamp(B.warp    + dWarp*a,   0,1));
    push("scan",    clamp(B.scan    + dScan*a,   0,1));
    push("chroma",  clamp(B.chroma  + dChroma*a, 0,1));
    push("quant",   clamp(B.quant   + dQuant*a,  0,1));
    push("poster",  clamp(B.poster  + dPoster*a, 0,1));
    push("grain",   clamp(B.grain   + dGrain*a,  0,1));
    push("edge",    clamp(B.edge    + dEdge*a,   0,1));

    // optional: keyframe frequency “breathes” slightly with overall energy (keeps it from fully smearing)
    push("keyHz", clamp(B.keyHz + (0.18*lvl*a), 0, 4));

    // also, when sound is high, bias motion slightly up (more “codec” feel on movement)
    push("mbias", clamp(B.mbias + (0.18*punch*a), 0,1));
  }

  function updateSig(){
    const d=new Date();
    const iso=d.toISOString().slice(0,19).replace("T"," ");
    const I=STATE.internal;
    const snd = STATE.ui.snd && STATE.ui.audOn ? ` SND=${I.level.toFixed(2)} B=${I.bass.toFixed(2)} M=${I.mid.toFixed(2)} T=${I.tre.toFixed(2)}` : "";
    $("sig").textContent =
      `AE/EE/WB :: FILE_ID=KETADATA_LIVE_MOSH_SOUND • ROOM_ID=BASE_SURFACE • VERSION=1 • UPDATED_AT=${iso}Z • MODE=${STATE.ui.mode}${snd}`;
  }

  function render(){
    root.classList.toggle("invert",!!STATE.ui.invert);
    root.classList.toggle("null",!!STATE.ui.null);
    $("drawer").classList.toggle("open",!!STATE.ui.drawer);

    $("modeName").textContent = modeLabel(STATE.ui.mode);
    $("moshLabel").textContent = STATE.ui.mosh ? "ON":"OFF";
    $("sndLabel").textContent  = (STATE.ui.snd && STATE.ui.audOn) ? "ON":"OFF";
    $("recLabel").textContent  = STATE.internal.recOn ? "ON":"OFF";

    const bind=(id,key,fmt)=>{ $(id).value=STATE.ui[key]; $(id+"V").textContent=fmt(STATE.ui[key]); };

    bind("keyHz","keyHz",(x)=>x.toFixed(2));
    bind("feedback","feedback",(x)=>x.toFixed(3));
    bind("disp","disp",(x)=>String(x|0));
    bind("glitch","glitch",(x)=>x.toFixed(2));

    bind("block","block",(x)=>String(x|0));
    bind("refresh","refresh",(x)=>x.toFixed(2));
    bind("jitter","jitter",(x)=>x.toFixed(2));

    bind("mbias","mbias",(x)=>x.toFixed(2));
    bind("mthr","mthr",(x)=>x.toFixed(2));

    bind("c420","c420",(x)=>String(x|0));
    bind("chroma","chroma",(x)=>x.toFixed(2));
    bind("quant","quant",(x)=>x.toFixed(2));
    bind("poster","poster",(x)=>x.toFixed(2));
    bind("grain","grain",(x)=>x.toFixed(2));

    bind("scan","scan",(x)=>x.toFixed(2));
    bind("warp","warp",(x)=>x.toFixed(2));
    bind("edge","edge",(x)=>x.toFixed(2));

    bind("sndGain","sndGain",(x)=>x.toFixed(2));
    bind("sndSmooth","sndSmooth",(x)=>x.toFixed(2));
    bind("sndFloor","sndFloor",(x)=>x.toFixed(3));
    bind("sndPeak","sndPeak",(x)=>x.toFixed(2));
    bind("mapAmt","mapAmt",(x)=>x.toFixed(2));
    $("mapSel").value = STATE.ui.mapSel;

    updateSig();
  }

  async function startCam(){
    if(STATE.ui.camOn) return;
    try{
      const stream=await navigator.mediaDevices.getUserMedia({
        video:{ width:{ideal:1280}, height:{ideal:720}, facingMode:"user" },
        audio:false
      });
      v.srcObject=stream;
      await v.play();
      STATE.ui.camOn=true;
      STATE.internal.ready=true;
      fitCanvas();
      rebuildMotionGrid();
      keyframeNow();
      render();
    }catch(e){
      console.error(e);
      alert("Camera permission denied or unavailable.");
    }
  }

  async function startAudio(){
    if(STATE.ui.audOn) return;
    try{
      const stream=await navigator.mediaDevices.getUserMedia({audio:true, video:false});
      const AC = window.AudioContext || window.webkitAudioContext;
      const ac = new AC();
      const src = ac.createMediaStreamSource(stream);
      const an = ac.createAnalyser();
      an.fftSize = 1024;
      an.smoothingTimeConstant = 0.0; // we do our own smoothing
      src.connect(an);
      // no output to speakers
      STATE.internal.ac=ac;
      STATE.internal.an=an;
      STATE.internal.data=new Uint8Array(an.frequencyBinCount);
      STATE.ui.audOn=true;
      render();
    }catch(e){
      console.error(e);
      alert("Microphone permission denied or unavailable.");
    }
  }

  // --- Recording (canvas capture to .webm)
  function toggleRec(){
    if(!STATE.internal.recOn){
      const stream=canvas.captureStream(60);
      let rec;
      try{ rec=new MediaRecorder(stream,{mimeType:"video/webm;codecs=vp9"}); }
      catch(e){ rec=new MediaRecorder(stream); }
      STATE.internal.rec=rec;
      STATE.internal.recChunks=[];
      rec.ondataavailable=(ev)=>{ if(ev.data&&ev.data.size) STATE.internal.recChunks.push(ev.data); };
      rec.onstop=()=>{
        const blob=new Blob(STATE.internal.recChunks,{type:"video/webm"});
        const url=URL.createObjectURL(blob);
        const a=document.createElement("a");
        a.href=url;
        a.download=`KETADATA_MOSH_SOUND_${STATE.ui.mode}_${new Date().toISOString().replace(/[:.]/g,"-")}.webm`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url),2000);
      };
      rec.start(250);
      STATE.internal.recOn=true;
    } else {
      STATE.internal.rec.stop();
      STATE.internal.recOn=false;
    }
    render();
  }

  function scanTearOverlay(){
    const scan=clamp(STATE.ui.scan,0,1);
    if(scan<=0) return;
    const W=canvas.width,H=canvas.height;
    out.globalCompositeOperation="source-over";
    const lines=4+Math.floor(scan*40);
    for(let i=0;i<lines;i++){
      const y=(Math.random()*H)|0;
      const h=1+((Math.random()*(2+scan*8))|0);
      const a=0.02+Math.random()*0.10*scan;
      out.globalAlpha=a;
      out.fillStyle="rgba(255,255,255,1)";
      out.fillRect(0,y,W,h);
      if(Math.random()<scan*0.60){
        const sh=8+((Math.random()*54)|0);
        const sy=(Math.random()*Math.max(1,H-sh))|0;
        const dx=((Math.random()*2-1)*(10+scan*60))|0;
        out.globalAlpha=0.16*scan;
        out.drawImage(canvas, 0,sy,W,sh, dx,sy,W,sh);
      }
    }
    out.globalAlpha=1;
  }

  function tick(){
    fitCanvas();

    // audio update + sound modulation (doesn't require camera)
    computeAudio();
    applySoundMod();

    if(!STATE.internal.ready || !STATE.ui.camOn || !v.videoWidth){
      out.setTransform(1,0,0,1,0,0);
      out.globalAlpha=1; out.globalCompositeOperation="source-over";
      out.fillStyle="#000"; out.fillRect(0,0,canvas.width,canvas.height);
      out.fillStyle="rgba(255,255,255,0.70)";
      out.font="14px " + getComputedStyle(document.documentElement).getPropertyValue("--mono");
      out.fillText("CAM to start", 14, 22);
      requestAnimationFrame(tick);
      return;
    }

    // keyframe cadence
    const hz=clamp(STATE.ui.keyHz,0,10);
    const interval= hz<=0 ? Infinity : (1000/hz);
    if(now()-STATE.internal.lastKeyAt>interval) keyframeNow();

    renderSrc();

    const pb=STATE.internal.pbX;
    const W=canvas.width,H=canvas.height;

    if(STATE.ui.mosh){
      const fb=clamp(STATE.ui.feedback,0,0.9999);
      pb.setTransform(1,0,0,1,0,0);
      pb.globalCompositeOperation="source-over";
      pb.globalAlpha=fb;
      pb.drawImage(STATE.internal.pbC,0,0);

      const g=clamp(STATE.ui.glitch,0,1);
      const maxDisp=Math.max(0,STATE.ui.disp|0);
      if(Math.random()<g){
        const blocks=12+((Math.random()*46)|0);
        for(let i=0;i<blocks;i++){
          const bw=24+((Math.random()*Math.min(520,W*0.60))|0);
          const bh=12+((Math.random()*Math.min(360,H*0.50))|0);
          const sx=(Math.random()*Math.max(1,W-bw))|0;
          const sy=(Math.random()*Math.max(1,H-bh))|0;
          const dx=sx+((Math.random()*2-1)*maxDisp)|0;
          const dy=sy+((Math.random()*2-1)*maxDisp)|0;
          pb.globalAlpha=1;
          pb.globalCompositeOperation="source-over";
          pb.drawImage(STATE.internal.pbC, sx,sy,bw,bh, dx,dy,bw,bh);
        }
      }

      selectiveRefreshPB();
    } else {
      pb.setTransform(1,0,0,1,0,0);
      pb.globalAlpha=1; pb.globalCompositeOperation="source-over";
      pb.drawImage(STATE.internal.srcC,0,0);
    }

    STATE.internal.frame++;
    const N=Math.max(1,STATE.ui.texEvery|0);
    if((STATE.internal.frame%N)===0){
      if((STATE.ui.c420|0)===1) applyChroma420(pb,W,H);
      applyTexture(pb,W,H);
    }

    out.setTransform(1,0,0,1,0,0);
    out.globalAlpha=1; out.globalCompositeOperation="source-over";
    out.drawImage(STATE.internal.pbC,0,0);

    if(STATE.ui.warp>0) applyVHSWarpToOutput();
    scanTearOverlay();

    updateSig();
    requestAnimationFrame(tick);
  }

  function applyVHSWarpToOutput(){
    const warp=clamp(STATE.ui.warp,0,1);
    if(warp<=0) return;
    const W=canvas.width,H=canvas.height;
    const strips=36+((warp*96)|0);
    const sh=Math.max(2,(H/strips)|0);
    out.globalCompositeOperation="source-over";
    out.globalAlpha=1;
    for(let y=0;y<H;y+=sh){
      const amp=(2+warp*26);
      const dx=Math.sin((y/H)*Math.PI*2 + (STATE.internal.frame*0.02))*amp
             + Math.sin((y/H)*Math.PI*8 + (STATE.internal.frame*0.06))*amp*0.30;
      out.drawImage(canvas,0,y,W,sh, dx,y,W,sh);
    }
  }

  // --- UI wiring
  function bindRange(id,key,parseFn,post){
    const el=$(id);
    el.addEventListener("input", ()=>{
      STATE.ui[key]=parseFn(el.value);
      if(post) post();
      // if user manually changes a core param while sound is OFF, update baseline
      if(!STATE.ui.snd) snapshotBase();
      render();
    });
  }

  $("startCamBtn").onclick=()=>{ startCam(); };
  $("startAudBtn").onclick=async()=>{ await startAudio(); };

  $("drawerBtn").onclick=()=>{ STATE.ui.drawer=!STATE.ui.drawer; render(); };
  $("keyBtn").onclick=()=>{ keyframeNow(); };
  $("moshBtn").onclick=()=>{ STATE.ui.mosh=!STATE.ui.mosh; render(); };
  $("sndBtn").onclick=()=>{
    STATE.ui.snd=!STATE.ui.snd;
    // when arming sound, lock a new baseline immediately (prevents “jump”)
    snapshotBase();
    render();
  };
  $("recBtn").onclick=toggleRec;
  $("fsBtn").onclick=()=>{
    if(!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
  };
  $("nullBtn").onclick=()=>{ STATE.ui.null=!STATE.ui.null; render(); };
  $("invBtn").onclick=()=>{ STATE.ui.invert=!STATE.ui.invert; render(); };

  $("resetBtn").onclick=()=>{
    applyMode(STATE.ui.mode);
    snapshotBase();
  };

  $("modeSel").addEventListener("change",(e)=>applyMode(e.target.value));
  $("mapSel").addEventListener("change",(e)=>{ STATE.ui.mapSel=e.target.value; render(); });

  bindRange("keyHz","keyHz",(x)=>+x);
  bindRange("feedback","feedback",(x)=>+x);
  bindRange("disp","disp",(x)=>parseInt(x,10));
  bindRange("glitch","glitch",(x)=>+x);

  bindRange("block","block",(x)=>parseInt(x,10), rebuildMotionGrid);
  bindRange("refresh","refresh",(x)=>+x);
  bindRange("jitter","jitter",(x)=>+x);

  bindRange("mbias","mbias",(x)=>+x);
  bindRange("mthr","mthr",(x)=>+x);

  bindRange("c420","c420",(x)=>parseInt(x,10));
  bindRange("chroma","chroma",(x)=>+x);
  bindRange("quant","quant",(x)=>+x);
  bindRange("poster","poster",(x)=>+x);
  bindRange("grain","grain",(x)=>+x);

  bindRange("scan","scan",(x)=>+x);
  bindRange("warp","warp",(x)=>+x);
  bindRange("edge","edge",(x)=>+x);

  bindRange("sndGain","sndGain",(x)=>+x);
  bindRange("sndSmooth","sndSmooth",(x)=>+x);
  bindRange("sndFloor","sndFloor",(x)=>+x);
  bindRange("sndPeak","sndPeak",(x)=>+x);
  bindRange("mapAmt","mapAmt",(x)=>+x);

  window.addEventListener("resize", ()=>{ fitCanvas(); rebuildMotionGrid(); });

  window.addEventListener("keydown",(e)=>{
    const k=e.key.toLowerCase();
    const shift=e.shiftKey;
    if(k===" "){ e.preventDefault(); STATE.ui.mosh=!STATE.ui.mosh; render(); return; }
    if(k==="s"){ e.preventDefault(); STATE.ui.snd=!STATE.ui.snd; snapshotBase(); render(); return; }
    if(k==="d"){ e.preventDefault(); STATE.ui.drawer=!STATE.ui.drawer; render(); return; }
    if(k==="k"){ e.preventDefault(); keyframeNow(); return; }
    if(k==="r"){ e.preventDefault(); applyMode(STATE.ui.mode); snapshotBase(); return; }
    if(shift && k==="n"){ e.preventDefault(); STATE.ui.null=!STATE.ui.null; render(); return; }
    if(shift && k==="i"){ e.preventDefault(); STATE.ui.invert=!STATE.ui.invert; render(); return; }
    if(shift && k==="f"){ e.preventDefault();
      if(!document.fullscreenElement) document.documentElement.requestFullscreen?.();
      else document.exitFullscreen?.();
      return;
    }
  });

  // init
  fitCanvas();
  applyMode("codec");
  render();
  requestAnimationFrame(tick);
})();
</script>

<!--
AE/EE/WB :: FILE_ID=KETADATA_LIVE_MOSH_SOUND
ROOM_ID=BASE_SURFACE
VERSION=1
UPDATED_AT=2026-01-10
CHANGELOG=added_microphone_analyser_sound_mapping_modes_clean_bars_baseline_modulation
-->
</body>
</html>
