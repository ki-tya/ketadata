<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA MASTERDOC (MANIFEST-DRIVEN)</title>
<style>
  :root {
    --bg:#0b0b0b;
    --fg:#f2f2f2;
    --muted:rgba(242,242,242,.62);
    --hair:rgba(242,242,242,.18);
    --hair2:rgba(242,242,242,.08);
    --panel:rgba(0,0,0,.55);
    --panel2:rgba(0,0,0,.30);
    --font: 12px;
  }
  html, body {
    margin:0; padding:0; width:100%; height:100%;
    background:var(--bg); color:var(--fg);
    font-family: Arial, Helvetica, sans-serif;
    font-size: var(--font);
    overflow:hidden;
  }
  * { box-sizing:border-box; }
  a { color:var(--fg); text-decoration:none; }
  a:hover { text-decoration:underline; }
  button, input, textarea, select {
    font: inherit;
    color: var(--fg);
    background: transparent;
    border: 1px solid var(--hair);
    padding: 6px 8px;
    outline: none;
  }
  button { cursor:pointer; }
  button:hover { background: var(--hair2); }
  textarea {
    width:100%;
    background:transparent;
    border:1px solid var(--hair);
    resize:none;
    padding:10px;
    line-height:1.35;
  }
  .stage {
    position:relative;
    width:100%;
    height:100%;
    user-select:none;
  }
  .bg {
    position:absolute; inset:0;
    pointer-events:none;
    background:
      linear-gradient(0deg, transparent 0 96%, rgba(242,242,242,.05) 96% 97%, transparent 97% 100%),
      linear-gradient(90deg, transparent 0 96%, rgba(242,242,242,.05) 96% 97%, transparent 97% 100%);
    background-size: 120px 120px;
    opacity:.35;
    animation: drift 28s linear infinite;
  }
  @keyframes drift {
    from { background-position: 0 0, 0 0; }
    to   { background-position: 360px 240px, 240px 360px; }
  }
  .topbar {
    position:absolute; left:0; top:0; right:0;
    height:36px;
    display:flex; align-items:center; gap:8px;
    padding: 0 8px;
    background: rgba(0,0,0,.75);
    border-bottom:1px solid var(--hair);
    z-index: 50;
  }
  .topbar .title { letter-spacing:.3px; opacity:.9; }
  .topbar .spacer { flex:1; }
  .pill {
    border:1px solid var(--hair);
    padding:4px 8px;
    opacity:.9;
  }
  .hud {
    position:absolute; right:8px; top:44px;
    display:flex; flex-direction:column; gap:8px;
    z-index: 40;
  }
  .hud .box {
    width: 280px;
    background: var(--panel);
    border: 1px solid var(--hair);
    padding: 8px;
  }
  .row { display:flex; gap:8px; align-items:center; }
  .row > * { flex: 1; }
  .row .tight { flex:0; white-space:nowrap; }
  .muted { color: var(--muted); }
  .small { font-size: var(--font); }
  .kbd {
    border:1px solid var(--hair);
    padding:1px 5px;
    opacity:.8;
  }
  .drop {
    border:1px dashed var(--hair);
    padding:10px;
    background: rgba(0,0,0,.20);
  }
  .mod {
    position:absolute;
    min-width: 320px;
    background: var(--panel);
    border: 1px solid var(--hair);
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  .mod .hdr {
    display:flex; align-items:center; gap:8px;
    padding: 6px 8px;
    border-bottom: 1px solid var(--hair);
    background: rgba(0,0,0,.35);
    cursor: grab;
  }
  .mod .hdr:active { cursor: grabbing; }
  .mod .hdr .name { flex:1; opacity:.92; }
  .mod .hdr .btn {
    padding:2px 6px;
    border:1px solid var(--hair);
    background:transparent;
  }
  .mod .body {
    padding: 8px;
    max-height: 70vh;
    overflow:auto;
    user-select:text;
  }
  .list {
    border:1px solid var(--hair);
    background: rgba(0,0,0,.20);
    max-height: 52vh;
    overflow:auto;
  }
  .item {
    display:flex; align-items:center; gap:8px;
    padding: 6px 8px;
    border-bottom:1px solid var(--hair2);
  }
  .item:last-child { border-bottom:0; }
  .item .t { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .item .s { opacity:.7; }
  .item .act { flex:0; display:flex; gap:6px; }
  .badge {
    border:1px solid var(--hair);
    padding:2px 6px;
    opacity:.75;
  }
  body.null .topbar, body.null .hud { display:none; }
  body.null .bg { opacity:.18; }
  body.invert {
    --bg:#f2f2f2;
    --fg:#0b0b0b;
    --muted:rgba(0,0,0,.62);
    --hair:rgba(0,0,0,.20);
    --hair2:rgba(0,0,0,.08);
    --panel:rgba(242,242,242,.78);
    --panel2:rgba(242,242,242,.45);
  }
  @media print {
    html, body { overflow:visible; }
    .topbar, .hud { display:none !important; }
    .bg { display:none !important; }
    .mod {
      position: static !important;
      page-break-inside: avoid;
      margin: 0 0 10px 0;
      box-shadow: none !important;
    }
    body {
      -webkit-print-color-adjust: exact;
      print-color-adjust: exact;
      background: var(--bg) !important;
    }
  }
</style>
</head>
<body>
<div class="stage" id="stage">
  <div class="bg"></div>

  <div class="topbar">
    <div class="title">KETADATA MASTERDOC / MANIFEST-DRIVEN</div>
    <div class="pill muted" id="repoPill">repo: n/a</div>
    <div class="spacer"></div>
    <div class="pill muted">HOTKEYS: <span class="kbd">SHIFT</span>+<span class="kbd">I</span> invert · <span class="kbd">SHIFT</span>+<span class="kbd">N</span> NULL · <span class="kbd">SHIFT</span>+<span class="kbd">F</span> fullscreen</div>
  </div>

  <div class="hud">
    <div class="box">
      <div class="drop" id="dropZone">
        <div class="muted" style="margin-bottom:6px;">DROP / IMPORT MANIFEST JSON</div>
        <div class="muted small">Drag a manifest like your pasted.txt link index here, or click IMPORT JSON.</div>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="importJson">IMPORT JSON</button>
        <button id="exportJson">EXPORT JSON</button>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <div class="tight muted">FILTER</div>
        <select id="laneFilter"></select>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <input id="search" type="text" placeholder="SEARCH (PATH / NOTE / TAGS)"/>
        <button id="clear">CLEAR</button>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="exportPdf">EXPORT PDF</button>
        <button id="resetLayout">RESET</button>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <div class="tight muted">TEXT</div>
        <input id="fontSize" type="range" min="10" max="16" value="12"/>
        <div class="tight muted" id="fontLabel">12</div>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <label class="tight"><input id="onlyActive" type="checkbox" checked/> only active</label>
        <label class="tight"><input id="hideMissing" type="checkbox" checked/> hide missing</label>
      </div>
      <div style="height:6px"></div>
      <div class="muted small" id="counts">no manifest loaded</div>
    </div>
  </div>

  <div class="mod" id="modDoc" style="left:10px; top:46px; width:560px;">
    <div class="hdr" data-drag="1">
      <div class="name">MASTERDOC</div>
      <button class="btn" data-action="collapse">–</button>
    </div>
    <div class="body">
      <textarea id="masterdoc" style="height:52vh" placeholder="WRITE HERE."></textarea>
      <div style="height:8px"></div>
      <div class="row">
        <input id="docTitle" type="text" placeholder="EXPORT LABEL (OPTIONAL)"/>
        <button id="saveDoc">SAVE</button>
      </div>
      <div style="height:6px"></div>
      <div class="muted small">Local-first. PDF export uses print dialog.</div>
    </div>
  </div>

  <div class="mod" id="modNote" style="left:10px; top:640px; width:560px;">
    <div class="hdr" data-drag="1">
      <div class="name">KETA_NOTE</div>
      <button class="btn" data-action="collapse">–</button>
    </div>
    <div class="body">
      <textarea id="ketaNote" style="height:18vh" placeholder="OPTIONAL."></textarea>
      <div style="height:6px"></div>
      <div class="muted small">Capture surface. Not required.</div>
    </div>
  </div>

  <div class="mod" id="modLinks" style="left:590px; top:46px; width:640px;">
    <div class="hdr" data-drag="1">
      <div class="name">LINK SYSTEM (SPATIAL MODULES)</div>
      <button class="btn" id="collapseAll">COLLAPSE ALL</button>
      <button class="btn" id="expandAll">EXPAND ALL</button>
      <button class="btn" data-action="collapse">–</button>
    </div>
    <div class="body" id="lanesBody">
      <div class="muted">Import a manifest to populate lanes.</div>
    </div>
  </div>

  <div style="position:absolute; left:8px; bottom:8px; right:8px; opacity:.65; z-index:1;">
    <div style="border-top:1px solid var(--hair); padding-top:6px;">
      AE/EE/WB · FILE_ID: "KETADATA_MASTERDOC_MANIFEST" · ROOM_ID: "BASE" · VERSION_ID: "V1" · UPDATED_AT: "2026-01-03T20:30:24Z" · CHANGELOG: "masterdoc + lane modules; import manifest; focus-safe controllers; export JSON; export PDF (print)"
    </div>
  </div>
</div>

<script>
/* KETADATA MASTERDOC (manifest-driven) */

/* ===== STORAGE ===== */
const FILE_ID = "KETADATA_MASTERDOC_MANIFEST__V1";
const LS_KEY = "KD_STATE__" + FILE_ID;

/* ===== STATE ===== */
const DEFAULT_STATE = {
  fileId: FILE_ID,
  updatedAt: new Date().toISOString(),
  ui: {
    invert: false,
    nullMode: false,
    fontSize: 12,
    laneFilter: "ALL",
    search: "",
    onlyActive: true,
    hideMissing: true
  },
  manifest: null, // raw manifest JSON
  doc: { title: "", text: "" },
  note: { text: "" },
  layout: {
    modDoc: {x:10, y:46, w:560, collapsed:false},
    modNote: {x:10, y:640, w:560, collapsed:false},
    modLinks: {x:590, y:46, w:640, collapsed:false},
    laneMods: {}
  },
  edits: {}
};

function safeParse(s){ try{ return JSON.parse(s); }catch{ return null; } }
function deepFill(base, incoming) {
  if (incoming === null || incoming === undefined) return base;
  if (typeof base !== "object" || base === null) return incoming;
  if (Array.isArray(base)) return Array.isArray(incoming) ? incoming : base;
  const out = {...base};
  for (const k of Object.keys(incoming)) {
    if (k in base) out[k] = deepFill(base[k], incoming[k]);
    else out[k] = incoming[k];
  }
  return out;
}
function loadState(){
  const raw = localStorage.getItem(LS_KEY);
  const parsed = raw ? safeParse(raw) : null;
  if (!parsed) return structuredClone(DEFAULT_STATE);
  return deepFill(structuredClone(DEFAULT_STATE), parsed);
}
let state = loadState();
function saveState(){ state.updatedAt = new Date().toISOString(); localStorage.setItem(LS_KEY, JSON.stringify(state)); updateCounts(); }

/* ===== CONTROLLER BUG FIX (focus-aware hotkeys) ===== */
function isTypingTarget(el) {
  if (!el) return false;
  const tag = (el.tagName || "").toLowerCase();
  if (tag === "input" || tag === "textarea" || tag === "select") return true;
  if (el.isContentEditable) return true;
  return false;
}

/* ===== DOM ===== */
const stage = document.getElementById("stage");
const repoPill = document.getElementById("repoPill");
const dropZone = document.getElementById("dropZone");
const importJsonBtn = document.getElementById("importJson");
const exportJsonBtn = document.getElementById("exportJson");
const exportPdfBtn = document.getElementById("exportPdf");
const resetLayoutBtn = document.getElementById("resetLayout");
const collapseAllBtn = document.getElementById("collapseAll");
const expandAllBtn = document.getElementById("expandAll");
const laneFilter = document.getElementById("laneFilter");
const search = document.getElementById("search");
const clearBtn = document.getElementById("clear");
const onlyActive = document.getElementById("onlyActive");
const hideMissing = document.getElementById("hideMissing");
const counts = document.getElementById("counts");
const fontSize = document.getElementById("fontSize");
const fontLabel = document.getElementById("fontLabel");

const masterdoc = document.getElementById("masterdoc");
const docTitle = document.getElementById("docTitle");
const saveDocBtn = document.getElementById("saveDoc");
const ketaNote = document.getElementById("ketaNote");

/* ===== MANIFEST ADAPTER =====
Expected shape (like your pasted.txt link manifest):
{ repo: { pagesBase }, lanes: [{id,name,deprecated}], links: { "x.html": {path,url,laneId,tags,version,status,note,missing} } }
*/
function normalizeManifest(m) {
  if (!m || typeof m !== "object") return null;
  // allow already-normalized
  if (m.linksByLane) return m;

  const lanes = Array.isArray(m.lanes) ? m.lanes : [];
  const linksObj = m.links && typeof m.links === "object" ? m.links : null;
  if (!linksObj) return null;

  const links = Object.values(linksObj).filter(x => x && typeof x === "object" && x.url);
  const laneMap = new Map(lanes.map(l => [l.id, l]));
  const byLane = {};
  for (const rec of links) {
    const lid = rec.laneId || "UNLABELED";
    byLane[lid] = byLane[lid] || [];
    byLane[lid].push(rec);
    if (!laneMap.has(lid)) laneMap.set(lid, {id: lid, name: lid, deprecated: false});
  }
  // stable sort per lane
  for (const lid of Object.keys(byLane)) {
    byLane[lid].sort((a,b)=>((a.note||"").localeCompare(b.note||"")) || ((a.path||"").localeCompare(b.path||"")));
  }
  return {
    version: m.version || "manifest",
    updatedAt: m.updatedAt || new Date().toISOString(),
    repo: m.repo || {},
    lanes: Array.from(laneMap.values()).sort((a,b)=>String(a.name||a.id).localeCompare(String(b.name||b.id))),
    linksByLane: byLane
  };
}

/* ===== EDIT MERGE ===== */
function getLinkRecord(rec) {
  const k = rec.path || rec.url;
  const edit = state.edits[k];
  return edit ? {...rec, ...edit} : rec;
}

/* ===== RENDER ===== */
function applyUI() {
  document.body.classList.toggle("invert", !!state.ui.invert);
  document.body.classList.toggle("null", !!state.ui.nullMode);
  document.documentElement.style.setProperty("--font", (state.ui.fontSize||12) + "px");
  fontSize.value = String(state.ui.fontSize||12);
  fontLabel.textContent = String(state.ui.fontSize||12);

  search.value = state.ui.search || "";
  laneFilter.value = state.ui.laneFilter || "ALL";
  onlyActive.checked = !!state.ui.onlyActive;
  hideMissing.checked = !!state.ui.hideMissing;

  masterdoc.value = state.doc.text || "";
  docTitle.value = state.doc.title || "";
  ketaNote.value = state.note.text || "";

  const repoBase = state.manifest?.repo?.pagesBase || "";
  repoPill.textContent = repoBase ? repoBase.replace(/^https?:\/\//,"") : "repo: n/a";

  applyModLayout("modDoc");
  applyModLayout("modNote");
  applyModLayout("modLinks");
}

function rebuildLaneFilter(man) {
  laneFilter.innerHTML = "";
  const optAll = document.createElement("option");
  optAll.value = "ALL"; optAll.textContent = "ALL LANES";
  laneFilter.appendChild(optAll);
  if (!man) return;
  for (const l of man.lanes) {
    const opt = document.createElement("option");
    opt.value = l.id;
    opt.textContent = String(l.name||l.id) + (l.deprecated ? " (deprecated)" : "");
    laneFilter.appendChild(opt);
  }
  laneFilter.value = state.ui.laneFilter || "ALL";
}

function matchesSearch(rec, q) {
  if (!q) return true;
  const s = q.trim().toLowerCase();
  if (!s) return true;
  const hay = `${rec.path||""} ${rec.note||""} ${rec.tags||""} ${rec.laneId||""} ${rec.status||""}`.toLowerCase();
  return hay.includes(s);
}

function passesToggles(rec) {
  if (state.ui.onlyActive && String(rec.status||"").toLowerCase() !== "active") return false;
  if (state.ui.hideMissing && rec.missing === true) return false;
  return true;
}

function renderLanes(man) {
  const root = document.getElementById("lanesBody");
  if (!man) {
    root.innerHTML = '<div class="muted">Import a manifest to populate lanes.</div>';
    return;
  }
  root.innerHTML = "";

  const laneIds = Object.keys(man.linksByLane || {});
  // sort: non-deprecated first
  laneIds.sort((a,b)=>{
    const ad = !!man.lanes.find(x=>x.id===a)?.deprecated;
    const bd = !!man.lanes.find(x=>x.id===b)?.deprecated;
    if (ad !== bd) return ad ? 1 : -1;
    const an = String(man.lanes.find(x=>x.id===a)?.name||a);
    const bn = String(man.lanes.find(x=>x.id===b)?.name||b);
    return an.localeCompare(bn);
  });

  for (const lid of laneIds) {
    if (state.ui.laneFilter !== "ALL" && state.ui.laneFilter !== lid) continue;

    const laneInfo = man.lanes.find(x=>x.id===lid) || {id: lid, name: lid, deprecated:false};

    const laneBox = document.createElement("div");
    laneBox.style.border = "1px solid var(--hair)";
    laneBox.style.marginBottom = "8px";
    laneBox.style.background = "rgba(0,0,0,.22)";

    const hdr = document.createElement("div");
    hdr.style.display = "flex";
    hdr.style.alignItems = "center";
    hdr.style.gap = "8px";
    hdr.style.padding = "6px 8px";
    hdr.style.borderBottom = "1px solid var(--hair)";
    hdr.style.background = "rgba(0,0,0,.28)";
    hdr.style.userSelect = "none";

    const name = document.createElement("div");
    name.textContent = String(laneInfo.name||lid);
    name.style.flex = "1";
    name.style.opacity = ".92";

    const meta = document.createElement("div");
    meta.className = "badge";
    meta.textContent = (man.linksByLane[lid]?.length || 0) + " links";

    const toggle = document.createElement("button");
    toggle.textContent = (state.layout.laneMods[lid]?.collapsed) ? "+" : "–";
    toggle.style.padding = "2px 6px";
    toggle.onclick = (e) => {
      e.stopPropagation();
      state.layout.laneMods[lid] = state.layout.laneMods[lid] || {};
      state.layout.laneMods[lid].collapsed = !state.layout.laneMods[lid].collapsed;
      saveState(); render();
    };

    hdr.appendChild(name);
    if (laneInfo.deprecated) {
      const dep = document.createElement("div");
      dep.className = "badge";
      dep.textContent = "deprecated lane";
      hdr.appendChild(dep);
    }
    hdr.appendChild(meta);
    hdr.appendChild(toggle);

    const body = document.createElement("div");
    body.style.padding = "0";
    body.style.display = (state.layout.laneMods[lid]?.collapsed) ? "none" : "block";

    const list = document.createElement("div");
    list.className = "list";

    let shown = 0;
    for (const raw of (man.linksByLane[lid] || [])) {
      const rec = getLinkRecord(raw);
      if (!passesToggles(rec)) continue;
      if (!matchesSearch(rec, state.ui.search)) continue;

      shown++;
      const row = document.createElement("div");
      row.className = "item";

      const left = document.createElement("div");
      left.className = "t";
      left.title = rec.url;
      const label = (rec.note && rec.note.trim()) ? `${rec.note.trim()} · ${rec.path||rec.url}` : (rec.path||rec.url);
      const a = document.createElement("a");
      a.href = rec.url;
      a.target = "_blank";
      a.rel = "noopener";
      a.textContent = label;
      left.appendChild(a);

      const s = document.createElement("div");
      s.className = "s";
      s.textContent = (rec.tags || "").trim() ? ("#" + (rec.tags||"").trim()) : "";

      const act = document.createElement("div");
      act.className = "act";

      const editBtn = document.createElement("button");
      editBtn.textContent = "EDIT";
      editBtn.onclick = (e)=>{ e.stopPropagation(); openEdit(rec); };

      const copyBtn = document.createElement("button");
      copyBtn.textContent = "COPY";
      copyBtn.onclick = async (e)=>{
        e.stopPropagation();
        try { await navigator.clipboard.writeText(rec.url); flash(copyBtn,"OK"); }
        catch { flash(copyBtn,"NO"); }
      };

      act.appendChild(editBtn);
      act.appendChild(copyBtn);

      row.appendChild(left);
      row.appendChild(s);
      row.appendChild(act);
      list.appendChild(row);
    }

    body.appendChild(list);

    const foot = document.createElement("div");
    foot.style.padding = "6px 8px";
    foot.style.borderTop = "1px solid var(--hair2)";
    foot.className = "muted small";
    foot.textContent = state.ui.search ? `showing ${shown} / ${(man.linksByLane[lid]||[]).length}` : `showing ${shown}`;
    body.appendChild(foot);

    laneBox.appendChild(hdr);
    laneBox.appendChild(body);
    root.appendChild(laneBox);
  }
}

function render() {
  const man = state.manifest ? normalizeManifest(state.manifest) : null;
  applyUI();
  rebuildLaneFilter(man);
  renderLanes(man);
  updateCounts();
}

function flash(btn, txt) {
  const prev = btn.textContent;
  btn.textContent = txt;
  setTimeout(()=>btn.textContent=prev, 600);
}

/* ===== EDIT MODAL ===== */
let modalEl = null;
function openEdit(rec) {
  closeModal();
  modalEl = document.createElement("div");
  modalEl.style.position = "absolute";
  modalEl.style.left = "50%";
  modalEl.style.top = "50%";
  modalEl.style.transform = "translate(-50%,-50%)";
  modalEl.style.width = "520px";
  modalEl.style.background = "var(--panel)";
  modalEl.style.border = "1px solid var(--hair)";
  modalEl.style.zIndex = "999";
  modalEl.style.boxShadow = "0 20px 60px rgba(0,0,0,.45)";

  const hdr = document.createElement("div");
  hdr.style.padding = "6px 8px";
  hdr.style.borderBottom = "1px solid var(--hair)";
  hdr.style.background = "rgba(0,0,0,.35)";
  hdr.style.display = "flex";
  hdr.style.alignItems = "center";
  hdr.style.gap = "8px";

  const t = document.createElement("div");
  t.style.flex = "1";
  t.style.opacity = ".92";
  t.textContent = "EDIT LINK";

  const x = document.createElement("button");
  x.textContent = "X";
  x.onclick = closeModal;

  hdr.appendChild(t);
  hdr.appendChild(x);

  const body = document.createElement("div");
  body.style.padding = "8px";
  body.style.display = "flex";
  body.style.flexDirection = "column";
  body.style.gap = "8px";

  const p = document.createElement("div");
  p.className = "muted small";
  p.textContent = rec.url;

  const note = document.createElement("input");
  note.type = "text";
  note.placeholder = "NOTE";
  note.value = (rec.note || "");

  const tags = document.createElement("input");
  tags.type = "text";
  tags.placeholder = "TAGS";
  tags.value = (rec.tags || "");

  const lane = document.createElement("input");
  lane.type = "text";
  lane.placeholder = "LANE ID";
  lane.value = (rec.laneId || "");

  const row = document.createElement("div");
  row.className = "row";

  const save = document.createElement("button");
  save.textContent = "SAVE";
  save.onclick = () => {
    const k = rec.path || rec.url;
    state.edits[k] = {
      note: note.value,
      tags: tags.value,
      laneId: lane.value
    };
    saveState(); closeModal(); render();
  };

  const revert = document.createElement("button");
  revert.textContent = "REVERT";
  revert.onclick = () => {
    const k = rec.path || rec.url;
    delete state.edits[k];
    saveState(); closeModal(); render();
  };

  row.appendChild(save);
  row.appendChild(revert);

  body.appendChild(p);
  body.appendChild(note);
  body.appendChild(tags);
  body.appendChild(lane);
  body.appendChild(row);

  modalEl.appendChild(hdr);
  modalEl.appendChild(body);

  stage.appendChild(modalEl);
  note.focus();
}
function closeModal() { if (modalEl) modalEl.remove(); modalEl = null; }
window.addEventListener("keydown", (e)=>{ if (e.key==="Escape") closeModal(); });
stage.addEventListener("pointerdown", (e)=>{ if (modalEl && !modalEl.contains(e.target)) closeModal(); });

/* ===== MODULE DRAG ===== */
function applyModLayout(id) {
  const el = document.getElementById(id);
  const L = state.layout[id] || null;
  if (!el || !L) return;
  el.style.left = (L.x ?? 10) + "px";
  el.style.top  = (L.y ?? 46) + "px";
  el.style.width = (L.w ?? 520) + "px";
  const body = el.querySelector(".body");
  if (L.collapsed) body.style.display = "none"; else body.style.display = "block";
}

function enableDragging(modId) {
  const el = document.getElementById(modId);
  const hdr = el.querySelector(".hdr");
  let dragging = false;
  let startX=0, startY=0, baseX=0, baseY=0;

  hdr.addEventListener("pointerdown", (e)=>{
    const action = e.target?.getAttribute?.("data-action");
    if (action) return;
    if (e.target.tagName.toLowerCase() === "button") return;
    dragging = true;
    hdr.setPointerCapture(e.pointerId);
    startX = e.clientX; startY = e.clientY;
    const L = state.layout[modId];
    baseX = L.x; baseY = L.y;
    e.preventDefault();
    e.stopPropagation();
  });

  hdr.addEventListener("pointermove", (e)=>{
    if (!dragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    const L = state.layout[modId];
    L.x = Math.max(0, baseX + dx);
    L.y = Math.max(36, baseY + dy);
    el.style.left = L.x + "px";
    el.style.top  = L.y + "px";
    e.preventDefault();
  });

  hdr.addEventListener("pointerup", (e)=>{
    if (!dragging) return;
    dragging = false;
    try { hdr.releasePointerCapture(e.pointerId); } catch {}
    saveState();
  });

  el.querySelectorAll("[data-action='collapse']").forEach(btn=>{
    btn.addEventListener("click", (e)=>{
      e.stopPropagation();
      state.layout[modId].collapsed = !state.layout[modId].collapsed;
      saveState(); render();
    });
  });
}

/* ===== COUNTS ===== */
function updateCounts() {
  const man = state.manifest ? normalizeManifest(state.manifest) : null;
  if (!man) { counts.textContent = "no manifest loaded"; return; }
  let total=0, shown=0;
  for (const lid of Object.keys(man.linksByLane||{})) {
    if (state.ui.laneFilter !== "ALL" && state.ui.laneFilter !== lid) continue;
    for (const raw of (man.linksByLane[lid]||[])) {
      const rec = getLinkRecord(raw);
      if (!passesToggles(rec)) continue;
      total++;
      if (matchesSearch(rec, state.ui.search)) shown++;
    }
  }
  counts.textContent = `showing ${shown} / ${total} links · last save: ${(state.updatedAt||"").replace("T"," ").replace("Z","")}`;
}

/* ===== MANIFEST IMPORT ===== */
function setManifest(obj) {
  const norm = normalizeManifest(obj);
  if (!norm) return false;
  state.manifest = obj; // keep raw
  state.ui.laneFilter = "ALL";
  saveState();
  render();
  return true;
}

async function importFromFile(file) {
  const text = await file.text();
  const parsed = safeParse(text);
  if (!parsed) return false;
  return setManifest(parsed);
}

/* Drop zone */
dropZone.addEventListener("dragover", (e)=>{ e.preventDefault(); dropZone.style.background="rgba(0,0,0,.32)"; });
dropZone.addEventListener("dragleave", ()=>{ dropZone.style.background="rgba(0,0,0,.20)"; });
dropZone.addEventListener("drop", async (e)=>{
  e.preventDefault();
  dropZone.style.background="rgba(0,0,0,.20)";
  const file = e.dataTransfer.files?.[0];
  if (!file) return;
  const ok = await importFromFile(file);
  dropZone.querySelector(".muted")?.setAttribute("data-ok", ok ? "1" : "0");
});

importJsonBtn.addEventListener("click", ()=>{
  const inp = document.createElement("input");
  inp.type = "file";
  inp.accept = ".json,.txt,application/json,text/plain";
  inp.onchange = async () => {
    const file = inp.files?.[0];
    if (!file) return;
    await importFromFile(file);
  };
  inp.click();
});

exportJsonBtn.addEventListener("click", ()=>{
  const payload = { state };
  const label = (state.doc.title || "masterdoc").replace(/[^a-z0-9_-]+/gi,"_");
  download(`KD_MASTERDOC_${label}.json`, JSON.stringify(payload, null, 2), "application/json");
});

function download(filename, text, mime) {
  const blob = new Blob([text], {type:mime||"application/octet-stream"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
}

/* ===== UI WIRING ===== */
laneFilter.addEventListener("change", ()=>{ state.ui.laneFilter = laneFilter.value; saveState(); render(); });
search.addEventListener("input", ()=>{ state.ui.search = search.value; saveState(); render(); });
clearBtn.addEventListener("click", ()=>{ state.ui.search = ""; saveState(); render(); });
onlyActive.addEventListener("change", ()=>{ state.ui.onlyActive = onlyActive.checked; saveState(); render(); });
hideMissing.addEventListener("change", ()=>{ state.ui.hideMissing = hideMissing.checked; saveState(); render(); });
fontSize.addEventListener("input", ()=>{ state.ui.fontSize = Number(fontSize.value); saveState(); render(); });

saveDocBtn.addEventListener("click", ()=>{
  state.doc.title = docTitle.value || "";
  state.doc.text = masterdoc.value || "";
  saveState();
  flash(saveDocBtn, "SAVED");
});
masterdoc.addEventListener("input", ()=>{ state.doc.text = masterdoc.value || ""; saveState(); });
docTitle.addEventListener("input", ()=>{ state.doc.title = docTitle.value || ""; saveState(); });
ketaNote.addEventListener("input", ()=>{ state.note.text = ketaNote.value || ""; saveState(); });

collapseAllBtn.addEventListener("click", ()=>{
  const man = state.manifest ? normalizeManifest(state.manifest) : null;
  if (!man) return;
  for (const lid of Object.keys(man.linksByLane)) {
    state.layout.laneMods[lid] = state.layout.laneMods[lid] || {};
    state.layout.laneMods[lid].collapsed = true;
  }
  saveState(); render();
});
expandAllBtn.addEventListener("click", ()=>{
  const man = state.manifest ? normalizeManifest(state.manifest) : null;
  if (!man) return;
  for (const lid of Object.keys(man.linksByLane)) {
    state.layout.laneMods[lid] = state.layout.laneMods[lid] || {};
    state.layout.laneMods[lid].collapsed = false;
  }
  saveState(); render();
});

resetLayoutBtn.addEventListener("click", ()=>{
  const keep = {
    ui: state.ui,
    manifest: state.manifest,
    doc: state.doc,
    note: state.note,
    edits: state.edits
  };
  state = structuredClone(DEFAULT_STATE);
  state.ui = keep.ui;
  state.manifest = keep.manifest;
  state.doc = keep.doc;
  state.note = keep.note;
  state.edits = keep.edits;
  saveState(); render();
});

exportPdfBtn.addEventListener("click", ()=>{
  state.doc.text = masterdoc.value || "";
  state.note.text = ketaNote.value || "";
  saveState();
  window.print();
});

/* ===== HOTKEYS ===== */
window.addEventListener("keydown", (e)=>{
  if (isTypingTarget(document.activeElement)) return;
  if (!e.shiftKey) return;
  const k = (e.key||"").toLowerCase();
  if (k === "i") {
    state.ui.invert = !state.ui.invert;
    saveState(); render();
    e.preventDefault();
  } else if (k === "n") {
    state.ui.nullMode = !state.ui.nullMode;
    saveState(); render();
    e.preventDefault();
  } else if (k === "f") {
    if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
    e.preventDefault();
  }
});

/* ===== BOOT ===== */
enableDragging("modDoc");
enableDragging("modNote");
enableDragging("modLinks");
applyUI();
render();
saveState();
</script>
</body>
</html>
