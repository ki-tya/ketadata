<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brain Ball</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #canvas {
            display: block;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .btn {
            padding: 8px 16px;
            background: transparent;
            border: 1px solid #fff;
            color: #fff;
            font-size: 11px;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .btn:hover {
            background: #fff;
            color: #000;
        }

        .btn.active {
            background: #fff;
            color: #000;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .slider-label {
            font-size: 10px;
            color: #fff;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 150px;
            height: 2px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            cursor: pointer;
            border: 1px solid #fff;
        }

        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            cursor: pointer;
            border: 1px solid #fff;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <div class="control-group">
            <button class="btn active" id="autoRotate">AUTO ROTATE</button>
            <button class="btn" id="beatBump">BEAT BUMP</button>
            <button class="btn" id="resetView">RESET VIEW</button>
        </div>
        <div class="slider-container">
            <label class="slider-label">BEAT SPEED: <span id="speedValue">120</span> BPM</label>
            <input type="range" id="beatSpeed" min="60" max="200" value="120">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, sphere;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let isDragging = false;
        let autoRotate = true;
        let beatBump = false;
        let beatSpeed = 120; // BPM
        let beatScale = 1;

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000);

            createBrainSphere();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            window.addEventListener('resize', onResize);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('wheel', onWheel);
            document.addEventListener('touchstart', onTouchStart);
            document.addEventListener('touchmove', onTouchMove);
            document.addEventListener('touchend', onTouchEnd);

            document.getElementById('autoRotate').addEventListener('click', toggleAutoRotate);
            document.getElementById('beatBump').addEventListener('click', toggleBeatBump);
            document.getElementById('resetView').addEventListener('click', resetView);
            document.getElementById('beatSpeed').addEventListener('input', updateBeatSpeed);

            animate();
        }

        function createBrainSphere() {
            const geometry = new THREE.SphereGeometry(2, 64, 64);
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    beatBump: { value: 0.0 }
                },
                vertexShader: `
                    uniform float time;
                    uniform float beatBump;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying float vDisplacement;
                    
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    
                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                        vec3 i  = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        i = mod289(i);
                        vec4 p = permute(permute(permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        vec4 x = x_ *ns.x + ns.yyyy;
                        vec4 y = y_ *ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                        vec3 p0 = vec3(a0.xy, h.x);
                        vec3 p1 = vec3(a0.zw, h.y);
                        vec3 p2 = vec3(a1.xy, h.z);
                        vec3 p3 = vec3(a1.zw, h.w);
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                        p0 *= norm.x;
                        p1 *= norm.y;
                        p2 *= norm.z;
                        p3 *= norm.w;
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                    }
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        
                        // Multiple layers of flowing noise for water-like movement
                        float noise1 = snoise(position * 2.0 + vec3(time * 0.3, time * 0.2, time * 0.25));
                        float noise2 = snoise(position * 4.0 + vec3(-time * 0.4, time * 0.35, -time * 0.3));
                        float noise3 = snoise(position * 8.0 + vec3(time * 0.15, -time * 0.2, time * 0.18));
                        float noise4 = snoise(position * 16.0 + vec3(-time * 0.5, time * 0.45, -time * 0.4));
                        
                        // Combine noises with wave-like motion
                        float displacement = (
                            noise1 * 0.25 + 
                            noise2 * 0.18 + 
                            noise3 * 0.12 + 
                            noise4 * 0.08
                        );
                        
                        // Add flowing wave pattern
                        float wave = sin(position.x * 3.0 + time * 0.8) * 
                                    cos(position.y * 3.0 + time * 0.6) * 
                                    sin(position.z * 3.0 + time * 0.7) * 0.1;
                        
                        displacement += wave;
                        vDisplacement = displacement;
                        
                        // Add beat bump to displacement - edges pulse outward
                        float bumpAmount = displacement * beatBump * 0.3;
                        
                        vec3 newPosition = position + normal * (displacement + bumpAmount);
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying float vDisplacement;
                    
                    void main() {
                        vec3 light = normalize(vec3(1.0, 1.0, 1.0));
                        float dProd = max(0.0, dot(vNormal, light));
                        
                        // Edge glow effect
                        vec3 viewDirection = normalize(cameraPosition - vPosition);
                        float fresnel = pow(1.0 - abs(dot(viewDirection, vNormal)), 2.5);
                        
                        // Bright white base
                        vec3 baseColor = vec3(1.0, 1.0, 1.0);
                        
                        // Pulsing effect based on displacement
                        float pulse = sin(time * 2.0 + vDisplacement * 10.0) * 0.15 + 0.85;
                        
                        // Add shimmer based on position and time
                        float shimmer = sin(vPosition.x * 5.0 + time * 3.0) * 
                                       cos(vPosition.y * 5.0 + time * 2.5) * 
                                       sin(vPosition.z * 5.0 + time * 3.5) * 0.15 + 0.85;
                        
                        // Intense edge glow
                        vec3 glowColor = baseColor * fresnel * 1.8;
                        
                        vec3 finalColor = baseColor * pulse * shimmer + glowColor;
                        
                        // Slight hollow effect - subtle darkening in center
                        finalColor *= mix(0.75, 1.4, fresnel);
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });

            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);

            // Outer glow - more intense
            const glowGeometry = new THREE.SphereGeometry(2.4, 32, 32);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vec3 viewDirection = normalize(cameraPosition - vPosition);
                        float intensity = pow(0.6 - dot(vNormal, viewDirection), 3.0);
                        
                        // Pulsing outer glow
                        float pulse = sin(time * 1.5) * 0.2 + 0.8;
                        
                        vec3 glow = vec3(1.0, 1.0, 1.0) * intensity * pulse;
                        
                        gl_FragColor = vec4(glow, intensity * 0.6);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
            });
            
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            glowMesh.material.uniforms.time = sphere.material.uniforms.time;
            scene.add(glowMesh);

            // Wireframe - brighter and more prominent
            const wireframeGeometry = new THREE.SphereGeometry(2.02, 48, 48);
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                wireframe: true,
                transparent: true,
                opacity: 0.8
            });
            const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
            sphere.add(wireframe);
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            const btn = document.getElementById('autoRotate');
            btn.classList.toggle('active');
        }

        function toggleBeatBump() {
            beatBump = !beatBump;
            const btn = document.getElementById('beatBump');
            btn.classList.toggle('active');
        }

        function updateBeatSpeed() {
            beatSpeed = parseInt(document.getElementById('beatSpeed').value);
            document.getElementById('speedValue').textContent = beatSpeed;
        }

        function resetView() {
            targetRotationX = 0;
            targetRotationY = 0;
            camera.position.z = 5;
            beatScale = 1;
        }

        function onMouseDown(e) {
            isDragging = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        function onMouseMove(e) {
            if (isDragging) {
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                targetRotationY += deltaX * 0.005;
                targetRotationX += deltaY * 0.005;
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onTouchStart(e) {
            if (e.touches.length === 1) {
                isDragging = true;
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
            }
        }

        function onTouchMove(e) {
            if (isDragging && e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - mouseX;
                const deltaY = e.touches[0].clientY - mouseY;
                
                targetRotationY += deltaX * 0.005;
                targetRotationX += deltaY * 0.005;
                
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
            }
        }

        function onTouchEnd() {
            isDragging = false;
        }

        function onWheel(e) {
            e.preventDefault();
            const delta = e.deltaY * 0.001;
            camera.position.z = Math.max(3, Math.min(10, camera.position.z + delta));
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (autoRotate && !isDragging) {
                targetRotationY += 0.003;
            }
            
            sphere.rotation.y += (targetRotationY - sphere.rotation.y) * 0.05;
            sphere.rotation.x += (targetRotationX - sphere.rotation.x) * 0.05;

            // Beat bump effect - only affects edges
            if (beatBump) {
                const bpm = beatSpeed / 60;
                const beat = Math.sin(sphere.material.uniforms.time.value * bpm * Math.PI * 2);
                const bump = beat > 0.7 ? (beat - 0.7) * 3.33 : 0; // Sharp spike on beat
                beatScale += (bump - beatScale) * 0.3;
            } else {
                beatScale += (0 - beatScale) * 0.1;
            }
            
            sphere.material.uniforms.beatBump.value = beatScale;

            sphere.material.uniforms.time.value += 0.02;

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
