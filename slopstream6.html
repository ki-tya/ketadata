<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA // SLOPSTREAM (FIXED)</title>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --red:#ff2b2b;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Arial, Helvetica, sans-serif;}
    body{overflow:hidden;}

    #stage{position:fixed;inset:0;background:#000;}
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;}

    #ui{
      position:fixed;top:0;right:0;width:280px;height:100%;
      border-left:1px solid rgba(255,255,255,0.10);
      background:linear-gradient(to bottom, rgba(0,0,0,0.00), rgba(0,0,0,0.35));
      z-index:60;
      pointer-events:none;
    }
    #uiInner{
      position:absolute;top:18px;right:18px;
      display:flex;flex-direction:column;gap:10px;
      pointer-events:auto;user-select:none;align-items:flex-end;
    }
    .btn{
      min-width:160px;
      border:1px solid rgba(255,255,255,0.28);
      background:rgba(0,0,0,0.45);
      color:rgba(255,255,255,0.86);
      padding:9px 10px;
      font-size:11px;
      letter-spacing:0.16em;
      text-transform:uppercase;
      cursor:pointer;
    }
    .btn:hover{background:rgba(255,255,255,0.07);border-color:rgba(255,255,255,0.42);}
    .btn.on{background:rgba(255,255,255,0.10);border-color:rgba(255,255,255,0.52);}

    #brand{
      position:fixed;left:14px;top:14px;z-index:50;
      display:flex;align-items:center;gap:10px;
      font-size:11px;letter-spacing:0.18em;text-transform:uppercase;
      color:rgba(255,255,255,0.80);
      user-select:none;pointer-events:none;
      mix-blend-mode:screen;
    }
    .whiteBox{width:10px;height:10px;background:#fff;display:inline-block;}

    #hud{
      position:fixed;left:14px;bottom:12px;z-index:50;
      font-size:10px;letter-spacing:0.14em;text-transform:uppercase;
      color:rgba(255,255,255,0.42);
      user-select:none;pointer-events:none;
      line-height:1.45;
      max-width:min(720px, calc(100% - 28px));
    }
    #hud b{color:rgba(255,255,255,0.68);font-weight:600;}

    #fx{
      position:fixed;inset:0;z-index:40;pointer-events:none;
      background:
        repeating-linear-gradient(to bottom, rgba(255,255,255,0.012) 0px, rgba(255,255,255,0.00) 2px, rgba(0,0,0,0.00) 7px),
        repeating-linear-gradient(to right, rgba(255,255,255,0.008) 0px, rgba(255,255,255,0.00) 3px, rgba(0,0,0,0.00) 13px);
      mix-blend-mode:screen;
      opacity:0.55;
    }

    body.invert{filter:invert(1);background:#fff;}
  </style>
</head>
<body>
  <div id="stage"><canvas id="c"></canvas></div>
  <div id="fx"></div>

  <div id="brand"><span class="whiteBox"></span><span>KETADATA // SLOPSTREAM (FIXED)</span></div>

  <div id="ui">
    <div id="uiInner">
      <button id="autoBtn" class="btn on" type="button">AUTO ROTATE</button>
      <button id="resetBtn" class="btn" type="button">RESET VIEW</button>
      <button id="pulseBtn" class="btn on" type="button">PULSE</button>
      <button id="stormBtn" class="btn on" type="button">STORM LAYER</button>
      <button id="linksBtn" class="btn on" type="button">LINK TRACES</button>
      <button id="labelsBtn" class="btn on" type="button">MICRO LABELS</button>
      <button id="lockBtn" class="btn" type="button">LOCK CAMERA</button>
    </div>
  </div>

  <div id="hud">
    <div><b>DRAG</b> ROTATE · <b>WHEEL</b> ZOOM · <b>CLICK</b> DROP NODE</div>
    <div><b>SPACE</b> TOGGLE HYPER · <b>H</b> HIDE UI · <b>I</b> INVERT · <b>R</b> RESET</div>
  </div>

  <script>
    // FIX: your screenshot shows "nothing" because the prior build had a runtime error:
    // - pointOnGreatCircle basis math used uninitialized cross terms
    // - drawLinks referenced L.a incorrectly
    // This version is cleaned and guarded so the globe always renders.

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha:false });

    const autoBtn  = document.getElementById('autoBtn');
    const resetBtn = document.getElementById('resetBtn');
    const pulseBtn = document.getElementById('pulseBtn');
    const stormBtn = document.getElementById('stormBtn');
    const linksBtn = document.getElementById('linksBtn');
    const labelsBtn= document.getElementById('labelsBtn');
    const lockBtn  = document.getElementById('lockBtn');

    const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
    const mix = (a,b,t)=>a+(b-a)*t;
    const smoothstep=(a,b,t)=>{ t=clamp((t-a)/(b-a),0,1); return t*t*(3-2*t); };

    function resize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const w = canvas.clientWidth|0;
      const h = canvas.clientHeight|0;
      canvas.width  = Math.floor(w*dpr);
      canvas.height = Math.floor(h*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', resize);

    // Noise
    const seed = Math.random()*9999;
    function h2(x,y){
      const s = Math.sin(x*127.1 + y*311.7 + seed*0.01) * 43758.5453123;
      return s - Math.floor(s);
    }
    function vnoise(x,y){
      const ix=Math.floor(x), iy=Math.floor(y);
      const fx=x-ix, fy=y-iy;
      const a=h2(ix,iy), b=h2(ix+1,iy), c=h2(ix,iy+1), d=h2(ix+1,iy+1);
      const ux=fx*fx*(3-2*fx), uy=fy*fy*(3-2*fy);
      return mix(mix(a,b,ux), mix(c,d,ux), uy);
    }
    function fbm(x,y){
      let v=0, a=0.5;
      for(let i=0;i<5;i++){
        v += a*vnoise(x,y);
        x*=2.02; y*=2.01; a*=0.5;
      }
      return v;
    }

    // Camera
    const cam = {
      yaw: 0.65, pitch: -0.18,
      yawV: 0, pitchV: 0,
      zoom: 1.0,
      auto: true,
      locked: false
    };
    const base = { yaw: cam.yaw, pitch: cam.pitch, zoom: 1.0 };

    function rotY(p,a){
      const ca=Math.cos(a), sa=Math.sin(a);
      return { x:p.x*ca + p.z*sa, y:p.y, z:-p.x*sa + p.z*ca };
    }
    function rotX(p,a){
      const ca=Math.cos(a), sa=Math.sin(a);
      return { x:p.x, y:p.y*ca - p.z*sa, z:p.y*sa + p.z*ca };
    }
    function project(p,cx,cy,r){
      const z = p.z;
      const persp = 0.88 + 0.42*(z+1)*0.5;
      return { x: cx + p.x*r*persp, y: cy + p.y*r*persp, z };
    }

    // UI toggles
    let invert=false;
    let pulseOn=true, stormOn=true, linksOn=true, labelsOn=true;
    let hyper=true, hudHidden=false;

    autoBtn.addEventListener('click', ()=>{ cam.auto=!cam.auto; autoBtn.classList.toggle('on', cam.auto); });
    resetBtn.addEventListener('click', ()=> resetView(true));
    pulseBtn.addEventListener('click', ()=>{ pulseOn=!pulseOn; pulseBtn.classList.toggle('on', pulseOn); });
    stormBtn.addEventListener('click', ()=>{ stormOn=!stormOn; stormBtn.classList.toggle('on', stormOn); });
    linksBtn.addEventListener('click', ()=>{ linksOn=!linksOn; linksBtn.classList.toggle('on', linksOn); });
    labelsBtn.addEventListener('click', ()=>{ labelsOn=!labelsOn; labelsBtn.classList.toggle('on', labelsOn); });
    lockBtn.addEventListener('click', ()=>{ cam.locked=!cam.locked; lockBtn.classList.toggle('on', cam.locked); });

    function resetView(withBurst){
      cam.yaw=base.yaw; cam.pitch=base.pitch; cam.zoom=base.zoom;
      cam.yawV=0; cam.pitchV=0;
      if(withBurst) burst(1.0);
    }

    // Drag
    let dragging=false, lastX=0,lastY=0;
    window.addEventListener('mousedown', (e)=>{
      if(cam.locked) return;
      dragging=true; lastX=e.clientX; lastY=e.clientY;
    });
    window.addEventListener('mousemove', (e)=>{
      if(!dragging || cam.locked) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      lastX=e.clientX; lastY=e.clientY;
      cam.yawV += dx*0.0022;
      cam.pitchV += dy*0.0018;
    });
    window.addEventListener('mouseup', ()=> dragging=false);

    // Zoom
    window.addEventListener('wheel', (e)=>{
      e.preventDefault();
      const z = Math.exp(-e.deltaY*0.0012);
      cam.zoom = clamp(cam.zoom*z, 0.68, 1.75);
    }, { passive:false });

    // Keys
    window.addEventListener('keydown', (e)=>{
      if(e.key==='i' || e.key==='I'){
        invert=!invert;
        document.body.classList.toggle('invert', invert);
      }
      if(e.key==='h' || e.key==='H'){
        hudHidden=!hudHidden;
        document.getElementById('ui').style.display = hudHidden ? 'none' : '';
        document.getElementById('brand').style.display = hudHidden ? 'none' : '';
        document.getElementById('hud').style.display = hudHidden ? 'none' : '';
      }
      if(e.code==='Space'){
        e.preventDefault();
        hyper=!hyper;
        burst(hyper?0.8:0.5);
      }
      if(e.key==='r' || e.key==='R'){
        resetView(true);
      }
    });

    // Stars
    const stars=[];
    function seedStars(){
      stars.length=0;
      const N=560;
      for(let i=0;i<N;i++){
        stars.push({ x:Math.random(), y:Math.random(), z:Math.random(), tw:Math.random()*6.28 });
      }
    }

    // Land
    function isLand(lat, lon){
      const u = (lon + Math.PI) / (2*Math.PI);
      const v = (lat + Math.PI/2) / Math.PI;
      const n1 = fbm(u*3.4, v*2.6);
      const n2 = fbm(u*6.8 + 10.0, v*5.2 + 3.0);
      const n = n1*0.75 + n2*0.25;
      const band = Math.abs(v-0.52);
      const cut = 0.10 * (1 - smoothstep(0.08, 0.32, band));
      return (n - cut) > 0.54;
    }
    const landPts=[];
    function buildLand(){
      landPts.length=0;
      const latSteps=140, lonSteps=260;
      for(let i=0;i<=latSteps;i++){
        const lat = mix(-Math.PI/2, Math.PI/2, i/latSteps);
        for(let j=0;j<=lonSteps;j++){
          const lon = mix(-Math.PI, Math.PI, j/lonSteps);
          if(((i*lonSteps+j)%3)!==0) continue;
          if(isLand(lat,lon)){
            landPts.push({
              x: Math.cos(lat)*Math.cos(lon),
              y: Math.sin(lat),
              z: Math.cos(lat)*Math.sin(lon)
            });
          }
        }
      }
    }

    // Nodes
    const nodes=[];
    function addNode(lat,lon,strength=1){
      nodes.push({
        x: Math.cos(lat)*Math.cos(lon),
        y: Math.sin(lat),
        z: Math.cos(lat)*Math.sin(lon),
        t: 0,
        strength
      });
    }
    function seedNodes(){
      nodes.length=0;
      for(let i=0;i<220;i++){
        const a=Math.random();
        let lat = mix(-0.85, 0.95, Math.random());
        let lon = mix(-Math.PI, Math.PI, Math.random());
        if(a<0.52){ lat=mix(0.12,0.78,Math.random()); lon=mix(-0.30,1.30,Math.random()); }
        else if(a<0.68){ lat=mix(0.10,0.55,Math.random()); lon=mix(-2.60,-0.85,Math.random()); }
        else if(a<0.82){ lat=mix(-0.45,0.25,Math.random()); lon=mix(1.00,2.70,Math.random()); }
        addNode(lat,lon,0.55+Math.random()*1.05);
      }
    }

    // Screen -> sphere
    function screenToSphere(mx,my,cx,cy,r){
      const dx=(mx-cx)/r, dy=(my-cy)/r;
      const rr=dx*dx+dy*dy;
      if(rr>1) return null;
      const z=Math.sqrt(1-rr);
      let p={x:dx,y:dy,z};
      p=rotX(p,-cam.pitch);
      p=rotY(p,-cam.yaw);
      const L=Math.hypot(p.x,p.y,p.z)||1;
      return {x:p.x/L,y:p.y/L,z:p.z/L};
    }
    window.addEventListener('click', (e)=>{
      const ui = document.getElementById('uiInner');
      if(ui.contains(e.target)) return;

      const w=canvas.clientWidth, h=canvas.clientHeight;
      const cx=w*0.50, cy=h*0.52;
      const r=Math.min(w,h)*0.30*cam.zoom;

      const p=screenToSphere(e.clientX,e.clientY,cx,cy,r);
      if(!p) return;
      nodes.push({...p,t:0,strength:1.25});
      burst(0.85, p);
      if(linksOn) linkBurstFrom(p, 10 + (hyper?16:10));
    });

    // Ribbons (fixed basis)
    const ribbons=[];
    function cross(a,b){ return {x:a.y*b.z-a.z*b.y, y:a.z*b.x-a.x*b.z, z:a.x*b.y-a.y*b.x}; }
    function norm(v){
      const L=Math.hypot(v.x,v.y,v.z)||1;
      return {x:v.x/L,y:v.y/L,z:v.z/L};
    }
    function spawnRibbon(n=1){
      for(let k=0;k<n;k++){
        const nrm = norm({x:Math.random()*2-1, y:Math.random()*2-1, z:Math.random()*2-1});
        ribbons.push({
          n:nrm,
          phase:Math.random()*Math.PI*2,
          spd:(0.25+Math.random()*0.75),
          life:0.7+Math.random()*1.8,
          age:0,
          len:18+Math.random()*80,
          bright:0.14+Math.random()*0.36,
          wob:Math.random()*6.28
        });
      }
    }
    function pointOnGreatCircle(nrm, ang){
      // Choose arbitrary non-parallel vector
      const a = Math.abs(nrm.x) < 0.9 ? {x:1,y:0,z:0} : {x:0,y:0,z:1};
      const u = norm(cross(nrm, a));
      const v = norm(cross(nrm, u));
      const ca=Math.cos(ang), sa=Math.sin(ang);
      return { x:u.x*ca + v.x*sa, y:u.y*ca + v.y*sa, z:u.z*ca + v.z*sa };
    }

    // Links (fixed)
    const links=[];
    function addLink(a,b,life=0.9,boost=1){ links.push({a,b,t:0,life,boost}); }
    function linkBurstFrom(p,count){
      for(let i=0;i<count;i++){
        const j=(Math.random()*nodes.length)|0;
        const q=nodes[j];
        if(!q) continue;
        addLink(p, q, 0.6+Math.random()*1.0, 0.7+Math.random()*1.2);
      }
    }

    // Labels
    const labels=[];
    const glyph="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    function makeLabel(){
      const len=6+((Math.random()*8)|0);
      let s=""; for(let i=0;i<len;i++) s+=glyph[(Math.random()*glyph.length)|0];
      return s;
    }
    function seedLabels(){
      labels.length=0;
      for(let i=0;i<160;i++){
        const lat=mix(-1.1,1.1,Math.random());
        const lon=mix(-Math.PI,Math.PI,Math.random());
        labels.push({
          x:Math.cos(lat)*Math.cos(lon),
          y:Math.sin(lat),
          z:Math.cos(lat)*Math.sin(lon),
          text:makeLabel(),
          phase:Math.random()*6.28,
          a:0.25+Math.random()*0.35
        });
      }
    }

    // Storm
    function drawStorm(w,h,now,pulse){
      ctx.save();
      ctx.globalCompositeOperation="screen";
      const nBands = hyper ? 18 : 12;
      for(let i=0;i<nBands;i++){
        const k=i/(nBands-1);
        const y=k*h;
        const n=fbm(k*2.6, now*0.00018 + i*0.11);
        const thick=(12+30*n)*(0.75+0.9*pulse);
        const alpha=(0.015+0.055*n)*(0.55+0.8*pulse);
        ctx.fillStyle=`rgba(255,255,255,${alpha})`;
        const xOff=Math.sin(now*0.00025+i)*42;
        ctx.fillRect(xOff-80, y-thick*0.5, w+160, thick);
      }
      ctx.restore();
    }

    function clearBG(w,h,now){
      const g=ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0.00,"rgb(0,0,0)");
      g.addColorStop(0.45,"rgb(14,14,14)");
      g.addColorStop(0.62,"rgb(24,24,24)");
      g.addColorStop(1.00,"rgb(0,0,0)");
      ctx.fillStyle=g;
      ctx.fillRect(0,0,w,h);

      // stars
      ctx.save();
      ctx.globalCompositeOperation="screen";
      const driftX=Math.sin(now*0.00012)*0.02;
      const driftY=Math.cos(now*0.00010)*0.02;
      for(const s of stars){
        const tw=0.5+0.5*Math.sin(now*0.0012+s.tw);
        const a=(0.03+0.10*tw)*(0.40+0.60*s.z);
        const x=(((s.x+driftX*s.z)%1)+1)%1*w;
        const y=(((s.y+driftY*s.z)%1)+1)%1*h;
        ctx.fillStyle=`rgba(255,255,255,${a})`;
        ctx.fillRect((x|0)+0.5,(y|0)+0.5,1,1);
      }
      ctx.restore();
    }

    function drawGlow(cx,cy,r,pulse){
      ctx.save();
      ctx.globalCompositeOperation="screen";

      const halo=ctx.createRadialGradient(cx,cy,r*0.80,cx,cy,r*1.24);
      halo.addColorStop(0,"rgba(255,255,255,0.00)");
      halo.addColorStop(0.55,`rgba(255,255,255,${0.06+0.06*pulse})`);
      halo.addColorStop(1,"rgba(255,255,255,0.00)");
      ctx.fillStyle=halo;
      ctx.beginPath(); ctx.arc(cx,cy,r*1.24,0,Math.PI*2); ctx.fill();

      const haze=ctx.createRadialGradient(cx,cy,0,cx,cy,r*1.00);
      haze.addColorStop(0,`rgba(255,255,255,${0.015+0.020*pulse})`);
      haze.addColorStop(1,"rgba(255,255,255,0.00)");
      ctx.fillStyle=haze;
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();

      ctx.globalAlpha=0.92;
      ctx.strokeStyle="rgba(255,255,255,0.92)";
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();

      ctx.restore();
    }

    function drawGraticule(cx,cy,r,yaw,pitch,pulse){
      ctx.save();
      ctx.globalCompositeOperation="screen";
      ctx.strokeStyle=`rgba(255,255,255,${0.10+0.08*pulse})`;
      ctx.lineWidth=1;

      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.clip();

      const latLines = hyper ? 14 : 12;
      const lonLines = hyper ? 22 : 18;

      for(let i=1;i<latLines;i++){
        const lat=mix(-Math.PI/2,Math.PI/2,i/latLines);
        ctx.beginPath(); let started=false;
        for(let j=0;j<=260;j++){
          const lon=mix(-Math.PI,Math.PI,j/260);
          let p={x:Math.cos(lat)*Math.cos(lon), y:Math.sin(lat), z:Math.cos(lat)*Math.sin(lon)};
          p=rotY(p,yaw); p=rotX(p,pitch);
          if(p.z<0){started=false; continue;}
          const s=project(p,cx,cy,r);
          if(!started){ctx.moveTo(s.x,s.y); started=true;} else ctx.lineTo(s.x,s.y);
        }
        ctx.stroke();
      }

      for(let i=0;i<lonLines;i++){
        const lon=mix(-Math.PI,Math.PI,i/lonLines);
        ctx.beginPath(); let started=false;
        for(let j=0;j<=260;j++){
          const lat=mix(-Math.PI/2,Math.PI/2,j/260);
          let p={x:Math.cos(lat)*Math.cos(lon), y:Math.sin(lat), z:Math.cos(lat)*Math.sin(lon)};
          p=rotY(p,yaw); p=rotX(p,pitch);
          if(p.z<0){started=false; continue;}
          const s=project(p,cx,cy,r);
          if(!started){ctx.moveTo(s.x,s.y); started=true;} else ctx.lineTo(s.x,s.y);
        }
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawLand(cx,cy,r,yaw,pitch,pulse){
      ctx.save();
      ctx.globalCompositeOperation="screen";
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.clip();

      ctx.fillStyle=`rgba(255,255,255,${0.16+0.12*pulse})`;

      for(let i=0;i<landPts.length;i++){
        let p=landPts[i];
        p=rotY(p,yaw); p=rotX(p,pitch);
        if(p.z<0) continue;
        const s=project(p,cx,cy,r);
        const sz=0.6+1.4*(p.z*0.5+0.5);
        ctx.fillRect((s.x|0)+0.5,(s.y|0)+0.5,sz,sz);
      }
      ctx.restore();
    }

    function drawRibbons(cx,cy,r,yaw,pitch,t,pulse){
      ctx.save();
      ctx.globalCompositeOperation="screen";
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.clip();

      const baseAlpha=0.10+0.26*pulse;
      const speedBoost = hyper ? 1.55 : 1.0;

      for(let i=ribbons.length-1;i>=0;i--){
        const P=ribbons[i];
        P.age += 0.016;
        P.phase += P.spd*0.016*speedBoost;
        P.wob += 0.016*(0.6+1.2*pulse);

        if(P.age > P.life){ ribbons.splice(i,1); continue; }

        const lifeK=1-P.age/P.life;
        const a=baseAlpha*P.bright*(0.28+0.72*lifeK);

        ctx.strokeStyle=`rgba(255,255,255,${a})`;
        ctx.lineWidth=1;

        const steps=hyper?14:10;
        ctx.beginPath(); let started=false;

        for(let k=0;k<steps;k++){
          const ang = P.phase - (k/steps)*0.62*(1.0+1.4*pulse);
          let q = pointOnGreatCircle(P.n, ang);

          const lift=(0.012+0.028*pulse)*Math.sin(t*2.1+P.wob+k*0.6);
          q={x:q.x*(1+lift), y:q.y*(1+lift), z:q.z*(1+lift)};

          q=rotY(q,yaw); q=rotX(q,pitch);
          if(q.z<0){started=false; continue;}

          const s=project(q,cx,cy,r);
          if(!started){ctx.moveTo(s.x,s.y); started=true;}
          else{
            if((k%2)===0) ctx.lineTo(s.x,s.y);
            else ctx.moveTo(s.x,s.y);
          }
        }
        ctx.stroke();
      }

      const min = hyper ? 460 : 320;
      if(ribbons.length < min) spawnRibbon(hyper ? 18 : 10);

      ctx.restore();
    }

    function drawNodes(cx,cy,r,yaw,pitch,t,pulse){
      ctx.save();
      ctx.globalCompositeOperation="screen";

      for(let i=0;i<nodes.length;i++){
        const n=nodes[i];
        n.t += 0.016;

        let p={x:n.x,y:n.y,z:n.z};
        p=rotY(p,yaw); p=rotX(p,pitch);
        if(p.z<0) continue;

        const s=project(p,cx,cy,r);
        const ring = pulseOn ? (0.5+0.5*Math.sin(t*1.9+i*0.08)) : 0.35;
        const rr=(2.0+3.0*ring)*n.strength*(0.85+0.55*pulse);
        const core=1.25*n.strength;

        ctx.fillStyle="rgba(255,43,43,0.95)";
        ctx.beginPath(); ctx.arc(s.x,s.y,core,0,Math.PI*2); ctx.fill();

        ctx.strokeStyle=`rgba(255,255,255,${0.10+0.22*pulse})`;
        ctx.lineWidth=1;
        ctx.beginPath(); ctx.arc(s.x,s.y,rr,0,Math.PI*2); ctx.stroke();
      }
      ctx.restore();
    }

    function drawLinks(cx,cy,r,yaw,pitch,t,pulse){
      if(!linksOn) return;

      ctx.save();
      ctx.globalCompositeOperation="screen";
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.clip();

      const maxLinks=hyper?260:160;
      while(links.length>maxLinks) links.shift();

      for(let i=links.length-1;i>=0;i--){
        const L=links[i];
        L.t += 0.016;
        if(L.t > L.life){ links.splice(i,1); continue; }

        const k=1-(L.t/L.life);
        const a=(0.05+0.22*k)*(0.60+0.85*pulse)*L.boost;

        let A={x:L.a.x,y:L.a.y,z:L.a.z};
        let B={x:L.b.x,y:L.b.y,z:L.b.z};

        A=rotY(A,yaw); A=rotX(A,pitch);
        B=rotY(B,yaw); B=rotX(B,pitch);

        if(A.z<0 && B.z<0) continue;

        const As=project(A,cx,cy,r);
        const Bs=project(B,cx,cy,r);

        const mx=(As.x+Bs.x)*0.5;
        const my=(As.y+Bs.y)*0.5;
        const dx=Bs.x-As.x, dy=Bs.y-As.y;
        const dl=Math.hypot(dx,dy)||1;
        const nx=-dy/dl, ny=dx/dl;
        const bulge=(12+38*pulse)*(0.35+0.65*((i*0.618)%1))*(hyper?1.2:1.0);
        const cx2=mx+nx*bulge, cy2=my+ny*bulge;

        ctx.strokeStyle=`rgba(255,255,255,${a})`;
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(As.x,As.y);
        ctx.quadraticCurveTo(cx2,cy2,Bs.x,Bs.y);
        ctx.stroke();

        const tt=(1-k);
        const qx=(1-tt)*(1-tt)*As.x + 2*(1-tt)*tt*cx2 + tt*tt*Bs.x;
        const qy=(1-tt)*(1-tt)*As.y + 2*(1-tt)*tt*cy2 + tt*tt*Bs.y;
        ctx.fillStyle=`rgba(255,43,43,${0.10+0.26*k})`;
        ctx.fillRect((qx|0)+0.5,(qy|0)+0.5,2,2);
      }

      ctx.restore();
    }

    function drawLabels(cx,cy,r,yaw,pitch,t,pulse){
      if(!labelsOn) return;

      ctx.save();
      ctx.globalCompositeOperation="screen";
      ctx.font="10px Arial";
      ctx.textBaseline="middle";
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.clip();

      const count=hyper?140:110;
      for(let i=0;i<count && i<labels.length;i++){
        const L=labels[i];
        L.phase += 0.010*(0.7+1.2*pulse);

        let p={x:L.x,y:L.y,z:L.z};
        const drift=0.002+0.004*pulse;
        p={x:p.x+Math.sin(L.phase+i)*drift, y:p.y+Math.cos(L.phase*0.9+i)*drift, z:p.z};
        const ll=Math.hypot(p.x,p.y,p.z)||1;
        p={x:p.x/ll,y:p.y/ll,z:p.z/ll};

        p=rotY(p,yaw); p=rotX(p,pitch);
        if(p.z<0) continue;

        const s=project(p,cx,cy,r);
        const a=(0.10+0.25*L.a)*(0.35+0.75*pulse);

        ctx.fillStyle=`rgba(255,255,255,${a})`;
        ctx.fillText(L.text, s.x+6, s.y);
        ctx.fillRect((s.x|0)+0.5,(s.y|0)+0.5,2,1);
      }
      ctx.restore();
    }

    function drawFrame(w,h,pulse){
      ctx.save();
      ctx.globalAlpha=0.34;
      ctx.strokeStyle="rgba(255,255,255,0.14)";
      ctx.lineWidth=1;
      ctx.strokeRect(0.5,0.5,w-1,h-1);

      ctx.globalAlpha=0.26;
      ctx.beginPath();
      ctx.moveTo(w-280+0.5,0); ctx.lineTo(w-280+0.5,h);
      ctx.stroke();

      ctx.globalAlpha=0.30+0.14*pulse;
      ctx.strokeStyle="rgba(255,255,255,0.18)";
      ctx.beginPath();
      ctx.moveTo(18,18); ctx.lineTo(48,18);
      ctx.moveTo(18,18); ctx.lineTo(18,48);

      ctx.moveTo(w-18,18); ctx.lineTo(w-48,18);
      ctx.moveTo(w-18,18); ctx.lineTo(w-18,48);

      ctx.moveTo(18,h-18); ctx.lineTo(48,h-18);
      ctx.moveTo(18,h-18); ctx.lineTo(18,h-48);

      ctx.moveTo(w-18,h-18); ctx.lineTo(w-48,h-18);
      ctx.moveTo(w-18,h-18); ctx.lineTo(w-18,h-48);
      ctx.stroke();

      ctx.restore();
    }

    // Bursts
    const bursts=[];
    function burst(intensity=1.0, center=null){
      bursts.push({t:0,intensity,center});
      spawnRibbon(Math.floor(22 + 34*intensity*(hyper?1.4:1.0)));
    }
    function drawBursts(cx,cy,r,dt,pulse){
      for(let i=bursts.length-1;i>=0;i--){
        const b=bursts[i];
        b.t += dt;
        if(b.t>1.2){ bursts.splice(i,1); continue; }
        const k=1-b.t/1.2;
        const ring=(1-k);

        ctx.save();
        ctx.globalCompositeOperation="screen";
        ctx.globalAlpha=0.24*k*b.intensity*(0.7+0.7*pulse);
        ctx.strokeStyle="rgba(255,255,255,0.26)";
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.arc(cx,cy,r*(1.02+ring*0.22),0,Math.PI*2);
        ctx.stroke();
        ctx.restore();

        if(linksOn && b.t < dt*1.5 && nodes.length>10){
          const j=(Math.random()*nodes.length)|0;
          const p=nodes[j];
          linkBurstFrom(p, hyper ? 22 : 14);
        }
      }
    }

    // Init content
    resize();
    seedStars();
    buildLand();
    seedNodes();
    seedLabels();
    spawnRibbon(520);
    burst(0.9);

    // Safety: draw a visible fallback ring even if something goes wrong
    function fallback(cx,cy,r){
      ctx.save();
      ctx.fillStyle="rgb(0,0,0)";
      ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
      ctx.strokeStyle="rgba(255,255,255,0.65)";
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
      ctx.restore();
    }

    // Loop
    let tPrev=performance.now();
    function tick(now){
      const dt=Math.min(0.05,(now-tPrev)/1000);
      tPrev=now;

      const w=canvas.clientWidth, h=canvas.clientHeight;
      const cx=w*0.50, cy=h*0.52;
      const r=Math.min(w,h)*0.30*cam.zoom;

      try{
        const pulse = pulseOn ? (0.5+0.5*Math.sin(now*0.00105)) : 0.25;

        clearBG(w,h,now);
        if(stormOn) drawStorm(w,h,now,pulse);

        if(cam.auto){
          cam.yawV += (0.0016+0.0012*pulse)*(hyper?1.25:1.0);
          cam.pitchV += 0.00022*Math.sin(now*0.001)*(hyper?1.2:1.0);
        }
        cam.yaw += cam.yawV;
        cam.pitch += cam.pitchV;
        cam.yawV *= 0.92;
        cam.pitchV *= 0.92;
        cam.pitch = clamp(cam.pitch, -1.08, 1.08);

        drawGlow(cx,cy,r,pulse);
        drawGraticule(cx,cy,r,cam.yaw,cam.pitch,pulse);
        drawLand(cx,cy,r,cam.yaw,cam.pitch,pulse);
        drawRibbons(cx,cy,r,cam.yaw,cam.pitch, now*0.001, pulse);
        drawLinks(cx,cy,r,cam.yaw,cam.pitch, now*0.001, pulse);
        drawNodes(cx,cy,r,cam.yaw,cam.pitch, now*0.001, pulse);
        drawLabels(cx,cy,r,cam.yaw,cam.pitch, now*0.001, pulse);
        drawBursts(cx,cy,r,dt,pulse);

        if(hyper && Math.random() < 0.015) burst(0.55 + Math.random()*0.55);

        drawFrame(w,h,pulse);
      }catch(err){
        fallback(cx,cy,r);
      }

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
