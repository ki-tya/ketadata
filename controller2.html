<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>KETADATA — TESTER</title>

<style>
:root{
  --void:#000;
  --fg:#fff;
  --muted:#666;
  --hot:#ffffff;

  /* gradients (editable) */
  --bg1:#050508;
  --bg2:#120000;     /* darkroom base */
  --tx1:#ffffff;
  --tx2:#ff2a2a;     /* hot aggressive red */

  /* motion */
  --spinSpeed: 18s;

  /* fonts */
  --nameFont: Arial, Helvetica, sans-serif;
  --uiFont: Arial, Helvetica, sans-serif;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
}

*{ box-sizing:border-box; }
html,body{ height:100%; }
body{
  margin:0;
  background:var(--void);
  color:var(--fg);
  font-family:var(--uiFont);
  overflow:hidden;
}

/* ======= VISIBLE SURFACE ======= */
.stage{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;

  background:
    radial-gradient(circle at var(--radialX, 50%) var(--radialY, 50%), var(--bg1), var(--bg2));
  background-blend-mode: screen;

  will-change: filter, background, transform;
}

.stage.huespin{
  animation: hueSpin var(--spinSpeed) linear infinite;
}
@keyframes hueSpin{
  from{ filter:hue-rotate(0deg); }
  to{ filter:hue-rotate(360deg); }
}

/* ======= BIG WORD ======= */
.word{
  font-family:var(--nameFont);
  font-weight:900;
  letter-spacing:.06em;
  white-space:nowrap;
  line-height:.92;
  user-select:none;

  background: linear-gradient(90deg, var(--tx1), var(--tx2));
  -webkit-background-clip:text;
  background-clip:text;
  color:transparent;

  padding: 0.1em 0.02em;
}

/* ======= INPUT ======= */
.inputWrap{
  position:fixed;
  left:50%;
  bottom:18px;
  transform:translateX(-50%);
  width:min(560px, 92vw);
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:center;
}
.inputWrap input{
  width:100%;
  background:rgba(0,0,0,.55);
  color:var(--fg);
  border:1px solid rgba(255,255,255,.18);
  padding:10px 12px;
  font-size:11px;
  letter-spacing:.22em;
  text-transform:uppercase;
  outline:none;
}
.inputWrap .hint{
  font-family:var(--mono);
  font-size:10px;
  letter-spacing:.18em;
  color:rgba(255,255,255,.55);
  white-space:nowrap;
}

/* ======= OPEN-PLAN PANELS ======= */
.dock{
  position:fixed;
  top:14px;
  left:14px;
  right:14px;
  display:grid;
  grid-template-columns: 1.2fr 1fr;
  gap:12px;
  pointer-events:none;
}
.panel{
  pointer-events:auto;
  background: rgba(0,0,0,.72);
  border:1px solid rgba(255,255,255,.14);
  padding:12px;
}
.panelHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom:10px;
}
.panelHeader b{
  font-family:var(--mono);
  font-size:11px;
  letter-spacing:.22em;
  text-transform:uppercase;
}
.panelHeader .mini{
  font-family:var(--mono);
  font-size:10px;
  letter-spacing:.18em;
  color:rgba(255,255,255,.55);
}
.toggle{
  background:transparent;
  border:1px solid rgba(255,255,255,.18);
  color:var(--muted);
  padding:7px 10px;
  font-size:11px;
  letter-spacing:.18em;
  font-family:var(--mono);
  cursor:pointer;
}
.toggle:hover{ color:var(--hot); border-color:rgba(255,255,255,.45); }

.rows{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px 14px;
}
@media (max-width: 980px){
  .dock{ grid-template-columns: 1fr; }
  .rows{ grid-template-columns: 1fr; }
}

.ctrl{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.label{
  font-family:var(--mono);
  font-size:10px;
  letter-spacing:.18em;
  color:rgba(255,255,255,.62);
  text-transform:uppercase;
}
.rangeRow{
  display:flex;
  gap:10px;
  align-items:center;
}
input[type="range"]{ width:100%; }
select, input[type="color"], input[type="number"]{
  background:transparent;
  color:var(--fg);
  border:1px solid rgba(255,255,255,.18);
  padding:8px 10px;
  font-size:11px;
  letter-spacing:.12em;
  outline:none;
  width:100%;
  font-family:var(--uiFont);
}
small.kbd{
  font-family:var(--mono);
  font-size:10px;
  letter-spacing:.12em;
  color:rgba(255,255,255,.55);
}
.kbdKey{
  display:inline-block;
  border:1px solid rgba(255,255,255,.22);
  padding:2px 6px;
  margin:0 4px;
  font-family:var(--mono);
  font-size:10px;
  letter-spacing:.12em;
  color:rgba(255,255,255,.72);
}

.kRow{ display:flex; gap:10px; flex-wrap:wrap; }
.kBtn{
  background:transparent;
  border:none;
  color:#666;
  font-family:var(--mono);
  font-size:11px;
  letter-spacing:.18em;
  cursor:pointer;
  padding:6px 0;
  text-transform:uppercase;
}
.kBtn:hover{ color:#fff; }
.kBtn[data-active="true"]{ color:#fff; }

.hidden{ display:none; }
</style>
</head>

<body>

<div id="stage" class="stage huespin">
  <div id="word" class="word">WHATEVER</div>
</div>

<div class="dock">

  <div class="panel" id="tester">
    <div class="panelHeader">
      <b>[TESTER]</b>
      <div style="display:flex; gap:10px; align-items:center;">
        <span class="mini">OPEN / PLAN</span>
        <button class="toggle" id="toggleTester">[TOGGLE]</button>
      </div>
    </div>

    <div id="testerBody">
      <div class="rows">
        <div class="ctrl">
          <div class="label">NAME FONT</div>
          <select id="nameFont">
            <option value="Arial, Helvetica, sans-serif">ARIAL (SANS)</option>
            <option value="ui-sans-serif, system-ui, -apple-system, 'Helvetica Neue', Helvetica, Arial, sans-serif">SYSTEM UI</option>
            <option value="'Helvetica Neue', Helvetica, Arial, sans-serif">HELVETICA NEUE</option>
            <option value="'Arial Black', Arial, sans-serif">ARIAL BLACK</option>
          </select>
          <small class="kbd">UI stays ARIAL sans-serif.</small>
        </div>

        <div class="ctrl">
          <div class="label">TEXT SIZE BIAS</div>
          <div class="rangeRow">
            <input id="textScale" type="range" min="0" max="100" value="50" />
          </div>
          <small class="kbd">Auto-fit stays on; this biases it.</small>
        </div>

        <div class="ctrl">
          <div class="label">TEXT GRADIENT A</div>
          <input type="color" id="tx1" value="#ffffff">
        </div>

        <div class="ctrl">
          <div class="label">TEXT GRADIENT B (HOT)</div>
          <input type="color" id="tx2" value="#ff2a2a">
        </div>

        <div class="ctrl">
          <div class="label">BG GRADIENT A</div>
          <input type="color" id="bg1" value="#050508">
        </div>

        <div class="ctrl">
          <div class="label">BG GRADIENT B (DARKROOM)</div>
          <input type="color" id="bg2" value="#120000">
          <small class="kbd">Dried-blood: #2a0000 → #120000.</small>
        </div>

        <div class="ctrl">
          <div class="label">HUE SPIN SPEED</div>
          <input id="spinSpeed" type="range" min="4" max="40" value="18"/>
          <small class="kbd">Lower = faster.</small>
        </div>

        <div class="ctrl">
          <div class="label">RADIAL DRIFT SPEED</div>
          <input id="radialSpeed" type="range" min="1" max="30" value="10"/>
          <small class="kbd">Higher = faster drift.</small>
        </div>
      </div>

      <div style="margin-top:10px;">
        <small class="kbd">
          <span class="kbdKey">SPACE</span> toggle current light
          <span class="kbdKey">1–6</span> select + start
          <span class="kbdKey">0</span> stop
        </small>
      </div>
    </div>
  </div>

  <div class="panel" id="lights">
    <div class="panelHeader">
      <b>[LIGHTS]</b>
      <div style="display:flex; gap:10px; align-items:center;">
        <span class="mini" id="status">OFF</span>
        <button class="toggle" id="toggleLights">[TOGGLE]</button>
      </div>
    </div>

    <div id="lightsBody">
      <div class="kRow">
        <button class="kBtn" data-e="1">[1 STROBE]</button>
        <button class="kBtn" data-e="2">[2 MED]</button>
        <button class="kBtn" data-e="3">[3 XRAY]</button>
        <button class="kBtn" data-e="4">[4 HEARTBEAT]</button>
        <button class="kBtn" data-e="5">[5 UV]</button>
        <button class="kBtn" data-e="6">[6 PAPARAZZI]</button>
        <button class="kBtn" data-e="7">[7 EMDR]</button>
      </div>

      <div style="margin-top:10px;" class="rows">
        <div class="ctrl">
          <div class="label">EFFECT SPEED</div>
          <input id="fxSpeed" type="range" min="5" max="120" value="50"/>
          <small class="kbd">Lower = faster.</small>
        </div>
        <div class="ctrl">
          <div class="label">INTENSITY</div>
          <input id="fxIntensity" type="range" min="0" max="100" value="70"/>
          <small class="kbd">Affects contrast / brightness.</small>
        </div>
      </div>
    </div>
  </div>

</div>

<div class="inputWrap">
  <input id="textInput" maxlength="11" placeholder="TYPE PHRASE (MAX 11)"/>
  <div class="hint">LIVE UPDATE • ENTER TO COMMIT</div>
</div>

<script>
/* ===== DOM ===== */
const stage = document.getElementById("stage");
const word  = document.getElementById("word");
const input = document.getElementById("textInput");

const testerBody = document.getElementById("testerBody");
const lightsBody = document.getElementById("lightsBody");
document.getElementById("toggleTester").onclick = ()=> testerBody.classList.toggle("hidden");
document.getElementById("toggleLights").onclick = ()=> lightsBody.classList.toggle("hidden");

/* ===== AUTO FIT (edge-to-edge) ===== */
let bias = 50;
function fit(){
  // start with a width-based guess, then tighten to ~98.8% of viewport width
  let size = Math.max(40, Math.floor(innerWidth * 0.12));
  size = size + Math.floor((bias - 50) * 2);

  word.style.fontSize = size + "px";

  const target = innerWidth * 0.988;
  let guard = 0;

  while(word.scrollWidth < target && guard < 260){
    size += 2;
    word.style.fontSize = size + "px";
    guard++;
  }
  while(word.scrollWidth > target && size > 10 && guard < 520){
    size -= 2;
    word.style.fontSize = size + "px";
    guard++;
  }
}
window.addEventListener("resize", fit);

/* ===== TEXT INPUT (LIVE) ===== */
function applyTextFromInput(){
  const v = (input.value || "WHATEVER").toUpperCase().slice(0,11);
  word.textContent = v;
  fit();
}
input.addEventListener("input", applyTextFromInput);
input.addEventListener("keydown",(e)=>{
  if(e.key === "Enter"){
    e.preventDefault();
    applyTextFromInput();
    input.blur();
  }
});

/* ===== UI CONTROLS ===== */
document.body.style.fontFamily = "Arial, Helvetica, sans-serif"; // UI font spec

document.getElementById("nameFont").onchange = (e)=>{
  document.documentElement.style.setProperty("--nameFont", e.target.value);
  fit();
};

document.getElementById("textScale").oninput = (e)=>{
  bias = parseInt(e.target.value, 10);
  fit();
};

["bg1","bg2","tx1","tx2"].forEach(id=>{
  document.getElementById(id).oninput = (e)=>{
    // IMPORTANT: update CSS vars only (stage background uses them)
    document.documentElement.style.setProperty(`--${id}`, e.target.value);
  };
});

document.getElementById("spinSpeed").oninput = (e)=>{
  document.documentElement.style.setProperty("--spinSpeed", `${e.target.value}s`);
};

/* ===== RADIAL DRIFT (uses speed slider) ===== */
let rT = 0;
let radialSpeedVal = parseFloat(document.getElementById("radialSpeed").value);
document.getElementById("radialSpeed").oninput = (e)=> radialSpeedVal = parseFloat(e.target.value);

function radialTick(){
  // speed scales the phase increment
  rT += 0.0025 * radialSpeedVal;

  const x = 50 + Math.cos(rT) * 28;
  const y = 50 + Math.sin(rT*1.17) * 22;
  stage.style.setProperty("--radialX", x + "%");
  stage.style.setProperty("--radialY", y + "%");
  requestAnimationFrame(radialTick);
}
radialTick();

/* ===== LIGHT ENGINE (APPLIES TO STAGE) ===== */
let activeEffect = 0;   // 1..6
let running = false;
let fxTimer = null;

/* effect state (for UV + MED etc) */
let fxCount = 0;
let hue = 0, pulse = 0;        // MED
let angle = 0, radius = 0;     // UV
let xrayCount = 0;             // XRAY

const status = document.getElementById("status");
const fxSpeed = document.getElementById("fxSpeed");
const fxIntensity = document.getElementById("fxIntensity");
const effectButtons = Array.from(document.querySelectorAll(".kBtn[data-e]"));

function setStatus(){
  status.textContent = running ? `ON — ${activeEffect}` : "OFF";
}
function paintButtons(){
  effectButtons.forEach(b=>{
    b.dataset.active = (parseInt(b.dataset.e,10) === activeEffect) ? "true" : "false";
  });
}

/* CRITICAL FIX: clear *background* and *filter* so gradients respond again */
function clearFX(){
  clearInterval(fxTimer);
  fxTimer = null;

  fxCount = 0;
  hue = 0; pulse = 0;
  angle = 0; radius = 0;
  xrayCount = 0;

  stage.style.filter = "";
  stage.style.background = "";        // <-- this restores CSS gradient immediately
  stage.style.backgroundColor = "";

  stage.classList.add("huespin");
}

function stopFX(){
  running = false;
  setStatus();
  clearFX();
}

function intervalMs(){
  // map slider (5..120) to ms (fast..slow)
  const v = Math.max(5, parseInt(fxSpeed.value,10));
  return v;
}

function intensity01(){
  return Math.max(0, Math.min(100, parseInt(fxIntensity.value,10))) / 100;
}

function startFX(){
  if(!activeEffect) return;

  clearFX();
  running = true;
  setStatus();
  paintButtons();

  // lights read cleaner without global hue spin
  stage.classList.remove("huespin");

  fxTimer = setInterval(()=>{
    fxCount++;
    const I = intensity01();

    /* 1 STROBE (B/W) */
    if(activeEffect === 1){
      const on = (fxCount % 2 === 0);
      stage.style.background = on ? "#ffffff" : "#000000";
      stage.style.filter = `contrast(${1.5 + I*2.5}) brightness(${1 + I*0.9})`;
      return;
    }

    /* 2 MED (your chromatic pulse, ported from 2.0) */
    if(activeEffect === 2){
      hue = (hue + 30) % 360;
      pulse += 0.5;
      const lightness = 50 + Math.sin(pulse) * 40;
      stage.style.background = `hsl(${hue}, 100%, ${lightness}%)`;
      stage.style.filter = `contrast(${1.2 + I*2.2}) brightness(${1 + I*0.7}) saturate(${1.2 + I*2.8})`;
      return;
    }

    /* 3 XRAY (adapted from your 3.0 pattern logic idea) */
    if(activeEffect === 3){
      xrayCount++;
      const beat = xrayCount % 16;
      if (beat === 0 || beat === 1) {
        stage.style.background = "#ffffff";
        stage.style.filter = "invert(1) contrast(3) brightness(2)";
      } else if (beat === 2) {
        stage.style.background = "#000000";
        stage.style.filter = "invert(1) contrast(2)";
      } else if (beat === 3) {
        stage.style.background = "#00ff00";
        stage.style.filter = "contrast(2) saturate(3)";
      } else if (beat === 4) {
        stage.style.background = "#ff00ff";
        stage.style.filter = "invert(1) hue-rotate(90deg)";
      } else if (beat === 5 || beat === 6) {
        stage.style.background = "#00ffff";
        stage.style.filter = "invert(0.7) contrast(2)";
      } else if (beat === 7) {
        stage.style.background = "#ffffff";
        stage.style.filter = "invert(1) brightness(3)";
      } else if (beat === 8) {
        stage.style.background = "#000000";
        stage.style.filter = "invert(1) contrast(3)";
      } else if (beat === 9 || beat === 10) {
        stage.style.background = "#00ff00";
        stage.style.filter = "saturate(5) contrast(2)";
      } else if (beat === 11) {
        stage.style.background = "#ff00ff";
        stage.style.filter = "invert(1) saturate(3)";
      } else {
        stage.style.background = "#0088ff";
        stage.style.filter = "contrast(1.5) brightness(1.2)";
      }
      return;
    }

    /* 4 HEARTBEAT (red pulse) */
    if(activeEffect === 4){
      const beat = fxCount % 18;
      const pulseBeat = (beat === 0 || beat === 2) ? 1 : (beat < 6 ? 0.35 : 0);
      const red = Math.floor(40 + pulseBeat * 215);
      stage.style.background = `rgb(${red},0,0)`;
      stage.style.filter = `contrast(${1.4 + I*2.2}) brightness(${1 + pulseBeat*(0.9 + I)})`;
      return;
    }

    /* 5 UV (YOUR REAL ULTRAVIOLET, ported from 5.0) */
    if(activeEffect === 5){
      angle += 15;
      radius = (radius + 2) % 100;

      const hueUV = 260 + Math.sin(angle * 0.1) * 40;
      const saturation = 80 + Math.cos(angle * 0.05) * 20;
      const lightness = 30 + Math.sin(radius * 0.1) * 30;

      const spiralBrightness = 1 + Math.abs(Math.sin(angle * 0.05)) * 0.8;
      const spiralContrast = 1.5 + Math.abs(Math.cos(angle * 0.08)) * 1;

      stage.style.background = `hsl(${hueUV}, ${saturation}%, ${lightness}%)`;
      stage.style.filter =
        `contrast(${spiralContrast + I*1.2}) saturate(${2 + I*2}) brightness(${spiralBrightness + I*0.6}) hue-rotate(${angle * 0.5}deg)`;
      return;
    }

    /* 6 PAPARAZZI (double flash) */
    if(activeEffect === 6){
      const m = fxCount % 50;
      const flash = (m === 0 || m === 2);
      stage.style.background = flash ? "#ffffff" : "#000000";
      stage.style.filter = flash
        ? `brightness(${2.5 + I*4}) contrast(${2 + I*4})`
        : "none";
      return;
    }
    /* 7 EMDR (bilateral stimulation) */
if(activeEffect === 7){
  emdrPhase++;
  emdrSide = emdrPhase % 2;

  const I = intensity01(); // 0..1
  const speedFactor = Math.max(0.6, 1.6 - I);

  // Subtle medical whites / blues
  const baseBg = emdrSide === 0 ? "#f8f9ff" : "#eef2ff";
  const edgeGlow = emdrSide === 0
    ? "inset 12vw 0 0 rgba(255,255,255,0.35)"
    : "inset -12vw 0 0 rgba(255,255,255,0.35)";

  stage.style.background = baseBg;
  stage.style.filter = `
    contrast(${1.1 + I * 1.2})
    brightness(${1 + I * 0.4})
    saturate(${0.9 + I * 0.4})
  `;
  stage.style.boxShadow = edgeGlow;

  return;
}


  }, intervalMs());
}

function toggleFX(){
  if(!activeEffect){
    activeEffect = 1;
    paintButtons();
  }
  if(running) stopFX();
  else startFX();
}

/* Buttons: select + start */
effectButtons.forEach(btn=>{
  btn.addEventListener("click", ()=>{
    activeEffect = parseInt(btn.dataset.e,10);
    paintButtons();
    startFX();
  });
});

/* speed slider restarts to apply new interval */
fxSpeed.oninput = ()=>{ if(running) startFX(); };

/* Keyboard */
document.addEventListener("keydown",(e)=>{
  // do not steal typing inside inputs
  if(document.activeElement && document.activeElement.tagName === "INPUT"){
    if(e.code === "Space") return; // allow space in input if you want (though we uppercase)
  }

  if(e.code === "Space"){
    e.preventDefault();
    toggleFX();
    return;
  }
  if(e.key === "0"){
    stopFX();
    return;
  }
  if(e.key >= "1" && e.key <= "6"){
    activeEffect = parseInt(e.key,10);
    paintButtons();
    startFX();
    return;
  }
});

/* init */
word.textContent = "WHATEVER";
fit();
paintButtons();
setStatus();
</script>

</body>
</html>
