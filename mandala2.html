<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstract Hypnotic Mandala</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            cursor: none;
        }
        
        canvas {
            display: block;
            filter: contrast(1.15) brightness(1.05);
        }
        
        #speedControl {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 1000;
        }
        
        #speedControl.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        #speedSlider {
            width: 200px;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #e0e0e0, #999);
            outline: none;
            -webkit-appearance: none;
            display: block;
        }
        
        #speedSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #666;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        
        #speedSlider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #666;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <canvas id="kaleidoscope"></canvas>
    
    <div id="speedControl">
        <input type="range" id="speedSlider" min="10" max="200" value="100">
    </div>
    
    <script>
        const canvas = document.getElementById('kaleidoscope');
        const ctx = canvas.getContext('2d');
        const speedControl = document.getElementById('speedControl');
        const speedSlider = document.getElementById('speedSlider');
        
        let speedMultiplier = 1.0;
        let hideTimeout;
        
        // Speed control functionality
        speedSlider.addEventListener('input', (e) => {
            speedMultiplier = e.target.value / 100;
        });
        
        // Show/hide speed control on mouse movement
        document.addEventListener('mousemove', () => {
            speedControl.classList.add('visible');
            document.body.style.cursor = 'auto';
            
            clearTimeout(hideTimeout);
            hideTimeout = setTimeout(() => {
                speedControl.classList.remove('visible');
                document.body.style.cursor = 'none';
            }, 2000);
        });
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        
        function getCenter() {
            return {
                x: canvas.width / 2,
                y: canvas.height / 2
            };
        }
        
        const segments = 36;
        let time = 0;
        
        function drawFlowingCurve(startR, endR, complexity, phase) {
            ctx.beginPath();
            const steps = 200;
            
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const angle = t * Math.PI * 2 * complexity + phase;
                
                const wave1 = Math.sin(t * 12 + time * 3) * 25;
                const wave2 = Math.cos(t * 18 - time * 4) * 18;
                const wave3 = Math.sin(t * 24 + time * 2.5) * 12;
                
                const r = startR + (endR - startR) * t + wave1 + wave2 + wave3;
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
        }
        
        function drawMorphingShape(radius, vertices, rotation, distortion) {
            ctx.beginPath();
            
            for (let i = 0; i <= vertices; i++) {
                const angle = (Math.PI * 2 * i) / vertices + rotation;
                const distort = Math.sin(i * 3 + time * distortion) * 35;
                const r = radius + distort;
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            
            ctx.closePath();
        }
        
        function drawAbstractPath(radius, seed) {
            ctx.beginPath();
            const points = 150;
            
            for (let i = 0; i <= points; i++) {
                const t = i / points;
                const angle = t * Math.PI * 2;
                
                const r1 = radius + Math.sin(t * 10 + time * 3 + seed) * 35;
                const r2 = Math.cos(t * 14 - time * 4 + seed * 2) * 25;
                const r3 = Math.sin(t * 18 + time * 2.5 + seed * 3) * 18;
                
                const finalR = r1 + r2 + r3;
                const x = Math.cos(angle) * finalR;
                const y = Math.sin(angle) * finalR;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            
            ctx.closePath();
        }
        
        function drawFlowField(radius, density, rotation) {
            ctx.save();
            ctx.rotate(rotation);
            
            for (let i = 0; i < density; i++) {
                const angle = (Math.PI * 2 * i) / density;
                const flowPhase = Math.sin(time * 3 + i * 0.6) * 45;
                const r = radius + flowPhase;
                
                const x1 = Math.cos(angle) * r;
                const y1 = Math.sin(angle) * r;
                
                const x2 = Math.cos(angle + 0.4) * (r + 35);
                const y2 = Math.sin(angle + 0.4) * (r + 35);
                
                const opacity = 0.25 + Math.sin(time * 2 + i) * 0.2;
                ctx.strokeStyle = `rgba(160, 160, 160, ${opacity})`;
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.quadraticCurveTo(
                    x1 + (x2 - x1) * 0.5 + Math.sin(time * 4 + i) * 20,
                    y1 + (y2 - y1) * 0.5 + Math.cos(time * 4 + i) * 20,
                    x2, y2
                );
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        function drawParticleRing(radius, count, rotation, size) {
            ctx.save();
            ctx.rotate(rotation);
            
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const wobble = Math.sin(time * 3 + i * 0.7) * 25;
                const x = Math.cos(angle) * (radius + wobble);
                const y = Math.sin(angle) * (radius + wobble);
                
                const particleSize = size + Math.sin(time * 4 + i) * 5;
                const opacity = 0.35 + Math.sin(time * 2.5 + i * 0.4) * 0.25;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, Math.max(1, particleSize));
                gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                gradient.addColorStop(0.5, `rgba(200, 200, 200, ${opacity * 0.7})`);
                gradient.addColorStop(1, `rgba(150, 150, 150, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, Math.max(1, particleSize), 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function drawKaleidoscope() {
            const center = getCenter();
            
            // Dynamic breathing background
            const pulse = Math.sin(time * 1.2) * 15 + 245;
            ctx.fillStyle = `rgb(${pulse}, ${pulse}, ${pulse})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(center.x, center.y);
            
            // Create abstract mandala layers
            for (let seg = 0; seg < segments; seg++) {
                ctx.save();
                ctx.rotate((Math.PI * 2 * seg) / segments);
                
                // Outer flowing curves
                for (let curve = 0; curve < 5; curve++) {
                    drawFlowingCurve(
                        300 + curve * 50, 
                        420 + curve * 50, 
                        3 + curve, 
                        time * (0.8 + curve * 0.3)
                    );
                    
                    const opacity = 0.25 + Math.sin(time * 2 + curve) * 0.18;
                    ctx.strokeStyle = `rgba(${130 + curve * 20}, ${130 + curve * 20}, ${130 + curve * 20}, ${opacity})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Abstract morphing shapes
                for (let shape = 0; shape < 7; shape++) {
                    const shapeRadius = 240 - shape * 35;
                    const vertices = 6 + shape * 2;
                    
                    drawMorphingShape(
                        shapeRadius,
                        vertices,
                        time * (1.5 - shape * 0.18) * (shape % 2 ? 1 : -1),
                        2.5 + shape * 0.5
                    );
                    
                    const opacity = 0.3 + Math.sin(time * 2.5 + shape) * 0.15;
                    const gradient = ctx.createRadialGradient(0, 0, Math.max(1, shapeRadius - 40), 0, 0, shapeRadius + 40);
                    gradient.addColorStop(0, `rgba(240, 240, 240, ${opacity * 0.6})`);
                    gradient.addColorStop(0.5, `rgba(190, 190, 190, ${opacity})`);
                    gradient.addColorStop(1, `rgba(150, 150, 150, ${opacity * 0.7})`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    ctx.strokeStyle = `rgba(${120 + shape * 15}, ${120 + shape * 15}, ${120 + shape * 15}, ${opacity * 1.5})`;
                    ctx.lineWidth = 2.5;
                    ctx.stroke();
                }
                
                // Organic abstract paths
                for (let path = 0; path < 6; path++) {
                    drawAbstractPath(120 + path * 35, path * 2);
                    
                    const opacity = 0.3 + Math.sin(time * 2 + path) * 0.18;
                    ctx.strokeStyle = `rgba(160, 160, 160, ${opacity})`;
                    ctx.lineWidth = 2.5 + Math.sin(time * 1.5 + path) * 0.8;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            // Particle rings with organic motion
            for (let ring = 0; ring < 10; ring++) {
                drawParticleRing(
                    70 + ring * 45,
                    20 + ring * 4,
                    time * (0.7 + ring * 0.12) * (ring % 2 ? 1 : -1),
                    6 + ring * 0.8
                );
            }
            
            // Abstract center core
            for (let core = 0; core < 25; core++) {
                const coreRadius = 8 + core * 6;
                const corePulse = Math.sin(time * 4 - core * 0.2) * 0.35 + 0.85;
                const coreOpacity = (0.55 - core * 0.02) * corePulse;
                
                // Undulating circles
                ctx.beginPath();
                const corePoints = 80;
                for (let i = 0; i <= corePoints; i++) {
                    const angle = (Math.PI * 2 * i) / corePoints;
                    const wave = Math.sin(i * 0.6 + time * 5) * 3;
                    const r = Math.max(1, (coreRadius + wave) * corePulse);
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                
                ctx.strokeStyle = `rgba(${150 + core * 4}, ${150 + core * 4}, ${150 + core * 4}, ${coreOpacity})`;
                ctx.lineWidth = Math.max(0.5, 3 - core * 0.1);
                ctx.stroke();
                
                // Abstract rotating elements
                const elements = 12 + core * 2;
                for (let e = 0; e < elements; e++) {
                    const elemAngle = (Math.PI * 2 * e) / elements + time * (3 + core * 0.15);
                    const dist = Math.sin(time * 3 + e) * 4;
                    const ex = Math.cos(elemAngle) * (coreRadius + dist);
                    const ey = Math.sin(elemAngle) * (coreRadius + dist);
                    
                    const elemGradient = ctx.createRadialGradient(ex, ey, 0, ex, ey, 4);
                    elemGradient.addColorStop(0, `rgba(255, 255, 255, ${coreOpacity * 1.3})`);
                    elemGradient.addColorStop(1, `rgba(170, 170, 170, 0)`);
                    
                    ctx.fillStyle = elemGradient;
                    ctx.beginPath();
                    ctx.arc(ex, ey, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Pulsing center void
            const voidPulse = Math.sin(time * 5) * 0.5 + 1.2;
            for (let v = 0; v < 7; v++) {
                const voidRadius = Math.max(2, (15 - v * 2) * voidPulse);
                const voidOpacity = 0.85 - v * 0.11;
                
                const voidGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, voidRadius);
                voidGradient.addColorStop(0, `rgba(255, 255, 255, ${voidOpacity})`);
                voidGradient.addColorStop(0.6, `rgba(215, 215, 215, ${voidOpacity * 0.7})`);
                voidGradient.addColorStop(1, `rgba(170, 170, 170, 0)`);
                
                ctx.fillStyle = voidGradient;
                ctx.beginPath();
                ctx.arc(0, 0, voidRadius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Outer abstract boundary
            for (let boundary = 0; boundary < 4; boundary++) {
                const boundaryRadius = 450 + boundary * 70;
                const boundaryElements = 64 + boundary * 20;
                
                ctx.save();
                ctx.rotate(time * (0.4 + boundary * 0.15));
                
                for (let e = 0; e < boundaryElements; e++) {
                    const angle = (Math.PI * 2 * e) / boundaryElements;
                    const noise = Math.sin(e * 0.6 + time * 4) * 30;
                    const x = Math.cos(angle) * (boundaryRadius + noise);
                    const y = Math.sin(angle) * (boundaryRadius + noise);
                    
                    const size = Math.max(2, 6 + Math.sin(time * 2.5 + e * 0.4) * 3);
                    const opacity = 0.4 + Math.sin(time * 1.8 + e * 0.3) * 0.25;
                    
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size * 2.5);
                    gradient.addColorStop(0, `rgba(225, 225, 225, ${opacity})`);
                    gradient.addColorStop(0.5, `rgba(180, 180, 180, ${opacity * 0.6})`);
                    gradient.addColorStop(1, `rgba(140, 140, 140, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, size * 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            ctx.restore();
            
            time += 0.025 * speedMultiplier;
            requestAnimationFrame(drawKaleidoscope);
        }
        
        drawKaleidoscope();
        
        window.addEventListener('resize', () => {
            resizeCanvas();
        });
    </script>
</body>
</html>
