<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA — JUNG INTERFACE (MANDALA / ARCHETYPE GRAVITY / SHADOW INVERT)</title>
  <style>
    :root{
      --bg:#000;
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.56);
      --panel:rgba(0,0,0,.55);
      --hair:rgba(255,255,255,.14);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background:var(--bg);
      color:var(--fg);
      font-family: Arial, Helvetica, sans-serif;
    }
    canvas{ position:fixed; inset:0; width:100vw; height:100vh; display:block; }

    .hud{
      position:fixed; left:18px; top:16px;
      user-select:none; pointer-events:none;
      mix-blend-mode:screen;
    }
    .brand{
      font-weight:900;
      letter-spacing:.18em;
      text-transform:uppercase;
      font-size:15px;
      text-shadow:0 0 18px rgba(255,255,255,.18);
    }
    .sub{
      margin-top:4px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:var(--muted);
      line-height:1.25;
    }

    .dock{
      position:fixed; left:18px; bottom:16px;
      display:flex; flex-wrap:wrap;
      gap:10px; align-items:center;
      pointer-events:auto;
    }
    .btn{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.22);
      color:rgba(255,255,255,.86);
      padding:10px 12px;
      border-radius:10px;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{ background:rgba(255,255,255,.10); border-color:rgba(255,255,255,.36); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }

    .panel{
      position:fixed; right:16px; top:16px;
      width:min(720px, calc(100vw - 32px));
      max-height: calc(100vh - 32px);
      overflow:auto;
      border:1px solid rgba(255,255,255,.18);
      background:var(--panel);
      backdrop-filter: blur(10px);
      border-radius:14px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset, 0 16px 50px rgba(0,0,0,.65);
    }
    .panelHeader{
      position:sticky; top:0;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.72);
      backdrop-filter: blur(10px);
      display:flex; justify-content:space-between; align-items:center;
      z-index:10;
    }
    .title{
      font-weight:900;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      color:rgba(255,255,255,.86);
    }
    .hint{
      font-size:11px;
      letter-spacing:.08em;
      color:rgba(255,255,255,.55);
      text-align:right;
      line-height:1.2;
    }
    .panelBody{ padding:10px 12px 14px; display:flex; flex-direction:column; gap:10px; }

    .block{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      overflow:hidden;
      background:rgba(255,255,255,.02);
    }
    .block h3{
      margin:0;
      padding:10px 10px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:rgba(255,255,255,.75);
      border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      display:flex; justify-content:space-between; align-items:center;
    }
    .pill{
      font-size:10px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:rgba(255,255,255,.62);
      border:1px solid rgba(255,255,255,.18);
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.20);
      white-space:nowrap;
    }
    .rows{ padding:10px; display:flex; flex-direction:column; gap:10px; }
    .row{
      display:grid;
      grid-template-columns: 240px 1fr 70px;
      gap:10px;
      align-items:center;
    }
    .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:rgba(255,255,255,.62);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    input[type="range"]{ width:100%; accent-color: rgba(255,255,255,.92); }
    .val{ font-variant-numeric: tabular-nums; font-size:11px; color:rgba(255,255,255,.76); text-align:right; }

    .toggles{ display:flex; flex-wrap:wrap; gap:8px; padding:10px; border-top:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.10); }
    .toggle{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }
    .toggle span{
      font-size:11px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:rgba(255,255,255,.78);
      white-space:nowrap;
    }

    .status{
      padding:10px;
      border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
      display:flex; flex-direction:column; gap:8px;
    }
    .mono{
      font-variant-numeric: tabular-nums;
      letter-spacing:.10em;
      text-transform:uppercase;
      font-size:10px;
      color:rgba(255,255,255,.72);
      line-height:1.35;
    }
    .prompt{
      font-size:11px;
      color:rgba(255,255,255,.84);
      line-height:1.35;
      letter-spacing:.02em;
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      background:rgba(0,0,0,.45);
      padding:10px 10px;
      white-space:pre-wrap;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="brand">KETADATA</div>
    <div class="sub">JUNG MODE · MANDALA CORE · ARCHETYPE GRAVITY · SHADOW INTEGRATION · SYNCHRONICITY</div>
  </div>

  <div class="dock">
    <button class="btn" id="invert">SHADOW INVERT</button>
    <button class="btn" id="pause">PAUSE</button>
    <button class="btn" id="syncPulse">SYNCHRONICITY</button>
    <button class="btn" id="newDream">NEW DREAM</button>
    <button class="btn" id="reset">RESET</button>
  </div>

  <div class="panel" id="panel">
    <div class="panelHeader">
      <div class="title">MANDALA CONTROLS</div>
      <div class="hint">
        CLICK = DROP SYMBOL · SHIFT+CLICK = PIN SYMBOL<br/>
        DRAG = PAN · SCROLL = ZOOM<br/>
        [H] PANEL · [I] INVERT · [P] PAUSE
      </div>
    </div>

    <div class="panelBody">
      <div class="block">
        <h3>Time / Motion <span class="pill">slow-mo</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">time scale (real slow)</div>
            <input id="timeScale" type="range" min="0.000" max="2.000" step="0.001" value="0.35">
            <div class="val" id="timeScaleV">0.350</div>
          </div>
          <div class="row">
            <div class="label">spin / orbit rate</div>
            <input id="spin" type="range" min="0.00" max="2.50" step="0.01" value="0.90">
            <div class="val" id="spinV">0.90</div>
          </div>
          <div class="row">
            <div class="label">cursor gravity (ego pull)</div>
            <input id="ego" type="range" min="0.00" max="2.50" step="0.01" value="1.05">
            <div class="val" id="egoV">1.05</div>
          </div>
          <div class="row">
            <div class="label">damping (calm ↔ agitation)</div>
            <input id="damp" type="range" min="0.00" max="1.00" step="0.01" value="0.22">
            <div class="val" id="dampV">0.22</div>
          </div>
          <div class="row">
            <div class="label">zoom</div>
            <input id="zoom" type="range" min="0.55" max="2.60" step="0.01" value="1.25">
            <div class="val" id="zoomV">1.25</div>
          </div>
          <div class="row">
            <div class="label">trace (memory)</div>
            <input id="trace" type="range" min="0.000" max="0.22" step="0.001" value="0.055">
            <div class="val" id="traceV">0.055</div>
          </div>
        </div>
      </div>

      <div class="block">
        <h3>Psyche Engine <span class="pill">symbols</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">symbol density</div>
            <input id="density" type="range" min="0.40" max="3.00" step="0.01" value="1.55">
            <div class="val" id="densityV">1.55</div>
          </div>
          <div class="row">
            <div class="label">dream noise (distortion)</div>
            <input id="dream" type="range" min="0.00" max="1.00" step="0.01" value="0.36">
            <div class="val" id="dreamV">0.36</div>
          </div>
          <div class="row">
            <div class="label">shadow intensity</div>
            <input id="shadow" type="range" min="0.00" max="1.50" step="0.01" value="0.65">
            <div class="val" id="shadowV">0.65</div>
          </div>
          <div class="row">
            <div class="label">integration rate (own it)</div>
            <input id="integrate" type="range" min="0.00" max="1.50" step="0.01" value="0.55">
            <div class="val" id="integrateV">0.55</div>
          </div>
          <div class="row">
            <div class="label">synchronicity frequency</div>
            <input id="sync" type="range" min="0.00" max="1.00" step="0.01" value="0.22">
            <div class="val" id="syncV">0.22</div>
          </div>
        </div>

        <div class="toggles">
          <label class="toggle"><input id="T_mandala" type="checkbox" checked><span>mandala rings</span></label>
          <label class="toggle"><input id="T_archetypes" type="checkbox" checked><span>archetype nodes</span></label>
          <label class="toggle"><input id="T_symbols" type="checkbox" checked><span>symbol field</span></label>
          <label class="toggle"><input id="T_trace" type="checkbox" checked><span>ego trace</span></label>
          <label class="toggle"><input id="T_labels" type="checkbox" checked><span>labels</span></label>
        </div>

        <div class="status">
          <div class="mono" id="statLine">—</div>
          <div class="prompt" id="prompt">PROMPT: New Dream generates a symbolic field. Click to drop your own symbol. “Shadow Invert” flips valence and palette.</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha:false });

      let W=0, H=0, DPR=Math.min(2, window.devicePixelRatio||1);
      function resize(){
        W=innerWidth; H=innerHeight;
        canvas.width = Math.floor(W*DPR);
        canvas.height = Math.floor(H*DPR);
        canvas.style.width = W+'px';
        canvas.style.height = H+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize);
      resize();

      const $ = (id)=>document.getElementById(id);

      const ui = {
        timeScale: $('timeScale'),
        spin: $('spin'),
        ego: $('ego'),
        damp: $('damp'),
        zoom: $('zoom'),
        trace: $('trace'),
        density: $('density'),
        dream: $('dream'),
        shadow: $('shadow'),
        integrate: $('integrate'),
        sync: $('sync'),
        T_mandala: $('T_mandala'),
        T_archetypes: $('T_archetypes'),
        T_symbols: $('T_symbols'),
        T_trace: $('T_trace'),
        T_labels: $('T_labels'),
      };
      const vv = {
        timeScaleV: $('timeScaleV'),
        spinV: $('spinV'),
        egoV: $('egoV'),
        dampV: $('dampV'),
        zoomV: $('zoomV'),
        traceV: $('traceV'),
        densityV: $('densityV'),
        dreamV: $('dreamV'),
        shadowV: $('shadowV'),
        integrateV: $('integrateV'),
        syncV: $('syncV'),
      };

      function syncVals(){
        vv.timeScaleV.textContent = (+ui.timeScale.value).toFixed(3);
        vv.spinV.textContent = (+ui.spin.value).toFixed(2);
        vv.egoV.textContent = (+ui.ego.value).toFixed(2);
        vv.dampV.textContent = (+ui.damp.value).toFixed(2);
        vv.zoomV.textContent = (+ui.zoom.value).toFixed(2);
        vv.traceV.textContent = (+ui.trace.value).toFixed(3);
        vv.densityV.textContent = (+ui.density.value).toFixed(2);
        vv.dreamV.textContent = (+ui.dream.value).toFixed(2);
        vv.shadowV.textContent = (+ui.shadow.value).toFixed(2);
        vv.integrateV.textContent = (+ui.integrate.value).toFixed(2);
        vv.syncV.textContent = (+ui.sync.value).toFixed(2);
      }
      Object.values(ui).forEach(el=>{
        if (!el || !el.addEventListener) return;
        el.addEventListener('input', syncVals);
        el.addEventListener('change', syncVals);
      });
      syncVals();

      function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
      function lerp(a,b,t){ return a + (b-a)*t; }
      function hash32(n){
        n = (n ^ (n >>> 16)) >>> 0;
        n = Math.imul(n, 2246822519) >>> 0;
        n = (n ^ (n >>> 13)) >>> 0;
        n = Math.imul(n, 3266489917) >>> 0;
        n = (n ^ (n >>> 16)) >>> 0;
        return n >>> 0;
      }
      function rnd01(n){ return hash32(n) / 4294967295; }

      const st = {
        t:0,
        invert:false, // “Shadow invert”
        paused:false,
        seed:(Math.random()*1e9)|0,
        ox:0, oy:0,
        drag:false,
        lx:0, ly:0,
        wheel:0,
        zoom:1.0,
        syncPulse:0.0,
        cursor: { x:0, y:0, vx:0.0, vy:0.0 }, // ego point in world coords
        steps:0,
      };

      // World coordinates are normalized to [-1..1] range around center
      function worldToScreen(wx,wy){
        const S = Math.min(W,H) * 0.62 * st.zoom;
        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;
        return { x: cx + wx*S, y: cy + wy*S };
      }
      function screenToWorld(sx,sy){
        const S = Math.min(W,H) * 0.62 * st.zoom;
        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;
        return { x: (sx-cx)/S, y: (sy-cy)/S };
      }

      // Archetypes orbit the Self (mandala center)
      const archetypes = [
        { key:"SELF",      a:0.00, r:0.00, mass:1.80, val:+1, label:"SELF" },
        { key:"PERSONA",   a:0.15, r:0.48, mass:0.90, val:+1, label:"PERSONA" },
        { key:"SHADOW",    a:1.78, r:0.52, mass:1.15, val:-1, label:"SHADOW" },
        { key:"ANIMA",     a:2.55, r:0.60, mass:0.85, val:+1, label:"ANIMA/ANIMUS" },
        { key:"TRICKSTER", a:4.10, r:0.70, mass:0.75, val: 0, label:"TRICKSTER" },
        { key:"SAGE",      a:3.35, r:0.78, mass:0.70, val:+1, label:"SAGE" },
        { key:"CHILD",     a:5.55, r:0.58, mass:0.70, val:+1, label:"CHILD" },
      ];

      // Symbols are “complex fragments” with charge and pinning
      const symbols = []; // {x,y,str,charge,label,pin,heat,age}
      const SYMBOL_WORDS = [
        "KEY","DOOR","WATER","BONE","MASK","MIRROR","LADDER","SNAKE","CROWN","EYE",
        "RING","THREAD","KNIFE","BOOK","FIRE","CLOCK","TOWER","SEAL","HAND","MOON"
      ];

      function newDream(){
        st.seed = (Math.random()*1e9)|0;
        symbols.length = 0;
        st.cursor.x = 0; st.cursor.y = 0; st.cursor.vx = 0.0; st.cursor.vy = 0.0;
        st.steps = 0;
        st.syncPulse = 0;

        const density = +ui.density.value;
        const N = Math.floor(lerp(24, 120, clamp(density/3,0,1)));
        for (let i=0;i<N;i++){
          const a = rnd01(st.seed + i*91) * Math.PI*2;
          const rr = Math.sqrt(rnd01(st.seed + i*151)) * 0.92;
          const x = Math.cos(a)*rr;
          const y = Math.sin(a)*rr;

          // charge: positive vs shadow; shadow slider biases intensity
          const shadow = +ui.shadow.value;
          const sign = (rnd01(st.seed + i*211) < (0.52 + 0.15*shadow)) ? -1 : +1;
          const str = lerp(0.08, 0.55, rnd01(st.seed + i*271)) * (1 + 0.55*shadow);

          symbols.push({
            x, y,
            str,
            charge: sign,
            label: SYMBOL_WORDS[i % SYMBOL_WORDS.length],
            pin:false,
            heat:0.7,
            age:0
          });
        }

        issuePrompt();
      }

      function issuePrompt(){
        const prompts = [
          "Name the symbol that irritates you most. Move toward it slowly. Do not explain it.",
          "Find a repeating motif. Raise integration rate until it stops feeling 'other.'",
          "Let the Persona pull you outward; then increase Shadow intensity and watch the correction.",
          "Trigger Synchronicity once. Observe which two distant symbols behave as if they were one.",
          "Drop a symbol where your attention keeps returning. Pin it. Build the mandala around it.",
          "Turn on Shadow Invert. Identify which 'negative' element becomes structurally useful.",
        ];
        const i = Math.floor(rnd01(st.seed + ((st.t*1000)|0) + st.steps*17) * prompts.length);
        $('prompt').textContent = "PROMPT: " + prompts[i];
      }

      // UI buttons
      $('invert').onclick = ()=> st.invert = !st.invert;
      $('pause').onclick = ()=> st.paused = !st.paused;
      $('syncPulse').onclick = ()=> st.syncPulse = 1.0; // manual pulse
      $('newDream').onclick = ()=> newDream();
      $('reset').onclick = ()=>{
        st.t=0; st.invert=false; st.paused=false; st.ox=0; st.oy=0; st.wheel=0; st.zoom=1.0;
        ui.timeScale.value=0.35; ui.spin.value=0.90; ui.ego.value=1.05; ui.damp.value=0.22; ui.zoom.value=1.25;
        ui.trace.value=0.055; ui.density.value=1.55; ui.dream.value=0.36; ui.shadow.value=0.65; ui.integrate.value=0.55; ui.sync.value=0.22;
        syncVals();
        newDream();
      };

      addEventListener('keydown', (e)=>{
        if (e.key==='i' || e.key==='I') st.invert = !st.invert;
        if (e.key==='p' || e.key==='P') st.paused = !st.paused;
        if (e.key==='h' || e.key==='H'){
          const panel = document.getElementById('panel');
          panel.style.display = (panel.style.display === 'none') ? '' : 'none';
        }
        if (e.key==='n' || e.key==='N') newDream();
        if (e.key==='g' || e.key==='G') issuePrompt();
      });

      addEventListener('wheel', (e)=>{
        const d = Math.max(-160, Math.min(160, e.deltaY));
        st.wheel += (-d/160) * 0.18;
        st.wheel = clamp(st.wheel, -0.85, 0.95);
      }, { passive:true });

      function hitSymbol(sx,sy){
        const p = screenToWorld(sx,sy);
        let best=-1, bd=1e9;
        for (let i=0;i<symbols.length;i++){
          const s = symbols[i];
          const dx = s.x - p.x, dy = s.y - p.y;
          const d2 = dx*dx + dy*dy;
          if (d2 < 0.018 && d2 < bd){ bd=d2; best=i; }
        }
        return best;
      }

      addEventListener('pointerdown', (e)=>{
        // Pan begins
        st.drag=true; st.lx=e.clientX; st.ly=e.clientY;

        const hit = hitSymbol(e.clientX, e.clientY);
        if (hit !== -1){
          if (e.shiftKey){
            symbols[hit].pin = !symbols[hit].pin;
            symbols[hit].heat = 1.3;
          } else {
            symbols[hit].heat = 1.35;
            symbols[hit].str *= 1.06;
          }
          return;
        }

        // Drop symbol at click
        const p = screenToWorld(e.clientX, e.clientY);
        const shadow = +ui.shadow.value;
        const sign = (rnd01(st.seed + symbols.length*999) < (0.50 + 0.18*shadow)) ? -1 : +1;
        const label = SYMBOL_WORDS[symbols.length % SYMBOL_WORDS.length];
        symbols.push({
          x:p.x, y:p.y,
          str: lerp(0.10, 0.60, rnd01(st.seed + symbols.length*131)) * (1 + 0.55*shadow),
          charge: sign,
          label,
          pin:false,
          heat:1.2,
          age:0
        });
      });

      addEventListener('pointerup', ()=> st.drag=false);
      addEventListener('pointercancel', ()=> st.drag=false);
      addEventListener('pointermove', (e)=>{
        if (!st.drag) return;
        const dx = e.clientX - st.lx;
        const dy = e.clientY - st.ly;
        st.lx=e.clientX; st.ly=e.clientY;
        st.ox += dx;
        st.oy += dy;
        st.ox = clamp(st.ox, -W*0.60, W*0.60);
        st.oy = clamp(st.oy, -H*0.60, H*0.60);
      });

      // Trace
      const trace = []; // {x,y}
      function pushTrace(){
        trace.push({x:st.cursor.x, y:st.cursor.y});
        if (trace.length > 1300) trace.shift();
      }

      function step(dt){
        const spin = +ui.spin.value;
        const ego = +ui.ego.value;
        const damp = +ui.damp.value;
        const dream = +ui.dream.value;
        const integrate = +ui.integrate.value;
        const syncF = +ui.sync.value;

        // zoom smoothing
        st.wheel *= 0.88;
        st.zoom += st.wheel;
        st.zoom = clamp(st.zoom, 0.55, 2.60);

        // pull actual zoom toward slider
        const baseZ = +ui.zoom.value;
        st.zoom = lerp(st.zoom, baseZ, clamp(dt*0.9,0,1));

        // archetype positions evolve (orbit)
        const archPos = [];
        for (let i=0;i<archetypes.length;i++){
          const a0 = archetypes[i].a + st.t * (0.18 + 0.55*spin) * (i===0?0:1);
          const rr = archetypes[i].r * (1 + 0.08*Math.sin(st.t*0.7 + i));
          archPos.push({ x: Math.cos(a0)*rr, y: Math.sin(a0)*rr, ...archetypes[i] });
        }

        // Synchronicity: occasionally align two distant symbols
        const spont = (rnd01(st.seed + ((st.t*1000)|0) + st.steps*73) < (syncF*0.008));
        if (spont) st.syncPulse = 1.0;

        if (st.syncPulse > 0){
          // pick two symbols far apart and gently pull them into shared orbit
          if (symbols.length > 8){
            let iA = Math.floor(rnd01(st.seed + st.steps*11)*symbols.length);
            let iB = Math.floor(rnd01(st.seed + st.steps*29)*symbols.length);
            if (iA === iB) iB = (iB+3) % symbols.length;

            const A = symbols[iA], B = symbols[iB];
            const dx = B.x - A.x, dy = B.y - A.y;
            const d = Math.sqrt(dx*dx + dy*dy) + 1e-6;
            const pull = (0.10 + 0.35*syncF) * st.syncPulse;
            // move each toward midpoint slightly (non-heavy, no velocities)
            const mx = (A.x+B.x)*0.5, my = (A.y+B.y)*0.5;
            if (!A.pin){ A.x = lerp(A.x, mx + dx/d*0.06, pull); A.y = lerp(A.y, my + dy/d*0.06, pull); A.heat = 1.2; }
            if (!B.pin){ B.x = lerp(B.x, mx - dx/d*0.06, pull); B.y = lerp(B.y, my - dy/d*0.06, pull); B.heat = 1.2; }
          }
          st.syncPulse *= Math.pow(0.06, dt*0.7);
        }

        // Ego dynamics: the cursor is pulled by Self and archetype masses + symbol charges.
        let ax=0, ay=0;

        // pull toward Self center (individuation)
        const selfPull = 0.45 + 0.85*ego;
        ax += (-st.cursor.x) * selfPull;
        ay += (-st.cursor.y) * selfPull;

        // archetype pulls and pushes
        for (let i=0;i<archPos.length;i++){
          const A = archPos[i];
          const dx = A.x - st.cursor.x;
          const dy = A.y - st.cursor.y;
          const d2 = dx*dx + dy*dy + 1e-5;
          const inv = 1 / d2;
          // valence flips in shadow invert
          const val = st.invert ? -A.val : A.val;
          const mass = A.mass * (0.55 + 0.45*Math.abs(val));
          // Trickster has lateral / tangential component
          if (A.key === "TRICKSTER"){
            const d = Math.sqrt(d2);
            const tx = -dy/d, ty = dx/d;
            ax += tx * (0.35 + 0.35*dream) * inv;
            ay += ty * (0.35 + 0.35*dream) * inv;
          } else {
            ax += dx * inv * mass * (0.55 + 0.55*ego) * (val===0 ? 0.35 : (val>0 ? 1 : -1));
            ay += dy * inv * mass * (0.55 + 0.55*ego) * (val===0 ? 0.35 : (val>0 ? 1 : -1));
          }
        }

        // symbol field: complexes (attract/repel depending on charge)
        const shadow = +ui.shadow.value;
        for (let i=0;i<symbols.length;i++){
          const s = symbols[i];
          s.age += dt;
          s.heat *= Math.pow(0.10, dt*0.35);

          const dx = s.x - st.cursor.x;
          const dy = s.y - st.cursor.y;
          const d2 = dx*dx + dy*dy + 1e-5;
          const inv = 1 / d2;

          // integration: shadow charge gradually becomes “owned” (moves toward positive valence)
          if (!s.pin){
            const toward = (s.charge < 0) ? 1 : s.charge;
            const rate = integrate * 0.03 * dt;
            s.charge = lerp(s.charge, toward, rate);
          }

          const charge = st.invert ? -s.charge : s.charge; // invert flips valence
          const strength = s.str * (0.65 + 0.55*shadow);

          ax += dx * inv * strength * charge;
          ay += dy * inv * strength * charge;

          // dream noise wobbles symbols (slight)
          if (!s.pin){
            const n = (rnd01(st.seed + i*97 + ((st.t*1000)|0)) - 0.5) * 2;
            s.x += Math.cos(st.t*0.8 + i) * 0.0025 * dream * n;
            s.y += Math.sin(st.t*0.9 + i) * 0.0025 * dream * n;
          }
        }

        // apply to cursor velocity
        st.cursor.vx += ax * dt * 0.55;
        st.cursor.vy += ay * dt * 0.55;

        // damping
        const dmp = clamp(lerp(0.995, 0.88, damp), 0.82, 0.995);
        st.cursor.vx *= Math.pow(dmp, dt*60);
        st.cursor.vy *= Math.pow(dmp, dt*60);

        // update cursor position
        st.cursor.x += st.cursor.vx * dt;
        st.cursor.y += st.cursor.vy * dt;

        // keep in bounds (soft wrap)
        const B = 0.98;
        if (st.cursor.x < -B) st.cursor.x += 2*B;
        if (st.cursor.x >  B) st.cursor.x -= 2*B;
        if (st.cursor.y < -B) st.cursor.y += 2*B;
        if (st.cursor.y >  B) st.cursor.y -= 2*B;

        st.steps += 1;
        if ((st.steps % 3) === 0) pushTrace();

        // status
        const shadowCount = symbols.filter(s => (st.invert ? -s.charge : s.charge) < 0).length;
        $('statLine').textContent =
          `SYMBOLS ${symbols.length} · SHADOW-CHARGED ${shadowCount} · TRACE ${trace.length} · SYNC ${(st.syncPulse>0.02)?"ON":"OFF"}`;
      }

      function draw(){
        const inv = st.invert;
        const bg = inv ? 255 : 0;
        const fg = inv ? 0 : 255;

        const tr = +ui.trace.value;
        if (tr > 0){
          ctx.fillStyle = `rgba(${bg},${bg},${bg},${clamp(tr,0,1)})`;
          ctx.fillRect(0,0,W,H);
        } else {
          ctx.fillStyle = `rgb(${bg},${bg},${bg})`;
          ctx.fillRect(0,0,W,H);
        }

        // In invert mode: keep source-over so geometry truly becomes black.
        ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';

        const S = Math.min(W,H) * 0.62 * st.zoom;
        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;

        const spin = +ui.spin.value;
        const density = +ui.density.value;
        const dream = +ui.dream.value;

        // Mandala rings
        if (ui.T_mandala.checked){
          ctx.lineWidth = 1.2;
          const rings = Math.floor(lerp(5, 10, clamp(density/3,0,1)));
          for (let i=1;i<=rings;i++){
            const r = (i/rings) * Math.min(W,H)*0.38 * (0.85 + 0.15*Math.sin(st.t*0.4 + i));
            const a = clamp(0.03 + 0.06*(1 - i/rings), 0, 0.14);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
            ctx.beginPath();
            ctx.arc(cx,cy,r,0,Math.PI*2);
            ctx.stroke();
          }

          // petals (sacred-geometry-ish without heavy shaders)
          const petals = 12;
          for (let k=0;k<petals;k++){
            const a0 = (k/petals)*Math.PI*2 + st.t*(0.06+0.16*spin);
            const r0 = Math.min(W,H)*0.32;
            const x1 = cx + Math.cos(a0)*r0;
            const y1 = cy + Math.sin(a0)*r0;
            const x2 = cx + Math.cos(a0 + Math.PI/petals)*r0;
            const y2 = cy + Math.sin(a0 + Math.PI/petals)*r0;
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.06})`;
            ctx.beginPath();
            ctx.moveTo(cx,cy);
            ctx.quadraticCurveTo(x1,y1,x2,y2);
            ctx.stroke();
          }
        }

        // Symbol field
        if (ui.T_symbols.checked){
          ctx.lineWidth = 1.2;
          for (let i=0;i<symbols.length;i++){
            const s = symbols[i];
            const p = worldToScreen(s.x, s.y);
            const charge = st.invert ? -s.charge : s.charge;
            const heat = clamp(s.heat, 0, 1.4);

            const r = (6 + 18*Math.abs(s.str) + 10*heat) * (0.8 + 0.25*st.zoom*0.2);
            const a = clamp(0.10 + 0.18*Math.abs(charge) + 0.25*heat, 0, 0.75);

            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, r*0.55, 0, Math.PI*2);
            ctx.stroke();

            // charge mark (+ for integrated / - for shadow)
            ctx.beginPath();
            if (charge >= 0){
              ctx.moveTo(p.x-r*0.25, p.y);
              ctx.lineTo(p.x+r*0.25, p.y);
              ctx.moveTo(p.x, p.y-r*0.25);
              ctx.lineTo(p.x, p.y+r*0.25);
            } else {
              ctx.moveTo(p.x-r*0.25, p.y);
              ctx.lineTo(p.x+r*0.25, p.y);
            }
            ctx.stroke();

            // dream distortion halo
            if (dream > 0.02){
              const wob = (Math.sin(st.t*1.1 + i)*0.5 + 0.5) * dream;
              ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.05 + 0.10*wob})`;
              ctx.beginPath();
              ctx.arc(p.x, p.y, r*(0.9 + 0.4*wob), 0, Math.PI*2);
              ctx.stroke();
            }

            if (s.pin){
              ctx.beginPath();
              ctx.moveTo(p.x-r*0.55, p.y);
              ctx.lineTo(p.x+r*0.55, p.y);
              ctx.stroke();
            }
          }
        }

        // Archetypes orbit
        if (ui.T_archetypes.checked){
          const archPos = [];
          for (let i=0;i<archetypes.length;i++){
            const A = archetypes[i];
            const a0 = A.a + st.t * (0.18 + 0.55*spin) * (i===0?0:1);
            const rr = A.r * (1 + 0.08*Math.sin(st.t*0.7 + i));
            archPos.push({ x: Math.cos(a0)*rr, y: Math.sin(a0)*rr, ...A });
          }

          for (let i=0;i<archPos.length;i++){
            const A = archPos[i];
            const p = worldToScreen(A.x, A.y);
            const val = st.invert ? -A.val : A.val;
            const r = (A.key==="SELF") ? 18 : (10 + 6*A.mass);
            ctx.lineWidth = 1.4;
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${A.key==="SELF" ? 0.55 : 0.22})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI*2);
            ctx.stroke();

            // valence sign
            ctx.beginPath();
            if (A.key !== "SELF"){
              if (val > 0){
                ctx.moveTo(p.x-r*0.35, p.y);
                ctx.lineTo(p.x+r*0.35, p.y);
                ctx.moveTo(p.x, p.y-r*0.35);
                ctx.lineTo(p.x, p.y+r*0.35);
              } else if (val < 0){
                ctx.moveTo(p.x-r*0.35, p.y);
                ctx.lineTo(p.x+r*0.35, p.y);
              } else {
                // trickster mark: zig
                ctx.moveTo(p.x-r*0.35, p.y-r*0.10);
                ctx.lineTo(p.x, p.y+r*0.10);
                ctx.lineTo(p.x+r*0.35, p.y-r*0.10);
              }
              ctx.stroke();
            }

            if (ui.T_labels.checked){
              ctx.globalCompositeOperation = 'source-over';
              ctx.font = '11px Arial';
              ctx.textBaseline = 'middle';
              ctx.fillStyle = inv ? 'rgba(0,0,0,0.84)' : 'rgba(255,255,255,0.76)';
              ctx.fillText(A.label, p.x + 14, p.y);
              ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';
            }
          }

          // self crosshair
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.18})`;
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.moveTo(cx-24, cy); ctx.lineTo(cx+24, cy);
          ctx.moveTo(cx, cy-24); ctx.lineTo(cx, cy+24);
          ctx.stroke();
        }

        // Ego trace
        if (ui.T_trace.checked && trace.length > 2){
          ctx.lineWidth = 1.4;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.22})`;
          ctx.beginPath();
          for (let i=0;i<trace.length;i++){
            const p = worldToScreen(trace[i].x, trace[i].y);
            if (i===0) ctx.moveTo(p.x,p.y);
            else ctx.lineTo(p.x,p.y);
          }
          ctx.stroke();
        }

        // Ego point
        const ep = worldToScreen(st.cursor.x, st.cursor.y);
        ctx.globalCompositeOperation = inv ? 'source-over' : 'lighter';
        ctx.lineWidth = 1.6;
        ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.85})`;
        ctx.beginPath();
        ctx.arc(ep.x, ep.y, 7, 0, Math.PI*2);
        ctx.stroke();

        // synchronicity flash ring
        if (st.syncPulse > 0.02){
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = inv ? `rgba(0,0,0,${0.25*st.syncPulse})` : `rgba(255,255,255,${0.25*st.syncPulse})`;
          ctx.lineWidth = 2.0;
          ctx.beginPath();
          ctx.arc(cx, cy, (Math.min(W,H)*0.18) * (1 + 0.6*(1-st.syncPulse)), 0, Math.PI*2);
          ctx.stroke();
        }

        ctx.globalCompositeOperation = 'source-over';
      }

      // Start
      newDream();
      pushTrace();

      // Loop
      let last = performance.now();
      function frame(now){
        const rawDt = Math.min(0.033, (now-last)/1000);
        last = now;

        const dt = rawDt * (+ui.timeScale.value) * (0.40 + 1.25*(+ui.spin.value));
        if (!st.paused){
          st.t += dt;
          step(dt);
        }
        draw();
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    })();
  </script>
</body>
</html>
