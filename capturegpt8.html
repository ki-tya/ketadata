<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sprawling Fractal Trap – Hypnosis Engine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: Arial, sans-serif;
      color: #ffffff;
    }
    #canvas {
      display: block;
      image-rendering: crisp-edges;
    }
    #instructions {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-size: 13px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-align: center;
      pointer-events: none;
      z-index: 10;
      transition: opacity 1s ease;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="instructions">SPACE — TOGGLE • CLICK — OVERLOAD • MOVE — IT FOLLOWS</div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    let w = canvas.width = window.innerWidth;
    let h = canvas.height = window.innerHeight;

    let running = false;
    let frameId = null;
    let t = 0;

    const CYCLE_FRAMES = 800; // full 4-phase cycle

    // camera
    let camZoom = 1;
    let camZoomTarget = 1;
    let camOffsetX = 0;
    let camOffsetY = 0;
    let camOffsetTargetX = 0;
    let camOffsetTargetY = 0;

    // core pulse
    let pulseAmp = 1;
    let pulseTarget = 1.25;

    // flashes
    let flashAlpha = 0;
    let microStrobe = 0;

    // mouse “gaze”
    let mouseX = w / 2;
    let mouseY = h / 2;

    // filaments / tendrils
    const MAX_BRANCHES = 40;
    const MAX_POINTS = 28;

    class Branch {
      constructor(x, y, angle, strength = 1) {
        this.reset(x, y, angle, strength);
      }
      reset(x, y, angle, strength = 1) {
        this.points = [{ x, y }];
        this.angle = angle;
        this.strength = strength;
        this.life = 0;
        this.maxLife = 320 + Math.random() * 260;
        this.curvePhase = Math.random() * Math.PI * 2;
      }
      update(intensity, beatWeight) {
        this.life++;
        const last = this.points[this.points.length - 1];

        // directional drift + noise
        const jitter = (Math.random() - 0.5) * 0.3 * (intensity + 0.3) * this.strength;
        const curve = Math.sin(this.curvePhase + this.life * 0.03) * 0.25 * (0.6 + intensity);
        this.angle += jitter + curve * 0.15;

        const baseStep = 3.5 + Math.random() * 3.5;
        const accel =
          0.7 +
          0.4 * intensity +
          0.25 * beatWeight +
          0.15 * Math.sin(t * 0.02 + this.life * 0.08);
        const step = baseStep * accel;

        const nx = last.x + Math.cos(this.angle) * step;
        const ny = last.y + Math.sin(this.angle) * step;

        this.points.push({ x: nx, y: ny });
        if (this.points.length > MAX_POINTS) {
          this.points.shift();
        }

        // wrap around screen to keep things sprawling
        if (nx < -100 || nx > w + 100 || ny < -100 || ny > h + 100 || this.life > this.maxLife) {
          const cx = w / 2;
          const cy = h / 2;
          const spawnRadius = Math.min(w, h) * (0.1 + Math.random() * 0.4);
          const ang = Math.random() * Math.PI * 2;
          const sx = cx + Math.cos(ang) * spawnRadius;
          const sy = cy + Math.sin(ang) * spawnRadius;
          this.reset(sx, sy, Math.random() * Math.PI * 2, this.strength);
        }
      }
      draw(intensity, beatWeight) {
        if (this.points.length < 2) return;

        const lifeFrac = this.life / this.maxLife;
        const baseAlpha = 0.06 + 0.2 * intensity * this.strength;
        const alpha = baseAlpha * (1 - lifeFrac * 0.5) * (0.8 + 0.5 * beatWeight);
        const width = (0.7 + 0.9 * intensity * this.strength) * (1 + 0.5 * beatWeight);

        ctx.beginPath();
        const p0 = this.points[0];
        ctx.moveTo(p0.x, p0.y);

        // slightly smoothed polyline
        for (let i = 1; i < this.points.length - 1; i++) {
          const p = this.points[i];
          const n = this.points[i + 1];
          const cx = (p.x + n.x) / 2;
          const cy = (p.y + n.y) / 2;
          ctx.quadraticCurveTo(p.x, p.y, cx, cy);
        }

        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
        ctx.lineWidth = width;
        ctx.shadowBlur = 18 * (intensity + 0.4) * this.strength;
        ctx.shadowColor = `rgba(255,255,255,${alpha * 0.95})`;
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    }

    let branches = [];

    function initBranches() {
      branches = [];
      const cx = w / 2;
      const cy = h / 2;
      for (let i = 0; i < MAX_BRANCHES; i++) {
        const spawnRadius = Math.min(w, h) * (0.15 + Math.random() * 0.6);
        const ang = Math.random() * Math.PI * 2;
        const x = cx + Math.cos(ang) * spawnRadius;
        const y = cy + Math.sin(ang) * spawnRadius;
        const strength = 0.7 + Math.random() * 0.5;
        const dir = Math.random() * Math.PI * 2;
        branches.push(new Branch(x, y, dir, strength));
      }
    }

    function resize() {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight;
      initBranches();
    }
    window.addEventListener("resize", resize);

    function lerp(a, b, f) {
      return a + (b - a) * f;
    }

    function softStep(edge0, edge1, x) {
      const t = Math.min(1, Math.max(0, (x - edge0) / (edge1 - edge0)));
      return t * t * (3 - 2 * t);
    }

    function getPhaseWeights(norm) {
      const lure = 1 - softStep(0.18, 0.3, norm);
      const sync = Math.min(
        softStep(0.18, 0.3, norm),
        1 - softStep(0.45, 0.55, norm)
      );
      const brk = Math.min(
        softStep(0.45, 0.55, norm),
        1 - softStep(0.7, 0.8, norm)
      );
      const dom = softStep(0.7, 0.86, norm);
      const sum = lure + sync + brk + dom || 1;
      return {
        lure: lure / sum,
        sync: sync / sum,
        brk: brk / sum,
        dom: dom / sum,
      };
    }

    // fractal-ish mist field – soft clusters popping in and out
    function drawFractalMist(time, intensity, breath, beatWeight, weights) {
      const count = 120 + Math.floor(80 * intensity);

      for (let i = 0; i < count; i++) {
        // hash-ish noise to avoid obvious patterns
        const n1 = Math.sin(i * 12.9898 + time * 0.0017) * 43758.5453;
        const n2 = Math.sin(i * 78.233 + time * 0.0013) * 12345.6789;

        const px = (n1 - Math.floor(n1)) * w;
        const py = (n2 - Math.floor(n2)) * h;

        const osc = Math.sin(time * 0.004 + i * 0.21) * 0.5 + 0.5;
        const phaseFlash = (weights.brk + weights.dom) * osc;
        const breathFactor = (breath + 1) * 0.5;

        const alpha =
          0.02 +
          0.04 * intensity +
          0.02 * beatWeight +
          0.04 * phaseFlash +
          0.02 * breathFactor;

        const size =
          1.5 +
          4 * intensity +
          2.5 * beatWeight +
          2 * phaseFlash +
          Math.random() * 1.5;

        ctx.shadowBlur = 16 * (intensity + beatWeight + 0.3);
        ctx.shadowColor = `rgba(255,255,255,${alpha})`;
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;

        ctx.beginPath();
        ctx.arc(px, py, size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // sprawling tendril field – abstract “neural” sprawl
    function drawTendrilField(time, intensity, beatWeight, weights) {
      ctx.save();

      const cx = w / 2;
      const cy = h / 2;
      ctx.translate(cx, cy);

      const layers = 3;
      for (let layer = 0; layer < layers; layer++) {
        const layerPhase = time * (0.0007 + 0.0004 * layer) * (1 + 0.4 * beatWeight);
        const baseLines = 12 + layer * 6 + Math.floor(6 * intensity);

        for (let i = 0; i < baseLines; i++) {
          ctx.save();

          // slightly irregular angular spacing to break symmetry
          const jitter = Math.sin(i * 1.37 + time * 0.002) * 0.4;
          ctx.rotate(layerPhase + (Math.PI * 2 * i) / baseLines + jitter);

          const segments = 7 + layer * 2;
          let r = 40 + 40 * layer;

          ctx.beginPath();
          ctx.moveTo(0, 0);

          for (let s = 0; s < segments; s++) {
            r += 35 + 25 * intensity + 20 * beatWeight;
            const wobble =
              Math.sin(time * 0.004 + s * 0.9 + i * 0.5 + layer * 1.1) *
              (0.4 + 0.3 * (weights.brk + weights.dom));
            const x = r * Math.cos(wobble);
            const y = r * Math.sin(wobble);
            ctx.lineTo(x, y);
          }

          const alpha =
            0.03 +
            0.05 * (1 - layer / layers) +
            0.06 * intensity +
            0.05 * beatWeight +
            0.04 * (weights.brk + weights.dom);

          ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
          ctx.lineWidth = (0.7 + 0.6 * intensity) * (1 + 0.4 * beatWeight);
          ctx.shadowBlur = 20 * (intensity + 0.4) * (1 - layer / layers);
          ctx.shadowColor = `rgba(255,255,255,${alpha})`;
          ctx.stroke();
          ctx.shadowBlur = 0;

          ctx.restore();
        }
      }

      ctx.restore();
    }

    function animate() {
      t++;

      const cyclePos = (t % CYCLE_FRAMES) / CYCLE_FRAMES;
      const weights = getPhaseWeights(cyclePos);

      // 6 breaths / minute
      const breath = Math.sin((Math.PI * 2 * t) / 600);

      // faster underlying beat (~1.5s)
      const BEAT_FRAMES = 90;
      const beatPhase = (t % BEAT_FRAMES) / BEAT_FRAMES;
      const beat = Math.sin(beatPhase * Math.PI * 2);
      const beatWeight = Math.max(0, Math.pow(beat, 2));

      const fadeBase =
        0.10 +
        0.05 * weights.sync +
        0.08 * weights.brk +
        0.10 * weights.dom;
      const trailFade = fadeBase + 0.02 * Math.sin(t * 0.01);
      ctx.fillStyle = `rgba(0,0,0,${trailFade})`;
      ctx.fillRect(0, 0, w, h);

      pulseAmp = lerp(pulseAmp, pulseTarget, 0.045);
      camZoom = lerp(camZoom, camZoomTarget, 0.035);
      camOffsetX = lerp(camOffsetX, camOffsetTargetX, 0.035);
      camOffsetY = lerp(camOffsetY, camOffsetTargetY, 0.035);

      if (Math.abs(camOffsetX - camOffsetTargetX) < 0.4) camOffsetTargetX *= 0.6;
      if (Math.abs(camOffsetY - camOffsetTargetY) < 0.4) camOffsetTargetY *= 0.6;

      const driftChance =
        0.002 +
        0.003 * weights.sync +
        0.005 * weights.brk +
        0.008 * weights.dom;
      if (Math.random() < driftChance) {
        const spread = 50 + 80 * (weights.brk + weights.dom);
        camOffsetTargetX = (Math.random() - 0.5) * spread;
        camOffsetTargetY = (Math.random() - 0.5) * spread;
      }

      camZoomTarget =
        1.03 +
        0.03 * breath * (weights.lure + weights.sync) +
        0.06 * Math.sin(t * 0.018) *
          (weights.brk + weights.dom) +
        0.06 * beatWeight;

      pulseTarget =
        1.25 +
        0.25 * ((breath + 1) / 2) * (weights.lure + weights.sync) +
        0.45 * Math.sin(t * 0.022) *
          (weights.brk + weights.dom) +
        0.55 * beatWeight;

      if (weights.brk + weights.dom > 0.2 && Math.random() < 0.004 * (1 + beatWeight)) {
        flashAlpha = 0.35 + 0.4 * (weights.dom + weights.brk) + 0.25 * beatWeight;
      }
      flashAlpha = Math.max(0, flashAlpha - 0.02);

      microStrobe = Math.max(0, microStrobe - 0.14);
      if (weights.sync > 0.25) {
        if (beatWeight > 0.8 && breath > 0 && t % 5 === 0) microStrobe = 0.25;
      }
      if (weights.brk > 0.2 && Math.random() < 0.04 * (1 + beatWeight)) microStrobe = 0.4;
      if (weights.dom > 0.2 && Math.random() < 0.06 * (1 + beatWeight)) microStrobe = 0.6;

      const intensity =
        0.4 * weights.lure +
        0.7 * weights.sync +
        0.95 * weights.brk +
        1.1 * weights.dom;

      ctx.save();
      ctx.translate(w / 2, h / 2);
      ctx.scale(camZoom, camZoom);
      ctx.translate(-w / 2 + camOffsetX, -h / 2 + camOffsetY);

      // atmospheric + tendril layers
      drawFractalMist(t, intensity, breath, beatWeight, weights);
      drawTendrilField(t, intensity, beatWeight, weights);

      branches.forEach(b => {
        b.update(intensity, beatWeight);
        b.draw(intensity, beatWeight);
      });

      ctx.restore();

      if (flashAlpha > 0) {
        ctx.globalAlpha = flashAlpha * 0.55;
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
      }

      if (microStrobe > 0) {
        ctx.globalAlpha = microStrobe * 0.35;
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
      }

      if (running) frameId = requestAnimationFrame(animate);
    }

    function start() {
      if (running) return;
      running = true;
      document.getElementById("instructions").style.opacity = "0.3";
      animate();
    }

    function stop() {
      running = false;
      if (frameId) cancelAnimationFrame(frameId);
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, w, h);
      document.getElementById("instructions").style.opacity = "0.9";

      pulseAmp = 1;
      pulseTarget = 1.25;
      camZoom = 1;
      camZoomTarget = 1;
      camOffsetX = camOffsetY = 0;
      camOffsetTargetX = camOffsetTargetY = 0;
      flashAlpha = 0;
      microStrobe = 0;
      t = 0;
      initBranches();
    }

    document.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        running ? stop() : start();
      }
    });

    canvas.addEventListener("click", () => {
      // click = stronger beat burst
      pulseTarget += 0.8;
      camZoomTarget += 0.2;
      flashAlpha = Math.min(1, flashAlpha + 0.7);
      microStrobe = Math.max(microStrobe, 0.7);

      setTimeout(() => {
        pulseTarget = 1.4;
        camZoomTarget = 1.08;
      }, 420);
    });

    canvas.addEventListener("mousemove", (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    // init
    initBranches();
    ctx.fillStyle = "#000000";
    ctx.fillRect(0, 0, w, h);
  </script>
</body>
</html>
