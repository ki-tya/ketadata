<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA // KITTY CAT</title>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --muted:rgba(255,255,255,.58);
      --hair:rgba(255,255,255,.14);
      --panel:rgba(0,0,0,.42);
      --panel2:rgba(0,0,0,.62);
      --motion:1;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:var(--bg);
      color:var(--fg);
      font:12px/1.25 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      overflow:hidden;
      user-select:none;
    }

    body.invert{ filter: invert(1) hue-rotate(180deg); background:#fff; }
    body.nullmode .chrome{display:none}
    body.nullmode #hud{opacity:0; pointer-events:none}

    #field{
      position:absolute; inset:0;
      background:
        radial-gradient(1200px 900px at 50% 40%, rgba(255,255,255,.06), rgba(0,0,0,0) 62%),
        radial-gradient(900px 800px at 28% 78%, rgba(255,255,255,.035), rgba(0,0,0,0) 58%),
        linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,0) 40%),
        linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.35));
    }
    canvas{position:absolute; inset:0; width:100%; height:100%}

    .chrome{position:absolute; inset:0; pointer-events:none}
    #frame{position:absolute; inset:8px; border:1px solid rgba(255,255,255,.08); pointer-events:none}

    #hud{
      position:absolute;
      top:10px; left:10px;
      width:360px;
      border:1px solid var(--hair);
      background:var(--panel);
      backdrop-filter: blur(6px);
      pointer-events:auto;
    }
    #hud .bar{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 8px;
      border-bottom:1px solid var(--hair);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,0));
    }
    #hud .bar .title{opacity:.92}
    #hud .bar .meta{opacity:.58}
    #hud .body{padding:8px; display:grid; gap:8px}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .btn, .pill, input[type="range"]{font:inherit; color:inherit}
    .btn{
      border:1px solid var(--hair);
      background:rgba(255,255,255,.04);
      padding:6px 8px;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{background:rgba(255,255,255,.07)}
    .btn:active{transform: translateY(1px)}
    .pill{
      border:1px solid var(--hair);
      padding:6px 8px;
      background:rgba(0,0,0,.18);
      opacity:.85;
    }
    input[type="range"]{width:140px; accent-color: var(--fg)}
    .label{opacity:.72}
    .mini{opacity:.58}
    .sep{height:1px;background:var(--hair);margin:2px 0}

    #note{
      position:absolute;
      right:10px; top:10px;
      width:360px; height:220px;
      border:1px solid var(--hair);
      background:var(--panel2);
      pointer-events:auto;
      display:none;
    }
    #note.open{display:block}
    #note .bar{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 8px;
      border-bottom:1px solid var(--hair);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,0));
      cursor:move;
      user-select:none;
    }
    #note textarea{
      width:100%; height: calc(100% - 34px);
      border:0; outline:none; resize:none;
      background:transparent;
      color:var(--fg);
      font:inherit;
      padding:8px;
      user-select:text;
    }

    #cornerDots{position:absolute; left:10px; bottom:10px; display:flex; gap:6px; pointer-events:none; opacity:.6}
    .dot{width:10px; height:10px; border-radius:50%; border:1px solid var(--hair); background:rgba(255,255,255,.06)}

    #statusLine{
      position:absolute; right:10px; bottom:10px;
      border:1px solid var(--hair);
      background:rgba(0,0,0,.25);
      padding:6px 8px;
      opacity:.78;
      pointer-events:none;
      max-width:60vw;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
  </style>
</head>
<body>
  <div id="field"><canvas id="c"></canvas></div>

  <div class="chrome">
    <div id="frame"></div>

    <div id="hud">
      <div class="bar">
        <div class="title">KETADATA // KITTY CAT</div>
        <div class="meta" id="meta">INVERT 0 · NULL 0</div>
      </div>

      <div class="body">
        <div class="row">
          <div class="pill"><span class="label">HOTKEYS</span> <span class="mini">SHIFT+I INVERT · SHIFT+N NULL · SHIFT+F FULLSCREEN · SHIFT+K NOTE · SPACE GLIDE</span></div>
        </div>

        <div class="sep"></div>

        <div class="row">
          <button class="btn" id="btnNote">NOTE</button>
          <button class="btn" id="btnInvert">INVERT</button>
          <button class="btn" id="btnNull">NULL</button>
          <button class="btn" id="btnFull">FULL</button>
          <span class="label">MOTION</span>
          <button class="btn" id="btnMotion">ON</button>
        </div>

        <div class="row">
          <span class="label">SIZE</span>
          <input type="range" id="rngSize" min="70" max="190" step="1" value="130" />
          <span class="label">PACE</span>
          <input type="range" id="rngSpeed" min="0" max="100" step="1" value="22" />
          <span class="label">TAIL</span>
          <input type="range" id="rngTail" min="0" max="100" step="1" value="84" />
        </div>

        <div class="row">
          <span class="label">FORM</span>
          <input type="range" id="rngForm" min="0" max="100" step="1" value="72" />
          <span class="label">GAIT</span>
          <input type="range" id="rngGait" min="0" max="100" step="1" value="42" />
          <span class="label">TRAIL</span>
          <input type="range" id="rngTrail" min="0" max="100" step="1" value="82" />
        </div>

        <div class="row">
          <span class="label">RESEED</span>
          <button class="btn" id="btnSeed">GO</button>
          <span class="label">REST</span>
          <button class="btn" id="btnRest">IDLE</button>
        </div>
      </div>
    </div>

    <div id="note">
      <div class="bar">
        <div>KETA_NOTE</div>
        <div class="mini">SHIFT+K TO TOGGLE</div>
      </div>
      <textarea id="noteText" spellcheck="false" placeholder="KETA_NOTE — optional, movable, non-interfering."></textarea>
    </div>

    <div id="cornerDots" aria-hidden="true">
      <div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div>
    </div>

    <div id="statusLine">READY</div>
  </div>

<script>
const FILE_ID = "KETADATA_KITTY_CAT_FLUID_MONO_V2";
const LS_KEY = "KETADATA::" + FILE_ID + "::STATE";
const $ = (id)=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;

const state = {
  invert:false, nullMode:false, fullscreen:false, motion:true,
  size:1.30, pace:0.22, tail:0.84,
  form:0.72, gait:0.42, trail:0.82,
  seed:(Math.random()*1e9)>>>0,
  noteOpen:false, notePos:{x:null,y:null}, noteText:"",
  rest:false
};

function loadState(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(!s || typeof s!=="object") return;
    Object.assign(state, s);
  }catch(_){}
}
function saveState(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(_){ } }
function status(t){ $("statusLine").textContent = t; }

function applyState(){
  document.body.classList.toggle("invert", !!state.invert);
  document.body.classList.toggle("nullmode", !!state.nullMode);
  document.documentElement.style.setProperty("--motion", state.motion ? "1" : "0");

  $("rngSize").value = String(Math.round(state.size*100));
  $("rngSpeed").value = String(Math.round(state.pace*100));
  $("rngTail").value = String(Math.round(state.tail*100));
  $("rngForm").value = String(Math.round(state.form*100));
  $("rngGait").value = String(Math.round(state.gait*100));
  $("rngTrail").value = String(Math.round(state.trail*100));
  $("btnMotion").textContent = state.motion ? "ON" : "OFF";
  $("btnRest").textContent = state.rest ? "WAKE" : "IDLE";

  $("meta").textContent = `INVERT ${state.invert?1:0} · NULL ${state.nullMode?1:0}`;

  $("noteText").value = state.noteText || "";
  $("note").classList.toggle("open", !!state.noteOpen);
  if(state.notePos && state.notePos.x!=null && state.notePos.y!=null){
    $("note").style.left = state.notePos.x + "px";
    $("note").style.top = state.notePos.y + "px";
    $("note").style.right = "auto";
  }

  status(`SIZE ${Math.round(state.size*100)} · PACE ${Math.round(state.pace*100)} · FORM ${Math.round(state.form*100)} · REST ${state.rest?1:0}`);
}

/* canvas */
const canvas = $("c");
const ctx = canvas.getContext("2d", { alpha:true });
let W=0,H=0,DPR=1;

function resize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  W = Math.floor(window.innerWidth * DPR);
  H = Math.floor(window.innerHeight * DPR);
  canvas.width = W;
  canvas.height = H;
}
addEventListener("resize", resize);

/* creature */
const kitty = {
  x: 0.52, y: 0.70,
  vx: 0, vy: 0,
  ang: 0,
  // smooth target trajectory (waypoints)
  wp: [],
  wpT: 0,
  // animation
  blink: 0,
  glide: 0,
  breath: 0
};

function strokeCol(){ return document.body.classList.contains("invert") ? "rgba(10,12,15,.82)" : "rgba(255,255,255,.82)"; }
function hairCol(){   return document.body.classList.contains("invert") ? "rgba(10,12,15,.20)" : "rgba(255,255,255,.20)"; }
function fillCol(){   return document.body.classList.contains("invert") ? "rgba(10,12,15,.06)" : "rgba(255,255,255,.06)"; }
function furCol(){    return document.body.classList.contains("invert") ? "rgba(10,12,15,.05)" : "rgba(255,255,255,.05)"; }

function makeWaypoint(){
  // fewer, calmer moves; bias to mid-lower “ground”
  return {
    x: clamp(0.14 + Math.random()*0.72, 0.08, 0.92),
    y: clamp(0.28 + Math.random()*0.58, 0.14, 0.92),
    hold: 1200 + Math.random()*2200
  };
}

function ensurePath(){
  while(kitty.wp.length < 4) kitty.wp.push(makeWaypoint());
}

function stepPath(t){
  ensurePath();
  if(t > kitty.wpT){
    // advance to next waypoint and set next time
    const w = kitty.wp.shift();
    kitty.wp.push(makeWaypoint());
    kitty.wpT = t + w.hold;
  }
  // current segment uses first two waypoints
  const a = kitty.wp[0];
  const b = kitty.wp[1];
  // smooth param
  const segLen = 2400; // fixed timebase for calm
  const u = clamp(1 - (kitty.wpT - t)/segLen, 0, 1);
  const s = u*u*(3-2*u); // smoothstep
  return { x: lerp(a.x, b.x, s), y: lerp(a.y, b.y, s) };
}

function drawCat(cx,cy,scale,ang,t){
  const stroke = strokeCol();
  const hair = hairCol();
  const fill = fillCol();
  const fur = furCol();

  const speed = Math.hypot(kitty.vx, kitty.vy);
  const gait = state.gait;   // 0..1
  const tail = state.tail;   // 0..1
  const form = state.form;   // 0..1
  const motion = state.motion;

  // slower, weighted cadence; stride amplitude now small and smooth
  const baseF = 0.9 + 1.8*speed*180;              // much slower than before
  const stride = motion ? (t*0.001*baseF) : 0;
  const amp = (0.06 + 0.18*gait) * clamp(speed*280, 0, 1); // softer
  const bob = motion ? Math.sin(stride) * (0.05 + 0.08*gait) * scale * amp : 0;

  // fuller silhouette controls
  const torsoL = (0.96 + 0.18*form) * scale;
  const torsoW = (0.22 + 0.14*form) * scale;      // fuller
  const headS  = (0.34 + 0.10*form) * scale;      // larger head
  const neckUp = (0.10 + 0.10*form) * scale;

  // spine (more “creature” curve)
  const p0 = { x: -0.46*torsoL, y:  0.06*scale + bob*0.20 };
  const p1 = { x: -0.06*torsoL, y: -0.08*scale + bob*0.10 };
  const p2 = { x:  0.44*torsoL, y:  0.03*scale + bob*0.05 };
  const head = { x: p2.x + 0.16*scale, y: p2.y - neckUp };

  // shoulders/hips (wider)
  const hipL  = { x: p0.x + 0.14*scale, y: p0.y + (0.12+0.04*form)*scale };
  const hipR  = { x: p0.x + 0.14*scale, y: p0.y + (0.12+0.04*form)*scale };
  const shL   = { x: p2.x - 0.07*scale, y: p2.y + (0.10+0.04*form)*scale };
  const shR   = { x: p2.x - 0.07*scale, y: p2.y + (0.10+0.04*form)*scale };

  // feet: slower, longer contact, minimal lift
  const groundY = (0.32 + 0.06*form)*scale + bob*0.12;
  const stepLen = (0.18 + 0.18*gait) * scale * clamp(speed*380, 0, 1); // modest

  // phase: slow walk, not frantic
  const ph = stride;
  const phFL = ph + 0.0;
  const phFR = ph + Math.PI;
  const phHL = ph + Math.PI;
  const phHR = ph + 0.0;

  function footX(base, ph){
    const s = Math.sin(ph)*0.9;
    return base + s * stepLen;
  }
  function footY(ph){
    const lift = Math.max(0, Math.sin(ph));
    // tiny lift to keep it grounded and calm
    return groundY - lift * (0.06 + 0.06*gait) * scale * amp;
  }

  const footFL = { x: shL.x + footX( 0.08*scale, phFL), y: footY(phFL) };
  const footFR = { x: shR.x + footX( 0.18*scale, phFR), y: footY(phFR) };
  const footHL = { x: hipL.x + footX(-0.12*scale, phHL), y: footY(phHL) };
  const footHR = { x: hipR.x + footX( 0.04*scale, phHR), y: footY(phHR) };

  // tail: longer + smoother
  const tailBase = { x: p0.x - 0.12*scale, y: p0.y - 0.02*scale };
  const tailLen = (0.96 + 0.70*tail) * scale;
  const tailWave = motion ? Math.sin(t*0.0010 + ph*0.22) : 0;

  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate(ang);
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  function spinePoint(tt){
    const a = (1-tt)*(1-tt);
    const b = 2*(1-tt)*tt;
    const c = tt*tt;
    return { x: a*p0.x + b*p1.x + c*p2.x, y: a*p0.y + b*p1.y + c*p2.y };
  }

  // silhouette polygon around spine, thicker and smoother
  const n = 26;
  const left = [];
  const right = [];
  for(let i=0;i<=n;i++){
    const tt = i/n;
    const sp = spinePoint(tt);
    const sp2 = spinePoint(clamp(tt+0.02,0,1));
    const tx = sp2.x - sp.x, ty = sp2.y - sp.y;
    const mag = Math.hypot(tx,ty) || 1;
    const nx = -ty/mag, ny = tx/mag;

    const swell = 0.90 + 0.52*Math.sin(tt*Math.PI);     // belly fullness
    const w = torsoW * swell;
    left.push({ x: sp.x + nx*w, y: sp.y + ny*w });
    right.push({ x: sp.x - nx*w, y: sp.y - ny*w });
  }

  // body
  ctx.fillStyle = fill;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2*DPR;
  ctx.beginPath();
  ctx.moveTo(left[0].x, left[0].y);
  for(const p of left) ctx.lineTo(p.x,p.y);
  for(let i=right.length-1;i>=0;i--) ctx.lineTo(right[i].x, right[i].y);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // fur micro-lines, sparser
  ctx.strokeStyle = fur;
  ctx.lineWidth = 1*DPR;
  for(let i=0;i<7;i++){
    const tt = (i+1)/8;
    const sp = spinePoint(tt);
    ctx.beginPath();
    ctx.moveTo(sp.x - 0.07*scale, sp.y + 0.03*scale);
    ctx.lineTo(sp.x + 0.05*scale, sp.y - 0.02*scale);
    ctx.stroke();
  }

  // legs: gentler bend, thicker for “real creature”
  function drawLeg(hip, foot, bend){
    const sx = hip.x, sy = hip.y;
    const fx = foot.x, fy = foot.y;

    const mx = lerp(sx, fx, 0.52);
    const my = lerp(sy, fy, 0.52);
    const dx = fx - sx, dy = fy - sy;
    const mag = Math.hypot(dx,dy) || 1;
    const px = -dy/mag, py = dx/mag;

    const kx = mx + px * bend;
    const ky = my + py * bend;

    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2*DPR;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(kx, ky);
    ctx.lineTo(fx, fy);
    ctx.stroke();

    // paw pad line
    ctx.strokeStyle = hair;
    ctx.lineWidth = 2*DPR;
    ctx.beginPath();
    ctx.moveTo(fx - 0.030*scale, fy);
    ctx.lineTo(fx + 0.030*scale, fy);
    ctx.stroke();
  }

  const bendA = (0.08 + 0.12*gait) * scale * (0.20 + amp);
  drawLeg(shL, footFL,  bendA);
  drawLeg(shR, footFR, -bendA*0.85);
  drawLeg(hipL, footHL,  bendA*0.85);
  drawLeg(hipR, footHR, -bendA);

  // head: slightly rounder, more feline
  const hx = head.x, hy = head.y + bob*0.06;
  const hr = headS*0.50;
  const rr = headS*0.22;

  ctx.fillStyle = fill;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2*DPR;
  ctx.beginPath();
  ctx.moveTo(hx-hr+rr, hy-hr);
  ctx.lineTo(hx+hr-rr, hy-hr);
  ctx.quadraticCurveTo(hx+hr, hy-hr, hx+hr, hy-hr+rr);
  ctx.lineTo(hx+hr, hy+hr-rr);
  ctx.quadraticCurveTo(hx+hr, hy+hr, hx+hr-rr, hy+hr);
  ctx.lineTo(hx-hr+rr, hy+hr);
  ctx.quadraticCurveTo(hx-hr, hy+hr, hx-hr, hy+hr-rr);
  ctx.lineTo(hx-hr, hy-hr+rr);
  ctx.quadraticCurveTo(hx-hr, hy-hr, hx-hr+rr, hy-hr);
  ctx.closePath();
  ctx.fill(); ctx.stroke();

  // muzzle contour (more present)
  ctx.strokeStyle = hair;
  ctx.lineWidth = 1*DPR;
  ctx.beginPath();
  ctx.moveTo(hx-0.14*scale, hy+0.05*scale);
  ctx.quadraticCurveTo(hx, hy+0.10*scale, hx+0.14*scale, hy+0.05*scale);
  ctx.stroke();

  // ears: wider base, less “triangle”
  function ear(ex,ey,flip){
    ctx.beginPath();
    ctx.moveTo(ex, ey);
    ctx.lineTo(ex + flip*0.12*scale, ey - 0.22*scale);
    ctx.lineTo(ex + flip*0.03*scale, ey - 0.03*scale);
    ctx.closePath();
    ctx.fill(); ctx.stroke();
  }
  ear(hx-0.12*scale, hy-0.16*scale, -1);
  ear(hx+0.12*scale, hy-0.16*scale,  1);

  // blink: slower, creature-like
  const blink = clamp(kitty.blink, 0, 1);
  const eyeOpen = 1 - blink;
  ctx.strokeStyle = hair;
  ctx.lineWidth = 2*DPR;
  function eye(ex){
    ctx.beginPath();
    if(eyeOpen > 0.12){
      ctx.moveTo(ex - 0.04*scale, hy-0.04*scale);
      ctx.quadraticCurveTo(ex, hy-0.07*scale, ex + 0.04*scale, hy-0.04*scale);
      ctx.quadraticCurveTo(ex, hy-0.01*scale, ex - 0.04*scale, hy-0.04*scale);
    }else{
      ctx.moveTo(ex - 0.045*scale, hy-0.04*scale);
      ctx.lineTo(ex + 0.045*scale, hy-0.04*scale);
    }
    ctx.stroke();
  }
  eye(hx - 0.08*scale);
  eye(hx + 0.08*scale);

  // whiskers: longer, calmer
  ctx.strokeStyle = hair;
  ctx.lineWidth = 1*DPR;
  for(let k=-1;k<=1;k++){
    const yy = hy+0.06*scale + k*0.025*scale;
    ctx.beginPath();
    ctx.moveTo(hx-0.02*scale, yy);
    ctx.lineTo(hx-0.28*scale, yy + Math.sin(t*0.0012 + k)*0.008*scale);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(hx+0.02*scale, yy);
    ctx.lineTo(hx+0.28*scale, yy + Math.cos(t*0.0012 + k)*0.008*scale);
    ctx.stroke();
  }

  // tail spline: very fluid, long, low frequency
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2*DPR;
  ctx.beginPath();
  ctx.moveTo(tailBase.x, tailBase.y);
  const segs = 32;
  for(let i=1;i<=segs;i++){
    const tt = i/segs;
    const xx = tailBase.x - tt*tailLen;
    const yy = tailBase.y
      + Math.sin(tt*2.2*Math.PI + tailWave) * (0.06 + 0.18*tail) * scale * (0.55 + 0.35*amp)
      + Math.sin(t*0.0008 + tt*5.0) * 0.02*scale;
    ctx.lineTo(xx, yy);
  }
  ctx.stroke();

  // subtle chest line (real creature detail)
  ctx.strokeStyle = hair;
  ctx.lineWidth = 1*DPR;
  ctx.beginPath();
  ctx.moveTo(p2.x - 0.02*scale, p2.y + 0.02*scale);
  ctx.lineTo(p2.x + 0.20*scale, p2.y + 0.10*scale);
  ctx.stroke();

  ctx.restore();
}

function step(t){
  const motion = state.motion;

  // smoother trailing (more “fluid”)
  const alpha = motion ? (0.22 - 0.18*state.trail) : 1.0;
  ctx.fillStyle = `rgba(0,0,0,${clamp(alpha, 0.02, 1)})`;
  ctx.fillRect(0,0,W,H);

  // minimal scanline texture
  ctx.strokeStyle = document.body.classList.contains("invert") ? "rgba(10,12,15,.018)" : "rgba(255,255,255,.018)";
  ctx.lineWidth = 1*DPR;
  const grid = 92*DPR;
  const ox = ((t*0.006*DPR) % grid);
  for(let x=ox; x < W; x += grid){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }

  // blink: less frequent, slower close/open
  if(kitty.blink <= 0 && Math.random() < 0.0022) kitty.blink = 1.2;
  kitty.blink = Math.max(0, kitty.blink - 0.045);

  // target path (waypoints)
  const tgt = state.rest ? {x:0.52, y:0.76} : stepPath(t);
  const dx = tgt.x - kitty.x;
  const dy = tgt.y - kitty.y;

  const dist = Math.hypot(dx,dy) + 1e-6;

  // pacing: slow, weighted, responsive
  const pace = state.pace; // 0..1
  const accel = 0.00030 + pace*0.00110 + kitty.glide*0.00110;
  const maxV  = 0.00100 + pace*0.00480 + kitty.glide*0.00600;

  // very gentle wander, not frenetic
  const w = 0.00018 * (0.25 + pace);
  kitty.vx += (dx/dist)*accel + Math.sin(t*0.0009)*w;
  kitty.vy += (dy/dist)*accel + Math.cos(t*0.0007)*w;

  // heavier damping to remove frantic jitter
  kitty.vx *= 0.992;
  kitty.vy *= 0.992;
  kitty.glide *= 0.94;

  // clamp velocity
  const vmag = Math.hypot(kitty.vx, kitty.vy);
  if(vmag > maxV){
    kitty.vx = (kitty.vx/vmag)*maxV;
    kitty.vy = (kitty.vy/vmag)*maxV;
  }

  kitty.x = clamp(kitty.x + kitty.vx, 0.08, 0.92);
  kitty.y = clamp(kitty.y + kitty.vy, 0.14, 0.92);

  // orientation smoothing (slow turning)
  const ang = Math.atan2(kitty.vy, kitty.vx);
  if(isFinite(ang)){
    const da = ((ang - kitty.ang + Math.PI*3)%(Math.PI*2)) - Math.PI;
    kitty.ang += da * 0.045;
  }

  const cx = kitty.x * W;
  const cy = kitty.y * H;

  const base = Math.min(W,H) * 0.22;
  const scale = base * state.size;

  drawCat(cx, cy, scale, kitty.ang, t);

  // frame echo
  ctx.strokeStyle = document.body.classList.contains("invert") ? "rgba(10,12,15,.06)" : "rgba(255,255,255,.06)";
  ctx.lineWidth = 1*DPR;
  ctx.strokeRect(10*DPR, 10*DPR, W-20*DPR, H-20*DPR);

  requestAnimationFrame(step);
}

/* NOTE drag */
(function noteDrag(){
  const el = $("note");
  const bar = el.querySelector(".bar");
  let dragging=false, ox=0, oy=0;

  bar.addEventListener("mousedown",(e)=>{
    dragging=true;
    const r = el.getBoundingClientRect();
    ox = e.clientX - r.left;
    oy = e.clientY - r.top;
    e.preventDefault();
  });
  window.addEventListener("mousemove",(e)=>{
    if(!dragging) return;
    const x = Math.max(10, Math.min(window.innerWidth - 10 - el.offsetWidth, e.clientX - ox));
    const y = Math.max(10, Math.min(window.innerHeight - 10 - el.offsetHeight, e.clientY - oy));
    el.style.left = x + "px";
    el.style.top = y + "px";
    el.style.right = "auto";
    state.notePos = { x, y };
  });
  window.addEventListener("mouseup",()=>{
    if(!dragging) return;
    dragging=false;
    saveState();
  });
})();

/* controls */
function toggleNote(){ state.noteOpen=!state.noteOpen; saveState(); applyState(); }
function toggleInvert(){ state.invert=!state.invert; saveState(); applyState(); }
function toggleNull(){ state.nullMode=!state.nullMode; saveState(); applyState(); }
async function toggleFullscreen(){
  try{
    if(!document.fullscreenElement){ await document.documentElement.requestFullscreen(); state.fullscreen=true; }
    else { await document.exitFullscreen(); state.fullscreen=false; }
  }catch(_){}
  saveState(); applyState();
}
function reseed(){
  state.seed = (Math.random()*1e9)>>>0;
  kitty.wp.length = 0;
  kitty.wpT = 0;
  saveState(); applyState();
}
function glide(){
  kitty.glide = 1.0;
  state.rest = false;
  saveState(); applyState();
}

$("btnNote").addEventListener("click", toggleNote);
$("btnInvert").addEventListener("click", toggleInvert);
$("btnNull").addEventListener("click", toggleNull);
$("btnFull").addEventListener("click", toggleFullscreen);
$("btnSeed").addEventListener("click", reseed);
$("btnMotion").addEventListener("click",()=>{ state.motion=!state.motion; saveState(); applyState(); });
$("btnRest").addEventListener("click",()=>{ state.rest=!state.rest; saveState(); applyState(); });

$("rngSize").addEventListener("input",(e)=>{ state.size = clamp((parseInt(e.target.value,10)||130)/100, 0.70, 1.90); saveState(); applyState(); });
$("rngSpeed").addEventListener("input",(e)=>{ state.pace = clamp((parseInt(e.target.value,10)||22)/100, 0, 1); saveState(); applyState(); });
$("rngTail").addEventListener("input",(e)=>{ state.tail = clamp((parseInt(e.target.value,10)||84)/100, 0, 1); saveState(); applyState(); });
$("rngForm").addEventListener("input",(e)=>{ state.form = clamp((parseInt(e.target.value,10)||72)/100, 0, 1); saveState(); applyState(); });
$("rngGait").addEventListener("input",(e)=>{ state.gait = clamp((parseInt(e.target.value,10)||42)/100, 0, 1); saveState(); applyState(); });
$("rngTrail").addEventListener("input",(e)=>{ state.trail = clamp((parseInt(e.target.value,10)||82)/100, 0, 1); saveState(); applyState(); });

$("noteText").addEventListener("input",(e)=>{ state.noteText = e.target.value || ""; saveState(); });

/* hotkeys */
function isTypingTarget(t){
  if(!t) return false;
  const tag = (t.tagName||"").toLowerCase();
  return tag==="textarea" || tag==="input" || t.isContentEditable;
}
window.addEventListener("keydown",(e)=>{
  const typing = isTypingTarget(e.target);

  if(e.shiftKey && e.key.toLowerCase()==="i"){ e.preventDefault(); toggleInvert(); return; }
  if(e.shiftKey && e.key.toLowerCase()==="n"){ e.preventDefault(); toggleNull(); return; }
  if(e.shiftKey && e.key.toLowerCase()==="f"){ e.preventDefault(); toggleFullscreen(); return; }
  if(e.shiftKey && e.key.toLowerCase()==="k"){ e.preventDefault(); toggleNote(); return; }

  if(e.code==="Space" && !typing){
    e.preventDefault();
    glide();
    return;
  }
}, { passive:false });

/* boot */
loadState();
resize();
applyState();
requestAnimationFrame(step);
</script>

<!--
AE: VISUAL (MONOCHROME FIELD + FULLER FELINE: THICKER SILHOUETTE, ROUNDER HEAD, LONGER TAIL, CALMER STRIDE)
EE: ENGINE (WAYPOINT PATHING FOR SMOOTH ROAM, SLOW TURNING, REST/IDLE MODE, LOCAL-FIRST STATE, HOTKEYS)
WB: WIRING BRIDGE (APPLY STATE TO DOM, CONTROLS)

FILE_ID: "KETADATA_KITTY_CAT_FLUID_MONO_V2"
ROOM_ID: "K_KITTY_CAT"
VERSION: "V2"
UPDATED_AT: "2026-01-06T00:00:00.000-05:00"
CHANGELOG:
- V2: Fuller, slower creature motion (waypoints + heavy damping), thicker body form control, calmer gait and blink, longer fluid tail, added REST toggle.
-->
</body>
</html>
