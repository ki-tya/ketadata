<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA MASTERDOC (TXT INGEST + CLUSTERS)</title>
<style>
  :root {
    --bg:#0b0b0b; --fg:#f2f2f2;
    --muted:rgba(242,242,242,.62);
    --hair:rgba(242,242,242,.18);
    --hair2:rgba(242,242,242,.08);
    --panel:rgba(0,0,0,.55);
    --panel2:rgba(0,0,0,.30);
    --font:12px;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:Arial,Helvetica,sans-serif;font-size:var(--font);overflow:hidden;}
  *{box-sizing:border-box;}
  a{color:var(--fg);text-decoration:none;}
  a:hover{text-decoration:underline;}
  button,input,textarea,select{font:inherit;color:var(--fg);background:transparent;border:1px solid var(--hair);padding:6px 8px;outline:none;}
  button{cursor:pointer;}
  button:hover{background:var(--hair2);}
  textarea{width:100%;background:transparent;border:1px solid var(--hair);resize:none;padding:10px;line-height:1.35;}
  .stage{position:relative;width:100%;height:100%;user-select:none;}
  .bg{position:absolute;inset:0;pointer-events:none;background:
      linear-gradient(0deg, transparent 0 96%, rgba(242,242,242,.05) 96% 97%, transparent 97% 100%),
      linear-gradient(90deg, transparent 0 96%, rgba(242,242,242,.05) 96% 97%, transparent 97% 100%);
    background-size:120px 120px;opacity:.30;animation:drift 28s linear infinite;}
  @keyframes drift{from{background-position:0 0,0 0;}to{background-position:360px 240px,240px 360px;}}
  .topbar{position:absolute;left:0;top:0;right:0;height:36px;display:flex;align-items:center;gap:8px;padding:0 8px;background:rgba(0,0,0,.75);border-bottom:1px solid var(--hair);z-index:200;}
  .topbar .title{opacity:.9;letter-spacing:.3px;}
  .spacer{flex:1;}
  .pill{border:1px solid var(--hair);padding:4px 8px;opacity:.9;}
  .kbd{border:1px solid var(--hair);padding:1px 5px;opacity:.8;}
  .hud{position:absolute;right:8px;top:44px;display:flex;flex-direction:column;gap:8px;z-index:190;}
  .hud .box{width:320px;background:var(--panel);border:1px solid var(--hair);padding:8px;}
  .row{display:flex;gap:8px;align-items:center;}
  .row>*{flex:1;}
  .row .tight{flex:0;white-space:nowrap;}
  .muted{color:var(--muted);}
  .small{font-size:var(--font);}
  .drop{border:1px dashed var(--hair);padding:10px;background:rgba(0,0,0,.20);}
  .mod{position:absolute;min-width:320px;background:var(--panel);border:1px solid var(--hair);box-shadow:0 10px 30px rgba(0,0,0,.35);}
  .mod .hdr{display:flex;align-items:center;gap:8px;padding:6px 8px;border-bottom:1px solid var(--hair);background:rgba(0,0,0,.35);cursor:grab;}
  .mod .hdr:active{cursor:grabbing;}
  .mod .hdr .name{flex:1;opacity:.92;}
  .mod .hdr .btn{padding:2px 6px;border:1px solid var(--hair);background:transparent;}
  .mod .body{padding:8px;max-height:70vh;overflow:auto;user-select:text;}
  .list{border:1px solid var(--hair);background:rgba(0,0,0,.20);max-height:46vh;overflow:auto;}
  .item{display:flex;align-items:center;gap:8px;padding:6px 8px;border-bottom:1px solid var(--hair2);}
  .item:last-child{border-bottom:0;}
  .item .t{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
  .item .act{flex:0;display:flex;gap:6px;align-items:center;}
  .badge{border:1px solid var(--hair);padding:2px 6px;opacity:.75;}
  body.null .topbar, body.null .hud{display:none;}
  body.null .bg{opacity:.18;}
  body.invert{--bg:#f2f2f2;--fg:#0b0b0b;--muted:rgba(0,0,0,.62);--hair:rgba(0,0,0,.20);--hair2:rgba(0,0,0,.08);--panel:rgba(242,242,242,.78);--panel2:rgba(242,242,242,.45);}
  @media print{
    html,body{overflow:visible;}
    .topbar,.hud{display:none !important;}
    .bg{display:none !important;}
    .mod{position:static !important;page-break-inside:avoid;margin:0 0 10px 0;box-shadow:none !important;}
    body{-webkit-print-color-adjust:exact;print-color-adjust:exact;background:var(--bg) !important;}
  }
</style>
</head>
<body>
<div class="stage" id="stage">
  <div class="bg"></div>

  <div class="topbar">
    <div class="title">KETADATA MASTERDOC / TXT INGEST + CLUSTERS</div>
    <div class="pill muted" id="repoPill">repo: n/a</div>
    <div class="spacer"></div>
    <div class="pill muted">HOTKEYS: <span class="kbd">SHIFT</span>+<span class="kbd">I</span> invert · <span class="kbd">SHIFT</span>+<span class="kbd">N</span> NULL · <span class="kbd">SHIFT</span>+<span class="kbd">F</span> fullscreen</div>
  </div>

  <div class="hud">
    <div class="box">
      <div class="drop" id="dropZone">
        <div class="muted" style="margin-bottom:6px;">PASTE TEXT / DROP TXT</div>
        <div class="muted small">Paste directly into the box below, or drop/import a .txt. If it’s JSON-in-txt it will load as manifest; otherwise it extracts URLs and builds a manifest you can EXPORT.</div>
      </div>

      <div style="height:8px"></div>
      <textarea id="pasteArea" style="height:120px" placeholder="PASTE HERE (TEXT OR JSON)."></textarea>
      <div style="height:8px"></div>
      <div class="row">
        <button id="ingestPaste">INGEST PASTE</button>
        <button id="clearPaste">CLEAR PASTE</button>
      </div>

      <div style="height:8px"></div>
      <div class="row">
        <button id="importTxt">IMPORT TXT</button>
        <button id="exportManifest">EXPORT MANIFEST JSON</button>
      </div>

      <div style="height:8px"></div>
      <div class="row">
        <button id="exportState">EXPORT STATE JSON</button>
        <button id="exportPdf">EXPORT PDF</button>
      </div>

      <div style="height:8px"></div>
      <div class="row">
        <div class="tight muted">SEARCH</div>
        <input id="search" type="text" placeholder="PATH / NOTE / TAGS"/>
      </div>

      <div style="height:8px"></div>
      <div class="row">
        <div class="tight muted">CLUSTER</div>
        <select id="clusterFilter"></select>
      </div>

      <div style="height:8px"></div>
      <div class="row">
        <input id="newClusterName" type="text" placeholder="NEW CLUSTER NAME"/>
        <button id="addCluster">ADD</button>
      </div>

      <div style="height:8px"></div>
      <div class="row">
        <label class="tight"><input id="onlyActive" type="checkbox" checked/> only active</label>
        <label class="tight"><input id="hideMissing" type="checkbox" checked/> hide missing</label>
      </div>

      <div style="height:8px"></div>
      <div class="row">
        <div class="tight muted">TEXT</div>
        <input id="fontSize" type="range" min="10" max="16" value="12"/>
        <div class="tight muted" id="fontLabel">12</div>
      </div>

      <div style="height:8px"></div>
      <div class="row">
        <button id="reflow">REFLOW CLUSTERS</button>
        <button id="resetLayout">RESET</button>
      </div>

      <div style="height:6px"></div>
      <div class="muted small" id="counts">no manifest loaded</div>
    </div>
  </div>

  <div class="mod" id="modDoc" style="left:10px; top:46px; width:560px; z-index:150;">
    <div class="hdr" data-drag="1">
      <div class="name">MASTERDOC</div>
      <button class="btn" data-action="collapse">–</button>
    </div>
    <div class="body">
      <textarea id="masterdoc" style="height:60vh" placeholder="WRITE HERE."></textarea>
      <div style="height:8px"></div>
      <div class="row">
        <input id="docTitle" type="text" placeholder="EXPORT LABEL (OPTIONAL)"/>
        <button id="saveDoc">SAVE</button>
      </div>
      <div style="height:6px"></div>
      <div class="muted small">Clusters are draggable modules. Assign links to clusters via the dropdown on each link row.</div>
    </div>
  </div>

  <div id="clusterLayer"></div>

  <div style="position:absolute; left:8px; bottom:8px; right:8px; opacity:.65; z-index:1;">
    <div style="border-top:1px solid var(--hair); padding-top:6px;">
      AE/EE/WB · FILE_ID: "KETADATA_MASTERDOC_CLUSTERS" · ROOM_ID: "BASE" · VERSION_ID: "V1" · UPDATED_AT: "2026-01-03T23:22:08Z" · CHANGELOG: "paste ingest; txt ingest; url-extract; spatial cluster modules; cluster assignment; export manifest/state; focus-safe hotkeys; pdf export"
    </div>
  </div>
</div>

<script>
const FILE_ID = "KETADATA_MASTERDOC_CLUSTERS__V1";
const LS_KEY = "KD_STATE__" + FILE_ID;

const DEFAULT_STATE = {
  fileId: FILE_ID,
  updatedAt: new Date().toISOString(),
  ui: {
    invert:false, nullMode:false, fontSize:12,
    search:"", clusterFilter:"ALL",
    onlyActive:true, hideMissing:true
  },
  manifest: null,
  sourceText: "",
  doc: { title:"", text:"" },
  clusters: {},
  linkCluster: {},
  layout: {
    modDoc: {x:10,y:46,w:560,collapsed:false},
  }
};

function safeParse(s){ try{ return JSON.parse(s); }catch{ return null; } }
function deepFill(base,incoming){
  if(incoming===null||incoming===undefined) return base;
  if(typeof base!=="object"||base===null) return incoming;
  if(Array.isArray(base)) return Array.isArray(incoming)?incoming:base;
  const out={...base};
  for(const k of Object.keys(incoming)) out[k]=(k in base)?deepFill(base[k],incoming[k]):incoming[k];
  return out;
}
function loadState(){ const raw=localStorage.getItem(LS_KEY); const p=raw?safeParse(raw):null; return p?deepFill(structuredClone(DEFAULT_STATE),p):structuredClone(DEFAULT_STATE); }
let state = loadState();
function saveState(){ state.updatedAt=new Date().toISOString(); localStorage.setItem(LS_KEY, JSON.stringify(state)); updateCounts(); }

function isTypingTarget(el){
  if(!el) return false;
  const tag=(el.tagName||"").toLowerCase();
  if(tag==="input"||tag==="textarea"||tag==="select") return true;
  if(el.isContentEditable) return true;
  return false;
}

const stage=document.getElementById("stage");
const clusterLayer=document.getElementById("clusterLayer");
const repoPill=document.getElementById("repoPill");

const pasteArea=document.getElementById("pasteArea");
const ingestPasteBtn=document.getElementById("ingestPaste");
const clearPasteBtn=document.getElementById("clearPaste");
const dropZone=document.getElementById("dropZone");
const importTxtBtn=document.getElementById("importTxt");

const exportManifestBtn=document.getElementById("exportManifest");
const exportStateBtn=document.getElementById("exportState");
const exportPdfBtn=document.getElementById("exportPdf");

const search=document.getElementById("search");
const clusterFilter=document.getElementById("clusterFilter");
const newClusterName=document.getElementById("newClusterName");
const addClusterBtn=document.getElementById("addCluster");
const onlyActive=document.getElementById("onlyActive");
const hideMissing=document.getElementById("hideMissing");
const fontSize=document.getElementById("fontSize");
const fontLabel=document.getElementById("fontLabel");
const reflowBtn=document.getElementById("reflow");
const resetLayoutBtn=document.getElementById("resetLayout");
const counts=document.getElementById("counts");

const masterdoc=document.getElementById("masterdoc");
const docTitle=document.getElementById("docTitle");
const saveDocBtn=document.getElementById("saveDoc");

function extractUrls(text){
  const re = /https?:\/\/[^\s"'<>()]+/g;
  const found = text.match(re) || [];
  const seen=new Set();
  const out=[];
  for(const u of found){
    const clean=u.replace(/[\]\),.]+$/g,"");
    if(!seen.has(clean)){ seen.add(clean); out.push(clean); }
  }
  return out;
}

function buildManifestFromUrls(urls){
  const pagesBase = "https://ki-tya.github.io/ketadata/";
  const lanes=[
    {id:"L0",name:"INBOX",deprecated:false},
    {id:"L3",name:"DEPRECATED",deprecated:true}
  ];
  const links={};
  for(const url of urls){
    const path = url.startsWith(pagesBase) ? url.slice(pagesBase.length) : url;
    links[path] = {
      path: path,
      url: url,
      laneId: "L0",
      tags: "",
      version: "",
      status: "active",
      note: "",
      missing: false
    };
  }
  return {
    version: "KETADATA_TXT_URL_EXTRACT_v1",
    updatedAt: new Date().toISOString(),
    exportLabel: "",
    exportTag: "",
    ketaNote: "",
    repo: { owner:"ki-tya", repo:"ketadata", branch:"main", pagesBase },
    ui: { laneId:"L0", filterStatus:"active", filterTag:"", filterSearch:"" },
    lanes,
    links
  };
}

function normalizeManifest(m){
  if(!m||typeof m!=="object") return null;
  if(m.lanes && m.links && m.repo) return m;
  if(Array.isArray(m.urls)) return buildManifestFromUrls(m.urls);
  return null;
}

function ingestText(text){
  state.sourceText = text || "";
  const parsed = safeParse(text);
  if(parsed){
    const man = normalizeManifest(parsed);
    if(man){ state.manifest = man; ensureDefaultCluster(); ensureClusterPositions(); saveState(); render(); return true; }
  }
  const urls = extractUrls(text);
  if(urls.length){
    state.manifest = buildManifestFromUrls(urls);
    ensureDefaultCluster();
    ensureClusterPositions();
    saveState(); render(); return true;
  }
  return false;
}

/* ===== CLUSTERS ===== */
function ensureDefaultCluster(){
  if(!state.clusters || typeof state.clusters!=="object") state.clusters={};
  if(!state.clusters["C0"]){
    state.clusters["C0"] = {id:"C0", name:"UNCLUSTERED", collapsed:false, x:590, y:46, w:520};
  }
}

function addCluster(name){
  const n = (name||"").trim();
  if(!n) return null;
  const id = "C" + Math.random().toString(16).slice(2,8).toUpperCase();
  state.clusters[id] = {id, name:n, collapsed:false, x:null, y:null, w:520};
  saveState();
  ensureClusterPositions();
  render();
  return id;
}

function ensureClusterPositions(){
  const ids = Object.keys(state.clusters||{}).filter(x=>x!=="C0");
  const baseX = 640, baseY = 120;
  for(let i=0;i<ids.length;i++){
    const id=ids[i];
    const c=state.clusters[id];
    if(typeof c.x==="number" && typeof c.y==="number") continue;
    const a = i*0.9;
    const r = 120 + i*55;
    c.x = Math.max(8, baseX + Math.cos(a)*r);
    c.y = Math.max(44, baseY + Math.sin(a)*r);
    c.w = c.w || 520;
  }
  const c0 = state.clusters["C0"];
  if(c0){
    c0.x = (typeof c0.x==="number")?c0.x:590;
    c0.y = (typeof c0.y==="number")?c0.y:46;
    c0.w = c0.w || 520;
  }
  saveState();
}

function linkKey(rec){ return rec.path || rec.url; }
function assignLinkToCluster(rec, clusterId){
  const k = linkKey(rec);
  state.linkCluster[k] = clusterId;
  saveState();
  render();
}
function clusterOf(rec){
  const k = linkKey(rec);
  return state.linkCluster[k] || "C0";
}

/* ===== RENDER ===== */
function manifestLinks(man){
  if(!man || !man.links) return [];
  return Object.values(man.links).filter(r=>r && r.url);
}
function matchesSearch(rec,q){
  if(!q) return true;
  const s=q.trim().toLowerCase();
  if(!s) return true;
  const hay = `${(rec.path||"")} ${(rec.note||"")} ${(rec.tags||"")} ${(rec.laneId||"")} ${(rec.status||"")}`.toLowerCase();
  return hay.includes(s);
}
function passesToggles(rec){
  if(state.ui.onlyActive && String(rec.status||"").toLowerCase()!=="active") return false;
  if(state.ui.hideMissing && rec.missing===true) return false;
  return true;
}
function applyUI(){
  document.body.classList.toggle("invert", !!state.ui.invert);
  document.body.classList.toggle("null", !!state.ui.nullMode);
  document.documentElement.style.setProperty("--font", (state.ui.fontSize||12) + "px");
  fontSize.value = String(state.ui.fontSize||12);
  fontLabel.textContent = String(state.ui.fontSize||12);
  search.value = state.ui.search || "";
  onlyActive.checked = !!state.ui.onlyActive;
  hideMissing.checked = !!state.ui.hideMissing;
  masterdoc.value = state.doc.text || "";
  docTitle.value = state.doc.title || "";
  const repoBase = state.manifest?.repo?.pagesBase || "";
  repoPill.textContent = repoBase ? repoBase.replace(/^https?:\/\//,"") : "repo: n/a";
}
function rebuildClusterFilter(){
  clusterFilter.innerHTML="";
  const optAll=document.createElement("option");
  optAll.value="ALL"; optAll.textContent="ALL CLUSTERS";
  clusterFilter.appendChild(optAll);
  for(const id of Object.keys(state.clusters||{})){
    const opt=document.createElement("option");
    opt.value=id;
    opt.textContent=state.clusters[id].name || id;
    clusterFilter.appendChild(opt);
  }
  clusterFilter.value = state.ui.clusterFilter || "ALL";
}

let zTop=300;
function bringToFront(el){ zTop++; el.style.zIndex=String(zTop); }

function renderClusters(){
  clusterLayer.innerHTML="";
  if(!state.manifest) return;

  const all = manifestLinks(state.manifest);
  const filtered = all.filter(rec => passesToggles(rec) && matchesSearch(rec, state.ui.search));

  const by={};
  for(const rec of filtered){
    const cid = clusterOf(rec);
    by[cid] = by[cid] || [];
    by[cid].push(rec);
  }
  for(const cid of Object.keys(by)){
    by[cid].sort((a,b)=>String(a.note||"").localeCompare(String(b.note||"")) || String(a.path||"").localeCompare(String(b.path||"")));
  }

  for(const cid of Object.keys(state.clusters||{})){
    if(state.ui.clusterFilter!=="ALL" && state.ui.clusterFilter!==cid) continue;
    const c = state.clusters[cid];
    const items = by[cid] || [];
    if(state.ui.clusterFilter==="ALL" && items.length===0 && cid!=="C0") continue;

    const mod=document.createElement("div");
    mod.className="mod";
    mod.id="cluster_"+cid;
    mod.style.left=(c.x||80)+"px";
    mod.style.top=(c.y||80)+"px";
    mod.style.width=(c.w||520)+"px";
    mod.style.zIndex="120";

    const hdr=document.createElement("div");
    hdr.className="hdr";

    const name=document.createElement("div");
    name.className="name";
    name.textContent=c.name||cid;

    const meta=document.createElement("div");
    meta.className="badge";
    meta.textContent=items.length+" links";

    const collapse=document.createElement("button");
    collapse.className="btn";
    collapse.textContent=c.collapsed?"+":"–";
    collapse.addEventListener("click",(e)=>{
      e.stopPropagation();
      c.collapsed=!c.collapsed;
      saveState();
      render();
    });

    hdr.appendChild(name);
    hdr.appendChild(meta);
    hdr.appendChild(collapse);

    const body=document.createElement("div");
    body.className="body";
    body.style.display=c.collapsed?"none":"block";

    const list=document.createElement("div");
    list.className="list";

    for(const rec of items){
      const row=document.createElement("div");
      row.className="item";

      const left=document.createElement("div");
      left.className="t";
      left.title=rec.url;
      const label=(rec.note&&rec.note.trim()) ? `${rec.note.trim()} · ${(rec.path||rec.url)}` : (rec.path||rec.url);
      const a=document.createElement("a");
      a.href=rec.url; a.target="_blank"; a.rel="noopener"; a.textContent=label;
      left.appendChild(a);

      const act=document.createElement("div");
      act.className="act";

      const sel=document.createElement("select");
      sel.style.padding="4px 6px";
      for(const id of Object.keys(state.clusters||{})){
        const opt=document.createElement("option");
        opt.value=id;
        opt.textContent=state.clusters[id].name || id;
        sel.appendChild(opt);
      }
      sel.value=clusterOf(rec);
      sel.addEventListener("change",()=>assignLinkToCluster(rec, sel.value));

      const copyBtn=document.createElement("button");
      copyBtn.textContent="COPY";
      copyBtn.addEventListener("click", async (e)=>{
        e.stopPropagation();
        try{ await navigator.clipboard.writeText(rec.url); copyBtn.textContent="OK"; setTimeout(()=>copyBtn.textContent="COPY",600); }
        catch{ copyBtn.textContent="NO"; setTimeout(()=>copyBtn.textContent="COPY",600); }
      });

      act.appendChild(sel);
      act.appendChild(copyBtn);

      row.appendChild(left);
      row.appendChild(act);
      list.appendChild(row);
    }

    body.appendChild(list);
    mod.appendChild(hdr);
    mod.appendChild(body);
    clusterLayer.appendChild(mod);

    enableDraggingForCluster(mod, cid);
  }
}

function enableDraggingForCluster(mod, cid){
  const hdr=mod.querySelector(".hdr");
  let dragging=false, startX=0,startY=0,baseX=0,baseY=0;

  hdr.addEventListener("pointerdown",(e)=>{
    if(e.target.tagName.toLowerCase()==="button" || e.target.tagName.toLowerCase()==="select") return;
    dragging=true;
    hdr.setPointerCapture(e.pointerId);
    startX=e.clientX; startY=e.clientY;
    const c=state.clusters[cid];
    baseX=c.x||0; baseY=c.y||0;
    bringToFront(mod);
    e.preventDefault(); e.stopPropagation();
  });
  hdr.addEventListener("pointermove",(e)=>{
    if(!dragging) return;
    const dx=e.clientX-startX, dy=e.clientY-startY;
    const c=state.clusters[cid];
    c.x=Math.max(0, baseX+dx);
    c.y=Math.max(36, baseY+dy);
    mod.style.left=c.x+"px";
    mod.style.top=c.y+"px";
    e.preventDefault();
  });
  hdr.addEventListener("pointerup",(e)=>{
    if(!dragging) return;
    dragging=false;
    try{ hdr.releasePointerCapture(e.pointerId); }catch{}
    saveState();
  });
}

/* ===== MASTERDOC MODULE DRAG ===== */
function enableDragging(modId){
  const el=document.getElementById(modId);
  const hdr=el.querySelector(".hdr");
  let dragging=false, startX=0,startY=0,baseX=0,baseY=0;
  hdr.addEventListener("pointerdown",(e)=>{
    const action=e.target?.getAttribute?.("data-action");
    if(action) return;
    if(e.target.tagName.toLowerCase()==="button") return;
    dragging=true;
    hdr.setPointerCapture(e.pointerId);
    startX=e.clientX; startY=e.clientY;
    const L=state.layout[modId];
    baseX=L.x; baseY=L.y;
    bringToFront(el);
    e.preventDefault(); e.stopPropagation();
  });
  hdr.addEventListener("pointermove",(e)=>{
    if(!dragging) return;
    const dx=e.clientX-startX, dy=e.clientY-startY;
    const L=state.layout[modId];
    L.x=Math.max(0, baseX+dx);
    L.y=Math.max(36, baseY+dy);
    el.style.left=L.x+"px";
    el.style.top=L.y+"px";
    e.preventDefault();
  });
  hdr.addEventListener("pointerup",(e)=>{
    if(!dragging) return;
    dragging=false;
    try{ hdr.releasePointerCapture(e.pointerId); }catch{}
    saveState();
  });
  el.querySelectorAll("[data-action='collapse']").forEach(btn=>{
    btn.addEventListener("click",(e)=>{
      e.stopPropagation();
      state.layout[modId].collapsed=!state.layout[modId].collapsed;
      el.querySelector(".body").style.display = state.layout[modId].collapsed ? "none" : "block";
      saveState();
    });
  });
}

/* ===== EXPORT ===== */
function download(filename,text,mime){
  const blob=new Blob([text],{type:mime||"application/octet-stream"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url; a.download=filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },0);
}

/* ===== EVENTS ===== */
ingestPasteBtn.addEventListener("click",()=>{
  const ok=ingestText(pasteArea.value||"");
  if(!ok) alert("Ingest failed: paste JSON manifest or any text containing URLs.");
});
clearPasteBtn.addEventListener("click",()=>{ pasteArea.value=""; });

importTxtBtn.addEventListener("click",()=>{
  const inp=document.createElement("input");
  inp.type="file";
  inp.accept=".txt,.json,text/plain,application/json";
  inp.onchange=async ()=>{
    const file=inp.files?.[0]; if(!file) return;
    const text=await file.text();
    const ok=ingestText(text);
    if(!ok) alert("Import failed: not JSON and no URLs found.");
  };
  inp.click();
});

dropZone.addEventListener("dragover",(e)=>{ e.preventDefault(); dropZone.style.background="rgba(0,0,0,.32)"; });
dropZone.addEventListener("dragleave",()=>{ dropZone.style.background="rgba(0,0,0,.20)"; });
dropZone.addEventListener("drop",async (e)=>{
  e.preventDefault();
  dropZone.style.background="rgba(0,0,0,.20)";
  const file=e.dataTransfer.files?.[0];
  if(!file) return;
  const text=await file.text();
  const ok=ingestText(text);
  if(!ok) alert("Import failed: not JSON and no URLs found.");
});

exportManifestBtn.addEventListener("click",()=>{
  if(!state.manifest) return;
  const label=(state.doc.title||"manifest").replace(/[^a-z0-9_-]+/gi,"_");
  download(`KD_MANIFEST_${label}.json`, JSON.stringify(state.manifest,null,2), "application/json");
});

exportStateBtn.addEventListener("click",()=>{
  const label=(state.doc.title||"state").replace(/[^a-z0-9_-]+/gi,"_");
  download(`KD_STATE_${label}.json`, JSON.stringify(state,null,2), "application/json");
});

exportPdfBtn.addEventListener("click",()=>{ state.doc.text=masterdoc.value||""; saveState(); window.print(); });

search.addEventListener("input",()=>{ state.ui.search=search.value; saveState(); render(); });
clusterFilter.addEventListener("change",()=>{ state.ui.clusterFilter=clusterFilter.value; saveState(); render(); });
onlyActive.addEventListener("change",()=>{ state.ui.onlyActive=onlyActive.checked; saveState(); render(); });
hideMissing.addEventListener("change",()=>{ state.ui.hideMissing=hideMissing.checked; saveState(); render(); });
fontSize.addEventListener("input",()=>{ state.ui.fontSize=Number(fontSize.value); saveState(); applyUI(); renderClusters(); });

addClusterBtn.addEventListener("click",()=>{
  const id=addCluster(newClusterName.value);
  if(id) newClusterName.value="";
});

reflowBtn.addEventListener("click",()=>{
  const ids=Object.keys(state.clusters||{}).filter(x=>x!=="C0");
  const baseX = 640, baseY = 120;
  for(let i=0;i<ids.length;i++){
    const id=ids[i];
    const c=state.clusters[id];
    const a=i*0.9;
    const r=120+i*55;
    c.x=Math.max(8, baseX + Math.cos(a)*r);
    c.y=Math.max(44, baseY + Math.sin(a)*r);
    c.w=c.w||520;
  }
  saveState(); render();
});

resetLayoutBtn.addEventListener("click",()=>{
  const keep={ ui:state.ui, manifest:state.manifest, sourceText:state.sourceText, doc:state.doc, clusters:state.clusters, linkCluster:state.linkCluster };
  state=structuredClone(DEFAULT_STATE);
  state.ui=keep.ui; state.manifest=keep.manifest; state.sourceText=keep.sourceText; state.doc=keep.doc;
  state.clusters=keep.clusters; state.linkCluster=keep.linkCluster;
  ensureDefaultCluster(); ensureClusterPositions();
  saveState(); render();
});

saveDocBtn.addEventListener("click",()=>{
  state.doc.title = docTitle.value || "";
  state.doc.text = masterdoc.value || "";
  saveState();
  saveDocBtn.textContent="SAVED";
  setTimeout(()=>saveDocBtn.textContent="SAVE",600);
});
masterdoc.addEventListener("input",()=>{ state.doc.text = masterdoc.value || ""; saveState(); });
docTitle.addEventListener("input",()=>{ state.doc.title = docTitle.value || ""; saveState(); });

/* ===== HOTKEYS (focus-safe) ===== */
window.addEventListener("keydown",(e)=>{
  if(isTypingTarget(document.activeElement)) return;
  if(!e.shiftKey) return;
  const k=(e.key||"").toLowerCase();
  if(k==="i"){ state.ui.invert=!state.ui.invert; saveState(); render(); e.preventDefault(); }
  else if(k==="n"){ state.ui.nullMode=!state.ui.nullMode; saveState(); render(); e.preventDefault(); }
  else if(k==="f"){ if(!document.fullscreenElement) document.documentElement.requestFullscreen?.(); else document.exitFullscreen?.(); e.preventDefault(); }
});

function updateCounts(){
  if(!state.manifest){ counts.textContent="no manifest loaded"; return; }
  const all = manifestLinks(state.manifest);
  const filtered = all.filter(rec => passesToggles(rec) && matchesSearch(rec, state.ui.search));
  counts.textContent = `links: ${filtered.length} / ${all.length} · clusters: ${Object.keys(state.clusters||{}).length} · last save: ${(state.updatedAt||"").replace("T"," ").replace("Z","")}`;
}

function render(){
  ensureDefaultCluster();
  applyUI();
  rebuildClusterFilter();
  renderClusters();
  updateCounts();
}

/* ===== BOOT ===== */
enableDragging("modDoc");
(function applyDocLayout(){
  const L=state.layout.modDoc;
  const el=document.getElementById("modDoc");
  el.style.left=(L.x??10)+"px";
  el.style.top=(L.y??46)+"px";
  el.style.width=(L.w??560)+"px";
  el.querySelector(".body").style.display = L.collapsed ? "none" : "block";
})();

ensureDefaultCluster();
ensureClusterPositions();
applyUI();
render();
saveState();
</script>
</body>
</html>
