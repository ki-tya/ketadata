<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KETADATA // PDF → JPEG (ROBUST)</title>
  <style>
    :root{
      --bg:#fff; --fg:#000;
      --muted:rgba(0,0,0,.58);
      --line:rgba(0,0,0,.14);
      --line2:rgba(0,0,0,.08);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: Arial, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, sans-serif;
      --r:10px;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:var(--sans)}
    header{
      position:sticky;top:0;z-index:10;
      background:rgba(255,255,255,.92);backdrop-filter:blur(8px);
      border-bottom:1px solid var(--line);
      padding:14px 16px;display:flex;align-items:center;justify-content:space-between;gap:12px;
    }
    .brand{user-select:none}
    .brand .k{font-weight:700;font-size:14px;letter-spacing:1.4px}
    .brand .s{font-family:var(--mono);font-size:12px;color:var(--muted)}
    .actions{display:flex;gap:10px;align-items:center}
    .btn{
      appearance:none;border:1px solid var(--fg);background:transparent;color:var(--fg);
      padding:9px 10px;border-radius:999px;font-size:12px;font-family:var(--mono);
      cursor:pointer;transition:.12s;user-select:none;
    }
    .btn:hover{background:var(--fg);color:var(--bg)}
    .btn.secondary{border-color:var(--line)}
    .btn.secondary:hover{background:rgba(0,0,0,.06);color:var(--fg);border-color:rgba(0,0,0,.22)}
    main{display:grid;grid-template-columns:1fr 360px;min-height:calc(100vh - 56px)}
    @media (max-width:980px){ main{grid-template-columns:1fr} }
    .work{padding:16px;border-right:1px solid var(--line);display:flex;flex-direction:column;gap:12px;min-width:0}
    @media (max-width:980px){ .work{border-right:none;border-bottom:1px solid var(--line)} }
    .rail{padding:16px;display:flex;flex-direction:column;gap:12px}
    details.keta{border:1px solid var(--line);border-radius:var(--r);overflow:hidden;background:#fff}
    details.keta>summary{
      list-style:none;cursor:pointer;user-select:none;
      padding:12px;border-bottom:1px solid var(--line2);
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      font-family:var(--mono);font-size:12px;letter-spacing:.7px;text-transform:uppercase;
    }
    details.keta>summary::-webkit-details-marker{display:none}
    .content{padding:12px}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:720px){ .grid2{grid-template-columns:1fr} }
    label{display:flex;flex-direction:column;gap:6px;font-family:var(--mono);font-size:12px;color:var(--muted)}
    input[type="file"], select, input[type="number"]{
      width:100%;border:1px solid var(--line);border-radius:8px;padding:10px;
      background:#fff;color:#000;font-family:var(--mono);font-size:12px
    }
    input[type="range"]{width:100%}
    .inline{display:flex;gap:10px;align-items:center;flex-wrap:wrap;font-family:var(--mono);font-size:12px;color:var(--muted)}
    .pill{border:1px solid var(--line);border-radius:999px;padding:6px 10px;background:#fff;color:#000}
    .pill strong{color:#000}
    .small{font-family:var(--mono);font-size:11px;color:var(--muted);line-height:1.35}
    .stage{border:1px solid var(--line);border-radius:var(--r);padding:12px;min-height:360px;display:grid;place-items:center}
    canvas{max-width:100%;height:auto;display:block;background:#fff}
    .progress{
      width:220px;height:10px;border:1px solid var(--line);border-radius:999px;overflow:hidden;background:#fff
    }
    .progress>div{height:100%;width:0%;background:#000;transition:width .12s}
    textarea{
      width:100%;min-height:160px;resize:vertical;
      border:1px solid var(--line);border-radius:8px;padding:10px;
      font-family:var(--mono);font-size:12px;line-height:1.35
    }
    .kbd{font-family:var(--mono);border:1px solid var(--line);border-bottom-width:2px;border-radius:6px;padding:2px 6px;background:#fff;color:#000;font-size:11px}
    .thumbRow{
      border:1px solid var(--line);border-radius:var(--r);padding:10px;display:none;
      gap:10px;overflow:auto;align-items:center;background:#fff
    }
    .thumb{width:56px;height:56px;border:1px solid var(--line);border-radius:10px;overflow:hidden;flex:0 0 auto;display:grid;place-items:center;cursor:pointer}
    .thumb.selected{outline:2px solid #000;outline-offset:2px}
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="k">KETADATA</div>
      <div class="s">PDF → JPEG CONVERTER // ROBUST (100–200 PAGES / 100MB+)</div>
    </div>
    <div class="actions">
      <button class="btn secondary" id="btnClear">CLEAR</button>
      <button class="btn" id="btnConvert">CONVERT → ZIP</button>
    </div>
  </header>

  <main>
    <section class="work">
      <details class="keta" open>
        <summary><span>INPUT</span><span class="small">PDF in, ZIP out — no upload</span></summary>
        <div class="content">
          <div class="grid2">
            <label>
              PDF FILE(S)
              <input id="pdfInput" type="file" accept="application/pdf" multiple />
              <div class="small">
                Runs locally in your browser. If worker loading is blocked on your domain, this auto-falls back to no-worker mode.
              </div>
            </label>

            <div>
              <div class="inline">
                <span class="pill"><strong id="countPDF">0</strong> PDF</span>
                <span class="pill"><strong id="countPages">0</strong> pages</span>
                <span class="pill"><strong id="modeLabel">—</strong></span>
              </div>
              <div style="height:10px"></div>
              <div class="inline">
                <span>Progress</span><span class="kbd" id="progLabel">0%</span>
                <div class="progress"><div id="progBar"></div></div>
              </div>
              <div style="height:10px"></div>
              <div class="small" id="statusLine">No files loaded.</div>
            </div>
          </div>
        </div>
      </details>

      <details class="keta" open>
        <summary><span>OUTPUT CONTROLS</span><span class="small">scale, quality, inversion</span></summary>
        <div class="content">
          <div class="grid2">
            <label>
              OUTPUT FORMAT
              <select id="outFormat">
                <option value="jpeg" selected>JPEG (.jpg)</option>
                <option value="png">PNG (.png) [larger]</option>
              </select>
            </label>

            <label id="qWrap">
              JPEG QUALITY
              <input id="quality" type="range" min="0.4" max="1" step="0.05" value="0.92" />
              <div class="inline"><span>Quality</span><span class="pill"><strong id="qualityVal">0.92</strong></span></div>
            </label>

            <label>
              RENDER SCALE (DETAIL)
              <input id="scale" type="range" min="1" max="3" step="0.25" value="2" />
              <div class="inline"><span>Scale</span><span class="pill"><strong id="scaleVal">2.00</strong>x</span></div>
              <div class="small">If it crashes, drop to 1.5x.</div>
            </label>

            <label>
              INVERT OUTPUT
              <select id="invert">
                <option value="on" selected>ON (black page / white writing)</option>
                <option value="off">OFF (normal output)</option>
              </select>
            </label>

            <label>
              THUMB STRIP (OPTIONAL)
              <select id="thumbs">
                <option value="off" selected>OFF (max stability)</option>
                <option value="on">ON (windowed thumbnails)</option>
              </select>
              <div class="small">Thumbs on long PDFs can spike memory. Default OFF.</div>
            </label>

            <label>
              FOLDER NAMING
              <select id="nameMode">
                <option value="pdfName" selected>Folder per PDF (filename)</option>
                <option value="timestamp">Folder per PDF (timestamp)</option>
              </select>
            </label>
          </div>
        </div>
      </details>

      <details class="keta" open>
        <summary><span>PREVIEW</span><span class="small">single-page render</span></summary>
        <div class="content">
          <div class="stage"><canvas id="preview"></canvas></div>
          <div style="height:10px"></div>
          <div class="thumbRow" id="thumbRow"></div>
          <div class="small">
            Controls: <span class="kbd">←</span> <span class="kbd">→</span> page,
            <span class="kbd">I</span> invert,
            <span class="kbd">C</span> convert.
          </div>
        </div>
      </details>
    </section>

    <aside class="rail">
      <details class="keta" open>
        <summary><span>KETA NOTE</span><span class="small">page-level note</span></summary>
        <div class="content">
          <textarea id="noteText" placeholder="SYSTEM NOTE // decisions, constraints, next actions"></textarea>
          <div style="height:10px"></div>
          <button class="btn secondary" id="btnNoteExport">EXPORT NOTE JSON</button>
          <div style="height:10px"></div>
          <div class="small" id="noteMeta"></div>
        </div>
      </details>

      <details class="keta">
        <summary><span>ERROR DETAIL</span><span class="small">console-grade message</span></summary>
        <div class="content">
          <div class="small" id="errBox">—</div>
        </div>
      </details>
    </aside>
  </main>

  <!-- Dependencies (CDN). For absolute reliability, self-host these in your repo later. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.6.82/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <script>
    // -------------------------
    // PDF.js configuration
    // -------------------------
    const PDFJS_VERSION = "4.6.82";
    const CDN_BASE = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/" + PDFJS_VERSION;

    // Worker may fail on some hosted setups; we try worker first, then fall back.
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = CDN_BASE + "/pdf.worker.min.js";
    }

    const el = {
      pdfInput: document.getElementById("pdfInput"),
      btnConvert: document.getElementById("btnConvert"),
      btnClear: document.getElementById("btnClear"),
      outFormat: document.getElementById("outFormat"),
      nameMode: document.getElementById("nameMode"),
      scale: document.getElementById("scale"),
      scaleVal: document.getElementById("scaleVal"),
      quality: document.getElementById("quality"),
      qualityVal: document.getElementById("qualityVal"),
      qWrap: document.getElementById("qWrap"),
      invert: document.getElementById("invert"),
      thumbs: document.getElementById("thumbs"),

      countPDF: document.getElementById("countPDF"),
      countPages: document.getElementById("countPages"),
      modeLabel: document.getElementById("modeLabel"),
      statusLine: document.getElementById("statusLine"),
      progBar: document.getElementById("progBar"),
      progLabel: document.getElementById("progLabel"),

      preview: document.getElementById("preview"),
      thumbRow: document.getElementById("thumbRow"),

      noteText: document.getElementById("noteText"),
      noteMeta: document.getElementById("noteMeta"),
      btnNoteExport: document.getElementById("btnNoteExport"),

      errBox: document.getElementById("errBox")
    };

    const state = {
      docs: [], // { file, doc, numPages }
      totalPages: 0,
      selected: { docIndex: 0, pageIndex: 0 },
      busy: false,
      workerMode: "UNKNOWN" // "WORKER" | "NO_WORKER"
    };

    function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
    function pad3(n){ return String(n).padStart(3,"0"); }
    function safeName(name){
      return (name || "PDF").replace(/\.pdf$/i,"").replace(/[^\w\-]+/g,"_").replace(/_+/g,"_").slice(0,80);
    }

    function setProgress(p){
      const pct = Math.round(clamp(p,0,1)*100);
      el.progBar.style.width = pct + "%";
      el.progLabel.textContent = pct + "%";
    }

    function setCounts(){
      el.countPDF.textContent = state.docs.length;
      el.countPages.textContent = state.totalPages;
      el.modeLabel.textContent = state.workerMode === "WORKER" ? "WORKER" : (state.workerMode === "NO_WORKER" ? "NO_WORKER" : "—");
    }

    function updateQualityVisibility(){
      el.qWrap.style.display = (el.outFormat.value === "jpeg") ? "block" : "none";
    }

    function invertCanvas(ctx, w, h){
      const img = ctx.getImageData(0,0,w,h);
      const d = img.data;
      for (let i=0; i<d.length; i+=4){
        d[i] = 255 - d[i];
        d[i+1] = 255 - d[i+1];
        d[i+2] = 255 - d[i+2];
      }
      ctx.putImageData(img, 0, 0);
    }

    function dataURLToBlob(dataURL){
      const parts = dataURL.split(",");
      const mime = parts[0].match(/:(.*?);/)[1];
      const bstr = atob(parts[1]);
      let n = bstr.length;
      const u8arr = new Uint8Array(n);
      while(n--) u8arr[n] = bstr.charCodeAt(n);
      return new Blob([u8arr], { type: mime });
    }

    function selectedDoc(){
      return state.docs[state.selected.docIndex] || null;
    }

    function setError(err){
      const msg = (err && (err.stack || err.message || String(err))) ? (err.stack || err.message || String(err)) : "Unknown error.";
      el.errBox.textContent = msg;
      console.error(err);
    }

    async function tryLoadPdf(arrayBuffer, opts){
      const data = new Uint8Array(arrayBuffer);
      const loadingTask = pdfjsLib.getDocument({
        data,
        // Performance + stability options:
        disableFontFace: true,
        useSystemFonts: true,
        stopAtErrors: false,
        // Worker control:
        ...opts
      });
      return loadingTask.promise;
    }

    async function loadFiles(fileList){
      clearSession();
      const files = Array.from(fileList || []).filter(f => f.type === "application/pdf" || /\.pdf$/i.test(f.name));
      if (!files.length) return;

      state.busy = true;
      setProgress(0);
      el.btnConvert.textContent = "LOADING…";
      el.btnConvert.disabled = true;
      el.statusLine.textContent = "Loading PDFs…";
      el.errBox.textContent = "—";

      try{
        // We detect worker viability by attempting first PDF in worker mode; on failure retry no-worker.
        let workerOk = true;

        for (let i=0; i<files.length; i++){
          const file = files[i];
          const ab = await file.arrayBuffer();

          let doc;
          try{
            // Attempt with worker
            doc = await tryLoadPdf(ab, { disableWorker: false });
            state.workerMode = "WORKER";
          } catch (e1){
            workerOk = false;
            // Retry without worker
            try{
              doc = await tryLoadPdf(ab, { disableWorker: true });
              state.workerMode = "NO_WORKER";
            } catch (e2){
              setError(e2);
              throw new Error("PDF.js failed in both WORKER and NO_WORKER modes for: " + file.name);
            }
          }

          const numPages = doc.numPages;
          state.docs.push({ file, doc, numPages });
          state.totalPages += numPages;

          setProgress((i+1)/files.length * 0.25);
          el.statusLine.textContent = `Loaded: ${file.name} (${numPages} pages).`;
        }

        setCounts();
        state.selected = { docIndex: 0, pageIndex: 0 };

        el.statusLine.textContent = `Ready. ${state.docs.length} PDF(s), ${state.totalPages} pages. Mode: ${state.workerMode}.`;

        await renderPreview();
        maybeBuildThumbWindow();

      } catch(err){
        setError(err);
        alert("PDF load failed. Open ERROR DETAIL for the exact reason. Most common cause is worker-blocking; this build auto-falls back, so if it still fails the PDF is malformed or the browser ran out of memory.");
      } finally{
        state.busy = false;
        el.btnConvert.textContent = "CONVERT → ZIP";
        el.btnConvert.disabled = !state.docs.length;
        setProgress(0);
      }
    }

    function clearSession(){
      state.docs = [];
      state.totalPages = 0;
      state.selected = { docIndex:0, pageIndex:0 };
      state.workerMode = "UNKNOWN";
      setCounts();
      setProgress(0);
      el.statusLine.textContent = "No files loaded.";
      el.thumbRow.style.display = "none";
      el.thumbRow.innerHTML = "";
      const ctx = el.preview.getContext("2d");
      ctx.clearRect(0,0,el.preview.width, el.preview.height);
      updateNoteMeta();
    }

    async function renderPreview(){
      const d = selectedDoc();
      if (!d) return;

      const pageNumber = state.selected.pageIndex + 1;
      const page = await d.doc.getPage(pageNumber);

      const scale = parseFloat(el.scale.value || "2");
      const viewport = page.getViewport({ scale });

      const canvas = el.preview;
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      canvas.width = Math.ceil(viewport.width);
      canvas.height = Math.ceil(viewport.height);

      await page.render({ canvasContext: ctx, viewport }).promise;

      if (el.invert.value === "on"){
        invertCanvas(ctx, canvas.width, canvas.height);
      }

      updateNoteMeta();
      markThumbSelection();
      el.statusLine.textContent = `Preview: ${d.file.name} — page ${pageNumber}/${d.numPages} (Mode: ${state.workerMode})`;
    }

    function updateNoteMeta(){
      const d = selectedDoc();
      const payload = {
        page: "KETADATA_PDF_TO_JPEG_CONVERTER_ROBUST",
        room: "STUDIO/TOOLS",
        clearance: "INTERNAL",
        polarity: "MIND (ANGULAR)",
        timestamp: new Date().toISOString(),
        selection: d ? { pdf: d.file.name, page: state.selected.pageIndex + 1 } : null
      };
      el.noteMeta.textContent = "META: " + JSON.stringify(payload);
    }

    function exportNoteJSON(){
      const d = selectedDoc();
      const payload = {
        id: "note_" + Date.now(),
        room: "STUDIO/TOOLS",
        clearance: "INTERNAL",
        type: "spec/decision",
        polarity: "mind",
        timestamp: new Date().toISOString(),
        source: "KETADATA PDF→JPEG Converter (ROBUST)",
        selection: d ? { pdf: d.file.name, page: state.selected.pageIndex + 1 } : null,
        note: el.noteText.value || ""
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      saveAs(blob, `KETA_NOTE_${Date.now()}.json`);
    }

    async function convertAllToZip(){
      if (state.busy) return;
      if (!state.docs.length) return alert("Load a PDF first.");

      state.busy = true;
      el.btnConvert.textContent = "CONVERTING…";
      el.btnConvert.disabled = true;
      setProgress(0);
      el.errBox.textContent = "—";

      const zip = new JSZip();
      const format = el.outFormat.value; // jpeg | png
      const jpegQuality = parseFloat(el.quality.value || "0.92");
      const scale = parseFloat(el.scale.value || "2");
      const invertOn = (el.invert.value === "on");

      let done = 0;
      const total = state.totalPages;

      try{
        for (const d of state.docs){
          const folderName = (document.getElementById("nameMode").value === "timestamp")
            ? `${Date.now()}_${safeName(d.file.name)}`
            : safeName(d.file.name);

          const folder = zip.folder(folderName);

          for (let p=1; p<=d.numPages; p++){
            const page = await d.doc.getPage(p);
            const viewport = page.getViewport({ scale });

            const c = document.createElement("canvas");
            const ctx = c.getContext("2d", { willReadFrequently: true });
            c.width = Math.ceil(viewport.width);
            c.height = Math.ceil(viewport.height);

            await page.render({ canvasContext: ctx, viewport }).promise;

            if (invertOn) invertCanvas(ctx, c.width, c.height);

            const filename = `page-${pad3(p)}.${format === "jpeg" ? "jpg" : "png"}`;
            const dataUrl = (format === "jpeg")
              ? c.toDataURL("image/jpeg", jpegQuality)
              : c.toDataURL("image/png");

            folder.file(filename, dataURLToBlob(dataUrl));

            done++;
            if (done % 2 === 0) setProgress(done / total); // lighten UI churn
            if (p % 10 === 0) el.statusLine.textContent = `Converting: ${d.file.name} page ${p}/${d.numPages}…`;
          }
        }

        zip.file("KETADATA_MANIFEST.txt", [
          "KETADATA // PDF → JPEG (ROBUST)",
          "Generated: " + new Date().toISOString(),
          "Mode: " + state.workerMode,
          "Format: " + format,
          "Scale: " + scale.toFixed(2),
          "Invert: " + (invertOn ? "ON" : "OFF"),
          (format === "jpeg" ? ("JPEG Quality: " + jpegQuality.toFixed(2)) : ""),
          "",
          "Files:",
          ...state.docs.map(x => `- ${x.file.name} (${x.numPages} pages)`)
        ].filter(Boolean).join("\n"));

        const blob = await zip.generateAsync({ type:"blob" });
        saveAs(blob, `KETADATA_PDF_TO_JPEG_${Date.now()}.zip`);

        el.statusLine.textContent = "Done. ZIP downloaded.";

      } catch(err){
        setError(err);
        alert("Conversion failed. Open ERROR DETAIL for the exact reason. If it’s memory/CPU, drop scale to 1.5x and convert one PDF at a time.");
      } finally{
        state.busy = false;
        el.btnConvert.textContent = "CONVERT → ZIP";
        el.btnConvert.disabled = !state.docs.length;
        setProgress(0);
      }
    }

    // -------------------------
    // Optional thumb window (NOT full thumbs)
    // -------------------------
    async function maybeBuildThumbWindow(){
      if (el.thumbs.value !== "on"){
        el.thumbRow.style.display = "none";
        el.thumbRow.innerHTML = "";
        return;
      }
      const d = selectedDoc();
      if (!d) return;

      el.thumbRow.style.display = "flex";
      el.thumbRow.innerHTML = "";

      // window of 25 pages around current selection
      const win = 25;
      const cur = state.selected.pageIndex + 1;
      const start = Math.max(1, cur - Math.floor(win/2));
      const end = Math.min(d.numPages, start + win - 1);

      for (let p = start; p <= end; p++){
        const t = document.createElement("div");
        t.className = "thumb";
        t.dataset.p = String(p);

        const c = document.createElement("canvas");
        c.width = 56; c.height = 56;
        t.appendChild(c);

        t.addEventListener("click", async () => {
          state.selected.pageIndex = p - 1;
          await renderPreview();
          // rebuild window to keep selected centered
          await maybeBuildThumbWindow();
        });

        el.thumbRow.appendChild(t);

        // Render thumb cheaply
        renderThumb(d.doc, p, c).catch(()=>{});
      }

      markThumbSelection();
    }

    async function renderThumb(doc, pageNumber, canvas){
      const page = await doc.getPage(pageNumber);
      const viewport = page.getViewport({ scale: 0.18 }); // tiny
      const target = 56;

      const off = document.createElement("canvas");
      const offCtx = off.getContext("2d", { willReadFrequently: true });

      off.width = Math.ceil(viewport.width);
      off.height = Math.ceil(viewport.height);

      await page.render({ canvasContext: offCtx, viewport }).promise;

      if (el.invert.value === "on"){
        invertCanvas(offCtx, off.width, off.height);
      }

      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      canvas.width = target; canvas.height = target;
      ctx.fillStyle = "#fff"; ctx.fillRect(0,0,target,target);

      const s = Math.min(target/off.width, target/off.height);
      const rw = off.width*s, rh = off.height*s;
      const dx = (target - rw)/2, dy = (target - rh)/2;
      ctx.drawImage(off, dx, dy, rw, rh);
    }

    function markThumbSelection(){
      if (el.thumbRow.style.display !== "flex") return;
      const d = selectedDoc();
      if (!d) return;
      const selectedPage = state.selected.pageIndex + 1;
      [...el.thumbRow.children].forEach(node=>{
        node.classList.toggle("selected", Number(node.dataset.p) === selectedPage);
      });
    }

    // -------------------------
    // Events / shortcuts
    // -------------------------
    el.pdfInput.addEventListener("change", e => loadFiles(e.target.files));
    el.btnConvert.addEventListener("click", convertAllToZip);
    el.btnClear.addEventListener("click", () => { if(!state.busy){ el.pdfInput.value=""; clearSession(); } });

    el.scale.addEventListener("input", async () => {
      el.scaleVal.textContent = parseFloat(el.scale.value).toFixed(2);
      if (state.docs.length && !state.busy) await renderPreview();
    });
    el.quality.addEventListener("input", () => el.qualityVal.textContent = parseFloat(el.quality.value).toFixed(2));
    el.outFormat.addEventListener("change", updateQualityVisibility);
    el.invert.addEventListener("change", async () => {
      if (state.docs.length && !state.busy){
        await renderPreview();
        await maybeBuildThumbWindow();
      }
    });
    el.thumbs.addEventListener("change", async () => {
      if (state.docs.length && !state.busy) await maybeBuildThumbWindow();
    });
    el.btnNoteExport.addEventListener("click", exportNoteJSON);

    document.addEventListener("keydown", async (e) => {
      if (state.busy) return;
      const d = selectedDoc();
      if (!d) return;

      if (e.key === "ArrowRight"){
        e.preventDefault();
        state.selected.pageIndex = Math.min(d.numPages - 1, state.selected.pageIndex + 1);
        await renderPreview();
        await maybeBuildThumbWindow();
      }
      if (e.key === "ArrowLeft"){
        e.preventDefault();
        state.selected.pageIndex = Math.max(0, state.selected.pageIndex - 1);
        await renderPreview();
        await maybeBuildThumbWindow();
      }
      if (e.key.toLowerCase() === "i"){
        el.invert.value = (el.invert.value === "on") ? "off" : "on";
        await renderPreview();
        await maybeBuildThumbWindow();
      }
      if (e.key.toLowerCase() === "c"){
        await convertAllToZip();
      }
    });

    // init
    el.scaleVal.textContent = parseFloat(el.scale.value).toFixed(2);
    el.qualityVal.textContent = parseFloat(el.quality.value).toFixed(2);
    updateQualityVisibility();
    setCounts();
    setProgress(0);
    updateNoteMeta();
  </script>
</body>
</html>
