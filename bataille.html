<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA — BATAILLE (GENERAL ECONOMY / EXCESS ENGINE)</title>
  <style>
    :root{
      --bg:#000;
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.56);
      --hair:rgba(255,255,255,.14);
      --panel:rgba(0,0,0,.58);
      --panel2:rgba(255,255,255,.03);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; overflow:hidden;
      background:var(--bg); color:var(--fg);
      font-family: Arial, Helvetica, sans-serif;
    }
    canvas{ position:fixed; inset:0; width:100vw; height:100vh; display:block; }

    .hud{
      position:fixed; left:18px; top:16px;
      user-select:none; pointer-events:none;
      mix-blend-mode:screen;
    }
    .brand{
      font-weight:900;
      letter-spacing:.18em;
      text-transform:uppercase;
      font-size:15px;
      text-shadow:0 0 18px rgba(255,255,255,.18);
    }
    .sub{
      margin-top:4px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:var(--muted);
      line-height:1.25;
      max-width: 78ch;
    }

    .dock{
      position:fixed; left:18px; bottom:16px;
      display:flex; flex-wrap:wrap;
      gap:10px; align-items:center;
      pointer-events:auto;
    }
    .btn, select{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.22);
      color:rgba(255,255,255,.86);
      padding:10px 12px;
      border-radius:10px;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
      outline:none;
    }
    .btn:hover, select:hover{
      background:rgba(255,255,255,.10);
      border-color:rgba(255,255,255,.36);
      transform: translateY(-1px);
    }
    .btn:active{ transform: translateY(0px); }

    .panel{
      position:fixed; right:16px; top:16px;
      width:min(900px, calc(100vw - 32px));
      max-height: calc(100vh - 32px);
      overflow:auto;
      border:1px solid rgba(255,255,255,.18);
      background:var(--panel);
      backdrop-filter: blur(10px);
      border-radius:14px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset, 0 16px 50px rgba(0,0,0,.65);
    }
    .panelHeader{
      position:sticky; top:0;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.74);
      backdrop-filter: blur(10px);
      display:flex; justify-content:space-between; align-items:center;
      z-index:10;
    }
    .title{
      font-weight:900;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      color:rgba(255,255,255,.86);
    }
    .hint{
      font-size:11px;
      letter-spacing:.08em;
      color:rgba(255,255,255,.55);
      text-align:right;
      line-height:1.2;
    }

    .panelBody{ padding:10px 12px 14px; display:flex; flex-direction:column; gap:10px; }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 980px){ .grid2{ grid-template-columns:1fr; } }

    .block{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      overflow:hidden;
      background:var(--panel2);
    }
    .block h3{
      margin:0;
      padding:10px 10px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:rgba(255,255,255,.75);
      border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      display:flex; justify-content:space-between; align-items:center; gap:10px;
    }
    .pill{
      font-size:10px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:rgba(255,255,255,.62);
      border:1px solid rgba(255,255,255,.18);
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.20);
      white-space:nowrap;
    }
    .rows{ padding:10px; display:flex; flex-direction:column; gap:10px; }
    .row{
      display:grid;
      grid-template-columns: 310px 1fr 70px;
      gap:10px;
      align-items:center;
    }
    .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:rgba(255,255,255,.62);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    input[type="range"]{ width:100%; accent-color: rgba(255,255,255,.92); }
    .val{ font-variant-numeric: tabular-nums; font-size:11px; color:rgba(255,255,255,.76); text-align:right; }

    .toggles{
      padding:10px;
      display:flex; flex-wrap:wrap; gap:8px;
      border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
    }
    .toggle{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }
    .toggle span{
      font-size:11px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:rgba(255,255,255,.78);
      white-space:nowrap;
    }

    .status{
      padding:10px;
      border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
      display:flex; flex-direction:column; gap:10px;
    }
    .mono{
      font-variant-numeric: tabular-nums;
      letter-spacing:.10em;
      text-transform:uppercase;
      font-size:10px;
      color:rgba(255,255,255,.74);
      line-height:1.35;
    }
    .bar{
      height:12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.04);
      overflow:hidden;
    }
    .fill{ height:100%; width:0%; background:rgba(255,255,255,.60); }
    .card{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      background:rgba(0,0,0,.45);
      padding:10px;
      font-size:12px;
      line-height:1.35;
      letter-spacing:.02em;
      white-space:pre-wrap;
    }

    /* ===== FIX: controller must win pointer interactions ===== */
    canvas{ z-index:0; }
    .dock{ z-index:20; }
    .panel{ z-index:30; }
    .panel input,
    .panel select,
    .panel button,
    .panel label,
    .panel .toggle,
    .panel .rows,
    .panel .block,
    .dock *{
      pointer-events:auto;
      touch-action: manipulation;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="brand">KETADATA</div>
    <div class="sub" id="sub">
      BATAILLE MODE · GENERAL ECONOMY / EXCESS ENGINE · ACCUMULATION → PRESSURE → EXPENDITURE → RESIDUE · CLICK = SACRIFICE · DRAG = WASTE FLOW · HOLD [SPACE] = POTLATCH (FAST BURN) · SHIFT+DRAG = TABOO RITUAL
    </div>
  </div>

  <div class="dock">
    <select id="scene">
      <option value="solar">SCENE: SOLAR SURPLUS</option>
      <option value="festival">SCENE: FESTIVAL</option>
      <option value="war">SCENE: WAR MACHINE</option>
      <option value="sacrifice">SCENE: SACRIFICE</option>
      <option value="taboo">SCENE: TABOO / TRANSGRESSION</option>
      <option value="potlatch">SCENE: POTLATCH</option>
      <option value="monastery">SCENE: ASCESIS (CONTAINMENT)</option>
      <option value="casino">SCENE: CASINO (LOSS LOOP)</option>
    </select>
    <button class="btn" id="invert">INVERT</button>
    <button class="btn" id="pause">PAUSE</button>
    <button class="btn" id="reseed">RESEED ECONOMY</button>
    <button class="btn" id="clear">CLEAR RESIDUE</button>
    <button class="btn" id="reset">RESET</button>
  </div>

  <div class="panel" id="panel">
    <div class="panelHeader">
      <div class="title">EXCESS CONTROL SURFACE</div>
      <div class="hint">
        CLICK = SACRIFICE (EXCESS→BURN) · DRAG = WASTE FLOW (SPILL FIELD)<br/>
        SHIFT+DRAG = TABOO RITUAL (HIGH RISK/HIGH RELEASE) · HOLD [SPACE] = POTLATCH (FAST DUMP)<br/>
        SCROLL = ZOOM · DRAG EMPTY = PAN · [H] PANEL · [I] INVERT · [P] PAUSE
      </div>
    </div>

    <div class="panelBody">
      <div class="grid2">
        <div class="block">
          <h3>Thermodynamics <span class="pill">pressure / heat</span></h3>
          <div class="rows">
            <div class="row">
              <div class="label">time scale (slow-mo)</div>
              <input id="timeScale" type="range" min="0.000" max="2.000" step="0.001" value="0.24">
              <div class="val" id="timeScaleV">0.240</div>
            </div>
            <div class="row">
              <div class="label">complexity (intricacy)</div>
              <input id="complex" type="range" min="0.40" max="2.80" step="0.01" value="1.85">
              <div class="val" id="complexV">1.85</div>
            </div>
            <div class="row">
              <div class="label">influx (surplus rate)</div>
              <input id="influx" type="range" min="0.00" max="2.50" step="0.01" value="1.05">
              <div class="val" id="influxV">1.05</div>
            </div>
            <div class="row">
              <div class="label">containment (suppress expenditure)</div>
              <input id="contain" type="range" min="0.00" max="2.50" step="0.01" value="0.62">
              <div class="val" id="containV">0.62</div>
            </div>
            <div class="row">
              <div class="label">trace (residue persistence)</div>
              <input id="trace" type="range" min="0.000" max="0.24" step="0.001" value="0.060">
              <div class="val" id="traceV">0.060</div>
            </div>
            <div class="row">
              <div class="label">zoom</div>
              <input id="zoom" type="range" min="0.55" max="2.80" step="0.01" value="1.15">
              <div class="val" id="zoomV">1.15</div>
            </div>
          </div>
          <div class="toggles">
            <label class="toggle"><input id="T_sun" type="checkbox" checked><span>solar core</span></label>
            <label class="toggle"><input id="T_torus" type="checkbox" checked><span>torus spill</span></label>
            <label class="toggle"><input id="T_lattice" type="checkbox" checked><span>loss lattice</span></label>
            <label class="toggle"><input id="T_ledger" type="checkbox" checked><span>ledger ring</span></label>
            <label class="toggle"><input id="T_taboo" type="checkbox" checked><span>taboo seams</span></label>
            <label class="toggle"><input id="T_fracture" type="checkbox" checked><span>rupture marks</span></label>
          </div>
        </div>

        <div class="block">
          <h3>General Economy <span class="pill">mechanics</span></h3>
          <div class="rows">
            <div class="row">
              <div class="label">expenditure rate (burn)</div>
              <input id="burnRate" type="range" min="0.00" max="2.50" step="0.01" value="0.85">
              <div class="val" id="burnRateV">0.85</div>
            </div>
            <div class="row">
              <div class="label">waste viscosity (flow resistance)</div>
              <input id="visc" type="range" min="0.00" max="2.50" step="0.01" value="1.10">
              <div class="val" id="viscV">1.10</div>
            </div>
            <div class="row">
              <div class="label">transgression risk (taboo cost)</div>
              <input id="risk" type="range" min="0.00" max="2.50" step="0.01" value="1.00">
              <div class="val" id="riskV">1.00</div>
            </div>
            <div class="row">
              <div class="label">shock coupling (pressure→fracture)</div>
              <input id="shock" type="range" min="0.00" max="2.50" step="0.01" value="1.10">
              <div class="val" id="shockV">1.10</div>
            </div>
            <div class="row">
              <div class="label">ritual coherence (patterning)</div>
              <input id="ritual" type="range" min="0.00" max="2.50" step="0.01" value="0.92">
              <div class="val" id="ritualV">0.92</div>
            </div>
          </div>

          <div class="status">
            <div class="mono" id="stat">—</div>

            <div class="mono">SURPLUS (ACCUMULATION)</div>
            <div class="bar"><div class="fill" id="surFill"></div></div>

            <div class="mono">PRESSURE (NEED TO DUMP)</div>
            <div class="bar"><div class="fill" id="preFill"></div></div>

            <div class="mono">BURN (CURRENT EXPENDITURE)</div>
            <div class="bar"><div class="fill" id="burFill"></div></div>

            <div class="mono">RUPTURE (BREAKDOWN EVENTS)</div>
            <div class="bar"><div class="fill" id="rupFill"></div></div>

            <div class="card" id="card">
              YOUR ECONOMY ACCUMULATES SURPLUS. IF YOU OVER-CONTAIN IT, PRESSURE FORCES RUPTURES.
              CLICK PERFORMS SACRIFICE. DRAG SPILLS WASTE. HOLD [SPACE] POTLATCH DUMPS SURPLUS FAST.
              SHIFT+DRAG PERFORMS TABOO RITUAL: IT CAN DISCHARGE PRESSURE HARD OR CAUSE FRACTURE.
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha:false });

      let W=0, H=0, DPR=Math.min(2, window.devicePixelRatio||1);
      function resize(){
        W=innerWidth; H=innerHeight;
        canvas.width = Math.floor(W*DPR);
        canvas.height = Math.floor(H*DPR);
        canvas.style.width = W+'px';
        canvas.style.height = H+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize);
      resize();

      const $ = (id)=>document.getElementById(id);

      const ui = {
        scene: $('scene'),
        timeScale: $('timeScale'),
        complex: $('complex'),
        influx: $('influx'),
        contain: $('contain'),
        trace: $('trace'),
        zoom: $('zoom'),

        burnRate: $('burnRate'),
        visc: $('visc'),
        risk: $('risk'),
        shock: $('shock'),
        ritual: $('ritual'),

        T_sun: $('T_sun'),
        T_torus: $('T_torus'),
        T_lattice: $('T_lattice'),
        T_ledger: $('T_ledger'),
        T_taboo: $('T_taboo'),
        T_fracture: $('T_fracture'),
      };

      const vv = {
        timeScaleV: $('timeScaleV'),
        complexV: $('complexV'),
        influxV: $('influxV'),
        containV: $('containV'),
        traceV: $('traceV'),
        zoomV: $('zoomV'),

        burnRateV: $('burnRateV'),
        viscV: $('viscV'),
        riskV: $('riskV'),
        shockV: $('shockV'),
        ritualV: $('ritualV'),
      };

      function syncVals(){
        vv.timeScaleV.textContent = (+ui.timeScale.value).toFixed(3);
        vv.complexV.textContent   = (+ui.complex.value).toFixed(2);
        vv.influxV.textContent    = (+ui.influx.value).toFixed(2);
        vv.containV.textContent   = (+ui.contain.value).toFixed(2);
        vv.traceV.textContent     = (+ui.trace.value).toFixed(3);
        vv.zoomV.textContent      = (+ui.zoom.value).toFixed(2);

        vv.burnRateV.textContent  = (+ui.burnRate.value).toFixed(2);
        vv.viscV.textContent      = (+ui.visc.value).toFixed(2);
        vv.riskV.textContent      = (+ui.risk.value).toFixed(2);
        vv.shockV.textContent     = (+ui.shock.value).toFixed(2);
        vv.ritualV.textContent    = (+ui.ritual.value).toFixed(2);
      }
      Object.values(ui).forEach(el=>{
        if (!el || !el.addEventListener) return;
        el.addEventListener('input', syncVals);
        el.addEventListener('change', syncVals);
      });
      syncVals();

      const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
      const lerp=(a,b,t)=>a+(b-a)*t;
      const tau = Math.PI*2;

      function hash32(n){
        n=(n^(n>>>16))>>>0; n=Math.imul(n,2246822519)>>>0;
        n=(n^(n>>>13))>>>0; n=Math.imul(n,3266489917)>>>0;
        n=(n^(n>>>16))>>>0; return n>>>0;
      }
      function rnd01(n){ return hash32(n)/4294967295; }

      /* ===== FIX: UI event gating so sliders/selects work ===== */
      const PANEL = $('panel');
      const DOCK  = document.querySelector('.dock');
      function isUIEventTarget(t){
        if (!t) return false;
        if (PANEL && PANEL.contains(t)) return true;
        if (DOCK && DOCK.contains(t)) return true;
        return !!t.closest('input, button, select, textarea, label, a, [role="button"], .panel, .dock');
      }
      /* ======================================================= */

      // Scenes tune coefficients (meaningful, not cosmetic)
      const SCENES = {
        solar:      { influx:1.15, contain:0.55, burn:0.75, visc:0.95, risk:0.85, shock:1.00, ritual:0.85, note:"SOLAR SURPLUS: steady inflow, rhythmic expenditure." },
        festival:   { influx:1.35, contain:0.35, burn:1.10, visc:0.85, risk:0.90, shock:1.10, ritual:1.20, note:"FESTIVAL: high burn with patterned release." },
        war:        { influx:1.20, contain:0.65, burn:0.95, visc:1.20, risk:1.10, shock:1.40, ritual:0.75, note:"WAR MACHINE: pressure couples to fracture fast." },
        sacrifice:  { influx:1.05, contain:0.55, burn:1.25, visc:1.00, risk:1.20, shock:1.15, ritual:1.05, note:"SACRIFICE: deliberate expenditure; scars accumulate." },
        taboo:      { influx:1.10, contain:0.75, burn:0.80, visc:1.10, risk:1.55, shock:1.35, ritual:1.10, note:"TABOO: containment builds; transgression is volatile." },
        potlatch:   { influx:1.25, contain:0.20, burn:1.50, visc:0.80, risk:1.05, shock:1.05, ritual:0.95, note:"POTLATCH: dump surplus aggressively; prestige through loss." },
        monastery:  { influx:0.95, contain:1.35, burn:0.35, visc:1.25, risk:0.75, shock:1.25, ritual:0.70, note:"ASCESIS: extreme containment; rupture becomes structural." },
        casino:     { influx:1.10, contain:0.45, burn:1.05, visc:0.90, risk:1.35, shock:1.20, ritual:0.80, note:"CASINO: repetitive loss-loop with spikes of fracture." }
      };

      const st = {
        t:0,
        invert:false,
        paused:false,
        seed:(Math.random()*1e9)|0,

        ox:0, oy:0,
        wheel:0,
        zoom:1.0,

        mx:0, my:0,
        dragging:false,
        dragType:"pan", // pan | waste | taboo
        lastX:0, lastY:0,

        holding:false,
        holdTime:0.0,

        // economy variables (0..1.6-ish)
        surplus:0.32,
        pressure:0.18,
        burn:0.05,
        rupture:0.00,

        // fields
        particles:[],    // waste / embers
        ledgers:[],      // ring entries
        seams:[],        // taboo seams
        fractures:[],    // rupture marks

        // geometry phase
        phi:0,
      };

      function stageScale(){ return Math.min(W,H) * 0.60 * st.zoom; }
      function stageCenter(){ return { x: W*0.5 + st.ox, y: H*0.5 + st.oy }; }
      function stageToScreen(x,y){
        const S = stageScale();
        const c = stageCenter();
        return { x: c.x + x*S, y: c.y + y*S };
      }
      function screenToStage(sx,sy){
        const S = stageScale();
        const c = stageCenter();
        return { x: (sx-c.x)/S, y: (sy-c.y)/S };
      }

      function reseedEconomy(){
        st.seed = (Math.random()*1e9)|0;

        st.surplus = 0.32;
        st.pressure = 0.18;
        st.burn = 0.05;
        st.rupture = 0.00;

        st.particles.length = 0;
        st.ledgers.length = 0;
        st.seams.length = 0;
        st.fractures.length = 0;

        // seed ledger entries
        const n = 18 + Math.floor(rnd01(st.seed+77)*22);
        for (let i=0;i<n;i++){
          const a = (i/n)*tau;
          st.ledgers.push({ a, v: 0.15 + 0.85*rnd01(st.seed+i*31), t: st.t, life: 0.8 + 0.2*rnd01(st.seed+i*11) });
        }

        // seed seams
        const sN = 12 + Math.floor(rnd01(st.seed+999)*14);
        for (let i=0;i<sN;i++){
          const a = rnd01(st.seed+i*113)*tau;
          const r = 0.25 + 0.60*rnd01(st.seed+i*127);
          st.seams.push({ a, r, phase:rnd01(st.seed+i*131)*tau, life: 1.0 });
        }

        updateCard();
      }

      function clearResidue(){
        st.particles.length = 0;
        st.fractures.length = 0;
      }

      function updateCard(extra=""){
        const s = SCENES[ui.scene.value] || SCENES.solar;
        const lines = [
          `SCENE: ${ui.scene.options[ui.scene.selectedIndex].textContent.replace("SCENE: ","")}`,
          s.note,
          "",
          `GENERAL ECONOMY: surplus accumulates regardless of utility. Containment converts surplus into pressure.`,
          `EXCESS MUST BE SPENT: burn it (sacrifice/potlatch) or it ruptures (fracture).`,
          "",
          `ACTIONS:`,
          `- CLICK: sacrifice (instant burn + ledger entry + residue).`,
          `- DRAG: waste flow (creates a viscous spill field).`,
          `- HOLD [SPACE]: potlatch (fast dump; stabilizes pressure).`,
          `- SHIFT+DRAG: taboo ritual (high discharge; can also crack the system).`
        ];
        $('card').textContent = lines.join("\n") + (extra ? `\n\n${extra}` : "");
      }

      // emitters
      function emitParticle(x,y, vx,vy, kind=0, heat=1.0){
        st.particles.push({
          x,y, vx,vy,
          kind, heat,
          t: st.t,
          life: 1.0,
          w: 0.35 + 0.65*rnd01(st.seed + st.particles.length*29)
        });
        if (st.particles.length > 1600) st.particles.splice(0, st.particles.length-1600);
      }
      function addLedger(a, v){
        st.ledgers.push({ a, v, t: st.t, life: 1.0 });
        if (st.ledgers.length > 320) st.ledgers.shift();
      }
      function addFracture(x,y, power){
        st.fractures.push({ x,y, power, t: st.t, life:1.0, k: 3 + Math.floor(rnd01(st.seed + st.fractures.length*17)*6) });
        if (st.fractures.length > 220) st.fractures.shift();
      }

      // meters update
      function setFill(id, v){
        $(id).style.width = Math.round(clamp(v,0,1)*100) + "%";
      }

      // ECONOMY STEP
      function step(dt){
        const sc = SCENES[ui.scene.value] || SCENES.solar;

        const C = +ui.complex.value;

        // primary controls with scene multipliers
        const influx  = (+ui.influx.value)  * sc.influx;
        const contain = (+ui.contain.value) * sc.contain;
        const burnR   = (+ui.burnRate.value)* sc.burn;
        const visc    = (+ui.visc.value)    * sc.visc;
        const risk    = (+ui.risk.value)    * sc.risk;
        const shock   = (+ui.shock.value)   * sc.shock;
        const ritual  = (+ui.ritual.value)  * sc.ritual;

        // zoom smoothing
        st.wheel *= 0.88;
        st.zoom += st.wheel;
        st.zoom = clamp(st.zoom, 0.55, 2.80);
        st.zoom = lerp(st.zoom, +ui.zoom.value, clamp(dt*0.9,0,1));

        // core phase
        st.phi += dt * (0.22 + 0.38*C) * (0.6 + 0.6*influx);

        // surplus inflow (solar)
        const addS = dt * (0.015 + 0.035*C) * influx;
        st.surplus = clamp(st.surplus + addS, 0, 1.60);

        // containment converts surplus into pressure
        const conv = dt * (0.010 + 0.030*C) * contain * (0.35 + 0.65*st.surplus/1.6);
        const moved = Math.min(st.surplus, conv);
        st.surplus -= moved;
        st.pressure = clamp(st.pressure + moved*(0.85 + 0.35*contain), 0, 1.60);

        // baseline burn (structured expenditure)
        const baseBurn = dt * (0.010 + 0.035*C) * burnR * (0.20 + 0.80*(1 - contain/2.5));
        const burnFromSur = Math.min(st.surplus, baseBurn*0.65);
        const burnFromPre = Math.min(st.pressure, baseBurn*0.35);
        st.surplus -= burnFromSur;
        st.pressure -= burnFromPre;

        st.burn = clamp(lerp(st.burn, baseBurn*(0.65 + 0.6*(st.pressure/1.6)), clamp(dt*(1.6+0.9*C),0,1)), 0, 1.60);

        // holding = potlatch dump
        if (st.holding){
          st.holdTime += dt;
          const pot = clamp((st.holdTime - 0.12), 0, 1.0);
          const dump = dt * (0.06 + 0.16*C) * (0.35 + 1.15*burnR) * (0.25 + pot) * sc.burn;
          const dS = Math.min(st.surplus, dump*0.70);
          const dP = Math.min(st.pressure, dump*0.30);
          st.surplus -= dS;
          st.pressure -= dP;
          st.burn = clamp(st.burn + dump*0.9, 0, 1.6);

          // emit particles around cursor
          const p = screenToStage(st.mx, st.my);
          for (let i=0;i<Math.floor(6 + 10*C);i++){
            const a = rnd01(st.seed + ((st.t*1000)|0) + i*13)*tau;
            const sp = (0.25 + 0.65*rnd01(st.seed + i*17)) * (0.6 + 0.7*burnR);
            emitParticle(p.x, p.y, Math.cos(a)*sp, Math.sin(a)*sp*0.72, 1, 0.9);
          }
        } else {
          st.holdTime = Math.max(0, st.holdTime - dt*1.1);
        }

        // rupture: if pressure exceeds capacity, fracture events
        const capacity = 0.85 + 0.45*(burnR/2.5) + 0.25*(ritual/2.5); // better ritual/burn increases capacity
        const over = Math.max(0, st.pressure - capacity);
        const rupRise = dt * (0.010 + 0.045*C) * shock * (over*1.8);
        st.rupture = clamp(st.rupture + rupRise, 0, 1.60);

        // rupture discharges pressure but leaves fractures/residue
        if (st.rupture > 0.18 && rnd01(st.seed + ((st.t*10000)|0)) < dt*(0.55 + 0.85*C) * shock * (0.35 + over)){
          const p = screenToStage(st.mx, st.my);
          addFracture(p.x, p.y, clamp(0.4 + over*1.2 + st.rupture, 0, 1.6));
          // discharge
          const d = Math.min(st.pressure, 0.10 + 0.18*over);
          st.pressure -= d;
          st.burn = clamp(st.burn + d*1.1, 0, 1.6);
          st.rupture = clamp(st.rupture - 0.10, 0, 1.6);
          // residue particles
          for (let i=0;i<Math.floor(10 + 14*C);i++){
            const a = rnd01(st.seed + st.fractures.length*101 + i*7)*tau;
            const sp = (0.20 + 0.85*rnd01(st.seed+i*19)) * (0.5 + 0.6*shock);
            emitParticle(p.x, p.y, Math.cos(a)*sp, Math.sin(a)*sp*0.72, 2, 0.7);
          }
        }

        // particle dynamics (viscous flow field)
        const drag = Math.pow(0.05, dt*(0.25 + 0.25*visc));
        for (let i=st.particles.length-1;i>=0;i--){
          const q = st.particles[i];

          // torus-like circulation + jitter scaled by heat
          const swirl = (0.010 + 0.030*C) * (0.35 + 0.65*(1/ (0.6 + visc))) * (0.3 + 0.7*q.heat);
          const ax = -q.y * swirl + Math.sin(st.phi + q.x*6)*0.002*C*q.heat;
          const ay =  q.x * swirl + Math.cos(st.phi + q.y*5)*0.002*C*q.heat;

          q.vx += ax;
          q.vy += ay;

          q.vx *= drag;
          q.vy *= drag;

          q.x += q.vx * dt * (0.90 + 0.55*C);
          q.y += q.vy * dt * (0.90 + 0.55*C);

          // heat decays into residue
          q.heat *= Math.pow(0.08, dt*(0.18 + 0.22*C));

          // life decay
          q.life -= dt*(0.06 + 0.18*C) * (0.35 + 0.65*(1-q.heat));
          if (q.life <= 0 || Math.abs(q.x) > 1.25 || Math.abs(q.y) > 1.25){
            st.particles.splice(i,1);
          }
        }

        // taboo seams evolve, tied to risk and ritual
        for (let i=0;i<st.seams.length;i++){
          const s = st.seams[i];
          s.phase += dt*(0.20 + 0.65*C) * (0.45 + 0.55*risk);
          // seam "tightens" when containment is high
          const tighten = clamp(contain/2.5, 0, 1);
          s.r = clamp(s.r + dt*(tighten-0.5)*0.06, 0.18, 0.92);
        }

        // ledger decay
        for (let i=st.ledgers.length-1;i>=0;i--){
          const L = st.ledgers[i];
          L.life -= dt*(0.02 + 0.05*C);
          if (L.life <= 0) st.ledgers.splice(i,1);
        }

        // fractures decay
        for (let i=st.fractures.length-1;i>=0;i--){
          st.fractures[i].life -= dt*(0.06 + 0.14*C);
          if (st.fractures[i].life <= 0) st.fractures.splice(i,1);
        }

        // UI meters
        setFill("surFill", st.surplus/1.6);
        setFill("preFill", st.pressure/1.6);
        setFill("burFill", st.burn/1.6);
        setFill("rupFill", st.rupture/1.6);

        $('stat').textContent =
          `BATAILLE · SURPLUS ${st.surplus.toFixed(2)} · PRESSURE ${st.pressure.toFixed(2)} · BURN ${st.burn.toFixed(2)} · RUPTURE ${st.rupture.toFixed(2)} · RESIDUE ${st.particles.length}`;
      }

      // DRAW
      function draw(){
        const inv = st.invert;
        const bg = inv ? 255 : 0;
        const fg = inv ? 0 : 255;

        const tr = +ui.trace.value;
        if (tr > 0){
          ctx.fillStyle = `rgba(${bg},${bg},${bg},${clamp(tr,0,1)})`;
          ctx.fillRect(0,0,W,H);
        } else {
          ctx.fillStyle = `rgb(${bg},${bg},${bg})`;
          ctx.fillRect(0,0,W,H);
        }

        ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';

        const C = +ui.complex.value;
        const sc = SCENES[ui.scene.value] || SCENES.solar;

        const center = stageCenter();

        // geometry radii
        const coreR = (18 + 70*(st.surplus/1.6)) * (0.85 + 0.15*Math.sin(st.phi));
        const torR1 = Math.min(W,H)*(0.18 + 0.18*(st.pressure/1.6));
        const torR2 = Math.min(W,H)*(0.36 + 0.12*(st.pressure/1.6));
        const ledgerR = Math.min(W,H)*(0.43);

        // SOLAR CORE
        if (ui.T_sun.checked){
          ctx.lineWidth = 1.6;
          const a = clamp(0.06 + 0.22*(st.surplus/1.6) + 0.08*(st.burn/1.6), 0, inv ? 0.75 : 0.55);
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
          ctx.beginPath();
          ctx.arc(center.x, center.y, coreR, 0, tau);
          ctx.stroke();

          const rays = Math.floor(lerp(28, 140, clamp(C/2.8,0,1)));
          for (let i=0;i<rays;i++){
            const aa = (i/rays)*tau + st.phi*(0.10 + 0.22*sc.influx);
            const len = 40 + 240*(st.surplus/1.6) * (0.55 + 0.45*rnd01(st.seed+i*19));
            const alpha = clamp(0.01 + 0.10*(st.surplus/1.6), 0, 0.18);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha})`;
            ctx.lineWidth = 1.0;
            ctx.beginPath();
            ctx.moveTo(center.x + Math.cos(aa)*coreR*0.2, center.y + Math.sin(aa)*coreR*0.2);
            ctx.lineTo(center.x + Math.cos(aa)*len,     center.y + Math.sin(aa)*len);
            ctx.stroke();
          }
        }

        // TORUS SPILL FIELD
        if (ui.T_torus.checked){
          ctx.lineWidth = 1.2;
          const bands = Math.floor(lerp(10, 44, clamp(C/2.8,0,1)));
          for (let i=0;i<bands;i++){
            const t = i/(bands-1);
            const r = lerp(torR1, torR2, t);
            const wob = 1 + 0.06*Math.sin(st.phi*0.8 + i) + 0.04*(st.burn/1.6);
            const alpha = clamp(0.01 + 0.08*(st.pressure/1.6) + 0.05*(1-t), 0, 0.20);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha})`;
            ctx.beginPath();
            ctx.arc(center.x, center.y, r*wob, 0, tau);
            ctx.stroke();
          }
        }

        // LOSS LATTICE
        if (ui.T_lattice.checked){
          const step = Math.floor(lerp(92, 34, clamp(C/2.8,0,1)));
          const skew = 0.10*(ui.scene.value==="casino" ? 1 : 0) + 0.08*(ui.scene.value==="war" ? 1 : 0);
          const alpha = clamp(0.02 + 0.10*(st.pressure/1.6) + 0.06*(ui.scene.value==="monastery"), 0, 0.22);
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha})`;
          ctx.lineWidth = 1.0;

          for (let x=0;x<W;x+=step){
            const off = (x - W/2) * skew * 0.25;
            ctx.beginPath();
            ctx.moveTo(x, 0+off);
            ctx.lineTo(x+off, H);
            ctx.stroke();
          }
          for (let y=0;y<H;y+=step){
            const off = (y - H/2) * skew * 0.25;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(W, y+off);
            ctx.stroke();
          }
        }

        // LEDGER RING
        if (ui.T_ledger.checked){
          ctx.lineWidth = 1.2;
          const alpha0 = clamp(0.03 + 0.12*(st.burn/1.6), 0, 0.30);
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${clamp(0.05 + 0.10*(st.burn/1.6),0,0.25)})`;
          ctx.beginPath();
          ctx.arc(center.x, center.y, ledgerR, 0, tau);
          ctx.stroke();

          for (let i=0;i<st.ledgers.length;i++){
            const L = st.ledgers[i];
            const aa = L.a + st.phi*0.08;
            const v = L.v;
            const span = (0.04 + 0.12*v) * (0.7 + 0.6*(st.burn/1.6));
            const a = clamp(alpha0 * L.life * (0.5 + 0.6*v), 0, inv ? 0.75 : 0.45);

            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
            ctx.beginPath();
            ctx.arc(center.x, center.y, ledgerR, aa-span, aa+span);
            ctx.stroke();
          }
        }

        // TABOO SEAMS
        if (ui.T_taboo.checked){
          const risk = (+ui.risk.value) * sc.risk;
          ctx.lineWidth = 1.2;
          for (let i=0;i<st.seams.length;i++){
            const s = st.seams[i];
            const aa = s.a + Math.sin(st.phi*0.6 + s.phase)*0.22;
            const rr = s.r * Math.min(W,H)*0.44;
            const span = (0.05 + 0.10*risk) * (0.7 + 0.6*(st.pressure/1.6));
            const alpha = clamp(0.02 + 0.14*(risk/2.5) + 0.10*(1 - st.surplus/1.6), 0, inv ? 0.70 : 0.50);

            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha * (0.55 + 0.45*Math.sin(s.phase))})`;
            ctx.beginPath();
            ctx.arc(center.x, center.y, rr, aa-span, aa+span);
            ctx.stroke();
          }
        }

        // FRACTURES
        if (ui.T_fracture.checked){
          for (let i=0;i<st.fractures.length;i++){
            const F = st.fractures[i];
            const p = stageToScreen(F.x, F.y);
            const a = clamp((0.10 + 0.25*(F.power/1.6)) * F.life, 0, inv ? 0.85 : 0.60);
            const r = 14 + 70*(1-F.life) + 40*(F.power/1.6);

            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
            ctx.lineWidth = 1.6;
            ctx.beginPath();
            ctx.arc(p.x,p.y,r,0,tau);
            ctx.stroke();

            const k = F.k;
            for (let j=0;j<k;j++){
              const ang = (j/k)*tau + (F.t*0.8) + Math.sin(st.phi+j)*0.3;
              const len = r*(0.5 + 0.9*rnd01(st.seed + i*131 + j*17));
              ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a*0.75})`;
              ctx.lineWidth = 1.2;
              ctx.beginPath();
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(p.x + Math.cos(ang)*len, p.y + Math.sin(ang)*len);
              ctx.stroke();
            }
          }
        }

        // RESIDUE PARTICLES
        ctx.lineWidth = 1.1;
        for (let i=0;i<st.particles.length;i++){
          const q = st.particles[i];
          const p = stageToScreen(q.x, q.y);
          const a = clamp((0.02 + 0.16*q.heat + 0.08*(st.burn/1.6)) * q.life, 0, inv ? 0.75 : 0.55);

          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
          const r = 2 + 10*q.w + 18*q.heat;
          if (q.kind === 0){
            ctx.beginPath(); ctx.arc(p.x,p.y,r*0.55,0,tau); ctx.stroke();
          } else if (q.kind === 1){
            ctx.beginPath(); ctx.rect(p.x-r*0.35,p.y-r*0.35,r*0.7,r*0.7); ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.moveTo(p.x-r, p.y);
            ctx.lineTo(p.x, p.y-r);
            ctx.lineTo(p.x+r, p.y);
            ctx.lineTo(p.x, p.y+r);
            ctx.closePath();
            ctx.stroke();
          }

          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a*0.55})`;
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x - q.vx*80, p.y - q.vy*80);
          ctx.stroke();
        }

        ctx.globalCompositeOperation = 'source-over';
      }

      // INPUT HANDLERS
      $('invert').onclick = ()=> st.invert = !st.invert;
      $('pause').onclick  = ()=> st.paused = !st.paused;
      $('reseed').onclick = ()=> reseedEconomy();
      $('clear').onclick  = ()=> { clearResidue(); updateCard("RESIDUE CLEARED."); };
      $('reset').onclick  = ()=>{
        st.t=0; st.invert=false; st.paused=false; st.ox=0; st.oy=0; st.wheel=0; st.zoom=1.0;
        ui.timeScale.value=0.24;
        ui.complex.value=1.85;
        ui.influx.value=1.05;
        ui.contain.value=0.62;
        ui.trace.value=0.060;
        ui.zoom.value=1.15;
        ui.burnRate.value=0.85;
        ui.visc.value=1.10;
        ui.risk.value=1.00;
        ui.shock.value=1.10;
        ui.ritual.value=0.92;

        ui.T_sun.checked=true;
        ui.T_torus.checked=true;
        ui.T_lattice.checked=true;
        ui.T_ledger.checked=true;
        ui.T_taboo.checked=true;
        ui.T_fracture.checked=true;

        ui.scene.value="solar";
        syncVals();
        reseedEconomy();
      };

      addEventListener('keydown', (e)=>{
        if (e.key==='i' || e.key==='I') st.invert = !st.invert;
        if (e.key==='p' || e.key==='P') st.paused = !st.paused;
        if (e.key==='h' || e.key==='H'){
          const panel = $('panel');
          panel.style.display = (panel.style.display === 'none') ? '' : 'none';
        }
        if (e.code === 'Space'){
          e.preventDefault();
          st.holding = true;
        }
      });
      addEventListener('keyup', (e)=>{
        if (e.code === 'Space'){
          st.holding = false;
        }
      });

      addEventListener('wheel', (e)=>{
        // FIX: if user is over panel/dock, do not zoom the stage
        if (isUIEventTarget(e.target)) return;

        const d = Math.max(-160, Math.min(160, e.deltaY));
        st.wheel += (-d/160) * 0.18;
        st.wheel = clamp(st.wheel, -0.85, 0.95);
      }, { passive:true });

      function insideStage(sx,sy){
        const p = screenToStage(sx,sy);
        return (Math.abs(p.x) < 1.1 && Math.abs(p.y) < 1.1);
      }

      addEventListener('pointerdown', (e)=>{
        // FIX: do not start stage gestures when interacting with controls
        if (isUIEventTarget(e.target)) return;

        st.mx=e.clientX; st.my=e.clientY;
        st.dragging=true;
        st.lastX=e.clientX; st.lastY=e.clientY;

        const p = screenToStage(e.clientX, e.clientY);

        if (!insideStage(e.clientX, e.clientY) || e.altKey){
          st.dragType = "pan";
        } else if (e.shiftKey){
          st.dragType = "taboo";
        } else {
          st.dragType = "waste";
        }

        // CLICK = sacrifice
        const sc = SCENES[ui.scene.value] || SCENES.solar;
        const C = +ui.complex.value;

        const offer = 0.06 + 0.10*C;
        const fromS = Math.min(st.surplus, offer*0.60);
        const fromP = Math.min(st.pressure, offer*0.40);
        st.surplus -= fromS;
        st.pressure -= fromP;
        const out = fromS + fromP;

        st.burn = clamp(st.burn + out*(0.9 + 0.4*(+ui.burnRate.value)), 0, 1.6);

        const ang = Math.atan2(p.y, p.x);
        addLedger(ang, clamp(out/0.16, 0.10, 1.00));

        for (let i=0;i<Math.floor(8 + 10*C);i++){
          const a = rnd01(st.seed + ((st.t*1000)|0) + i*13)*tau;
          const sp = (0.15 + 0.75*rnd01(st.seed+i*17)) * (0.7 + 0.6*(+ui.burnRate.value)*sc.burn);
          emitParticle(p.x, p.y, Math.cos(a)*sp, Math.sin(a)*sp*0.72, 0, 0.9);
        }

        st.pressure = clamp(st.pressure - out*0.45, 0, 1.6);
        st.rupture = clamp(st.rupture - out*0.15, 0, 1.6);
      });

      addEventListener('pointerup', ()=>{ st.dragging=false; st.dragType="pan"; });
      addEventListener('pointercancel', ()=>{ st.dragging=false; st.dragType="pan"; });

      addEventListener('pointermove', (e)=>{
        st.mx=e.clientX; st.my=e.clientY;
        if (!st.dragging) return;

        // FIX: ignore pointer-move drags originating from UI controls (slider drag)
        if (isUIEventTarget(e.target)) return;

        const dx = e.clientX - st.lastX;
        const dy = e.clientY - st.lastY;
        st.lastX = e.clientX; st.lastY = e.clientY;

        if (st.dragType === "pan"){
          st.ox += dx; st.oy += dy;
          st.ox = clamp(st.ox, -W*0.60, W*0.60);
          st.oy = clamp(st.oy, -H*0.60, H*0.60);
          return;
        }

        const p = screenToStage(e.clientX, e.clientY);
        const v = Math.sqrt(dx*dx + dy*dy);
        const C = +ui.complex.value;
        const sc = SCENES[ui.scene.value] || SCENES.solar;

        const visc = (+ui.visc.value) * sc.visc;
        const risk = (+ui.risk.value) * sc.risk;
        const ritual = (+ui.ritual.value) * sc.ritual;

        if (st.dragType === "waste"){
          const n = Math.floor(2 + 10*C);
          for (let i=0;i<n;i++){
            const a = Math.atan2(dy, dx) + (rnd01(st.seed + i*19 + ((st.t*1000)|0))*2-1)*0.8;
            const sp = (0.08 + 0.28*rnd01(st.seed + i*11)) * (0.85 + 0.35*(1/ (0.6+visc)));
            emitParticle(p.x, p.y, Math.cos(a)*sp, Math.sin(a)*sp*0.72, 1, 0.7);
          }
          const spend = (0.0008 + 0.0024*C) * v;
          const fromS = Math.min(st.surplus, spend*0.75);
          const fromP = Math.min(st.pressure, spend*0.25);
          st.surplus -= fromS; st.pressure -= fromP;
          st.burn = clamp(st.burn + (fromS+fromP)*0.6, 0, 1.6);
        } else {
          const discharge = (0.0015 + 0.0040*C) * v * (0.75 + 0.55*ritual);
          const outP = Math.min(st.pressure, discharge*0.85);
          st.pressure -= outP;
          st.burn = clamp(st.burn + outP*(0.9 + 0.5*ritual), 0, 1.6);

          const ang = Math.atan2(p.y, p.x);
          addLedger(ang, clamp(outP/0.12, 0.10, 1.00));

          const fracChance = (0.0000015 + 0.0000045*C) * v * (0.55 + 1.15*risk);
          if (rnd01(st.seed + ((st.t*100000)|0) + st.fractures.length*17) < fracChance){
            addFracture(p.x, p.y, clamp(0.5 + risk*0.5 + st.pressure, 0, 1.6));
            st.rupture = clamp(st.rupture + 0.08 + 0.12*(risk/2.5), 0, 1.6);
          }

          const n = Math.floor(4 + 12*C);
          for (let i=0;i<n;i++){
            const a = rnd01(st.seed + ((st.t*1000)|0) + i*23)*tau;
            const sp = (0.10 + 0.60*rnd01(st.seed+i*31)) * (0.55 + 0.65*(risk/2.5));
            emitParticle(p.x, p.y, Math.cos(a)*sp, Math.sin(a)*sp*0.72, 2, 1.0);
          }
        }
      });

      ui.scene.addEventListener('change', ()=>{
        updateCard();
      });

      // Loop
      let last = performance.now();
      function frame(now){
        const rawDt = Math.min(0.033, (now-last)/1000);
        last = now;

        const dt = rawDt * (+ui.timeScale.value) * (0.55 + 0.65*(+ui.complex.value));
        if (!st.paused){
          st.t += dt;
          step(dt);
        }
        draw();
        requestAnimationFrame(frame);
      }

      // init
      reseedEconomy();
      requestAnimationFrame(frame);
    })();
  </script>
</body>
</html>
