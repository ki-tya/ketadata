<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA // CAM SUBSTANCE (STABLE PARTICLES)</title>

<style>
:root{
  --bg:#000;
  --fg:rgba(255,255,255,.86);
  --muted:rgba(255,255,255,.52);
  --line:rgba(255,255,255,.14);
  --line2:rgba(255,255,255,.22);
  --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  --sans: Arial,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  --top:44px;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);overflow:hidden;font-family:var(--sans)}
#top{
  position:fixed;left:0;right:0;top:0;height:var(--top);
  display:flex;align-items:center;gap:8px;padding:6px 8px;
  background:rgba(0,0,0,.78);border-bottom:1px solid var(--line);
  z-index:50;
}
.btn,.chip{
  height:30px;display:inline-flex;align-items:center;gap:8px;
  padding:0 10px;border:1px solid var(--line2);
  background:rgba(0,0,0,.30);color:var(--fg);
  font:12px/1 var(--sans);white-space:nowrap;user-select:none;
}
.btn{cursor:pointer}
.btn:active{transform:translateY(1px)}
.k{font-family:var(--mono);opacity:.9}
.sep{flex:1}
input[type="range"]{width:120px;accent-color:#fff}

#stage{
  position:fixed;left:0;top:var(--top);
  width:100vw;height:calc(100vh - var(--top));
}
video{position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0}

/* VIZ modes */
#vizSmall{
  position:fixed;right:8px;bottom:8px;width:260px;height:160px;
  border:1px solid var(--line);background:#000;z-index:40;display:none;
}
#vizBig{
  position:fixed;left:0;top:var(--top);right:0;bottom:0;
  z-index:30;display:none;
}
#vizBig canvas{position:absolute;inset:0;width:100%;height:100%;background:#000}
#vizBig .label{
  position:absolute;left:8px;bottom:8px;
  border:1px solid var(--line);
  background:rgba(0,0,0,.55);
  padding:6px 8px;
  font:12px/1.2 var(--sans);
  color:var(--muted);
}
body.vizSmall #vizSmall{display:block}
body.vizBig #vizBig{display:block}

body.invert{filter:invert(1)}
</style>
</head>

<body>
<div id="top">
  <div class="chip k">KETADATA // CAM SUBSTANCE</div>

  <div class="btn" id="start">START CAM</div>
  <div class="btn" id="stopCam">STOP CAM</div>
  <div class="btn" id="run">STOP</div>
  <div class="btn" id="invert">INVERT</div>
  <div class="btn" id="vizToggle">VIZ: OFF</div>

  <div class="chip">FLOW <input id="flow" type="range" min="0" max="100" value="78"></div>
  <div class="chip">REACT <input id="react" type="range" min="0" max="100" value="86"></div>
  <div class="chip">TRAIL <input id="trail" type="range" min="0" max="100" value="96"></div>
  <div class="chip">THR <input id="thr" type="range" min="1" max="80" value="12"></div>
  <div class="chip">DENS <input id="dens" type="range" min="20000" max="180000" value="90000"></div>

  <div class="sep"></div>
  <div class="chip k" id="status">LOCAL</div>
</div>

<canvas id="stage"></canvas>

<canvas id="vizSmall" width="260" height="160"></canvas>
<div id="vizBig">
  <canvas id="vizBigCanvas"></canvas>
  <div class="label">
    <div class="k">VIZ BIG</div>
    <div>V = cycle viz â€¢ Esc = close big viz</div>
  </div>
</div>

<video id="video" playsinline muted autoplay></video>

<script>
(() => {
  const $ = id => document.getElementById(id);

  const stage = $("stage");
  const sctx = stage.getContext("2d",{alpha:false});

  const vizSmall = $("vizSmall");
  const vsctx = vizSmall.getContext("2d");

  const vizBigCanvas = $("vizBigCanvas");
  const vbctx = vizBigCanvas.getContext("2d");

  let W=0,H=0,DPR=1;
  const TOP = 44;

  function resizeStage(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    W = Math.max(1, Math.floor((stage.offsetWidth||1) * DPR));
    H = Math.max(1, Math.floor((stage.offsetHeight||1) * DPR));
    stage.width=W; stage.height=H;
  }
  function resizeVizBig(){
    const w = Math.max(1, Math.floor(innerWidth * DPR));
    const h = Math.max(1, Math.floor((innerHeight - TOP) * DPR));
    vizBigCanvas.width = w;
    vizBigCanvas.height = h;
  }
  function resizeAll(){ resizeStage(); resizeVizBig(); }
  addEventListener("resize", resizeAll);
  addEventListener("orientationchange", () => setTimeout(resizeAll, 60));
  setTimeout(resizeAll, 0);

  const STATE={
    running:true,
    flow:0.78,
    react:0.86,
    trail:0.96,
    thr:12,
    dens:90000,
    camOn:false,
    vizMode:0, // 0 off, 1 small, 2 big
    freezeTrails:false
  };

  const setStatus = s => ($("status").textContent = s);

  $("invert").onclick = () => document.body.classList.toggle("invert");

  function applyVizMode(){
    document.body.classList.toggle("vizSmall", STATE.vizMode===1);
    document.body.classList.toggle("vizBig", STATE.vizMode===2);
    $("vizToggle").textContent = STATE.vizMode===0 ? "VIZ: OFF" : (STATE.vizMode===1 ? "VIZ: SMALL" : "VIZ: BIG");
    if(STATE.vizMode===2) setTimeout(resizeVizBig, 40);
  }

  $("vizToggle").onclick = () => { STATE.vizMode = (STATE.vizMode + 1) % 3; applyVizMode(); };

  $("flow").oninput  = e => STATE.flow  = (+e.target.value)/100;
  $("react").oninput = e => STATE.react = (+e.target.value)/100;
  $("trail").oninput = e => STATE.trail = (+e.target.value)/100;
  $("thr").oninput   = e => STATE.thr   = (+e.target.value)|0;
  $("dens").oninput  = e => STATE.dens  = (+e.target.value)|0;

  $("run").onclick = () => { STATE.running=!STATE.running; $("run").textContent=STATE.running?"STOP":"RUN"; };

  addEventListener("keydown",(e)=>{
    if(e.repeat) return;
    const k=e.key.toLowerCase();
    if(k==="v"){ STATE.vizMode=(STATE.vizMode+1)%3; applyVizMode(); }
    if(k==="escape" && STATE.vizMode===2){ STATE.vizMode=0; applyVizMode(); }
  });

  // ===== CAM + FIELD =====
  const video = $("video");
  let stream=null;

  const DET_W = 180, DET_H = 102;
  const det = document.createElement("canvas");
  det.width=DET_W; det.height=DET_H;
  const dctx = det.getContext("2d",{willReadFrequently:true});

  let VX = new Float32Array(DET_W*DET_H);
  let VY = new Float32Array(DET_W*DET_H);
  let prevLuma = null;

  let energy=0, energySmooth=0;

  function stopCam(){
    if(stream){ try{ for(const t of stream.getTracks()) t.stop(); }catch(_){} }
    stream=null; STATE.camOn=false;
    prevLuma=null; VX.fill(0); VY.fill(0);
    energy=0; energySmooth=0;
    setStatus("LOCAL");
  }

  async function startCam(){
    if(STATE.camOn) return;
    setStatus("CAM REQUEST");
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:"user", width:{ideal:1280}, height:{ideal:720} },
        audio:false
      });
      video.srcObject = stream;
      await video.play();
      STATE.camOn=true;
      prevLuma=null;
      setStatus("CAM ON");
    }catch(e){
      setStatus("CAM BLOCKED");
    }
  }
  $("start").onclick = startCam;
  $("stopCam").onclick = stopCam;

  function updateField(){
    if(!STATE.camOn){ energy=0; return null; }

    dctx.save();
    dctx.scale(-1,1);
    dctx.drawImage(video, -DET_W, 0, DET_W, DET_H);
    dctx.restore();

    const data = dctx.getImageData(0,0,DET_W,DET_H).data;

    const cur = new Uint8Array(DET_W*DET_H);
    let p=0;
    for(let i=0;i<data.length;i+=4){
      const r=data[i], g=data[i+1], b=data[i+2];
      cur[p++] = (r*0.2126 + g*0.7152 + b*0.0722) | 0;
    }

    if(!prevLuma){ prevLuma=cur; energy=0; return null; }

    const thr = STATE.thr|0;

    // Decay field, but keep a floor so it doesn't go dead instantly
    const decay = 0.84 + 0.14*STATE.flow;
    for(let i=0;i<VX.length;i++){
      VX[i] *= decay;
      VY[i] *= decay;
    }

    const diff = new Uint8Array(DET_W*DET_H);
    let total=0;

    for(let i=0;i<diff.length;i++){
      const d = Math.abs(cur[i] - prevLuma[i]);
      prevLuma[i] = cur[i];
      diff[i] = d;
      if(d>thr) total += (d-thr);
    }

    const norm = (DET_W*DET_H) * 8.5;
    energy = Math.max(0, Math.min(1.6, total / norm));

    const baseInject = 0.0022 + 0.010*STATE.flow;
    const boost = 1.0 + 3.4*(STATE.react*energy);
    const inject = baseInject * boost;

    for(let y=1;y<DET_H-1;y++){
      let row = y*DET_W;
      for(let x=1;x<DET_W-1;x++){
        const i=row+x;
        const d=diff[i];
        if(d<thr) continue;

        const gx = (diff[i+1] - diff[i-1]);
        const gy = (diff[i+DET_W] - diff[i-DET_W]);
        const mag = Math.hypot(gx,gy) + 1e-6;

        // swirl sign alternation to make it "substance" not just push
        const sign = ((x+y)&1) ? 1 : -1;
        const ux = (gx/mag)*sign;
        const uy = (gy/mag)*sign;

        const w = (d - thr) / (80 - thr + 1e-6);
        const s = inject * (0.35 + 3.2*w);

        VX[i] += ux * s;
        VY[i] += uy * s;
      }
    }

    return diff;
  }

  function drawViz(diff){
    if(STATE.vizMode===0 || !diff) return;
    const ctx = (STATE.vizMode===1) ? vsctx : vbctx;
    const outW = (STATE.vizMode===1) ? vizSmall.width : vizBigCanvas.width;
    const outH = (STATE.vizMode===1) ? vizSmall.height : vizBigCanvas.height;

    ctx.fillStyle="#000"; ctx.fillRect(0,0,outW,outH);

    const img = ctx.createImageData(DET_W, DET_H);
    for(let i=0;i<diff.length;i++){
      const v=diff[i];
      const o=i*4;
      img.data[o]=255; img.data[o+1]=255; img.data[o+2]=255;
      img.data[o+3]=Math.max(0, Math.min(255, (v - STATE.thr) * 9));
    }
    const tmp=document.createElement("canvas");
    tmp.width=DET_W; tmp.height=DET_H;
    tmp.getContext("2d").putImageData(img,0,0);

    ctx.imageSmoothingEnabled=false;
    ctx.drawImage(tmp,0,0,DET_W,DET_H,0,0,outW,outH);

    ctx.strokeStyle="rgba(255,255,255,.55)";
    ctx.lineWidth=1;
    const step = (STATE.vizMode===1) ? 10 : 8;
    const sx=outW/DET_W, sy=outH/DET_H;
    for(let y=0;y<DET_H;y+=step){
      for(let x=0;x<DET_W;x+=step){
        const i=y*DET_W+x;
        const vx=VX[i]*2400*(1+energySmooth*1.5);
        const vy=VY[i]*2400*(1+energySmooth*1.5);
        const px=x*sx, py=y*sy;
        ctx.beginPath();
        ctx.moveTo(px,py);
        ctx.lineTo(px+vx, py+vy);
        ctx.stroke();
      }
    }

    const e=Math.max(0, Math.min(1, energySmooth/1.1));
    ctx.fillStyle="rgba(255,255,255,.18)";
    ctx.fillRect(8,outH-12,outW-16,4);
    ctx.fillStyle="rgba(255,255,255,.86)";
    ctx.fillRect(8,outH-12,(outW-16)*e,4);

    ctx.strokeStyle="rgba(255,255,255,.22)";
    ctx.strokeRect(0.5,0.5,outW-1,outH-1);
  }

  // ===== PARTICLES (STABLE ON SCREEN) =====
  // Fix: particles were "disappearing" due to heavy clearing + low alpha and high velocity burst.
  // Solution:
  // - keep a minimum on-screen brightness (alpha floor)
  // - clamp speed so particles don't smear out into invisibility
  // - wrap safely and never cull/reseed
  // - maintain baseline drift even at low motion
  let P=[];
  function reseed(n){
    P.length=0;
    for(let i=0;i<n;i++){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()-.5)*0.12,
        vy:(Math.random()-.5)*0.12
      });
    }
  }
  reseed(STATE.dens);

  function ensureDensity(){
    const n=STATE.dens|0;
    if(P.length===n) return;
    if(P.length>n){ P.length=n; return; }
    while(P.length<n){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()-.5)*0.12,
        vy:(Math.random()-.5)*0.12
      });
    }
  }

  function sampleField(x,y){
    const fx=(x/W)*(DET_W-1);
    const fy=(y/H)*(DET_H-1);
    const x0=fx|0, y0=fy|0;
    const x1=Math.min(DET_W-1,x0+1);
    const y1=Math.min(DET_H-1,y0+1);
    const tx=fx-x0, ty=fy-y0;

    const i00=y0*DET_W+x0;
    const i10=y0*DET_W+x1;
    const i01=y1*DET_W+x0;
    const i11=y1*DET_W+x1;

    const vx0=VX[i00]*(1-tx)+VX[i10]*tx;
    const vx1=VX[i01]*(1-tx)+VX[i11]*tx;
    const vy0=VY[i00]*(1-tx)+VY[i10]*tx;
    const vy1=VY[i01]*(1-tx)+VY[i11]*tx;

    return {
      vx: vx0*(1-ty)+vx1*ty,
      vy: vy0*(1-ty)+vy1*ty
    };
  }

  function clamp(v,min,max){ return v<min?min:(v>max?max:v); }

  // ===== LOOP =====
  let last=performance.now();
  function frame(t){
    requestAnimationFrame(frame);
    if(!STATE.running) return;

    resizeAll();
    ensureDensity();

    const dt = Math.min(32, t-last); last=t;

    const diff = updateField();
    energySmooth = energySmooth*0.90 + energy*0.10;

    drawViz(diff);

    // Keep particles visible: do NOT over-clear.
    // Slider TRAIL=1 => long trails => very low clear alpha.
    const baseClear = 0.16 - 0.15*STATE.trail; // 0.01..0.16
    // Motion makes it even less clear (brighter + persistence), never more.
    const clearA = Math.max(0.008, baseClear - (STATE.react*energySmooth*0.05));
    sctx.globalCompositeOperation="source-over";
    sctx.fillStyle=`rgba(0,0,0,${clearA})`;
    sctx.fillRect(0,0,W,H);

    // Always draw particles with a visible alpha floor
    sctx.globalCompositeOperation="lighter";
    const alpha = Math.min(0.98, 0.22 + 0.14*STATE.flow + 0.50*(STATE.react*energySmooth));
    const alphaFloor = 0.26; // <- ensures they don't vanish
    sctx.fillStyle=`rgba(255,255,255,${Math.max(alphaFloor, alpha)})`;

    // Stronger but controlled reaction
    const fieldScale = (1200 + 2600*STATE.flow) * (1.0 + 3.0*(STATE.react*energySmooth));
    const jitter = (0.006 + 0.040*STATE.flow) * (1.0 + 5.0*(STATE.react*energySmooth));

    // Clamp speed so they don't "teleport smear" and effectively disappear
    const maxSpeed = (0.55 + 2.6*STATE.flow) * (1.0 + 1.8*(STATE.react*energySmooth));

    // Particle size bumps slightly on energy, but stable
    const px = (energySmooth > 0.35) ? 2 : 1;

    for(const p of P){
      const f = sampleField(p.x,p.y);

      p.vx = p.vx*0.94 + f.vx*fieldScale + (Math.random()-0.5)*jitter;
      p.vy = p.vy*0.94 + f.vy*fieldScale + (Math.random()-0.5)*jitter;

      // clamp
      p.vx = clamp(p.vx, -maxSpeed, maxSpeed);
      p.vy = clamp(p.vy, -maxSpeed, maxSpeed);

      p.x += p.vx*dt;
      p.y += p.vy*dt;

      // wrap (never cull)
      if(p.x<0) p.x+=W; else if(p.x>=W) p.x-=W;
      if(p.y<0) p.y+=H; else if(p.y>=H) p.y-=H;

      sctx.fillRect(p.x, p.y, px, px);
    }

    sctx.globalCompositeOperation="source-over";

    if(STATE.camOn) setStatus(energySmooth>0.06 ? "CAM + MOTION" : "CAM (LOW MOTION)");
    else setStatus("LOCAL");
  }

  requestAnimationFrame(frame);
  addEventListener("beforeunload", () => { try{ stopCam(); }catch(_){} });

  applyVizMode();
})();
</script>

<!--
AE: KETADATA
EE: CAM_SUBSTANCE_STABLE_PARTICLES
WB: SINGLE_FILE_HTML
FILE_ID: KETA_CAM_SUBSTANCE_STABLE_v1
ROOM_ID: BASE
VERSION: 1
UPDATED_AT: 2026-01-08
CHANGELOG:
- v1: fixes particle "disappearing" by reducing over-clear, enforcing alpha floor, clamping speed, never culling, stable wrap; keeps BIG VIZ mode
-->
</body>
</html>
