<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA // INFINITE CURRENT POOL</title>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --stroke:rgba(255,255,255,0.16);
      --stroke2:rgba(255,255,255,0.10);
      --glass:rgba(255,255,255,0.06);
      --muted:rgba(255,255,255,0.52);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Arial, Helvetica, sans-serif;}
    body{overflow:hidden;}
    ::selection{background:rgba(255,255,255,0.18);}

    /* TOPBAR */
    #topbar{
      position:fixed; left:0; right:0; top:0;
      height:48px;
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid var(--stroke2);
      background:#000;
      user-select:none;
      z-index:80;
    }
    #brand{
      display:flex; align-items:center; gap:10px;
      font-size:11px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.80);
      min-width:240px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .whiteBox{width:10px;height:10px;background:#fff;display:inline-block;}
    .btn{
      border:1px solid var(--stroke);
      background:transparent;
      color:rgba(255,255,255,0.86);
      padding:7px 10px;
      font-size:11px;
      letter-spacing:0.14em;
      text-transform:uppercase;
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{background:var(--glass);border-color:rgba(255,255,255,0.34);}
    .btnPrimary{background:rgba(255,255,255,0.06);border-color:rgba(255,255,255,0.30);}
    .btnPrimary:hover{background:rgba(255,255,255,0.09);border-color:rgba(255,255,255,0.44);}

    #hud{
      position:fixed;
      left:12px;
      bottom:12px;
      z-index:70;
      display:flex;
      flex-direction:column;
      gap:6px;
      opacity:0.32;
      user-select:none;
      pointer-events:none;
      font-size:10px;
      letter-spacing:0.14em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.82);
    }
    #hud strong{font-weight:600;color:rgba(255,255,255,0.92)}
    #hud .row{display:flex;gap:10px;align-items:center}
    #meter{
      width:140px; height:6px;
      border:1px solid rgba(255,255,255,0.20);
      background:rgba(255,255,255,0.04);
      position:relative;
      overflow:hidden;
    }
    #meterFill{
      position:absolute; left:0; top:0; bottom:0;
      width:0%;
      background:rgba(255,255,255,0.55);
    }

    /* STAGE */
    #stage{
      position:fixed;
      inset:48px 0 0 0;
      width:100%;
      height:calc(100% - 48px);
      overflow:hidden;
      background:#000;
    }
    canvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
    }

    /* Vignette + scan */
    #fx{
      position:absolute; inset:0;
      pointer-events:none;
      z-index:10;
      background:
        radial-gradient(1200px 700px at 50% 55%, rgba(255,255,255,0.08), rgba(0,0,0,0.76) 60%, rgba(0,0,0,0.94)),
        repeating-linear-gradient(to bottom, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.00) 2px, rgba(0,0,0,0.00) 6px);
      mix-blend-mode:screen;
      opacity:0.55;
    }

    /* INVERT */
    body.invert{filter:invert(1) hue-rotate(180deg); background:#fff;}
    body.invert #topbar{background:#fff;border-bottom:1px solid rgba(0,0,0,0.10);}
    body.invert .whiteBox{background:#000;}
    body.invert .btn{color:rgba(0,0,0,0.84);border-color:rgba(0,0,0,0.18);}
    body.invert .btn:hover{background:rgba(0,0,0,0.06);border-color:rgba(0,0,0,0.28);}
    body.invert #hud{color:rgba(0,0,0,0.78);}
    body.invert #meter{border-color:rgba(0,0,0,0.22);background:rgba(0,0,0,0.06);}
    body.invert #meterFill{background:rgba(0,0,0,0.55);}
  </style>
</head>

<body>
  <div id="topbar">
    <div id="brand">
      <span class="whiteBox" aria-hidden="true"></span>
      <span>KETADATA // INFINITE CURRENT POOL</span>
    </div>
    <div style="display:flex;gap:8px;align-items:center;">
      <button id="reset" class="btn btnPrimary" type="button">Reset</button>
      <button id="freeze" class="btn" type="button">Toggle Run</button>
    </div>
  </div>

  <div id="stage">
    <canvas id="c"></canvas>
    <div id="fx"></div>
  </div>

  <div id="hud" aria-hidden="true">
    <div class="row"><strong>SPACE</strong> tap: run/stop Â· hold: accelerate</div>
    <div class="row"><strong>I</strong> invert</div>
    <div class="row"><span>THROTTLE</span>
      <span id="meter"><span id="meterFill"></span></span>
    </div>
  </div>

  <script>
    // =========================================================
    // KETADATA // INFINITE CURRENT POOL (fresh build)
    //
    // Controls:
    // - SPACE tap: start/stop
    // - SPACE hold: ramps speed up while held; eases down on release
    // - I: invert
    //
    // Aesthetic:
    // - advected vector-field water, horizon pull, specular streaking,
    //   volumetric mist, camera drift, speed-coupled intensity.
    // =========================================================

    const el = (id)=>document.getElementById(id);
    const canvas = el('c');
    const ctx = canvas.getContext('2d', { alpha:false });

    const meterFill = el('meterFill');
    const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
    const mix = (a,b,t)=>a+(b-a)*t;
    const smoothstep = (a,b,t)=>{ t=clamp((t-a)/(b-a),0,1); return t*t*(3-2*t); };

    // Resize / DPR
    function resize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const w = canvas.clientWidth|0;
      const h = canvas.clientHeight|0;
      canvas.width = Math.floor(w*dpr);
      canvas.height = Math.floor(h*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', resize);

    // Pointer (camera + current influence)
    const pointer = { x:0.5, y:0.56, vx:0, vy:0 };
    const target = { x:0.5, y:0.56 };
    function updatePointer(dt){
      const ax = (target.x - pointer.x) * 2.2;
      const ay = (target.y - pointer.y) * 1.7;
      pointer.vx = (pointer.vx + ax*dt) * 0.90;
      pointer.vy = (pointer.vy + ay*dt) * 0.90;
      pointer.x = clamp(pointer.x + pointer.vx*dt, 0, 1);
      pointer.y = clamp(pointer.y + pointer.vy*dt, 0, 1);
    }
    window.addEventListener('mousemove', (e)=>{
      const r = canvas.getBoundingClientRect();
      target.x = clamp((e.clientX - r.left) / r.width, 0, 1);
      target.y = clamp((e.clientY - r.top) / r.height, 0, 1);
    }, { passive:true });
    window.addEventListener('touchmove', (e)=>{
      if(!e.touches || !e.touches[0]) return;
      const t = e.touches[0];
      const r = canvas.getBoundingClientRect();
      target.x = clamp((t.clientX - r.left) / r.width, 0, 1);
      target.y = clamp((t.clientY - r.top) / r.height, 0, 1);
    }, { passive:true });

    // Hash / noise
    const seed = Math.random()*1000;
    function hash11(x){
      const s = Math.sin(x*127.1 + 311.7 + seed*0.01) * 43758.5453123;
      return s - Math.floor(s);
    }
    function h2(x,y){
      const s = Math.sin(x*127.1 + y*311.7 + seed*0.01) * 43758.5453123;
      return s - Math.floor(s);
    }
    function vnoise(x,y){
      const ix = Math.floor(x), iy = Math.floor(y);
      const fx = x - ix, fy = y - iy;
      const a = h2(ix,iy), b = h2(ix+1,iy), c = h2(ix,iy+1), d = h2(ix+1,iy+1);
      const ux = fx*fx*(3-2*fx);
      const uy = fy*fy*(3-2*fy);
      return mix(mix(a,b,ux), mix(c,d,ux), uy);
    }
    function fbm(x,y){
      // 4-octave fbm
      let v=0, a=0.5;
      for(let i=0;i<4;i++){
        v += a * vnoise(x,y);
        x *= 2.03;
        y *= 2.01;
        a *= 0.5;
      }
      return v;
    }

    // Control state
    let running = true;
    let invert = false;

    let spaceDown = false;
    let spaceTapGuard = false;

    const BASE_SPEED = 1.0;
    const HOLD_SPEED = 6.0;      // more vivid ceiling than prior version
    let speed = BASE_SPEED;
    let speedTarget = BASE_SPEED;

    let worldT = 0;
    let t0 = performance.now();

    // Keybinds
    function isTyping(){
      const tag = document.activeElement?.tagName?.toLowerCase() || '';
      return tag === 'input' || tag === 'textarea' || document.activeElement?.isContentEditable;
    }
    window.addEventListener('keydown', (e)=>{
      if(isTyping()) return;

      if(e.code === 'Space'){
        e.preventDefault();
        if(!spaceTapGuard){
          running = !running; // tap toggles run/stop
          spaceTapGuard = true;
        }
        spaceDown = true; // hold accelerates
      }
      if(e.key === 'i' || e.key === 'I'){
        invert = !invert;
        document.body.classList.toggle('invert', invert);
      }
      if(e.key === 'r' || e.key === 'R'){
        reset();
      }
    });

    window.addEventListener('keyup', (e)=>{
      if(e.code === 'Space'){
        e.preventDefault();
        spaceDown = false;
        spaceTapGuard = false;
      }
    });

    // Buttons
    el('freeze').addEventListener('click', ()=> running = !running);
    el('reset').addEventListener('click', ()=> reset());

    function reset(){
      worldT = 0;
      speed = BASE_SPEED;
      speedTarget = BASE_SPEED;
    }

    function updateSpeed(dt){
      speedTarget = spaceDown ? HOLD_SPEED : BASE_SPEED;
      // faster accel than decel for a "throttle" feel
      const tau = spaceDown ? 0.12 : 0.28;
      const a = 1 - Math.exp(-dt / tau);
      speed += (speedTarget - speed) * a;
      speed = clamp(speed, 0.0, 10.0);

      const thr = clamp((speed - BASE_SPEED)/(HOLD_SPEED - BASE_SPEED), 0, 1);
      meterFill.style.width = (thr*100).toFixed(1) + "%";
    }

    // ===== RENDER =====
    function draw(t){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;

      const thr = clamp((speed - BASE_SPEED)/(HOLD_SPEED - BASE_SPEED), 0, 1);
      const rush = thr*thr; // nonlinear intensity

      // camera drift & micro-zoom (feels like moving forward)
      const camZoom = 1.0 + 0.026*rush + 0.006*Math.sin(t*0.7);
      const camDx = (pointer.x - 0.5) * (18 + 44*rush) + Math.sin(t*0.33)*10;
      const camDy = (pointer.y - 0.5) * (10 + 26*rush) + Math.cos(t*0.28)*7;

      const breath = 0.5 + 0.5*Math.sin(t*0.55);
      const horizon = h * (0.325 + 0.06*(pointer.y-0.5) - 0.012*rush);
      const waterH = h - horizon;

      // SKY
      const sky = ctx.createLinearGradient(0,0,0,horizon);
      sky.addColorStop(0.0, "rgb(0,0,0)");
      sky.addColorStop(0.25, "rgb(3,6,14)");
      sky.addColorStop(0.60, "rgb(10,18,38)");
      sky.addColorStop(1.0, "rgb(18,28,52)");
      ctx.fillStyle = sky;
      ctx.fillRect(0,0,w,horizon);

      // Sky columns (more alive with rush)
      ctx.save();
      ctx.globalAlpha = (0.14 + 0.10*breath) * (1.0 + 0.9*rush);
      for(let i=0;i<64;i++){
        const n = hash11(i*19.7);
        const x = (i/63)*w;
        const width = 8 + 52*n;
        const y1 = horizon*(0.65 + 0.30*n);
        const g = ctx.createLinearGradient(0,0,0,y1);
        g.addColorStop(0, "rgba(255,255,255,0.00)");
        g.addColorStop(0.30, `rgba(180,210,255,${0.06 + 0.20*n + 0.10*rush*n})`);
        g.addColorStop(1, "rgba(255,255,255,0.00)");
        ctx.fillStyle = g;
        const wob = Math.sin(t*(0.85 + 1.2*rush) + i*0.9) * (2 + 16*n + 12*rush*n);
        ctx.fillRect(x+wob, 0, width, y1);
      }
      ctx.restore();

      // Horizon edge (pressure line)
      ctx.save();
      ctx.globalAlpha = 0.72 + 0.22*rush;
      const band = 12 + 12*rush;
      const edge = ctx.createLinearGradient(0,horizon-band,0,horizon+band);
      edge.addColorStop(0, "rgba(0,0,0,0.00)");
      edge.addColorStop(0.28, "rgba(0,0,0,0.80)");
      edge.addColorStop(0.52, `rgba(255,255,255,${0.04 + 0.08*rush})`);
      edge.addColorStop(0.82, "rgba(0,0,0,0.92)");
      edge.addColorStop(1, "rgba(0,0,0,0.00)");
      ctx.fillStyle = edge;
      ctx.fillRect(0, horizon-band, w, band*2);
      ctx.restore();

      // WATER BASE
      const water = ctx.createLinearGradient(0,horizon,0,h);
      water.addColorStop(0.00, "rgb(6,14,28)");
      water.addColorStop(0.22, "rgb(4,12,26)");
      water.addColorStop(0.62, "rgb(2,7,16)");
      water.addColorStop(1.00, "rgb(0,0,0)");
      ctx.fillStyle = water;
      ctx.fillRect(0,horizon,w,waterH);

      // ===== INFINITE CURRENT FIELD =====
      // We define a strong upward pull toward horizon + curl, and we advect ripples through it.
      const px = (pointer.x - 0.5) * 2;
      const py = (pointer.y - 0.5) * 2;

      const bands = Math.floor(110 + 90*rush);
      const stepX = 7; // performance knob

      const amp = (10 + 22*breath) * (1.0 + 0.95*rush);
      const adv = 0.10 + 0.42*rush;
      const warp = 0.35 + 1.35*rush;

      // Caustic lines
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(190,220,255,0.08)";

      for(let i=0;i<bands;i++){
        const yy0 = horizon + (i/(bands-1))*waterH;
        const depth = (yy0 - horizon) / waterH; // 0..1
        const pull = (1 - depth);               // 1 near horizon, 0 near bottom

        // shape activity: strong mid-depth + horizon compression when rushing
        const fade = smoothstep(0.02, 0.32, depth) * (1 - smoothstep(0.70 - 0.12*rush, 1.0, depth));
        if(fade < 0.003) continue;

        const driftT = t * (1.2 + 2.3*rush);

        // global alpha per band
        ctx.globalAlpha = (0.035 + 0.14*fade) * (0.72 + 0.34*breath) * (1.0 + 0.95*rush);

        ctx.beginPath();
        for(let x=0;x<=w;x+=stepX){
          // camera transform
          const xCam = (x - camDx) / camZoom;
          const yCam = (yy0 - camDy) / camZoom;

          const nx = xCam / Math.max(1,w);
          const ny = (yCam - horizon) / Math.max(1,waterH);

          // flow field
          const n = fbm(nx*5.0 + driftT*0.10, ny*6.0 - driftT*0.16);
          const curl = Math.sin((nx*6.0 + ny*2.9) + driftT*0.42 + px*0.8) * (0.10 + 0.28*rush);

          const flowX = curl + (n-0.5) * (0.10 + 0.30*rush) + px*0.06;
          const flowY = -(0.34 + 0.92*pull) * (0.55 + 0.85*rush) + (n-0.5) * (0.05 + 0.16*rush);

          // advected coordinates
          const ax = nx + flowX * adv;
          const ay = ny + flowY * adv;

          const p1 = (ax*10.0 + ay*8.0)  + driftT*1.35 + i*0.075;
          const p2 = (ax*6.4  + ay*11.0) + driftT*0.92 + i*0.045;
          const p3 = (ax*14.0 - ay*5.0)  + driftT*0.55 + i*0.022;

          let yy =
            yy0
            + Math.sin(p1 + px*1.2) * amp * (0.11 + 0.58*fade)
            + Math.sin(p2 + py*0.9) * amp * (0.05 + 0.33*fade)
            + Math.sin(p3) * (0.7 + 2.0*fade);

          // infinite conveyor projection toward horizon
          const proj = (0.86 + 1.2*rush) * (pull*pull) * warp;
          const yyProj = yy - proj * (18 + 56*rush);

          // mix projection: more at speed
          yy = mix(yy, yyProj, 0.34 + 0.34*rush);

          if(x===0) ctx.moveTo(x, yy);
          else ctx.lineTo(x, yy);
        }
        ctx.stroke();
      }
      ctx.restore();

      // Specular streaks (speed stretches them)
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.globalAlpha = (0.12 + 0.12*breath) * (1.0 + 1.05*rush);

      const streakCount = Math.floor(220 + 320*rush);
      for(let i=0;i<streakCount;i++){
        const n1 = hash11(i*33.3);
        const n2 = hash11(i*91.7);
        const x0 = n1*w;
        const y0 = horizon + n2*waterH;

        const d = (y0-horizon)/waterH;
        const closeness = (1-d);

        const baseLen = 10 + 92*closeness*(0.30+n1*0.70);
        const len = baseLen * (1.0 + 1.55*rush) * (0.85 + 0.25*Math.sin(t*(0.9+1.2*rush) + i));

        const a = (0.02 + 0.22*closeness) * (0.35 + 0.65*hash11(i*17.1)) * (1.0 + 0.75*rush);
        ctx.fillStyle = `rgba(205,225,255,${a})`;

        const sx = ((x0 - camDx)/camZoom)
          + Math.sin(t*(0.85 + 1.55*rush) + i)* (2 + 16*closeness + 14*rush*closeness)
          + (pointer.x-0.5)*24*closeness;

        const sy = ((y0 - camDy)/camZoom)
          + Math.cos(t*(0.65 + 1.25*rush) + i)* (1 + 8*closeness);

        ctx.fillRect(sx, sy, len, 1);
      }
      ctx.restore();

      // Volumetric mist at horizon (pressure builds with speed)
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      const mg = ctx.createLinearGradient(0, horizon-70, 0, horizon+180);
      mg.addColorStop(0, "rgba(255,255,255,0.00)");
      mg.addColorStop(0.42, `rgba(170,200,255,${0.09 + 0.12*breath + 0.12*rush})`);
      mg.addColorStop(1, "rgba(255,255,255,0.00)");
      ctx.fillStyle = mg;
      ctx.globalAlpha = 0.75 + 0.24*rush;
      ctx.fillRect(0, horizon-70, w, 250);
      ctx.restore();

      // Grain (tactile, speed-coupled)
      ctx.save();
      ctx.globalCompositeOperation = "overlay";
      ctx.globalAlpha = 0.07 + 0.11*rush;
      const step = 2;
      const tt = t * (70 + 160*rush);
      for(let y=0;y<h;y+=step){
        for(let x=0;x<w;x+=step){
          const n = hash11((x*12.9898 + y*78.233 + tt)*0.01);
          if(n>0.78){
            ctx.fillStyle = `rgba(255,255,255,${0.02 + 0.06*n})`;
            ctx.fillRect(x,y,1,1);
          }
        }
      }
      ctx.restore();

      // Subtle blackout at extreme bottom (depth)
      ctx.save();
      const depthV = ctx.createLinearGradient(0, horizon + waterH*0.65, 0, h);
      depthV.addColorStop(0, "rgba(0,0,0,0.00)");
      depthV.addColorStop(1, "rgba(0,0,0,0.55)");
      ctx.fillStyle = depthV;
      ctx.fillRect(0, horizon + waterH*0.65, w, h-(horizon+waterH*0.65));
      ctx.restore();
    }

    function loop(now){
      const dt = Math.min(0.05, (now - t0)/1000);
      t0 = now;

      updatePointer(dt);
      updateSpeed(dt);

      if(running) worldT += dt * speed;

      draw(worldT);
      requestAnimationFrame(loop);
    }

    // init
    resize();
    document.body.classList.toggle('invert', invert);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
