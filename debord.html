<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA — DEBORD INTERFACE (DÉRIVE / PSYCHOGEOGRAPHY ENGINE)</title>
  <style>
    :root{
      --bg:#000;
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.56);
      --panel:rgba(0,0,0,.55);
      --hair:rgba(255,255,255,.14);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      overflow:hidden;
      background:var(--bg);
      color:var(--fg);
      font-family: Arial, Helvetica, sans-serif;
    }
    canvas{ position:fixed; inset:0; width:100vw; height:100vh; display:block; }

    .hud{
      position:fixed; left:18px; top:16px;
      user-select:none; pointer-events:none;
      mix-blend-mode:screen;
    }
    .brand{
      font-weight:900;
      letter-spacing:.18em;
      text-transform:uppercase;
      font-size:15px;
      text-shadow:0 0 18px rgba(255,255,255,.18);
    }
    .sub{
      margin-top:4px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:var(--muted);
      line-height:1.25;
    }

    .dock{
      position:fixed; left:18px; bottom:16px;
      display:flex; flex-wrap:wrap;
      gap:10px; align-items:center;
      pointer-events:auto;
    }
    .btn{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.22);
      color:rgba(255,255,255,.86);
      padding:10px 12px;
      border-radius:10px;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .btn:hover{ background:rgba(255,255,255,.10); border-color:rgba(255,255,255,.36); transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }

    .panel{
      position:fixed; right:16px; top:16px;
      width:min(640px, calc(100vw - 32px));
      max-height: calc(100vh - 32px);
      overflow:auto;
      border:1px solid rgba(255,255,255,.18);
      background:var(--panel);
      backdrop-filter: blur(10px);
      border-radius:14px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset, 0 16px 50px rgba(0,0,0,.65);
    }
    .panelHeader{
      position:sticky; top:0;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.72);
      backdrop-filter: blur(10px);
      display:flex; justify-content:space-between; align-items:center;
      z-index:10;
    }
    .title{
      font-weight:900;
      letter-spacing:.14em;
      font-size:11px;
      text-transform:uppercase;
      color:rgba(255,255,255,.86);
    }
    .hint{
      font-size:11px;
      letter-spacing:.08em;
      color:rgba(255,255,255,.55);
      text-align:right;
      line-height:1.2;
    }
    .note{
      font-size:11px;
      color:rgba(255,255,255,.55);
      line-height:1.35;
      letter-spacing:.02em;
      padding:10px 12px 0;
    }
    .panelBody{ padding:10px 12px 14px; display:flex; flex-direction:column; gap:10px; }

    .block{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      overflow:hidden;
      background:rgba(255,255,255,.02);
    }
    .block h3{
      margin:0;
      padding:10px 10px;
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:rgba(255,255,255,.75);
      border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      display:flex; justify-content:space-between; align-items:center;
    }
    .pill{
      font-size:10px;
      letter-spacing:.10em;
      text-transform:uppercase;
      color:rgba(255,255,255,.62);
      border:1px solid rgba(255,255,255,.18);
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.20);
      white-space:nowrap;
    }

    .rows{ padding:10px; display:flex; flex-direction:column; gap:10px; }
    .row{
      display:grid;
      grid-template-columns: 220px 1fr 70px;
      gap:10px;
      align-items:center;
    }
    .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:rgba(255,255,255,.62);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    input[type="range"]{ width:100%; accent-color: rgba(255,255,255,.92); }
    .val{ font-variant-numeric: tabular-nums; font-size:11px; color:rgba(255,255,255,.76); text-align:right; }

    .toggles{ display:flex; flex-wrap:wrap; gap:8px; padding:10px; border-top:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.10); }
    .toggle{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }
    .toggle span{
      font-size:11px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:rgba(255,255,255,.78);
      white-space:nowrap;
    }

    .status{
      padding:10px;
      border-top:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.12);
      display:flex; flex-direction:column; gap:8px;
    }
    .mono{
      font-variant-numeric: tabular-nums;
      letter-spacing:.10em;
      text-transform:uppercase;
      font-size:10px;
      color:rgba(255,255,255,.72);
      line-height:1.35;
    }
    .prompt{
      font-size:11px;
      color:rgba(255,255,255,.80);
      line-height:1.35;
      letter-spacing:.02em;
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      background:rgba(0,0,0,.45);
      padding:10px 10px;
      white-space:pre-wrap;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="brand">KETADATA</div>
    <div class="sub">DEBORD MODE · DÉRIVE ENGINE · AFFECT MAP · UNITÉS D’AMBIANCE</div>
  </div>

  <div class="dock">
    <button class="btn" id="invert">INVERT</button>
    <button class="btn" id="pause">PAUSE</button>
    <button class="btn" id="newCity">NEW CITY</button>
    <button class="btn" id="promptBtn">PROMPT</button>
    <button class="btn" id="reset">RESET</button>
  </div>

  <div class="panel" id="panel">
    <div class="panelHeader">
      <div class="title">DÉRIVE CONTROLS</div>
      <div class="hint">
        CLICK = DROP AMBIENCE · SHIFT+CLICK = PIN AMBIENCE<br/>
        DRAG = PAN · SCROLL = ZOOM<br/>
        [H] PANEL · [I] INVERT · [P] PAUSE
      </div>
    </div>

    <div class="note">
      This is not a map. It’s a field of pulls. You drift through attraction/repulsion “quarters,”
      then cut across boundaries to reveal the city’s psychological relief.
    </div>

    <div class="panelBody">
      <div class="block">
        <h3>Dérive <span class="pill">movement</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">time scale (slow-mo)</div>
            <input id="timeScale" type="range" min="0.000" max="2.000" step="0.001" value="0.45">
            <div class="val" id="timeScaleV">0.450</div>
          </div>
          <div class="row">
            <div class="label">drift force</div>
            <input id="drift" type="range" min="0.00" max="2.50" step="0.01" value="0.95">
            <div class="val" id="driftV">0.95</div>
          </div>
          <div class="row">
            <div class="label">boundary crossing</div>
            <input id="cross" type="range" min="0.00" max="1.00" step="0.01" value="0.55">
            <div class="val" id="crossV">0.55</div>
          </div>
          <div class="row">
            <div class="label">chance (dice noise)</div>
            <input id="chance" type="range" min="0.00" max="1.00" step="0.01" value="0.32">
            <div class="val" id="chanceV">0.32</div>
          </div>
          <div class="row">
            <div class="label">trace (memory)</div>
            <input id="trace" type="range" min="0.000" max="0.22" step="0.001" value="0.055">
            <div class="val" id="traceV">0.055</div>
          </div>
          <div class="row">
            <div class="label">zoom</div>
            <input id="zoom" type="range" min="0.55" max="2.60" step="0.01" value="1.20">
            <div class="val" id="zoomV">1.20</div>
          </div>
        </div>
      </div>

      <div class="block">
        <h3>Situation Construction <span class="pill">détournement</span></h3>
        <div class="rows">
          <div class="row">
            <div class="label">attraction ↔ repulsion</div>
            <input id="attrRep" type="range" min="0" max="1" step="0.01" value="0.62">
            <div class="val" id="attrRepV">0.62</div>
          </div>
          <div class="row">
            <div class="label">spectacle pressure</div>
            <input id="spectacle" type="range" min="0" max="1" step="0.01" value="0.40">
            <div class="val" id="spectacleV">0.40</div>
          </div>
          <div class="row">
            <div class="label">derive radius (city scale)</div>
            <input id="scale" type="range" min="0.40" max="3.60" step="0.01" value="1.55">
            <div class="val" id="scaleV">1.55</div>
          </div>
          <div class="row">
            <div class="label">grid strictness</div>
            <input id="grid" type="range" min="0" max="1" step="0.01" value="0.55">
            <div class="val" id="gridV">0.55</div>
          </div>
        </div>

        <div class="toggles">
          <label class="toggle"><input id="T_city" type="checkbox" checked><span>city grid</span></label>
          <label class="toggle"><input id="T_fields" type="checkbox" checked><span>affect fields</span></label>
          <label class="toggle"><input id="T_path" type="checkbox" checked><span>drift trace</span></label>
          <label class="toggle"><input id="T_nodes" type="checkbox" checked><span>ambience nodes</span></label>
          <label class="toggle"><input id="T_labels" type="checkbox" checked><span>labels</span></label>
        </div>

        <div class="status">
          <div class="mono" id="statLine">—</div>
          <div class="prompt" id="prompt">PROMPT: Click “PROMPT” to issue a dérive instruction.</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha:false });

      let W=0, H=0, DPR=Math.min(2, window.devicePixelRatio||1);
      function resize(){
        W=innerWidth; H=innerHeight;
        canvas.width = Math.floor(W*DPR);
        canvas.height = Math.floor(H*DPR);
        canvas.style.width = W+'px';
        canvas.style.height = H+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize);
      resize();

      const $ = (id)=>document.getElementById(id);

      const ui = {
        timeScale: $('timeScale'),
        drift: $('drift'),
        cross: $('cross'),
        chance: $('chance'),
        trace: $('trace'),
        zoom: $('zoom'),
        attrRep: $('attrRep'),
        spectacle: $('spectacle'),
        scale: $('scale'),
        grid: $('grid'),
        T_city: $('T_city'),
        T_fields: $('T_fields'),
        T_path: $('T_path'),
        T_nodes: $('T_nodes'),
        T_labels: $('T_labels')
      };
      const vv = {
        timeScaleV: $('timeScaleV'),
        driftV: $('driftV'),
        crossV: $('crossV'),
        chanceV: $('chanceV'),
        traceV: $('traceV'),
        zoomV: $('zoomV'),
        attrRepV: $('attrRepV'),
        spectacleV: $('spectacleV'),
        scaleV: $('scaleV'),
        gridV: $('gridV')
      };

      function sync(){
        vv.timeScaleV.textContent = (+ui.timeScale.value).toFixed(3);
        vv.driftV.textContent = (+ui.drift.value).toFixed(2);
        vv.crossV.textContent = (+ui.cross.value).toFixed(2);
        vv.chanceV.textContent = (+ui.chance.value).toFixed(2);
        vv.traceV.textContent = (+ui.trace.value).toFixed(3);
        vv.zoomV.textContent = (+ui.zoom.value).toFixed(2);
        vv.attrRepV.textContent = (+ui.attrRep.value).toFixed(2);
        vv.spectacleV.textContent = (+ui.spectacle.value).toFixed(2);
        vv.scaleV.textContent = (+ui.scale.value).toFixed(2);
        vv.gridV.textContent = (+ui.grid.value).toFixed(2);
      }
      Object.values(ui).forEach(el=>{
        if (!el || !el.addEventListener) return;
        el.addEventListener('input', sync);
        el.addEventListener('change', sync);
      });
      sync();

      function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
      function lerp(a,b,t){ return a + (b-a)*t; }
      function hash32(n){
        n = (n ^ (n >>> 16)) >>> 0;
        n = Math.imul(n, 2246822519) >>> 0;
        n = (n ^ (n >>> 13)) >>> 0;
        n = Math.imul(n, 3266489917) >>> 0;
        n = (n ^ (n >>> 16)) >>> 0;
        return n >>> 0;
      }
      function rnd01(n){ return hash32(n) / 4294967295; }

      const st = {
        t:0,
        invert:false,
        paused:false,
        seed:(Math.random()*1e9)|0,
        ox:0, oy:0,
        drag:false,
        lx:0, ly:0,
        wheel:0,
        zoom:1.0,
        walker: { x:0, y:0, vx:0.1, vy:0.0, heat:1.0 },
        steps:0,
      };

      // “Unités d’ambiance” as nodes: each has pull (+) or push (-)
      const nodes = []; // {x,y,str,r,name,pin,heat}
      const nodeNames = [
        "LOBBY","PASSAGE","PLAZA","STAIRWELL","WATERLINE","ALLEY","LIBRARY","CINEMA",
        "MARKET","VAULT","TEMPLE","STUDIO","LAB","OBSERVATORY","OVERLOOK","UNDERPASS"
      ];

      function worldToScreen(wx,wy){
        const S = Math.min(W,H) * 0.62 * st.zoom * (+ui.scale.value);
        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;
        return { x: cx + wx*S, y: cy + wy*S };
      }
      function screenToWorld(sx,sy){
        const S = Math.min(W,H) * 0.62 * st.zoom * (+ui.scale.value);
        const cx = W*0.5 + st.ox;
        const cy = H*0.5 + st.oy;
        return { x: (sx-cx)/S, y: (sy-cy)/S };
      }

      function newCity(){
        st.seed = (Math.random()*1e9)|0;
        nodes.length = 0;
        st.walker.x = 0; st.walker.y = 0;
        st.walker.vx = 0.22; st.walker.vy = 0.0;
        st.steps = 0;

        // Seed nodes in a rough ring + interior
        const N = 10 + Math.floor(rnd01(st.seed^0x1234)*8);
        for (let i=0;i<N;i++){
          const a = rnd01(st.seed + i*91) * Math.PI*2;
          const rr = Math.sqrt(rnd01(st.seed + i*151)) * 0.75;
          const x = Math.cos(a)*rr;
          const y = Math.sin(a)*rr;

          // sign: attraction vs repulsion (balanced by slider)
          const bias = +ui.attrRep.value; // >0.5 = more attraction
          const sign = (rnd01(st.seed + i*211) < bias) ? 1 : -1;

          nodes.push({
            x, y,
            str: sign * lerp(0.18, 0.95, rnd01(st.seed + i*271)),
            r: lerp(0.08, 0.22, rnd01(st.seed + i*331)),
            name: nodeNames[i % nodeNames.length],
            pin:false,
            heat:0.7
          });
        }

        // Add “spectacle” gravity wells if spectacle pressure is high
        const sp = +ui.spectacle.value;
        const extra = Math.floor(lerp(0, 6, sp));
        for (let k=0;k<extra;k++){
          const a = rnd01(st.seed + 900 + k*77) * Math.PI*2;
          const rr = lerp(0.12, 0.62, rnd01(st.seed + 901 + k*99));
          nodes.push({
            x: Math.cos(a)*rr,
            y: Math.sin(a)*rr,
            str: lerp(0.55, 1.25, sp), // strong attraction
            r: lerp(0.10, 0.26, sp),
            name: "SPECTACLE",
            pin:false,
            heat:0.9
          });
        }

        issuePrompt();
      }

      function hitNode(sx,sy){
        const p = screenToWorld(sx,sy);
        let best=-1, bd=1e9;
        for (let i=0;i<nodes.length;i++){
          const n = nodes[i];
          const dx = n.x - p.x, dy = n.y - p.y;
          const d2 = dx*dx + dy*dy;
          if (d2 < 0.020 && d2 < bd){ bd=d2; best=i; }
        }
        return best;
      }

      // Drift trace
      const path = []; // {x,y}
      function pushPath(){
        path.push({x:st.walker.x, y:st.walker.y});
        if (path.length > 1400) path.shift();
      }

      // Prompts (Debord/Situationist derived instructions)
      const promptBank = [
        "Go where the street narrows. Follow the smallest opening you can find. Stay there until the urge changes.",
        "Choose the most fluorescent direction. Walk until it becomes boring, then cut across to the opposite mood.",
        "Avoid all obvious routes. If you recognize anything, turn 90°.",
        "Follow echoes: move toward the loudest imagined sound. When you reach it, reverse.",
        "Seek a threshold: doorways, stairs, bridges, tunnels. Spend 3 minutes inside the boundary.",
        "Make a map of repulsions: mark what you refuse. Navigate by refusal.",
        "Treat signage as orders from an alien bureaucracy. Obey three; sabotage one.",
        "Move only along edges. Do not enter centers. Orbit them.",
        "Pick a ‘unit of ambience’ and amplify it. Then detach: cross into its negation.",
        "Find the spectacle. Observe. Then exit by the least dramatic route.",
      ];

      function issuePrompt(){
        const i = Math.floor(rnd01(st.seed + ((st.t*1000)|0) + st.steps*17) * promptBank.length);
        $('prompt').textContent = "PROMPT: " + promptBank[i];
      }

      // UI buttons
      $('invert').onclick = ()=> st.invert = !st.invert;
      $('pause').onclick = ()=> st.paused = !st.paused;
      $('newCity').onclick = ()=> newCity();
      $('promptBtn').onclick = ()=> issuePrompt();
      $('reset').onclick = ()=>{
        st.t=0; st.invert=false; st.paused=false; st.ox=0; st.oy=0; st.wheel=0; st.zoom=1.0;
        ui.timeScale.value=0.45; ui.drift.value=0.95; ui.cross.value=0.55; ui.chance.value=0.32;
        ui.trace.value=0.055; ui.zoom.value=1.20; ui.attrRep.value=0.62; ui.spectacle.value=0.40;
        ui.scale.value=1.55; ui.grid.value=0.55;
        sync();
        newCity();
      };

      addEventListener('keydown', (e)=>{
        if (e.key==='i' || e.key==='I') st.invert = !st.invert;
        if (e.key==='p' || e.key==='P') st.paused = !st.paused;
        if (e.key==='h' || e.key==='H'){
          const panel = document.getElementById('panel');
          panel.style.display = (panel.style.display === 'none') ? '' : 'none';
        }
        if (e.key==='n' || e.key==='N') newCity();
        if (e.key==='g' || e.key==='G') issuePrompt();
      });

      addEventListener('wheel', (e)=>{
        const d = Math.max(-160, Math.min(160, e.deltaY));
        st.wheel += (-d/160) * 0.18;
        st.wheel = clamp(st.wheel, -0.85, 0.95);
      }, { passive:true });

      addEventListener('pointerdown', (e)=>{
        // Pan begins
        st.drag=true; st.lx=e.clientX; st.ly=e.clientY;

        const hit = hitNode(e.clientX, e.clientY);
        if (hit !== -1){
          if (e.shiftKey){
            nodes[hit].pin = !nodes[hit].pin;
            nodes[hit].heat = 1.2;
          } else {
            // pulse node (intensify)
            nodes[hit].heat = 1.4;
            nodes[hit].str *= 1.08;
          }
          return;
        }

        // Drop a new ambience node at click
        const p = screenToWorld(e.clientX, e.clientY);
        const bias = +ui.attrRep.value;
        const sign = (rnd01(st.seed + nodes.length*999) < bias) ? 1 : -1;
        const strength = sign * lerp(0.22, 0.95, rnd01(st.seed + nodes.length*111));
        nodes.push({
          x:p.x, y:p.y,
          str: strength,
          r: lerp(0.09, 0.20, rnd01(st.seed + nodes.length*131)),
          name: nodeNames[nodes.length % nodeNames.length],
          pin:false,
          heat:1.1
        });
      });

      addEventListener('pointerup', ()=> st.drag=false);
      addEventListener('pointercancel', ()=> st.drag=false);
      addEventListener('pointermove', (e)=>{
        if (!st.drag) return;
        const dx = e.clientX - st.lx;
        const dy = e.clientY - st.ly;
        st.lx=e.clientX; st.ly=e.clientY;
        st.ox += dx;
        st.oy += dy;
        st.ox = clamp(st.ox, -W*0.60, W*0.60);
        st.oy = clamp(st.oy, -H*0.60, H*0.60);
      });

      function step(dt){
        // zoom smoothing
        st.wheel *= 0.88;
        st.zoom += st.wheel;
        st.zoom = clamp(st.zoom, 0.55, 2.60);
        // also sync zoom slider for clarity (UI sets base; wheel adds transient)
        // keep the slider as "base", and st.zoom as actual.
        const baseZ = +ui.zoom.value;
        st.zoom = clamp(st.zoom, 0.55, 2.60);
        // gently pull actual zoom toward baseZ so slider remains meaningful
        st.zoom = lerp(st.zoom, baseZ, clamp(dt*0.9, 0, 1));

        const drift = +ui.drift.value;
        const cross = +ui.cross.value;
        const chance = +ui.chance.value;
        const grid = +ui.grid.value;
        const spectacle = +ui.spectacle.value;

        // City grid creates canals: in high grid strictness, movement snaps to street vectors.
        // In low grid strictness, movement is free-form.
        const gridAngle = (Math.PI/2) * Math.round((Math.sin(st.t*0.12) + 1)*2) / 2; // 0, 45, 90-ish drift of the whole city
        const g0x = Math.cos(gridAngle), g0y = Math.sin(gridAngle);
        const g1x = -g0y, g1y = g0x;

        // Affect field sum
        let ax=0, ay=0;
        for (let i=0;i<nodes.length;i++){
          const n = nodes[i];

          // heat decay
          n.heat *= Math.pow(0.12, dt*0.25);

          const dx = n.x - st.walker.x;
          const dy = n.y - st.walker.y;
          const d2 = dx*dx + dy*dy + 1e-6;
          const d = Math.sqrt(d2);

          // radial field with soft radius + boundary effect
          const R = n.r;
          const fall = 1 / (1 + (d/(R+0.0001))*(d/(R+0.0001)));
          // boundary crossing: when cross is low, you get “trapped” near local minima (stronger fall); when high, far fields matter more
          const field = fall * lerp(1.35, 0.85, cross);

          const strength = n.str * field;
          ax += (dx/d) * strength;
          ay += (dy/d) * strength;
        }

        // Chance: dice noise that occasionally overrides with a perpendicular cut
        const dice = (rnd01(st.seed + ((st.t*1000)|0) + st.steps*37) - 0.5) * 2;
        const cut = (rnd01(st.seed + ((st.t*777)|0) + st.steps*91) < (chance*0.12 + spectacle*0.05));

        // Base “derive” direction: follow gradient, but with anti-goal (don’t converge too hard)
        // We add a tangential component so you orbit ambiences rather than simply homing.
        const gd = Math.sqrt(ax*ax + ay*ay) + 1e-6;
        const tx = -ay/gd, ty = ax/gd; // tangential
        const orbitMix = lerp(0.20, 0.55, cross); // boundary crossing increases tangential roaming

        let vx = (ax/gd) * (1-orbitMix) + tx * orbitMix;
        let vy = (ay/gd) * (1-orbitMix) + ty * orbitMix;

        // If field is weak, wander (derive without attractor)
        if (gd < 0.06){
          vx = Math.cos(st.t*0.9 + dice*2.0);
          vy = Math.sin(st.t*0.8 + dice*2.0);
        }

        // Apply chance cuts
        if (cut){
          const px = -vy, py = vx;
          vx = lerp(vx, px, clamp(0.65 + 0.35*chance, 0, 1));
          vy = lerp(vy, py, clamp(0.65 + 0.35*chance, 0, 1));
        }

        // Grid snapping (streets): project motion onto nearest axis when grid strictness is high
        const dot0 = vx*g0x + vy*g0y;
        const dot1 = vx*g1x + vy*g1y;
        const snapTo0 = Math.abs(dot0) > Math.abs(dot1);
        const sx = snapTo0 ? g0x*Math.sign(dot0) : g1x*Math.sign(dot1);
        const sy = snapTo0 ? g0y*Math.sign(dot0) : g1y*Math.sign(dot1);
        vx = lerp(vx, sx, grid);
        vy = lerp(vy, sy, grid);

        // normalize
        const vn = Math.sqrt(vx*vx + vy*vy) + 1e-6;
        vx /= vn; vy /= vn;

        // speed
        const speed = drift * (0.08 + 0.12*(1-grid) + 0.08*chance);
        st.walker.vx = lerp(st.walker.vx, vx*speed, clamp(dt*2.0,0,1));
        st.walker.vy = lerp(st.walker.vy, vy*speed, clamp(dt*2.0,0,1));

        st.walker.x += st.walker.vx * dt;
        st.walker.y += st.walker.vy * dt;

        // soft bounds with wrap (city is “endless”)
        const B = 0.95;
        if (st.walker.x < -B) st.walker.x += 2*B;
        if (st.walker.x >  B) st.walker.x -= 2*B;
        if (st.walker.y < -B) st.walker.y += 2*B;
        if (st.walker.y >  B) st.walker.y -= 2*B;

        st.steps += 1;

        // periodically push trace point
        if ((st.steps % 3) === 0) pushPath();

        // status line
        const attractCount = nodes.filter(n => n.str > 0).length;
        const repelCount = nodes.length - attractCount;
        $('statLine').textContent =
          `AMBIENCES: ${nodes.length} (ATTR ${attractCount} / REP ${repelCount}) · STEP ${st.steps} · GRID ${(grid).toFixed(2)} · CROSS ${(cross).toFixed(2)}`;
      }

      function draw(){
        const inv = st.invert;
        const bg = inv ? 255 : 0;
        const fg = inv ? 0 : 255;

        const trace = +ui.trace.value;

        if (trace > 0){
          ctx.fillStyle = `rgba(${bg},${bg},${bg},${clamp(trace,0,1)})`;
          ctx.fillRect(0,0,W,H);
        } else {
          ctx.fillStyle = `rgb(${bg},${bg},${bg})`;
          ctx.fillRect(0,0,W,H);
        }

        // In invert mode: keep source-over so black shows
        ctx.globalCompositeOperation = inv ? 'source-over' : 'screen';

        const grid = +ui.grid.value;
        const chance = +ui.chance.value;
        const spectacle = +ui.spectacle.value;
        const S = Math.min(W,H) * 0.62 * st.zoom * (+ui.scale.value);

        // City grid: streets + blocks
        if (ui.T_city.checked){
          const cell = lerp(88, 38, grid) * (1/Math.max(0.65, st.zoom));
          const a = clamp(0.03 + 0.10*grid, 0, 0.22);
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
          ctx.lineWidth = 1;

          // slight rotation / drift gives psychogeographic instability
          const rot = (Math.sin(st.t*0.10) * 0.12 + Math.cos(st.t*0.07) * 0.08) * (0.25 + 0.75*chance);
          ctx.save();
          ctx.translate(W*0.5 + st.ox, H*0.5 + st.oy);
          ctx.rotate(rot);
          ctx.translate(-(W*0.5 + st.ox), -(H*0.5 + st.oy));

          for (let x=-cell*2; x<W+cell*2; x+=cell){
            ctx.beginPath();
            ctx.moveTo(x, -cell*2);
            ctx.lineTo(x, H+cell*2);
            ctx.stroke();
          }
          for (let y=-cell*2; y<H+cell*2; y+=cell){
            ctx.beginPath();
            ctx.moveTo(-cell*2, y);
            ctx.lineTo(W+cell*2, y);
            ctx.stroke();
          }
          ctx.restore();
        }

        // Affect fields (contours)
        if (ui.T_fields.checked){
          const density = Math.floor(lerp(120, 260, clamp(chance + spectacle*0.6,0,1)));
          ctx.lineWidth = 1;

          for (let i=0;i<density;i++){
            const r1 = rnd01(st.seed + i*19 + ((st.t*1000)|0));
            const r2 = rnd01(st.seed + i*41 + 777);
            const ang = r1*Math.PI*2;
            const rr = Math.sqrt(r2) * Math.min(W,H) * 0.55;

            const x = (W*0.5 + st.ox) + Math.cos(ang)*rr;
            const y = (H*0.5 + st.oy) + Math.sin(ang)*rr;

            // sample "field" strength by nearest node influence
            const p = screenToWorld(x,y);
            let fx=0, fy=0, mag=0;
            for (let k=0;k<nodes.length;k++){
              const n = nodes[k];
              const dx = n.x - p.x;
              const dy = n.y - p.y;
              const d2 = dx*dx + dy*dy + 1e-6;
              const d = Math.sqrt(d2);
              const fall = 1 / (1 + (d/(n.r+0.0001))*(d/(n.r+0.0001)));
              const s = n.str * fall;
              fx += (dx/d) * s;
              fy += (dy/d) * s;
              mag += Math.abs(s);
            }
            const m = Math.sqrt(fx*fx+fy*fy) + 1e-6;
            const tx = -fy/m, ty = fx/m;

            const len = lerp(10, 46, clamp(mag,0,1)) * (0.55 + 0.65*chance);
            const alpha = clamp(0.015 + 0.08*clamp(mag,0,1), 0, 0.25);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${alpha})`;

            ctx.beginPath();
            ctx.moveTo(x - tx*len, y - ty*len);
            ctx.lineTo(x + tx*len, y + ty*len);
            ctx.stroke();
          }
        }

        // Drift trace
        if (ui.T_path.checked && path.length > 2){
          ctx.lineWidth = 1.2;
          ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.24})`;
          ctx.beginPath();
          for (let i=0;i<path.length;i++){
            const p = worldToScreen(path[i].x, path[i].y);
            if (i===0) ctx.moveTo(p.x,p.y);
            else ctx.lineTo(p.x,p.y);
          }
          ctx.stroke();
        }

        // Ambience nodes
        if (ui.T_nodes.checked){
          for (let i=0;i<nodes.length;i++){
            const n = nodes[i];
            const p = worldToScreen(n.x, n.y);
            const sign = n.str >= 0 ? 1 : -1;
            const heat = clamp(n.heat, 0, 1.5);
            const r = (10 + 18*Math.abs(n.r) + 10*heat) * (0.7 + 0.4*st.zoom*0.2);

            // outline
            ctx.lineWidth = 1.2;
            const a = clamp(0.16 + 0.25*Math.abs(n.str) + 0.25*heat, 0, 0.75);
            ctx.strokeStyle = `rgba(${fg},${fg},${fg},${a})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, r*0.55, 0, Math.PI*2);
            ctx.stroke();

            // sign mark (attract = +, repel = ×)
            ctx.beginPath();
            if (sign > 0){
              ctx.moveTo(p.x-r*0.25, p.y);
              ctx.lineTo(p.x+r*0.25, p.y);
              ctx.moveTo(p.x, p.y-r*0.25);
              ctx.lineTo(p.x, p.y+r*0.25);
            } else {
              ctx.moveTo(p.x-r*0.22, p.y-r*0.22);
              ctx.lineTo(p.x+r*0.22, p.y+r*0.22);
              ctx.moveTo(p.x-r*0.22, p.y+r*0.22);
              ctx.lineTo(p.x+r*0.22, p.y-r*0.22);
            }
            ctx.stroke();

            if (n.pin){
              ctx.beginPath();
              ctx.moveTo(p.x-r*0.55, p.y);
              ctx.lineTo(p.x+r*0.55, p.y);
              ctx.stroke();
            }
          }
        }

        // Labels
        if (ui.T_labels.checked){
          ctx.globalCompositeOperation = 'source-over';
          ctx.font = '11px Arial';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = inv ? 'rgba(0,0,0,0.86)' : 'rgba(255,255,255,0.82)';

          for (let i=0;i<nodes.length;i++){
            const n = nodes[i];
            // label only hottest / pinned to avoid clutter
            if (n.heat < 0.35 && !n.pin) continue;
            const p = worldToScreen(n.x, n.y);
            const tag = `${n.name}${n.str>=0 ? " · ATTR" : " · REP"}${n.pin ? " · PIN" : ""}`;
            ctx.fillText(tag, p.x + 14, p.y);
          }

          const w = worldToScreen(st.walker.x, st.walker.y);
          ctx.fillText("DRIFTER", w.x + 14, w.y);
        }

        // Walker
        const wp = worldToScreen(st.walker.x, st.walker.y);
        ctx.globalCompositeOperation = inv ? 'source-over' : 'lighter';
        ctx.lineWidth = 1.4;
        ctx.strokeStyle = `rgba(${fg},${fg},${fg},${0.85})`;
        ctx.beginPath();
        ctx.arc(wp.x, wp.y, 7, 0, Math.PI*2);
        ctx.stroke();

        // heading indicator
        ctx.beginPath();
        ctx.moveTo(wp.x, wp.y);
        ctx.lineTo(wp.x + st.walker.vx*900, wp.y + st.walker.vy*900);
        ctx.stroke();

        ctx.globalCompositeOperation = 'source-over';
      }

      // Start
      newCity();
      pushPath();

      // Loop
      let last = performance.now();
      function frame(now){
        const rawDt = Math.min(0.033, (now-last)/1000);
        last = now;

        const dt = rawDt * (+ui.timeScale.value) * (0.40 + 1.25*(+ui.drift.value));
        if (!st.paused){
          st.t += dt;
          step(dt);
        }
        draw();
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);

    })();
  </script>
</body>
</html>
