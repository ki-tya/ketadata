<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA_BASE_SYSTEM.html</title>

<!-- ==================
AE ▸ CSS (BRUTAL MINIMALISM)
================== -->
<style>
  :root{
    --bg:#000;
    --fg:#fff;
    --muted:#aaa;
    --line:#222;
    --line2:#333;
    --panel:#0b0b0b;
    --panel2:#111;
    --chip:#0f0f0f;
    --danger:#ff2a2a;
    --ok:#00ff7f;

    --topbar-h:44px;
    --bottombar-h:44px;
    --drawer-h: 360px; /* persisted */
    --radius: 0px;
    --pad: 10px;
    --font: Arial, Helvetica, sans-serif;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;

    --note-w: 340px;
    --note-h: 220px;

    --motion: 1; /* 1 on / 0 off */
  }

  html,body{height:100%;}
  body{
    margin:0;
    background:var(--bg);
    color:var(--fg);
    font-family:var(--font);
    overflow:hidden;
  }
  *{box-sizing:border-box;}
  a{color:var(--fg); text-decoration:none;}
  a:hover{ text-decoration:underline; }

  .invert{
    filter: invert(1);
  }

  /* full-screen stage */
  #stage{
    position:fixed;
    inset:0;
    z-index:0;
    background: radial-gradient(circle at 50% 50%, #0a0a0a 0%, #000 60%);
  }

  /* motion layer */
  #motion{
    position:fixed;
    inset:0;
    z-index:1;
    pointer-events:none;
    opacity: calc(var(--motion) * 1);
  }
  #motion.run::before{
    content:"";
    position:absolute; inset:-20%;
    background:
      radial-gradient(circle at 10% 20%, rgba(255,255,255,0.05) 0%, transparent 35%),
      radial-gradient(circle at 80% 40%, rgba(255,255,255,0.04) 0%, transparent 35%),
      radial-gradient(circle at 40% 80%, rgba(255,255,255,0.03) 0%, transparent 40%);
    animation: drift 10s linear infinite;
  }
  @keyframes drift{
    0%{ transform: translate3d(0,0,0) scale(1); }
    50%{ transform: translate3d(2%, -2%, 0) scale(1.02); }
    100%{ transform: translate3d(0,0,0) scale(1); }
  }

  /* bars */
  #topbar, #bottombar{
    position:fixed;
    left:0; right:0;
    display:flex;
    align-items:center;
    gap:10px;
    padding: 0 var(--pad);
    z-index:10;
    background:rgba(0,0,0,0.85);
    border-bottom:1px solid var(--line);
    backdrop-filter: blur(6px);
  }
  #topbar{
    top:0; height: var(--topbar-h);
  }
  #bottombar{
    bottom:0; height: var(--bottombar-h);
    border-top:1px solid var(--line);
    border-bottom:none;
  }

  .spacer{flex:1;}
  .chip{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:6px 10px;
    background:var(--chip);
    border:1px solid var(--line2);
    border-radius:var(--radius);
    font-size:12px;
    letter-spacing:0.5px;
    text-transform:uppercase;
    white-space:nowrap;
  }
  .btn{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    gap:8px;
    padding:6px 10px;
    background:transparent;
    color:var(--fg);
    border:1px solid var(--line2);
    border-radius:var(--radius);
    font-size:12px;
    letter-spacing:0.5px;
    text-transform:uppercase;
    cursor:pointer;
    user-select:none;
    white-space:nowrap;
  }
  .btn:hover{ border-color:#555; }
  .btn:active{ transform: translateY(1px); }
  .btn.danger{ border-color:#5a1a1a; color:#ffd0d0; }
  .btn.ok{ border-color:#1a5a3a; color:#cffff0; }

  .tiny{
    font-family:var(--mono);
    font-size:11px;
    color:var(--muted);
    text-transform:none;
    letter-spacing:0;
  }

  #drawer{
    position:fixed;
    left:0; right:0;
    bottom: var(--bottombar-h);
    height: var(--drawer-h);
    background:rgba(0,0,0,0.9);
    border-top:1px solid var(--line);
    z-index:9;
    transform: translateY(0);
    transition: transform 120ms linear;
    overflow:hidden;
    backdrop-filter: blur(6px);
  }
  #drawer.closed{
    transform: translateY(calc(var(--drawer-h) + 4px));
  }
  #drawerInner{
    height:100%;
    display:grid;
    grid-template-columns: 1.2fr 1fr 1fr 1fr;
    gap:10px;
    padding:10px;
    overflow:auto;
  }

  .panel{
    background: rgba(10,10,10,0.85);
    border:1px solid var(--line2);
    border-radius:var(--radius);
    min-height: 120px;
    display:flex;
    flex-direction:column;
    overflow:hidden;
  }
  .panelHeader{
    display:flex;
    align-items:center;
    gap:10px;
    padding:8px 10px;
    border-bottom:1px solid var(--line);
    text-transform:uppercase;
    letter-spacing:0.5px;
    font-size:12px;
  }
  .panelHeader .spacer{flex:1;}
  .panelBody{
    padding:10px;
    overflow:auto;
  }
  .panelBody.collapsed{ display:none; }

  textarea, input{
    width:100%;
    background:#000;
    color:var(--fg);
    border:1px solid var(--line2);
    border-radius:var(--radius);
    padding:8px;
    font-family:var(--mono);
    font-size:12px;
    outline:none;
  }
  textarea{ min-height: 110px; resize: vertical; }

  .row{ display:flex; gap:8px; align-items:center; }
  .col{ flex:1; }
  .miniBtn{
    padding:6px 8px;
    font-size:11px;
  }

  /* KETA_NOTE */
  #ketaNote{
    position:fixed;
    z-index:20;
    right:16px;
    top: calc(var(--topbar-h) + 16px);
    width: var(--note-w);
    height: var(--note-h);
    background: rgba(0,0,0,0.92);
    border:1px solid var(--line2);
    border-radius:var(--radius);
    display:none;
    overflow:hidden;
    backdrop-filter: blur(6px);
  }
  #ketaNote.open{ display:block; }

  #ketaNoteHeader{
    display:flex;
    align-items:center;
    gap:10px;
    padding:8px 10px;
    border-bottom:1px solid var(--line);
    font-size:12px;
    letter-spacing:0.5px;
    text-transform:uppercase;
  }
  #ketaNoteHeader .spacer{flex:1;}
  #ketaNoteBody{
    height: calc(100% - 34px);
    padding:10px;
  }
  #ketaText{
    height:100%;
    resize:none;
  }

  /* pinned panel */
  #pinned{
    position:fixed;
    left:16px;
    top: calc(var(--topbar-h) + 16px);
    width: 360px;
    max-height: calc(100% - var(--topbar-h) - var(--bottombar-h) - 32px);
    z-index:18;
    background: rgba(0,0,0,0.92);
    border:1px solid var(--line2);
    border-radius:var(--radius);
    overflow:hidden;
    display:none;
    backdrop-filter: blur(6px);
  }
  #pinned.open{ display:block; }
  #pinnedHeader{
    display:flex;
    align-items:center;
    gap:10px;
    padding:8px 10px;
    border-bottom:1px solid var(--line);
    text-transform:uppercase;
    letter-spacing:0.5px;
    font-size:12px;
  }
  #pinnedBody{
    padding:10px;
    overflow:auto;
    max-height: calc(100% - 34px);
  }
  .pinnedItem{
    border:1px solid var(--line2);
    padding:8px;
    margin-bottom:10px;
    background: rgba(0,0,0,0.7);
  }
  .pinnedItemTitle{
    font-family:var(--mono);
    font-size:12px;
    margin-bottom:6px;
    color:var(--muted);
  }
  .pinnedItemText{
    font-family:var(--mono);
    font-size:12px;
    white-space:pre-wrap;
  }

  /* armed bar (active room quick actions) */
  #armed{
    position:fixed;
    left:50%;
    transform: translateX(-50%);
    bottom: calc(var(--bottombar-h) + 10px);
    z-index:19;
    display:none;
    align-items:center;
    gap:8px;
    padding:8px 10px;
    background: rgba(0,0,0,0.9);
    border:1px solid var(--line2);
    border-radius:var(--radius);
    backdrop-filter: blur(6px);
  }
  #armed.open{ display:flex; }

  /* blackout */
  body.blackout #topbar,
  body.blackout #bottombar,
  body.blackout #drawer,
  body.blackout #ketaNote,
  body.blackout #pinned,
  body.blackout #armed{
    display:none !important;
  }

  /* toast */
  #toast{
    position:fixed;
    right:16px;
    bottom: calc(var(--bottombar-h) + 16px);
    z-index:30;
    background: rgba(0,0,0,0.92);
    border:1px solid var(--line2);
    border-radius:var(--radius);
    padding:8px 10px;
    font-family:var(--mono);
    font-size:12px;
    opacity:0;
    transform: translateY(6px);
    transition: opacity 120ms linear, transform 120ms linear;
    pointer-events:none;
    white-space:pre-wrap;
    max-width: 520px;
  }
  #toast.show{
    opacity:1;
    transform: translateY(0);
  }

  /* icon square */
  #ketaIcon{
    width:14px; height:14px;
    border:1px solid var(--fg);
    background: transparent;
    display:inline-block;
    cursor:pointer;
  }
</style>
</head>

<body>
  <div id="stage"></div>
  <div id="motion"></div>

  <!-- TOP BAR -->
  <div id="topbar">
    <span class="chip">
      <span class="tiny">KETADATA</span>
      <span class="tiny">BASE</span>
    </span>

    <button class="btn" id="toggleDrawer">SYSTEM</button>
    <span class="chip"><span class="tiny">SIG</span> <span id="sig" class="tiny"></span></span>

    <div class="spacer"></div>

    <span class="chip"><span class="tiny">FS</span> <span id="fsLabel" class="tiny">OFF</span></span>
    <span class="chip"><span class="tiny">BLK</span> <span id="blkLabel" class="tiny">OFF</span></span>
    <span class="chip"><span class="tiny">LIGHT</span> <span id="lightLabel" class="tiny">1</span></span>
    <span class="chip"><span class="tiny">RUN</span> <span id="runLabel" class="tiny">OFF</span></span>
    <span class="chip"><span class="tiny">MOTION</span> <span id="motionLabel" class="tiny">ON</span></span>

    <span id="ketaIcon" title="KETA_NOTE"></span>
  </div>

  <!-- DRAWER -->
  <div id="drawer" class="closed">
    <div id="drawerInner">

      <!-- UNIVERSALS -->
      <div class="panel" id="panelUniversals">
        <div class="panelHeader">
          <span>UNIVERSALS</span>
          <div class="spacer"></div>
          <button class="btn miniBtn" id="btnToggleUniversals">TOGGLE</button>
          <button class="btn miniBtn" id="btnCopyUniversals">COPY</button>
        </div>
        <div class="panelBody" id="bodyUniversals">
          <textarea id="universals" placeholder="UNIVERSALS (PERSISTED)"></textarea>
          <div style="height:10px"></div>
          <div class="row">
            <button class="btn miniBtn" id="btnExport">EXPORT</button>
            <button class="btn miniBtn" id="btnImport">IMPORT</button>
            <input id="file" type="file" accept=".json,.txt" style="display:none"/>
            <button class="btn miniBtn" id="btnCopy">COPY</button>
          </div>
          <div style="height:10px"></div>
          <div class="tiny">SHIFT+I INVERT • SHIFT+N NULL • SHIFT+F FULLSCREEN • 1–6 LIGHTS • SPACE RUN/STOP</div>
        </div>
      </div>

      <!-- REGISTRY -->
      <div class="panel" id="panelRegistry">
        <div class="panelHeader">
          <span>REGISTRY</span>
          <div class="spacer"></div>
          <button class="btn miniBtn" id="btnToggleRegistry">TOGGLE</button>
        </div>
        <div class="panelBody" id="bodyRegistry">
          <div class="row">
            <input id="roomInput" placeholder="ROOM NAME (E.G. POD)" />
          </div>
          <div style="height:8px"></div>
          <div class="row">
            <input id="roomUrlInput" placeholder="ROOM URL (HTTPS://...)" />
          </div>
          <div style="height:10px"></div>
          <div class="row">
            <button class="btn miniBtn" id="btnSaveRoom">SAVE</button>
            <button class="btn miniBtn" id="btnSetActiveRoom">SET ACTIVE</button>
            <button class="btn miniBtn danger" id="btnDeleteRoom">DELETE</button>
          </div>
          <div style="height:10px"></div>
          <div class="tiny">CLICK A ROOM BELOW TO LOAD INTO EDITOR.</div>
          <div style="height:10px"></div>
          <div id="roomList" class="tiny"></div>
        </div>
      </div>

      <!-- ACTIVE -->
      <div class="panel" id="panelActive">
        <div class="panelHeader">
          <span>ACTIVE</span>
          <div class="spacer"></div>
          <button class="btn miniBtn" id="btnToggleActive">TOGGLE</button>
          <button class="btn miniBtn" id="btnGoActive">GO</button>
          <button class="btn miniBtn" id="btnNewTabActive">NEW TAB</button>
          <button class="btn miniBtn" id="btnCopyActiveUrl">COPY URL</button>
        </div>
        <div class="panelBody" id="bodyActive">
          <div class="tiny">ROOM</div>
          <input id="activeRoomBox" readonly />
          <div style="height:8px"></div>
          <div class="tiny">URL</div>
          <input id="activeUrlBox" readonly />
          <div style="height:10px"></div>
          <div class="row">
            <button class="btn miniBtn" id="btnTogglePins">PINS</button>
            <button class="btn miniBtn ok" id="btnToggleMotion">MOTION</button>
          </div>
          <div style="height:10px"></div>
          <div class="tiny">PINS PERSIST ON BASE UNTIL EXPLICIT UNPIN.</div>
        </div>
      </div>

      <!-- SETS -->
      <div class="panel" id="panelSets">
        <div class="panelHeader">
          <span>SETS</span>
          <div class="spacer"></div>
          <button class="btn miniBtn" id="btnToggleSets">TOGGLE</button>
        </div>
        <div class="panelBody" id="bodySets">
          <input id="setNameInput" placeholder="SET NAME" />
          <div style="height:8px"></div>
          <textarea id="setItemsInput" placeholder="ITEMS (ONE PER LINE)"></textarea>
          <div style="height:10px"></div>
          <div class="row">
            <button class="btn miniBtn" id="btnCreateSet">CREATE</button>
            <button class="btn miniBtn" id="btnRenameSet">RENAME</button>
            <button class="btn miniBtn danger" id="btnDeleteSet">DELETE</button>
          </div>
          <div style="height:8px"></div>
          <div class="row">
            <button class="btn miniBtn" id="btnSaveSetItems">SAVE ITEMS</button>
            <button class="btn miniBtn" id="btnClearSetItems">CLEAR</button>
            <button class="btn miniBtn" id="btnPinSet">PIN</button>
          </div>
          <div style="height:10px"></div>
          <div class="tiny">CLICK A SET BELOW TO LOAD INTO EDITOR.</div>
          <div style="height:10px"></div>
          <div id="setList" class="tiny"></div>
        </div>
      </div>

      <!-- BULK -->
      <div class="panel" id="panelBulk">
        <div class="panelHeader">
          <span>BULK</span>
          <div class="spacer"></div>
          <button class="btn miniBtn" id="btnToggleBulk">TOGGLE</button>
        </div>
        <div class="panelBody" id="bodyBulk">
          <textarea id="bulkInput" placeholder="BULK INPUT: ROOM|URL  (ONE PER LINE)"></textarea>
          <div style="height:10px"></div>
          <div class="row">
            <button class="btn miniBtn" id="btnBulkAdd">ADD / MERGE</button>
            <button class="btn miniBtn danger" id="btnBulkClear">CLEAR</button>
          </div>
          <div style="height:10px"></div>
          <div class="tiny">FORMAT: ROOM|HTTPS://...  (ROOM CAN BE ANY STRING)</div>
        </div>
      </div>

      <!-- PRESETS -->
      <div class="panel" id="panelPresets">
        <div class="panelHeader">
          <span>PRESETS</span>
          <div class="spacer"></div>
          <button class="btn miniBtn" id="btnTogglePresets">TOGGLE</button>
          <button class="btn miniBtn" id="btnCloseDrawer">CLOSE</button>
        </div>
        <div class="panelBody" id="bodyPresets">
          <div class="tiny">LOCKED HOTKEYS:</div>
          <div style="height:8px"></div>
          <div class="tiny">
            SHIFT+K LANDING • SHIFT+X PHOTOBOOTH • SHIFT+Z KDTV1 • SHIFT+V POD • SHIFT+W WORLD • SHIFT+P INFINITY
          </div>
          <div style="height:10px"></div>
          <div class="tiny">DRAWER HEIGHT PERSISTS.</div>
          <div style="height:8px"></div>
          <input id="drawerH" type="range" min="220" max="700" step="10"/>
        </div>
      </div>

    </div>
  </div>

  <!-- BOTTOM BAR -->
  <div id="bottombar">
    <span class="chip"><span class="tiny">ACTIVE</span> <span id="sig2" class="tiny"></span></span>
    <div class="spacer"></div>
    <button class="btn" id="toggleRun">RUN</button>
  </div>

  <!-- KETA NOTE -->
  <div id="ketaNote">
    <div id="ketaNoteHeader">
      <span>KETA_NOTE</span>
      <div class="spacer"></div>
      <button class="btn miniBtn" id="btnHideNote">-</button>
    </div>
    <div id="ketaNoteBody">
      <textarea id="ketaText" placeholder="KETA_NOTE (PERSISTED)"></textarea>
    </div>
  </div>

  <!-- PINNED -->
  <div id="pinned">
    <div id="pinnedHeader">
      <span>PINNED</span>
      <div class="spacer"></div>
      <button class="btn miniBtn" id="btnClosePinned">CLOSE</button>
    </div>
    <div id="pinnedBody"></div>
  </div>

  <!-- ARMED -->
  <div id="armed">
    <span class="chip"><span class="tiny">ARMED</span> <span id="armedRoom" class="tiny"></span></span>
    <button class="btn miniBtn" id="armedGo">GO</button>
    <button class="btn miniBtn" id="armedNewTab">NEW TAB</button>
    <button class="btn miniBtn" id="armedCopy">COPY URL</button>
  </div>

  <div id="toast"></div>

<script>
/* ==================
EE ▸ BASE KERNEL
================== */
const FILE_ID="KETADATA_SHELL8";
const ROOM_ID="BASE";

/* canonical urls (edit these in code; no UI drift) */
const URLS={
  LANDING:"https://ki-tya.github.io/ketadata/system.html",
  KDTV:"https://ki-tya.github.io/ketadata/kdtv1.html",
  PHOTOBOOTH:"https://ki-tya.github.io/ketadata/photobooth.html",
  POD:"https://ki-tya.github.io/ketadata/pod.html",
  WORLD:"https://ki-tya.github.io/ketadata/world.html",
  INFINITY:"https://ki-tya.github.io/ketadata/infinity.html"
};

/* utils */
const $=id=>document.getElementById(id);
const root=document.documentElement;
const stage=$("stage");
const motion=$("motion");

/* STORAGE KEYS (SOVEREIGN) */
const STORAGE_KEY_MAIN = "KDT::BASE::SOVEREIGN::STATE";
const STORAGE_KEY_BACKUP = "KDT::BASE::SOVEREIGN::STATE::BACKUP";

/* =========================================================
EE ▸ STORAGE WRAPPER (LAZY DIVA PERSISTENCE)
- Primary: localStorage (same-origin, durable)
- Fallback: sessionStorage
- Last-resort: window.name (persists through refresh + same-tab nav even when storage is blocked)
========================================================= */
const NAME_STORE_PREFIX = "KDT::NAME_STORE::";

function _nameStoreLoad(){
  try{
    const raw = String(window.name||"");
    if(!raw.startsWith(NAME_STORE_PREFIX)) return {};
    const json = raw.slice(NAME_STORE_PREFIX.length);
    const obj = JSON.parse(json);
    return (obj && typeof obj==="object") ? obj : {};
  }catch(e){ return {}; }
}
function _nameStoreWrite(obj){
  try{ window.name = NAME_STORE_PREFIX + JSON.stringify(obj||{}); }catch(e){}
}
function storageGet(key){
  const k=String(key||"");
  try{ const v = localStorage.getItem(k); if(v!==null) return v; }catch(e){}
  try{ const v = sessionStorage.getItem(k); if(v!==null) return v; }catch(e){}
  try{ const ns=_nameStoreLoad(); if(Object.prototype.hasOwnProperty.call(ns,k)) return ns[k]; }catch(e){}
  return null;
}
function storageSet(key, value){
  const k=String(key||"");
  const v=String(value??"");
  let wrote=false;
  try{ localStorage.setItem(k, v); wrote=true; }catch(e){}
  if(!wrote){
    try{ sessionStorage.setItem(k, v); }catch(e){}
  }
  // always mirror into window.name (best-effort)
  try{ const ns=_nameStoreLoad(); ns[k]=v; _nameStoreWrite(ns); }catch(e){}
}
function storageRemove(key){
  const k=String(key||"");
  try{ localStorage.removeItem(k); }catch(e){}
  try{ sessionStorage.removeItem(k); }catch(e){}
  try{ const ns=_nameStoreLoad(); if(Object.prototype.hasOwnProperty.call(ns,k)){ delete ns[k]; _nameStoreWrite(ns); } }catch(e){}
}

/* legacy keys (migration only) */
const STORAGE_KEY_CANON_OLD = "KETADATA_SHELL_KERNEL_v1";
const STORAGE_KEY_BACKUP_OLD = "KETADATA_SHELL_KERNEL_v1_BACKUP";

/* previous broken path-scoped keys */
const STORAGE_KEY_PATH_PREFIX = "KDT::BASE::STATE::PATH::";

/* default state (NO constraints/algorithms; literal UI recreation only) */
const DEFAULT={
  version:"BASE_SYSTEM_SOVEREIGN_v5",
  updatedAt: nowISO(),
  fileId: FILE_ID,
  roomId: ROOM_ID,

  room:"BASE",
  roomUrl:"",

  universals:"",
  ketaNote:"",

  registry:{
    rooms:[ /* {name,url,updatedAt} */ ],
    sets:[ /* {id,name,items[],pinned,updatedAt} */ ],
  },

  ui:{
    invert:false,
    blackout:false,
    fullscreen:false,

    drawerOpen:false,
    drawerH: 360,

    universalsCollapsed:false,
    registryCollapsed:false,
    activeCollapsed:false,
    setsCollapsed:false,
    bulkCollapsed:false,
    presetsCollapsed:false,

    noteOpen:false,
    noteRect:{ x:null, y: 60, w: 340, h: 220 }, /* x=null => dock right */
    pinnedOpen:false,

    pinnedSets:[], /* list of set ids pinned */
    motionOn:true,

    /* lights */
    lightPreset:1,
    lightRunning:false
  }
};

function nowISO(){ return new Date().toISOString(); }
function structuredClone(x){ return JSON.parse(JSON.stringify(x)); }

/* stable signature — MUST include (EE-10) additional identifiers */
function stableSig(){
  const u=STATE.updatedAt||"";
  const room=STATE.room||"";
  const url=STATE.roomUrl||"";
  const version=STATE.version||"";
  const fileId=STATE.fileId||FILE_ID;
  const roomId=STATE.roomId||ROOM_ID;
  const ketaLen=(STATE.ketaNote||"").length;
  const uLen=(STATE.universals||"").length;
  const rooms=(STATE.registry?.rooms||[]).length;
  const sets=(STATE.registry?.sets||[]).length;
  const pins=(STATE.ui?.pinnedSets||[]).length;
  const preset=Number(STATE.ui?.lightPreset||1);
  const run=STATE.ui?.lightRunning?"1":"0";
  const motionOn=STATE.ui?.motionOn?"1":"0";
  const inv=STATE.ui?.invert?"1":"0";
  const fs=STATE.ui?.fullscreen?"1":"0";
  const blk=STATE.ui?.blackout?"1":"0";
  const drawer=STATE.ui?.drawerOpen?"1":"0";
  const drH=Number(STATE.ui?.drawerH||360);

  return [
    "V",version,
    "F",fileId,
    "R",roomId,
    "ROOM",room,
    "URL",url,
    "KETA",ketaLen,
    "UNI",uLen,
    "ROOMS",rooms,
    "SETS",sets,
    "PINS",pins,
    "L",preset,
    "RUN",run,
    "M",motionOn,
    "I",inv,
    "FS",fs,
    "BLK",blk,
    "D",drawer,
    "DH",drH,
    "T",u
  ].join("|");
}

/* =========================================================
EE ▸ MERGE + MIGRATION
========================================================= */
function mergeDefault(partial){
  const base=structuredClone(DEFAULT);
  const out=deepMerge(base, partial||{});
  out.version=DEFAULT.version;
  out.fileId=FILE_ID;
  out.roomId=ROOM_ID;
  if(!out.ui) out.ui=structuredClone(DEFAULT.ui);
  if(!out.registry) out.registry=structuredClone(DEFAULT.registry);
  if(!Array.isArray(out.registry.rooms)) out.registry.rooms=[];
  if(!Array.isArray(out.registry.sets)) out.registry.sets=[];
  if(!Array.isArray(out.ui.pinnedSets)) out.ui.pinnedSets=[];
  return out;
}
function deepMerge(a,b){
  if(!b || typeof b!=="object") return a;
  for(const k of Object.keys(b)){
    const bv=b[k];
    if(Array.isArray(bv)){ a[k]=bv; continue; }
    if(bv && typeof bv==="object"){
      if(!a[k] || typeof a[k]!=="object" || Array.isArray(a[k])) a[k]={};
      a[k]=deepMerge(a[k], bv);
    }else{
      a[k]=bv;
    }
  }
  return a;
}

/* load JSON from a given key (wrapper) */
function loadFromKey(key){
  try{
    const raw = storageGet(key);
    if(!raw) return null;
    const obj = JSON.parse(raw);
    if(!obj || typeof obj!=="object") return null;
    return obj;
  }catch(e){ return null; }
}

/* pick most recent among an array of {key,obj} using updatedAt */
function pickMostRecent(arr){
  let best=null;
  let bestT=0;
  for(const it of (arr||[])){
    const t = Date.parse(it?.obj?.updatedAt||"") || 0;
    if(t>bestT){ bestT=t; best=it; }
  }
  return best ? best.obj : null;
}

function loadLocal(){
  // 1) sovereign main
  let s = loadFromKey(STORAGE_KEY_MAIN);
  if(s) return mergeDefault(s);

  // 2) sovereign backup
  s = loadFromKey(STORAGE_KEY_BACKUP);
  if(s){
    const merged = mergeDefault(s);
    try{
      storageSet(STORAGE_KEY_MAIN, JSON.stringify(merged));
      storageSet(STORAGE_KEY_BACKUP, JSON.stringify(merged));
    }catch(e){}
    return merged;
  }

  // 3) migrate broken path-scoped v2 (pick most recent)
  const mains=[], backups=[];
  try{
    for(let i=0;i<localStorage.length;i++){
      const k=localStorage.key(i);
      if(!k) continue;
      if(k.startsWith(STORAGE_KEY_PATH_PREFIX) && k.endsWith("::MAIN")){
        const o=loadFromKey(k);
        if(o) mains.push({key:k,obj:o});
      }
      if(k.startsWith(STORAGE_KEY_PATH_PREFIX) && k.endsWith("::BACKUP")){
        const o=loadFromKey(k);
        if(o) backups.push({key:k,obj:o});
      }
    }
  }catch(e){}
  const best = pickMostRecent(mains) || pickMostRecent(backups);
  if(best){
    const merged = mergeDefault(best);
    try{
      storageSet(STORAGE_KEY_MAIN, JSON.stringify(merged));
      storageSet(STORAGE_KEY_BACKUP, JSON.stringify(merged));
    }catch(e){}
    return merged;
  }

  // 4) migrate prior canon v1
  s = loadFromKey(STORAGE_KEY_CANON_OLD) || loadFromKey(STORAGE_KEY_BACKUP_OLD);
  if(s){
    const merged = mergeDefault(s);
    try{
      storageSet(STORAGE_KEY_MAIN, JSON.stringify(merged));
      storageSet(STORAGE_KEY_BACKUP, JSON.stringify(merged));
    }catch(e){}
    return merged;
  }

  return null;
}

/* =========================================================
EE ▸ STATE MUTATION + PERSIST (ATOMIC, NO DRIFT)
========================================================= */
let _BOOTING=true;

function ensureCorePresets(){
  // minimal default rooms (no UI change)
  const must=[
    {name:"LANDING", url: URLS.LANDING},
    {name:"KDTV1", url: URLS.KDTV},
    {name:"PHOTOBOOTH", url: URLS.PHOTOBOOTH},
    {name:"POD", url: URLS.POD},
    {name:"WORLD", url: URLS.WORLD},
    {name:"INFINITY", url: URLS.INFINITY},
  ];
  for(const r of must){
    upsertRoomPreset(r.name, r.url, true);
  }
}

function canonRoomName(s){
  return String(s||"").trim().toUpperCase();
}

function upsertRoomPreset(name,url,silent){
  const n=canonRoomName(name||"");
  const u=String(url||"").trim();
  if(!n) return;
  const rooms=STATE.registry.rooms;
  const i=rooms.findIndex(x=>canonRoomName(x.name)===n);
  const now=nowISO();
  if(i>=0){
    rooms[i].name=n;
    rooms[i].url=u;
    rooms[i].updatedAt=now;
  }else{
    rooms.push({name:n,url:u,updatedAt:now});
  }
  if(!silent) render();
}

function deleteRoomPreset(name){
  const n=canonRoomName(name||"");
  const rooms=STATE.registry.rooms;
  const i=rooms.findIndex(x=>canonRoomName(x.name)===n);
  if(i>=0) rooms.splice(i,1);
  if(STATE.room===n){ STATE.room="BASE"; STATE.roomUrl=""; }
  render();
}

function setActiveRoom(name,url){
  STATE.room=canonRoomName(name||"BASE");
  STATE.roomUrl=String(url||"").trim();
  render();
}

function ensureActiveSet(){
  // keep ACTIVE_SET_ID pointing at a real set if possible
  if(!ACTIVE_SET_ID){
    const first = STATE.registry.sets[0];
    if(first) ACTIVE_SET_ID = first.id;
  }else{
    const exists = STATE.registry.sets.some(s=>s.id===ACTIVE_SET_ID);
    if(!exists) ACTIVE_SET_ID="";
  }
}

function createId(){
  return "S_"+Math.random().toString(16).slice(2)+Date.now().toString(16);
}

let ACTIVE_SET_ID="";

function createSet(name){
  const id=createId();
  const s={id, name:String(name||"SET"), items:[], pinned:false, updatedAt:nowISO()};
  STATE.registry.sets.push(s);
  ACTIVE_SET_ID=id;
  return s;
}
function renameSet(id,newName){
  const s=STATE.registry.sets.find(x=>x.id===id);
  if(!s) return;
  s.name=String(newName||"SET");
  s.updatedAt=nowISO();
}
function deleteSet(id){
  const i=STATE.registry.sets.findIndex(x=>x.id===id);
  if(i>=0) STATE.registry.sets.splice(i,1);
  // remove from pinned list
  ensurePinnedSets();
  const p=STATE.ui.pinnedSets;
  const j=p.indexOf(id);
  if(j>=0) p.splice(j,1);
}
function saveSetItems(id,text){
  const s=STATE.registry.sets.find(x=>x.id===id);
  if(!s) return;
  const lines=String(text||"").split("\n").map(x=>x.trim()).filter(Boolean);
  s.items=lines;
  s.updatedAt=nowISO();
}
function setEditorFromSet(s){
  if(!s) return;
  ACTIVE_SET_ID=s.id;
  $("setNameInput").value=s.name||"";
  $("setItemsInput").value=(s.items||[]).join("\n");
}
function ensurePinnedSets(){
  if(!Array.isArray(STATE.ui.pinnedSets)) STATE.ui.pinnedSets=[];
}
function isSetPinned(id){
  ensurePinnedSets();
  return STATE.ui.pinnedSets.includes(id);
}
function togglePinSet(id){
  ensurePinnedSets();
  const sid=String(id||"");
  const i=STATE.ui.pinnedSets.indexOf(sid);
  if(i>=0) STATE.ui.pinnedSets.splice(i,1);
  else STATE.ui.pinnedSets.push(sid);
}

function persist(forceRender=true){
  if(_BOOTING) return;
  try{
    STATE.updatedAt=nowISO();
    ensureCorePresets();
    const blob = JSON.stringify(STATE);
    // atomic write to main + backup + name mirror (wrapper)
    storageSet(STORAGE_KEY_MAIN, blob);
    storageSet(STORAGE_KEY_BACKUP, blob);
  }catch(e){}
  if(forceRender) render();
}

/* lifecycle flush — guarantees most recent Base survives refresh/navigation */
(function bindLifecycleFlush(){
  const flush=()=>{ try{ persist(true); }catch(e){} };

  window.addEventListener("pagehide", flush, {capture:true});
  window.addEventListener("beforeunload", flush, {capture:true});
  window.addEventListener("pageshow", (ev)=>{
    // BFCache restore: ensure STATE rehydrates from storage
    if(ev && ev.persisted){
      try{ const s=loadLocal(); if(s){ STATE=s; render(); } }catch(e){}
    }
  }, {capture:true});
  document.addEventListener("visibilitychange", ()=>{
    if(document.visibilityState==="hidden") flush();
  }, {capture:true});
})();

/* export/import */
function exportState(){
  ensureCorePresets();
  return JSON.stringify({ STORAGE_KEY: STORAGE_KEY_MAIN, FILE_ID, PAGE_ID: ROOM_ID, state: STATE }, null, 2);
}
function importState(text){
  try{
    const obj=JSON.parse(String(text||""));
    const s = obj?.state ? obj.state : obj;
    const merged = mergeDefault(s);
    STATE = merged;
    ensureCorePresets();
    persist(true);
    toast("IMPORTED");
  }catch(e){
    toast("IMPORT FAILED");
  }
}

/* toast */
let TOAST_T=null;
function toast(msg){
  const t=$("toast");
  t.textContent=String(msg||"");
  t.classList.add("show");
  clearTimeout(TOAST_T);
  TOAST_T=setTimeout(()=>t.classList.remove("show"), 900);
}

/* clipboard */
async function copy(text){
  try{
    await navigator.clipboard.writeText(String(text||""));
    toast("COPIED");
  }catch(e){
    // fallback
    const ta=document.createElement("textarea");
    ta.value=String(text||"");
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
    toast("COPIED");
  }
}

/* =========================================================
EE ▸ UI SETTERS (PERSISTED)
========================================================= */
function setDrawer(on){
  STATE.ui.drawerOpen=!!on;
  if(on) STATE.ui.blackout=false;
  persist(false);
}

/* force KETA_NOTE to top-right under icon on open */
function setKetaNote(on){
  STATE.ui.noteOpen=!!on;
  if(on){
    STATE.ui.blackout=false;
    if(STATE.ui.noteRect && typeof STATE.ui.noteRect==="object"){
      STATE.ui.noteRect.x = null; // always dock right
    }
  }
  persist(false);
}

function setUniversalsCollapsed(on){ STATE.ui.universalsCollapsed=!!on; persist(false); }
function setRegistryCollapsed(on){ STATE.ui.registryCollapsed=!!on; persist(false); }
function setActiveCollapsed(on){ STATE.ui.activeCollapsed=!!on; persist(false); }
function setSetsCollapsed(on){ STATE.ui.setsCollapsed=!!on; persist(false); }
function setBulkCollapsed(on){ STATE.ui.bulkCollapsed=!!on; persist(false); }
function setPresetsCollapsed(on){ STATE.ui.presetsCollapsed=!!on; persist(false); }

function setInvert(on){ STATE.ui.invert=!!on; persist(false); }

/* blackout restore cache */
let BLACKOUT_CACHE=null;

function setBlackout(on){
  const next=!!on;

  if(next && !STATE.ui.blackout){
    BLACKOUT_CACHE = {
      drawerOpen: !!STATE.ui.drawerOpen,
      noteOpen: !!STATE.ui.noteOpen,
      motionOn: !!STATE.ui.motionOn,
      lightRunning: !!STATE.ui.lightRunning,
      lightPreset: Number(STATE.ui.lightPreset||1)
    };
  }

  STATE.ui.blackout=next;

  if(STATE.ui.blackout){
    STATE.ui.motionOn=false;
    stopLight(true);
    resetStage();
    motion.classList.remove("run");
    STATE.ui.drawerOpen=false;
    STATE.ui.noteOpen=false;
  }else{
    if(BLACKOUT_CACHE){
      STATE.ui.drawerOpen = !!BLACKOUT_CACHE.drawerOpen;
      STATE.ui.noteOpen   = !!BLACKOUT_CACHE.noteOpen;
      STATE.ui.motionOn   = !!BLACKOUT_CACHE.motionOn;
      const wasRunning    = !!BLACKOUT_CACHE.lightRunning;
      const wasPreset     = Number(BLACKOUT_CACHE.lightPreset||1);
      STATE.ui.lightPreset = wasPreset;
      if(wasRunning) startLight(wasPreset);
      BLACKOUT_CACHE=null;
    }
  }

  persist(false);
}
function toggleBlackout(){ setBlackout(!STATE.ui.blackout); }

function setFullscreen(on){
  STATE.ui.fullscreen=!!on;
  persist(false);
}
function toggleFullscreen(){ setFullscreen(!STATE.ui.fullscreen); }

/* =========================================================
WB ▸ NAVIGATION (GO + NEW TAB)
========================================================= */
function finalizeBeforeNav(){
  persist(true);
}
function go(url){
  const u=String(url||"").trim();
  if(!u) return;
  finalizeBeforeNav();
  window.location.href=u;
}
function openNewTab(url){
  const u=String(url||"").trim();
  if(!u) return;
  finalizeBeforeNav();
  window.open(u, "_blank", "noopener,noreferrer");
}

/* =========================================================
WB ▸ HOTKEYS (LOCKED)
========================================================= */
function bindHotkeys(){
  window.addEventListener("keydown",(ev)=>{
    if(ev.repeat) return;

    const ae=document.activeElement;
    const typing = ae && (ae.tagName==="TEXTAREA" || ae.tagName==="INPUT");

    if(ev.code==="Space"){
      if(!typing){
        ev.preventDefault();
        toggleRun();
        toast(STATE.ui.lightRunning ? "RUN ON" : "RUN OFF");
      }
      return;
    }

    if(ev.shiftKey && (ev.key==="I"||ev.key==="i")){ if(typing) return; ev.preventDefault(); setInvert(!STATE.ui.invert); return; }
    if(ev.shiftKey && (ev.key==="N"||ev.key==="n")){ if(typing) return; ev.preventDefault(); toggleBlackout(); return; }
    if(ev.shiftKey && (ev.key==="F"||ev.key==="f")){ if(typing) return; ev.preventDefault(); toggleFullscreen(); return; }

    if(ev.shiftKey && (ev.key==="K"||ev.key==="k")){ if(typing) return; ev.preventDefault(); go(URLS.LANDING); return; }
    if(ev.shiftKey && (ev.key==="X"||ev.key==="x")){ if(typing) return; ev.preventDefault(); go(URLS.PHOTOBOOTH); return; }
    if(ev.shiftKey && (ev.key==="Z"||ev.key==="z")){ if(typing) return; ev.preventDefault(); go(URLS.KDTV); return; }
    if(ev.shiftKey && (ev.key==="V"||ev.key==="v")){ if(typing) return; ev.preventDefault(); go(URLS.POD); return; }
    if(ev.shiftKey && (ev.key==="W"||ev.key==="w")){ if(typing) return; ev.preventDefault(); go(URLS.WORLD); return; }
    if(ev.shiftKey && (ev.key==="P"||ev.key==="p")){ if(typing) return; ev.preventDefault(); go(URLS.INFINITY); return; }

    // lights 1-6 continuous (SPACE does not interfere with typing above)
    if(!typing && !ev.shiftKey && !ev.ctrlKey && !ev.metaKey){
      if(["1","2","3","4","5","6"].includes(ev.key)){
        ev.preventDefault();
        const n=Number(ev.key);
        setLightPreset(n);
        toast("LIGHT "+n);
        return;
      }
    }
  });
}

/* =========================================================
EE ▸ LIGHTS (CONTINUOUS)
========================================================= */
let LIGHT_T=null;

function setLightPreset(n){
  const v=Math.max(1, Math.min(6, Number(n||1)));
  STATE.ui.lightPreset=v;
  if(STATE.ui.lightRunning){
    startLight(v);
  }else{
    render();
    persist(false);
  }
}
function startLight(n){
  stopLight(true);
  const v=Math.max(1, Math.min(6, Number(n||1)));
  STATE.ui.lightPreset=v;
  STATE.ui.lightRunning=true;
  const base = 70 + (v*12);
  const tick=()=>{
    // pulse stage background only (no UI drift)
    const t=Date.now();
    const k=(Math.sin(t/base)+1)/2;
    const g = Math.floor(8 + k*10);
    stage.style.background = `radial-gradient(circle at 50% 50%, rgb(${g},${g},${g}) 0%, #000 60%)`;
  };
  LIGHT_T=setInterval(tick, 30);
  render();
  persist(false);
}
function stopLight(silent){
  if(LIGHT_T){ clearInterval(LIGHT_T); LIGHT_T=null; }
  STATE.ui.lightRunning=false;
  resetStage();
  if(!silent){ render(); persist(false); }
}
function resetStage(){
  stage.style.background = "radial-gradient(circle at 50% 50%, #0a0a0a 0%, #000 60%)";
}

function toggleRun(){
  if(STATE.ui.lightRunning) stopLight();
  else startLight(STATE.ui.lightPreset||1);
}

/* =========================================================
EE ▸ RENDER
========================================================= */
function render(){
  // body classes
  document.body.classList.toggle("invert", !!STATE.ui.invert);
  document.body.classList.toggle("blackout", !!STATE.ui.blackout);

  // motion
  root.style.setProperty("--motion", STATE.ui.motionOn ? "1" : "0");
  if(STATE.ui.motionOn) motion.classList.add("run");
  else motion.classList.remove("run");

  // drawer
  const d=$("drawer");
  d.classList.toggle("closed", !STATE.ui.drawerOpen);

  // collapsed bodies
  $("bodyUniversals").classList.toggle("collapsed", !!STATE.ui.universalsCollapsed);
  $("bodyRegistry").classList.toggle("collapsed", !!STATE.ui.registryCollapsed);
  $("bodyActive").classList.toggle("collapsed", !!STATE.ui.activeCollapsed);
  $("bodySets").classList.toggle("collapsed", !!STATE.ui.setsCollapsed);
  $("bodyBulk").classList.toggle("collapsed", !!STATE.ui.bulkCollapsed);
  $("bodyPresets").classList.toggle("collapsed", !!STATE.ui.presetsCollapsed);

  // note
  const note=$("ketaNote");
  note.classList.toggle("open", !!STATE.ui.noteOpen);

  // pinned
  const pin=$("pinned");
  pin.classList.toggle("open", !!STATE.ui.pinnedOpen);

  // armed
  const armed=$("armed");
  armed.classList.toggle("open", !!STATE.roomUrl);

  // fullscreen (pure css, not actual API)
  if(STATE.ui.fullscreen){
    document.body.style.overflow="hidden";
  }

  // drawer height
  root.style.setProperty("--drawer-h", String(STATE.ui.drawerH));
  $("drawerH").value = String(STATE.ui.drawerH);

  // text areas
  $("universals").value = STATE.universals||"";
  $("ketaText").value = STATE.ketaNote||"";

  // active
  if($("activeRoomBox")) $("activeRoomBox").value = canonRoomName(STATE.room)||"BASE";
  if($("activeUrlBox")) $("activeUrlBox").value = String(STATE.roomUrl||"");

  const s=stableSig();
  $("sig").textContent=s;
  $("sig2").textContent=s;
  $("fsLabel").textContent=STATE.ui.fullscreen ? "ON" : "OFF";
  $("blkLabel").textContent=STATE.ui.blackout ? "ON" : "OFF";
  $("lightLabel").textContent=String(STATE.ui.lightPreset||1);
  $("runLabel").textContent=STATE.ui.lightRunning ? "ON" : "OFF";
  $("motionLabel").textContent=STATE.ui.motionOn ? "ON" : "OFF";

  if(STATE.ui.noteRect){
    const r=STATE.ui.noteRect;
    const box=$("ketaNote");
    if(r.x===null || typeof r.x==="undefined"){
      box.style.left="auto";
      box.style.right="16px";
      box.style.top=(Number(r.y)||76)+"px";
      box.style.width=(Number(r.w)||340)+"px";
      box.style.height=(Number(r.h)||220)+"px";
      box.style.right="16px";
    }else{
      box.style.left=(Number(r.x)||16)+"px";
      box.style.top=(Number(r.y)||76)+"px";
      box.style.width=(Number(r.w)||340)+"px";
      box.style.height=(Number(r.h)||220)+"px";
      box.style.right="auto";
    }
  }

  ensureActiveSet();
  renderRoomList();
  renderSetList();
  renderArmedBar();
  renderPinnedPanel();
}

/* =========================================================
WB ▸ EVENTS
========================================================= */
$("btnExport").addEventListener("click", ()=> copy(exportState()));
$("btnCopy").addEventListener("click", ()=> copy(exportState()));
$("btnImport").addEventListener("click", ()=> $("file").click());
$("file").addEventListener("change", async (ev)=>{
  const f=ev.target.files && ev.target.files[0];
  if(!f) return;
  const text=await f.text();
  importState(text);
  ev.target.value="";
});
$("btnCopyUniversals").addEventListener("click", ()=> copy($("universals").value||""));
$("btnCloseDrawer").addEventListener("click", ()=> setDrawer(false));

$("btnToggleMotion").addEventListener("click", ()=>{
  STATE.ui.motionOn = !STATE.ui.motionOn;
  toast(STATE.ui.motionOn ? "MOTION ON" : "MOTION OFF");
  persist();
});

$("btnToggleUniversals").addEventListener("click", ()=>{
  setUniversalsCollapsed(!STATE.ui.universalsCollapsed);
  toast(STATE.ui.universalsCollapsed ? "UNIVERSALS CLOSED" : "UNIVERSALS OPEN");
});

$("btnToggleRegistry").addEventListener("click", ()=>{
  setRegistryCollapsed(!STATE.ui.registryCollapsed);
  toast(STATE.ui.registryCollapsed ? "REGISTRY CLOSED" : "REGISTRY OPEN");
});
$("btnToggleActive").addEventListener("click", ()=>{
  setActiveCollapsed(!STATE.ui.activeCollapsed);
  toast(STATE.ui.activeCollapsed ? "ACTIVE CLOSED" : "ACTIVE OPEN");
});
$("btnToggleSets").addEventListener("click", ()=>{
  setSetsCollapsed(!STATE.ui.setsCollapsed);
  toast(STATE.ui.setsCollapsed ? "SETS CLOSED" : "SETS OPEN");
});
$("btnToggleBulk").addEventListener("click", ()=>{
  setBulkCollapsed(!STATE.ui.bulkCollapsed);
  toast(STATE.ui.bulkCollapsed ? "BULK CLOSED" : "BULK OPEN");
});
$("btnTogglePresets").addEventListener("click", ()=>{
  setPresetsCollapsed(!STATE.ui.presetsCollapsed);
  toast(STATE.ui.presetsCollapsed ? "PRESETS CLOSED" : "PRESETS OPEN");
});

$("toggleDrawer").addEventListener("click", ()=>{
  if(STATE.ui.blackout || STATE.ui.fullscreen) return;
  setDrawer(!STATE.ui.drawerOpen);
});
$("toggleRun").addEventListener("click", ()=> toggleRun());

$("universals").addEventListener("input", ()=>{ STATE.universals=$("universals").value||""; persist(); });
$("ketaText").addEventListener("input", ()=>{ STATE.ketaNote=$("ketaText").value||""; persist(); });

$("ketaIcon").addEventListener("click", ()=>{
  if(STATE.ui.blackout) return;
  setKetaNote(!STATE.ui.noteOpen);
});
$("btnHideNote").addEventListener("click", ()=> setKetaNote(false));

$("btnSaveRoom").addEventListener("click", ()=>{
  upsertRoomPreset($("roomInput").value||"LINK", $("roomUrlInput").value||"");
  toast("SAVED");
  persist();
});
$("btnSetActiveRoom").addEventListener("click", ()=>{
  const r=$("roomInput").value||"BASE";
  const u=$("roomUrlInput").value||"";
  upsertRoomPreset(r,u);
  setActiveRoom(r,u);
  toast("ACTIVE SET");
  persist();
});
$("btnDeleteRoom").addEventListener("click", ()=>{
  const r=$("roomInput").value||"";
  if(!r.trim()){ toast("NO ROOM"); return; }
  deleteRoomPreset(r);
  toast("DELETED");
  persist();
});

$("btnTogglePins").addEventListener("click", ()=>{ toast("PINS = VISIBLE WHEN PINNED"); });

$("btnGoActive").addEventListener("click", ()=>{
  if(STATE.roomUrl) go(STATE.roomUrl);
  else toast("NO ACTIVE URL");
});
$("btnNewTabActive").addEventListener("click", ()=>{
  if(STATE.roomUrl) openNewTab(STATE.roomUrl);
  else toast("NO ACTIVE URL");
});
$("btnCopyActiveUrl").addEventListener("click", ()=>{ copy(String(STATE.roomUrl||"")); });

$("armedGo").addEventListener("click", ()=>{
  if(STATE.roomUrl) go(STATE.roomUrl);
  else toast("NO ACTIVE URL");
});
$("armedNewTab").addEventListener("click", ()=>{
  if(STATE.roomUrl) openNewTab(STATE.roomUrl);
  else toast("NO ACTIVE URL");
});
$("armedCopy").addEventListener("click", ()=>{ copy(String(STATE.roomUrl||"")); });

$("btnCreateSet").addEventListener("click", ()=>{
  const s=createSet($("setNameInput").value||"SET");
  setEditorFromSet(s);
  toast("SET CREATED");
  persist();
});
$("btnRenameSet").addEventListener("click", ()=>{
  if(!ACTIVE_SET_ID){ toast("NO SET"); return; }
  renameSet(ACTIVE_SET_ID, $("setNameInput").value||"SET");
  toast("SET RENAMED");
  persist();
});
$("btnDeleteSet").addEventListener("click", ()=>{
  if(!ACTIVE_SET_ID){ toast("NO SET"); return; }
  deleteSet(ACTIVE_SET_ID);
  $("setNameInput").value="";
  $("setItemsInput").value="";
  ACTIVE_SET_ID="";
  toast("SET DELETED");
  persist();
});
$("btnPinSet").addEventListener("click", ()=>{
  if(!ACTIVE_SET_ID){ toast("NO SET"); return; }
  togglePinSet(ACTIVE_SET_ID);
  toast(isSetPinned(ACTIVE_SET_ID) ? "SET PINNED" : "SET UNPINNED");
  persist();
});
$("btnSaveSetItems").addEventListener("click", ()=>{
  if(!ACTIVE_SET_ID){ toast("NO SET"); return; }
  saveSetItems(ACTIVE_SET_ID, $("setItemsInput").value||"");
  toast("ITEMS SAVED");
  persist();
});
$("btnClearSetItems").addEventListener("click", ()=>{
  $("setItemsInput").value="";
  toast("CLEARED");
});

$("btnBulkAdd").addEventListener("click", ()=>{
  const txt=$("bulkInput").value||"";
  const lines=txt.split("\n").map(x=>x.trim()).filter(Boolean);
  for(const line of lines){
    const parts=line.split("|");
    const name=(parts[0]||"").trim();
    const url=(parts[1]||"").trim();
    if(!name) continue;
    upsertRoomPreset(name,url,true);
  }
  toast("BULK MERGED");
  persist();
});
$("btnBulkClear").addEventListener("click", ()=>{
  $("bulkInput").value="";
  toast("CLEARED");
});

$("drawerH").addEventListener("input", ()=>{
  STATE.ui.drawerH = Number($("drawerH").value||360);
  root.style.setProperty("--drawer-h", String(STATE.ui.drawerH));
  persist(false);
});

$("btnClosePinned").addEventListener("click", ()=>{
  STATE.ui.pinnedOpen=false;
  persist();
});

/* =========================================================
EE ▸ LIST RENDERERS
========================================================= */
function renderRoomList(){
  const box=$("roomList");
  const rooms=[...(STATE.registry.rooms||[])];
  rooms.sort((a,b)=>(canonRoomName(a.name)).localeCompare(canonRoomName(b.name)));
  box.innerHTML="";
  for(const r of rooms){
    const d=document.createElement("div");
    d.style.padding="6px 0";
    d.style.borderBottom="1px solid #111";
    d.style.cursor="pointer";
    d.textContent=`${canonRoomName(r.name)}  ${r.url||""}`;
    d.addEventListener("click", ()=>{
      $("roomInput").value=canonRoomName(r.name);
      $("roomUrlInput").value=r.url||"";
      toast("LOADED");
    });
    box.appendChild(d);
  }
}

function renderSetList(){
  const box=$("setList");
  const sets=[...(STATE.registry.sets||[])];
  sets.sort((a,b)=>String(a.name||"").localeCompare(String(b.name||"")));
  box.innerHTML="";
  for(const s of sets){
    const d=document.createElement("div");
    d.style.padding="6px 0";
    d.style.borderBottom="1px solid #111";
    d.style.cursor="pointer";
    const pin = isSetPinned(s.id) ? "■" : "□";
    d.textContent=`${pin} ${s.name||"SET"}  (${(s.items||[]).length})`;
    d.addEventListener("click", ()=>{
      setEditorFromSet(s);
      toast("SET LOADED");
      render();
    });
    box.appendChild(d);
  }
}

function renderArmedBar(){
  $("armedRoom").textContent = canonRoomName(STATE.room||"BASE");
}

function renderPinnedPanel(){
  ensurePinnedSets();
  const pins=STATE.ui.pinnedSets||[];
  const open = pins.length>0;
  STATE.ui.pinnedOpen = open;
  const panel=$("pinned");
  panel.classList.toggle("open", open);
  const body=$("pinnedBody");
  body.innerHTML="";
  if(!open) return;

  for(const id of pins){
    const s=STATE.registry.sets.find(x=>x.id===id);
    if(!s) continue;
    const wrap=document.createElement("div");
    wrap.className="pinnedItem";

    const title=document.createElement("div");
    title.className="pinnedItemTitle";
    title.textContent = s.name||"SET";
    wrap.appendChild(title);

    const txt=document.createElement("div");
    txt.className="pinnedItemText";
    txt.textContent = (s.items||[]).join("\n");
    wrap.appendChild(txt);

    const row=document.createElement("div");
    row.style.display="flex";
    row.style.gap="8px";
    row.style.marginTop="8px";

    const unpin=document.createElement("button");
    unpin.className="btn miniBtn";
    unpin.textContent="UNPIN";
    unpin.addEventListener("click", ()=>{
      togglePinSet(s.id);
      persist();
    });

    const copyBtn=document.createElement("button");
    copyBtn.className="btn miniBtn";
    copyBtn.textContent="COPY";
    copyBtn.addEventListener("click", ()=> copy((s.items||[]).join("\n")));

    row.appendChild(unpin);
    row.appendChild(copyBtn);

    wrap.appendChild(row);

    body.appendChild(wrap);
  }
}

/* =========================================================
BOOT
========================================================= */
const _BOOT_LOADED = loadLocal();
let STATE = _BOOT_LOADED ? _BOOT_LOADED : structuredClone(DEFAULT);
ensureCorePresets();
root.style.setProperty("--drawer-h", String(STATE.ui.drawerH));
bindHotkeys();

_BOOTING = false;
render();

/* Seed sovereign storage only if nothing exists yet */
if(!_BOOT_LOADED){
  persist(true);
}
</script>

<!-- =========================================================
AE/EE/WB SERIALIZATION STAMP (MANDATORY)
AE/EE/WB + FILE_ID/ROOM_ID/VERSION/UPDATED_AT/CHANGELOG
FILE_ID: KETADATA_SHELL8
ROOM_ID: BASE
VERSION: BASE_SYSTEM_SOVEREIGN_v5
UPDATED_AT: 2025-12-28T00:00:00-05:00
CHANGELOG:
- EE: LAZY DIVA PERSISTENCE WRAPPER: localStorage primary, sessionStorage fallback, window.name last-resort mirror (survives refresh even when storage is blocked)
- EE: ALL STORAGE CALLS ROUTED THROUGH WRAPPER (NO MORE DIRECT localStorage/sessionStorage CALLS)
- EE: BFCache PAGESHOW REHYDRATE HOOK ADDED
- WB: NO UI/AESTHETIC/INTERACTION CHANGES
========================================================= -->
</body>
</html>
