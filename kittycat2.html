<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA // KITTY</title>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --muted:rgba(255,255,255,.62);
      --hair:rgba(255,255,255,.12);
      --panel:rgba(0,0,0,.38);
      --panel2:rgba(0,0,0,.58);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:var(--bg);
      color:var(--fg);
      font:11px/1.3 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      overflow:hidden;
      user-select:none;
      letter-spacing: 0.02em;
    }

    body.invert{ filter: invert(1) hue-rotate(180deg); background:#fff; }
    body.nullmode .chrome{display:none}
    body.nullmode #hud{opacity:0; pointer-events:none}

    #field{
      position:absolute; inset:0;
      background:
        radial-gradient(1600px 1100px at 50% 35%, rgba(255,255,255,.10), rgba(0,0,0,0) 68%),
        radial-gradient(1100px 1000px at 25% 85%, rgba(255,255,255,.05), rgba(0,0,0,0) 62%),
        radial-gradient(900px 800px at 80% 25%, rgba(255,255,255,.04), rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,0) 48%),
        linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.50));
    }
    canvas{position:absolute; inset:0; width:100%; height:100%}

    .chrome{position:absolute; inset:0; pointer-events:none}
    #frame{position:absolute; inset:10px; border:1px solid rgba(255,255,255,.05); pointer-events:none; opacity: 0.6;}

    #hud{
      position:absolute;
      top:12px; left:12px;
      width:360px;
      border:1px solid var(--hair);
      background:var(--panel);
      backdrop-filter: blur(8px);
      pointer-events:auto;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    #hud .bar{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 10px;
      border-bottom:1px solid var(--hair);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,0));
    }
    #hud .bar .title{opacity:.95; font-weight: 400;}
    #hud .bar .meta{opacity:.58; font-size: 10px;}
    #hud .body{padding:10px; display:grid; gap:10px}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .btn, .pill, input[type="range"]{font:inherit; color:inherit}
    .btn{
      border:1px solid var(--hair);
      background:rgba(255,255,255,.03);
      padding:6px 10px;
      cursor:pointer;
      user-select:none;
      transition: all 0.15s ease;
    }
    .btn:hover{background:rgba(255,255,255,.08); border-color: rgba(255,255,255,0.2);}
    .btn:active{transform: translateY(1px)}
    .pill{
      border:1px solid var(--hair);
      padding:6px 10px;
      background:rgba(0,0,0,.15);
      opacity:.88;
    }
    input[type="range"]{width:130px; accent-color: var(--fg)}
    .label{opacity:.75; font-size: 10px; text-transform: uppercase;}
    .mini{opacity:.58; font-size: 10px;}
    .sep{height:1px;background:var(--hair);margin:4px 0; opacity: 0.5;}

    #note{
      position:absolute;
      right:12px; top:12px;
      width:360px; height:240px;
      border:1px solid var(--hair);
      background:var(--panel2);
      backdrop-filter: blur(8px);
      pointer-events:auto;
      display:none;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    #note.open{display:block}
    #note .bar{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 10px;
      border-bottom:1px solid var(--hair);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,0));
      cursor:move;
      user-select:none;
    }
    #note textarea{
      width:100%; height: calc(100% - 36px);
      border:0; outline:none; resize:none;
      background:transparent;
      color:var(--fg);
      font:inherit;
      padding:10px;
      user-select:text;
    }

    #cornerDots{position:absolute; left:12px; bottom:12px; display:flex; gap:7px; pointer-events:none; opacity:.5}
    .dot{width:8px; height:8px; border-radius:50%; border:1px solid var(--hair); background:rgba(255,255,255,.04)}

    #statusLine{
      position:absolute; right:12px; bottom:12px;
      border:1px solid var(--hair);
      background:rgba(0,0,0,.22);
      backdrop-filter: blur(4px);
      padding:6px 10px;
      opacity:.82;
      pointer-events:none;
      max-width:60vw;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-size: 10px;
    }
  </style>
</head>
<body>
  <div id="field"><canvas id="c"></canvas></div>

  <div class="chrome">
    <div id="frame"></div>

    <div id="hud">
      <div class="bar">
        <div class="title">KETADATA // KITTY</div>
        <div class="meta" id="meta">REALISTIC RENDER</div>
      </div>

      <div class="body">
        <div class="row">
          <div class="pill"><span class="label">HOTKEYS</span> <span class="mini">SHIFT+I INVERT · SHIFT+N NULL · SHIFT+F FULL · SHIFT+K NOTE · SPACE GLIDE</span></div>
        </div>

        <div class="sep"></div>

        <div class="row">
          <button class="btn" id="btnNote">NOTE</button>
          <button class="btn" id="btnInvert">INVERT</button>
          <button class="btn" id="btnNull">NULL</button>
          <button class="btn" id="btnFull">FULL</button>
          <span class="label">MOTION</span>
          <button class="btn" id="btnMotion">ON</button>
        </div>

        <div class="row">
          <span class="label">SIZE</span>
          <input type="range" id="rngSize" min="90" max="200" step="1" value="150" />
          <span class="label">PACE</span>
          <input type="range" id="rngSpeed" min="0" max="100" step="1" value="32" />
        </div>

        <div class="row">
          <span class="label">DETAIL</span>
          <input type="range" id="rngDetail" min="0" max="100" step="1" value="78" />
          <span class="label">TRAIL</span>
          <input type="range" id="rngTrail" min="0" max="100" step="1" value="88" />
        </div>

        <div class="row">
          <span class="label">RESEED</span>
          <button class="btn" id="btnSeed">GO</button>
          <span class="label">REST</span>
          <button class="btn" id="btnRest">IDLE</button>
        </div>
      </div>
    </div>

    <div id="note">
      <div class="bar">
        <div>KETA_NOTE</div>
        <div class="mini">SHIFT+K</div>
      </div>
      <textarea id="noteText" spellcheck="false" placeholder="KETA_NOTE"></textarea>
    </div>

    <div id="cornerDots" aria-hidden="true">
      <div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div>
    </div>

    <div id="statusLine">READY</div>
  </div>

<script>
const FILE_ID = "KETADATA_KITTY_REALISTIC";
const LS_KEY = "KETADATA::" + FILE_ID + "::STATE";
const $ = (id)=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;

const state = {
  invert:false, nullMode:false, fullscreen:false, motion:true,
  size:1.50, pace:0.32, detail:0.78, trail:0.88,
  seed:(Math.random()*1e9)>>>0,
  noteOpen:false, notePos:{x:null,y:null}, noteText:"",
  rest:false
};

function loadState(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(!s || typeof s!=="object") return;
    Object.assign(state, s);
  }catch(_){}
}
function saveState(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(_){ } }
function status(t){ $("statusLine").textContent = t; }

function applyState(){
  document.body.classList.toggle("invert", !!state.invert);
  document.body.classList.toggle("nullmode", !!state.nullMode);

  $("rngSize").value = String(Math.round(state.size*100));
  $("rngSpeed").value = String(Math.round(state.pace*100));
  $("rngDetail").value = String(Math.round(state.detail*100));
  $("rngTrail").value = String(Math.round(state.trail*100));
  $("btnMotion").textContent = state.motion ? "ON" : "OFF";
  $("btnRest").textContent = state.rest ? "WAKE" : "IDLE";

  $("meta").textContent = `REALISTIC RENDER`;

  $("noteText").value = state.noteText || "";
  $("note").classList.toggle("open", !!state.noteOpen);
  if(state.notePos && state.notePos.x!=null && state.notePos.y!=null){
    $("note").style.left = state.notePos.x + "px";
    $("note").style.top = state.notePos.y + "px";
    $("note").style.right = "auto";
  }

  status(`SIZE ${Math.round(state.size*100)} · PACE ${Math.round(state.pace*100)} · DETAIL ${Math.round(state.detail*100)} · REST ${state.rest?1:0}`);
}

const canvas = $("c");
const ctx = canvas.getContext("2d", { alpha:true });
let W=0,H=0,DPR=1;

function resize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  W = Math.floor(window.innerWidth * DPR);
  H = Math.floor(window.innerHeight * DPR);
  canvas.width = W;
  canvas.height = H;
}
addEventListener("resize", resize);

const kitty = {
  x: 0.50, y: 0.65,
  vx: 0, vy: 0,
  ang: 0,
  wp: [],
  wpT: 0,
  blink: 0,
  glide: 0,
  tailPhase: 0,
  breathPhase: 0
};

function strokeCol(){ return document.body.classList.contains("invert") ? "rgba(10,12,15,.92)" : "rgba(255,255,255,.92)"; }
function strokeDark(){ return document.body.classList.contains("invert") ? "rgba(10,12,15,.70)" : "rgba(255,255,255,.70)"; }
function strokeLight(){ return document.body.classList.contains("invert") ? "rgba(10,12,15,.45)" : "rgba(255,255,255,.45)"; }
function fillLight(){ return document.body.classList.contains("invert") ? "rgba(10,12,15,.08)" : "rgba(255,255,255,.08)"; }
function fillMid(){ return document.body.classList.contains("invert") ? "rgba(10,12,15,.15)" : "rgba(255,255,255,.15)"; }
function shadowCol(){ return document.body.classList.contains("invert") ? "rgba(10,12,15,.18)" : "rgba(0,0,0,.18)"; }
function furCol(){ return document.body.classList.contains("invert") ? "rgba(10,12,15,.06)" : "rgba(255,255,255,.06)"; }

function makeWaypoint(){
  return {
    x: clamp(0.18 + Math.random()*0.64, 0.12, 0.88),
    y: clamp(0.35 + Math.random()*0.48, 0.20, 0.85),
    hold: 1600 + Math.random()*2800
  };
}

function ensurePath(){
  while(kitty.wp.length < 4) kitty.wp.push(makeWaypoint());
}

function stepPath(t){
  ensurePath();
  if(t > kitty.wpT){
    const w = kitty.wp.shift();
    kitty.wp.push(makeWaypoint());
    kitty.wpT = t + w.hold;
  }
  const a = kitty.wp[0];
  const b = kitty.wp[1];
  const segLen = 2800;
  const u = clamp(1 - (kitty.wpT - t)/segLen, 0, 1);
  const s = u*u*(3-2*u);
  return { x: lerp(a.x, b.x, s), y: lerp(a.y, b.y, s) };
}

function drawRealisticCat(cx,cy,scale,ang,t){
  const stroke = strokeCol();
  const strokeD = strokeDark();
  const strokeL = strokeLight();
  const fillL = fillLight();
  const fillM = fillMid();
  const shadow = shadowCol();
  const fur = furCol();

  const speed = Math.hypot(kitty.vx, kitty.vy);
  const motion = state.motion;
  const detail = state.detail;

  // Hyper-realistic cat proportions
  const bodyLen = 1.25 * scale;
  const bodyHeight = 0.42 * scale;
  const headSize = 0.44 * scale;
  const legLen = 0.52 * scale;

  // Realistic stride
  const strideFreq = 0.8 + speed*120;
  const stride = motion ? (t*0.001*strideFreq) : 0;
  const stepAmp = clamp(speed*200, 0, 1);
  
  // Body bob (natural gait)
  const bob = motion ? Math.sin(stride*2) * 0.08 * scale * stepAmp : 0;

  // Anatomically accurate spine curve
  const spine = [];
  const spineSegments = 20;
  for(let i=0; i<=spineSegments; i++){
    const t = i/spineSegments;
    // Natural cat spine curve (arched slightly)
    const x = (t - 0.5) * bodyLen;
    const arch = Math.sin(t*Math.PI) * 0.15 * scale;
    const y = -arch + bob * (0.5 + 0.5*Math.cos(t*Math.PI));
    spine.push({x, y});
  }

  // Shoulders and hips (realistic placement)
  const shoulderIdx = Math.floor(spineSegments * 0.72);
  const hipIdx = Math.floor(spineSegments * 0.25);
  
  const shoulderPos = spine[shoulderIdx];
  const hipPos = spine[hipIdx];

  // Legs - realistic feline articulation
  const groundY = 0.42 * scale;
  
  function getLegPos(phase, isRear){
    const lift = Math.max(0, Math.sin(phase)) * stepAmp;
    const reach = Math.sin(phase) * 0.24 * scale * stepAmp;
    
    return {
      dx: reach,
      dy: groundY - lift * (isRear ? 0.10 : 0.12) * scale
    };
  }

  const legFL = getLegPos(stride, false);
  const legFR = getLegPos(stride + Math.PI, false);
  const legHL = getLegPos(stride + Math.PI, true);
  const legHR = getLegPos(stride, true);

  // Tail (flowing, natural)
  kitty.tailPhase += 0.012;
  const tailBase = spine[0];
  const tailLen = 1.10 * scale;

  // Head position (front of spine)
  const neckBase = spine[spineSegments];
  const headX = neckBase.x + 0.22*scale;
  const headY = neckBase.y - 0.18*scale;

  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate(ang);
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  // Drop shadow (realistic ground contact)
  ctx.save();
  ctx.globalAlpha = 0.3;
  const gradient = ctx.createRadialGradient(0, groundY+0.10*scale, 0, 0, groundY+0.10*scale, scale*0.60);
  gradient.addColorStop(0, shadow);
  gradient.addColorStop(1, 'transparent');
  ctx.fillStyle = gradient;
  ctx.fillRect(-scale, groundY, scale*2, scale*0.3);
  ctx.restore();

  // Body mass (realistic organic shape with gradient shading)
  ctx.save();
  
  // Create body silhouette
  const bodyTop = [];
  const bodyBottom = [];
  
  for(let i=0; i<=spineSegments; i++){
    const t = i/spineSegments;
    const sp = spine[i];
    
    // Realistic cat body width (fuller in middle)
    const widthCurve = Math.sin(t * Math.PI);
    const width = bodyHeight * (0.35 + widthCurve * 0.65);
    
    bodyTop.push({x: sp.x, y: sp.y - width});
    bodyBottom.push({x: sp.x, y: sp.y + width});
  }

  // Multi-layer body rendering for depth and realism
  
  // Base body fill with radial gradient (top-lit volume)
  const centerX = (bodyTop[10].x + bodyBottom[10].x) / 2;
  const centerY = (bodyTop[10].y + bodyBottom[10].y) / 2;
  const bodyRadial = ctx.createRadialGradient(centerX, centerY - bodyHeight*0.3, 0, centerX, centerY, bodyHeight*1.2);
  bodyRadial.addColorStop(0, fillM);
  bodyRadial.addColorStop(0.5, fillL);
  bodyRadial.addColorStop(1, 'rgba(0,0,0,0.08)');
  
  ctx.fillStyle = bodyRadial;
  ctx.beginPath();
  ctx.moveTo(bodyTop[0].x, bodyTop[0].y);
  for(const p of bodyTop) ctx.lineTo(p.x, p.y);
  for(let i=bodyBottom.length-1; i>=0; i--) ctx.lineTo(bodyBottom[i].x, bodyBottom[i].y);
  ctx.closePath();
  ctx.fill();
  
  // Belly shadow (underside darker)
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.beginPath();
  ctx.moveTo(bodyBottom[0].x, bodyBottom[0].y);
  for(const p of bodyBottom) ctx.lineTo(p.x, p.y);
  ctx.lineTo(bodyBottom[bodyBottom.length-1].x, bodyBottom[bodyBottom.length-1].y - bodyHeight*0.4);
  ctx.lineTo(bodyBottom[0].x, bodyBottom[0].y - bodyHeight*0.4);
  ctx.closePath();
  ctx.fill();
  
  // Shoulder/hip muscle definition
  if(detail > 0.4){
    ctx.strokeStyle = 'rgba(0,0,0,0.10)';
    ctx.lineWidth = 2*DPR;
    
    // Shoulder muscles
    const shoulderMuscle = spine[Math.floor(spineSegments * 0.70)];
    ctx.beginPath();
    ctx.arc(shoulderMuscle.x, shoulderMuscle.y - bodyHeight*0.15, bodyHeight*0.35, 0, Math.PI*2);
    ctx.stroke();
    
    // Hip muscles
    const hipMuscle = spine[Math.floor(spineSegments * 0.28)];
    ctx.beginPath();
    ctx.arc(hipMuscle.x, hipMuscle.y - bodyHeight*0.12, bodyHeight*0.32, 0, Math.PI*2);
    ctx.stroke();
  }
  
  // Main body outline (crisp edge)
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2.8*DPR;
  ctx.beginPath();
  ctx.moveTo(bodyTop[0].x, bodyTop[0].y);
  for(const p of bodyTop) ctx.lineTo(p.x, p.y);
  for(let i=bodyBottom.length-1; i>=0; i--) ctx.lineTo(bodyBottom[i].x, bodyBottom[i].y);
  ctx.closePath();
  ctx.stroke();
  
  // Spine ridge highlight
  if(detail > 0.6){
    ctx.strokeStyle = fillM;
    ctx.lineWidth = 1.5*DPR;
    ctx.beginPath();
    ctx.moveTo(spine[0].x, spine[0].y - bodyHeight*0.15);
    for(let i=0; i<=spineSegments; i++){
      const s = spine[i];
      ctx.lineTo(s.x, s.y - bodyHeight*0.15);
    }
    ctx.stroke();
  }
  
  ctx.restore();

  // Advanced fur texture (layered, directional, realistic)
  if(detail > 0.2){
    const furDensity = Math.floor(20 * detail);
    
    // Layer 1: Deep fur (darkest)
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.lineWidth = 1.2*DPR;
    for(let i=0; i<furDensity; i++){
      const t = (i+0.3)/furDensity;
      const idx = Math.floor(t * spineSegments);
      const sp = spine[Math.min(idx, spineSegments-1)];
      const nextIdx = Math.min(idx+1, spineSegments-1);
      const dir = {
        x: spine[nextIdx].x - sp.x,
        y: spine[nextIdx].y - sp.y
      };
      const mag = Math.hypot(dir.x, dir.y) || 1;
      const nx = -dir.y/mag, ny = dir.x/mag;
      
      // Vary fur length naturally
      const furLength = (0.10 + Math.random()*0.06) * scale;
      const furAngle = Math.random()*0.3 - 0.15;
      
      ctx.beginPath();
      ctx.moveTo(sp.x - nx*bodyHeight*0.4, sp.y - ny*bodyHeight*0.4);
      ctx.lineTo(
        sp.x + nx*furLength + dir.x*furAngle,
        sp.y + ny*furLength + dir.y*furAngle
      );
      ctx.stroke();
    }
    
    // Layer 2: Mid-tone fur
    ctx.strokeStyle = fur;
    ctx.lineWidth = 1*DPR;
    for(let i=0; i<furDensity*1.5; i++){
      const t = (i+0.5)/furDensity/1.5;
      const idx = Math.floor(t * spineSegments);
      const sp = spine[Math.min(idx, spineSegments-1)];
      const nextIdx = Math.min(idx+1, spineSegments-1);
      const dir = {
        x: spine[nextIdx].x - sp.x,
        y: spine[nextIdx].y - sp.y
      };
      const mag = Math.hypot(dir.x, dir.y) || 1;
      const nx = -dir.y/mag, ny = dir.x/mag;
      
      const furLength = (0.08 + Math.random()*0.04) * scale;
      const furAngle = Math.random()*0.25 - 0.125;
      
      ctx.beginPath();
      ctx.moveTo(sp.x - nx*bodyHeight*0.35, sp.y - ny*bodyHeight*0.35);
      ctx.lineTo(
        sp.x + nx*furLength + dir.x*furAngle,
        sp.y + ny*furLength + dir.y*furAngle
      );
      ctx.stroke();
    }
    
    // Layer 3: Top fur (highlights)
    if(detail > 0.5){
      ctx.strokeStyle = strokeL;
      ctx.lineWidth = 0.8*DPR;
      for(let i=0; i<furDensity*0.8; i++){
        const t = (i+0.7)/furDensity/0.8;
        const idx = Math.floor(t * spineSegments);
        const sp = spine[Math.min(idx, spineSegments-1)];
        const nextIdx = Math.min(idx+1, spineSegments-1);
        const dir = {
          x: spine[nextIdx].x - sp.x,
          y: spine[nextIdx].y - sp.y
        };
        const mag = Math.hypot(dir.x, dir.y) || 1;
        const nx = -dir.y/mag, ny = dir.x/mag;
        
        const furLength = (0.06 + Math.random()*0.03) * scale;
        
        ctx.beginPath();
        ctx.moveTo(sp.x - nx*bodyHeight*0.30, sp.y - ny*bodyHeight*0.30);
        ctx.lineTo(sp.x + nx*furLength, sp.y + ny*furLength);
        ctx.stroke();
      }
    }
  }

  // Legs (realistic feline anatomy with joints)
  function drawRealisticLeg(baseX, baseY, footPos, isRear){
    const fx = baseX + footPos.dx;
    const fy = footPos.dy;
    
    // Upper leg
    const upperLen = legLen * 0.48;
    // Knee/elbow position (realistic bend)
    const bendX = lerp(baseX, fx, 0.45);
    const bendY = lerp(baseY, fy, 0.35);
    
    // Add natural offset for realistic joint
    const jointOffX = (fx - baseX) * 0.15;
    const jointOffY = -legLen * 0.18;
    
    const kneeX = bendX + jointOffX;
    const kneeY = bendY + jointOffY;
    
    // Draw leg with gradient (volumetric)
    const legGrad = ctx.createLinearGradient(baseX, baseY, fx, fy);
    legGrad.addColorStop(0, strokeD);
    legGrad.addColorStop(1, strokeL);
    
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2.2*DPR;
    ctx.beginPath();
    ctx.moveTo(baseX, baseY);
    ctx.lineTo(kneeX, kneeY);
    ctx.lineTo(fx, fy);
    ctx.stroke();
    
    // Joint indicators
    ctx.fillStyle = fillM;
    ctx.beginPath();
    ctx.arc(kneeX, kneeY, 0.035*scale, 0, Math.PI*2);
    ctx.fill();
    
    // Paw (realistic shape)
    ctx.strokeStyle = strokeL;
    ctx.lineWidth = 2*DPR;
    ctx.beginPath();
    ctx.arc(fx, fy, 0.045*scale, 0, Math.PI);
    ctx.stroke();
    
    // Paw pads
    if(detail > 0.5){
      ctx.fillStyle = strokeL;
      for(let i=-1; i<=1; i++){
        ctx.beginPath();
        ctx.arc(fx + i*0.018*scale, fy, 0.010*scale, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  // Draw legs (rear first for natural layering)
  drawRealisticLeg(hipPos.x - 0.10*scale, hipPos.y + 0.08*scale, legHL, true);
  drawRealisticLeg(hipPos.x + 0.10*scale, hipPos.y + 0.08*scale, legHR, true);
  drawRealisticLeg(shoulderPos.x - 0.08*scale, shoulderPos.y + 0.06*scale, legFL, false);
  drawRealisticLeg(shoulderPos.x + 0.08*scale, shoulderPos.y + 0.06*scale, legFR, false);

  // Tail (realistic flowing motion)
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2.5*DPR;
  ctx.beginPath();
  ctx.moveTo(tailBase.x, tailBase.y);
  
  const tailSegs = 40;
  for(let i=1; i<=tailSegs; i++){
    const t = i/tailSegs;
    const x = tailBase.x - t * tailLen;
    const wave = Math.sin(kitty.tailPhase + t*4) * 0.16*scale * (1-t*0.5);
    const gravity = t * t * 0.08*scale;
    const y = tailBase.y + wave + gravity;
    
    ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Tail tapering effect
  if(detail > 0.4){
    ctx.lineWidth = 1.5*DPR;
    ctx.strokeStyle = strokeL;
    ctx.stroke();
  }

  // Head (hyper-realistic cat head with facial structure)
  ctx.save();
  ctx.translate(headX, headY);
  
  // Head dimensions with natural cat skull structure
  const headW = headSize * 0.95;
  const headH = headSize * 0.88;
  
  // Multi-layer head shading for volume
  // Base shadow layer
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.beginPath();
  ctx.ellipse(0, headH*0.05, headW*0.52, headH*0.52, 0, 0, Math.PI*2);
  ctx.fill();
  
  // Main head mass with radial gradient (top-lit)
  const headGrad = ctx.createRadialGradient(0, -headH*0.25, 0, 0, 0, headSize*0.65);
  headGrad.addColorStop(0, fillM);
  headGrad.addColorStop(0.6, fillL);
  headGrad.addColorStop(1, 'rgba(0,0,0,0.08)');
  
  ctx.fillStyle = headGrad;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2.8*DPR;
  
  // Realistic head outline with cheek structure
  ctx.beginPath();
  ctx.ellipse(0, 0, headW*0.50, headH*0.50, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.stroke();
  
  // Cheek definition
  if(detail > 0.5){
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.lineWidth = 1.5*DPR;
    ctx.beginPath();
    ctx.arc(-headW*0.30, headH*0.15, headW*0.18, -Math.PI*0.3, Math.PI*0.4);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(headW*0.30, headH*0.15, headW*0.18, Math.PI*0.6, Math.PI*1.3);
    ctx.stroke();
  }
  
  // Forehead contour
  if(detail > 0.6){
    ctx.strokeStyle = strokeL;
    ctx.lineWidth = 1*DPR;
    ctx.beginPath();
    ctx.moveTo(-headW*0.25, -headH*0.28);
    ctx.quadraticCurveTo(0, -headH*0.35, headW*0.25, -headH*0.28);
    ctx.stroke();
  }

  // Ears (realistic triangular with inner detail)
  function drawEar(ex, flip){
    ctx.fillStyle = fillL;
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2.2*DPR;
    
    ctx.beginPath();
    ctx.moveTo(ex, -headH*0.35);
    ctx.lineTo(ex + flip*0.16*scale, -headH*0.35 - 0.28*scale);
    ctx.lineTo(ex + flip*0.06*scale, -headH*0.35 - 0.05*scale);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Inner ear
    if(detail > 0.6){
      ctx.strokeStyle = strokeL;
      ctx.lineWidth = 1*DPR;
      ctx.beginPath();
      ctx.moveTo(ex + flip*0.04*scale, -headH*0.35 - 0.08*scale);
      ctx.lineTo(ex + flip*0.12*scale, -headH*0.35 - 0.22*scale);
      ctx.stroke();
    }
  }
  
  drawEar(-headW*0.35, -1);
  drawEar(headW*0.35, 1);

  // Muzzle (realistic cat snout with volume)
  ctx.strokeStyle = strokeL;
  ctx.lineWidth = 1.8*DPR;
  ctx.beginPath();
  ctx.moveTo(-0.17*scale, headH*0.15);
  ctx.quadraticCurveTo(0, headH*0.27, 0.17*scale, headH*0.15);
  ctx.stroke();
  
  // Muzzle padding (cheek puffs)
  if(detail > 0.5){
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.beginPath();
    ctx.ellipse(-0.12*scale, headH*0.18, 0.08*scale, 0.06*scale, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(0.12*scale, headH*0.18, 0.08*scale, 0.06*scale, 0, 0, Math.PI*2);
    ctx.fill();
  }
  
  // Nose (realistic detailed triangle with nostril shadows)
  ctx.fillStyle = strokeD;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5*DPR;
  
  ctx.beginPath();
  ctx.moveTo(-0.028*scale, headH*0.10);
  ctx.lineTo(0.028*scale, headH*0.10);
  ctx.lineTo(0, headH*0.17);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  
  // Nostril detail
  if(detail > 0.6){
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.ellipse(-0.012*scale, headH*0.13, 0.008*scale, 0.012*scale, Math.PI*0.25, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(0.012*scale, headH*0.13, 0.008*scale, 0.012*scale, -Math.PI*0.25, 0, Math.PI*2);
    ctx.fill();
  }
  
  // Philtrum (nose to mouth line)
  if(detail > 0.7){
    ctx.strokeStyle = strokeL;
    ctx.lineWidth = 1*DPR;
    ctx.beginPath();
    ctx.moveTo(0, headH*0.17);
    ctx.lineTo(0, headH*0.22);
    ctx.stroke();
  }

  // Eyes (hyper-realistic feline eyes with depth)
  kitty.breathPhase += 0.008;
  const blink = clamp(kitty.blink, 0, 1);
  const eyeOpen = 1 - blink;
  
  function drawEye(ex){
    if(eyeOpen > 0.2){
      // Eye socket shadow (depth)
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.beginPath();
      ctx.ellipse(ex, -headH*0.10, 0.072*scale, 0.052*scale, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Eye white (sclera)
      ctx.fillStyle = fillL;
      ctx.beginPath();
      ctx.ellipse(ex, -headH*0.10, 0.068*scale*eyeOpen, 0.048*scale*eyeOpen, 0, 0, Math.PI*2);
      ctx.fill();
      
      // Iris (colored with gradient)
      if(detail > 0.4 && eyeOpen > 0.4){
        const irisGrad = ctx.createRadialGradient(ex, -headH*0.10, 0, ex, -headH*0.10, 0.040*scale);
        irisGrad.addColorStop(0, strokeD);
        irisGrad.addColorStop(0.7, 'rgba(0,0,0,0.5)');
        irisGrad.addColorStop(1, 'rgba(0,0,0,0.2)');
        
        ctx.fillStyle = irisGrad;
        ctx.beginPath();
        ctx.ellipse(ex, -headH*0.10, 0.040*scale*eyeOpen, 0.040*scale*eyeOpen, 0, 0, Math.PI*2);
        ctx.fill();
      }
      
      // Pupil (vertical slit with realistic taper)
      if(detail > 0.3 && eyeOpen > 0.5){
        ctx.fillStyle = 'rgba(0,0,0,0.95)';
        ctx.beginPath();
        ctx.ellipse(ex, -headH*0.10, 0.012*scale, 0.038*scale*eyeOpen, 0, 0, Math.PI*2);
        ctx.fill();
        
        // Pupil inner detail
        if(detail > 0.7){
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.beginPath();
          ctx.ellipse(ex, -headH*0.10, 0.016*scale, 0.042*scale*eyeOpen, 0, 0, Math.PI*2);
          ctx.fill();
        }
      }
      
      // Eye outline (almond shape)
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2.2*DPR;
      ctx.beginPath();
      ctx.ellipse(ex, -headH*0.10, 0.068*scale*eyeOpen, 0.048*scale*eyeOpen, 0, 0, Math.PI*2);
      ctx.stroke();
      
      // Eye highlights (realistic multi-point shine)
      if(detail > 0.5 && eyeOpen > 0.6){
        // Primary shine
        ctx.fillStyle = 'rgba(255,255,255,0.75)';
        ctx.beginPath();
        ctx.arc(ex - 0.022*scale, -headH*0.12, 0.014*scale, 0, Math.PI*2);
        ctx.fill();
        
        // Secondary shine
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.beginPath();
        ctx.arc(ex + 0.018*scale, -headH*0.09, 0.008*scale, 0, Math.PI*2);
        ctx.fill();
      }
      
      // Lower eyelid detail
      if(detail > 0.6){
        ctx.strokeStyle = strokeL;
        ctx.lineWidth = 1*DPR;
        ctx.beginPath();
        ctx.arc(ex, -headH*0.10, 0.068*scale*eyeOpen, 0.048*scale*eyeOpen, Math.PI*0.25, Math.PI*0.75);
        ctx.stroke();
      }
    } else {
      // Closed eye (realistic lid shape)
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2.2*DPR;
      ctx.beginPath();
      ctx.ellipse(ex, -headH*0.10, 0.068*scale, 0.012*scale, 0, 0, Math.PI*2);
      ctx.stroke();
      
      // Eyelash detail
      if(detail > 0.5){
        ctx.strokeStyle = strokeL;
        ctx.lineWidth = 0.8*DPR;
        for(let i=-2; i<=2; i++){
          ctx.beginPath();
          ctx.moveTo(ex + i*0.015*scale, -headH*0.10);
          ctx.lineTo(ex + i*0.015*scale, -headH*0.10 - 0.015*scale);
          ctx.stroke();
        }
      }
    }
  }
  
  drawEye(-headW*0.28);
  drawEye(headW*0.28);

  // Whiskers (hyper-realistic with natural taper and curve)
  ctx.strokeStyle = strokeL;
  ctx.lineWidth = 1.2*DPR;
  
  // Whisker roots (pores)
  if(detail > 0.6){
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    for(let k=-1; k<=1; k++){
      const wy = headH*0.18 + k*0.038*scale;
      ctx.beginPath();
      ctx.arc(-headW*0.15, wy, 0.008*scale, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(headW*0.15, wy, 0.008*scale, 0, Math.PI*2);
      ctx.fill();
    }
  }
  
  for(let k=-1; k<=1; k++){
    const wy = headH*0.18 + k*0.038*scale;
    const wobble = Math.sin(t*0.0010 + k*1.2) * 0.014*scale;
    const wobble2 = Math.cos(t*0.0008 + k*0.8) * 0.010*scale;
    
    // Left whiskers (with realistic bezier curve)
    ctx.lineWidth = (1.2 - k*k*0.2)*DPR;
    ctx.beginPath();
    ctx.moveTo(-headW*0.15, wy);
    ctx.bezierCurveTo(
      -headW*0.28, wy - 0.02*scale + wobble2,
      -0.42*scale, wy + wobble - k*0.015*scale,
      -0.48*scale, wy + wobble*1.8 - k*0.020*scale
    );
    ctx.stroke();
    
    // Right whiskers
    ctx.beginPath();
    ctx.moveTo(headW*0.15, wy);
    ctx.bezierCurveTo(
      headW*0.28, wy - 0.02*scale + wobble2,
      0.42*scale, wy + wobble - k*0.015*scale,
      0.48*scale, wy + wobble*1.8 - k*0.020*scale
    );
    ctx.stroke();
  }
  
  // Eyebrow whiskers (short tufts)
  if(detail > 0.7){
    ctx.lineWidth = 0.8*DPR;
    for(let side of [-1, 1]){
      for(let i=0; i<2; i++){
        ctx.beginPath();
        ctx.moveTo(side * headW*0.35, -headH*0.25);
        ctx.lineTo(
          side * (headW*0.35 + 0.08*scale),
          -headH*0.25 - 0.06*scale + i*0.02*scale
        );
        ctx.stroke();
      }
    }
  }

  ctx.restore(); // end head transform

  // Chest/shoulder definition (realistic musculature hints)
  if(detail > 0.6){
    ctx.strokeStyle = strokeL;
    ctx.lineWidth = 1*DPR;
    ctx.beginPath();
    ctx.moveTo(shoulderPos.x - 0.10*scale, shoulderPos.y);
    ctx.lineTo(shoulderPos.x + 0.15*scale, shoulderPos.y + 0.08*scale);
    ctx.stroke();
  }

  ctx.restore();
}

function step(t){
  const motion = state.motion;

  // Refined trailing
  const alpha = motion ? (0.18 - 0.14*state.trail) : 1.0;
  ctx.fillStyle = `rgba(0,0,0,${clamp(alpha, 0.015, 1)})`;
  ctx.fillRect(0,0,W,H);

  // Subtle grid
  ctx.strokeStyle = document.body.classList.contains("invert") ? "rgba(10,12,15,.010)" : "rgba(255,255,255,.010)";
  ctx.lineWidth = 1*DPR;
  const grid = 110*DPR;
  const ox = ((t*0.004*DPR) % grid);
  for(let x=ox; x < W; x += grid){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }

  // Blink timing
  if(kitty.blink <= 0 && Math.random() < 0.0015) kitty.blink = 1.4;
  kitty.blink = Math.max(0, kitty.blink - 0.038);

  const tgt = state.rest ? {x:0.50, y:0.70} : stepPath(t);
  const dx = tgt.x - kitty.x;
  const dy = tgt.y - kitty.y;

  const dist = Math.hypot(dx,dy) + 1e-6;

  const pace = state.pace;
  const accel = 0.00025 + pace*0.00130 + kitty.glide*0.00130;
  const maxV  = 0.00085 + pace*0.00560 + kitty.glide*0.00700;

  const w = 0.00014 * (0.20 + pace);
  kitty.vx += (dx/dist)*accel + Math.sin(t*0.0007)*w;
  kitty.vy += (dy/dist)*accel + Math.cos(t*0.0005)*w;

  kitty.vx *= 0.994;
  kitty.vy *= 0.994;
  kitty.glide *= 0.96;

  const vmag = Math.hypot(kitty.vx, kitty.vy);
  if(vmag > maxV){
    kitty.vx = (kitty.vx/vmag)*maxV;
    kitty.vy = (kitty.vy/vmag)*maxV;
  }

  kitty.x = clamp(kitty.x + kitty.vx, 0.12, 0.88);
  kitty.y = clamp(kitty.y + kitty.vy, 0.20, 0.85);

  const ang = Math.atan2(kitty.vy, kitty.vx);
  if(isFinite(ang)){
    const da = ((ang - kitty.ang + Math.PI*3)%(Math.PI*2)) - Math.PI;
    kitty.ang += da * 0.040;
  }

  const cx = kitty.x * W;
  const cy = kitty.y * H;

  const base = Math.min(W,H) * 0.26;
  const scale = base * state.size;

  drawRealisticCat(cx, cy, scale, kitty.ang, t);

  // Refined frame
  ctx.strokeStyle = document.body.classList.contains("invert") ? "rgba(10,12,15,.04)" : "rgba(255,255,255,.04)";
  ctx.lineWidth = 1*DPR;
  ctx.strokeRect(12*DPR, 12*DPR, W-24*DPR, H-24*DPR);

  requestAnimationFrame(step);
}

/* NOTE drag */
(function noteDrag(){
  const el = $("note");
  const bar = el.querySelector(".bar");
  let dragging=false, ox=0, oy=0;

  bar.addEventListener("mousedown",(e)=>{
    dragging=true;
    const r = el.getBoundingClientRect();
    ox = e.clientX - r.left;
    oy = e.clientY - r.top;
    e.preventDefault();
  });
  window.addEventListener("mousemove",(e)=>{
    if(!dragging) return;
    const x = Math.max(12, Math.min(window.innerWidth - 12 - el.offsetWidth, e.clientX - ox));
    const y = Math.max(12, Math.min(window.innerHeight - 12 - el.offsetHeight, e.clientY - oy));
    el.style.left = x + "px";
    el.style.top = y + "px";
    el.style.right = "auto";
    state.notePos = { x, y };
  });
  window.addEventListener("mouseup",()=>{
    if(!dragging) return;
    dragging=false;
    saveState();
  });
})();

/* controls */
function toggleNote(){ state.noteOpen=!state.noteOpen; saveState(); applyState(); }
function toggleInvert(){ state.invert=!state.invert; saveState(); applyState(); }
function toggleNull(){ state.nullMode=!state.nullMode; saveState(); applyState(); }
async function toggleFullscreen(){
  try{
    if(!document.fullscreenElement){ await document.documentElement.requestFullscreen(); state.fullscreen=true; }
    else { await document.exitFullscreen(); state.fullscreen=false; }
  }catch(_){}
  saveState(); applyState();
}
function reseed(){
  state.seed = (Math.random()*1e9)>>>0;
  kitty.wp.length = 0;
  kitty.wpT = 0;
  saveState(); applyState();
}
function glide(){
  kitty.glide = 1.0;
  state.rest = false;
  saveState(); applyState();
}

$("btnNote").addEventListener("click", toggleNote);
$("btnInvert").addEventListener("click", toggleInvert);
$("btnNull").addEventListener("click", toggleNull);
$("btnFull").addEventListener("click", toggleFullscreen);
$("btnSeed").addEventListener("click", reseed);
$("btnMotion").addEventListener("click",()=>{ state.motion=!state.motion; saveState(); applyState(); });
$("btnRest").addEventListener("click",()=>{ state.rest=!state.rest; saveState(); applyState(); });

$("rngSize").addEventListener("input",(e)=>{ state.size = clamp((parseInt(e.target.value,10)||150)/100, 0.90, 2.00); saveState(); applyState(); });
$("rngSpeed").addEventListener("input",(e)=>{ state.pace = clamp((parseInt(e.target.value,10)||32)/100, 0, 1); saveState(); applyState(); });
$("rngDetail").addEventListener("input",(e)=>{ state.detail = clamp((parseInt(e.target.value,10)||78)/100, 0, 1); saveState(); applyState(); });
$("rngTrail").addEventListener("input",(e)=>{ state.trail = clamp((parseInt(e.target.value,10)||88)/100, 0, 1); saveState(); applyState(); });

$("noteText").addEventListener("input",(e)=>{ state.noteText = e.target.value || ""; saveState(); });

/* hotkeys */
function isTypingTarget(t){
  if(!t) return false;
  const tag = (t.tagName||"").toLowerCase();
  return tag==="textarea" || tag==="input" || t.isContentEditable;
}
window.addEventListener("keydown",(e)=>{
  const typing = isTypingTarget(e.target);

  if(e.shiftKey && e.key.toLowerCase()==="i"){ e.preventDefault(); toggleInvert(); return; }
  if(e.shiftKey && e.key.toLowerCase()==="n"){ e.preventDefault(); toggleNull(); return; }
  if(e.shiftKey && e.key.toLowerCase()==="f"){ e.preventDefault(); toggleFullscreen(); return; }
  if(e.shiftKey && e.key.toLowerCase()==="k"){ e.preventDefault(); toggleNote(); return; }

  if(e.code==="Space" && !typing){
    e.preventDefault();
    glide();
    return;
  }
}, { passive:false });

/* boot */
loadState();
resize();
applyState();
requestAnimationFrame(step);
</script>

<!--
FILE_ID: "KETADATA_KITTY_REALISTIC"
VERSION: "HYPER-REALISTIC"
UPDATED_AT: "2026-01-06"
CHANGELOG:
- HYPER-REALISTIC RENDER: Multi-layer body shading with radial gradients for volumetric depth, belly shadow underside, shoulder and hip muscle definition with circular contours, spine ridge highlight, 3-layer fur rendering (deep/mid/highlight) with natural directional strokes and varied lengths, advanced head anatomy with facial structure shadows, cheek definition curves, forehead contours, hyper-realistic eyes with socket shadows, sclera, detailed iris with gradient, vertical slit pupils with inner detail, multi-point highlights (primary + secondary), lower eyelid detail, eyelashes on closed eyes, enhanced nose with nostril shadows and philtrum line, muzzle padding (cheek puffs), whisker root pores, natural whisker curvature with varied widths, eyebrow whisker tufts, realistic leg joints with visible articulation, detailed paw structure with individual pads, flowing tail with natural taper, anatomically accurate proportions, natural musculature hints, sophisticated gradient shading throughout, organic textures, depth perception through layered opacity
-->
</body>
</html>
