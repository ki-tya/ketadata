<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TEMPLE // AURA GENERATOR (LITE)</title>
  <style>
    :root{
      --bg:#000;
      --line:#1f1f1f;
      --line2:#2a2a2a;
      --txt:#eaeaea;
      --muted:#a8a8a8;
      --muted2:#7a7a7a;
      --pad:14px;
      --gap:14px;
    }
    *{ box-sizing:border-box; font-family: Arial, Helvetica, sans-serif; }
    html,body{ height:100%; }
    body{ margin:0; background:var(--bg); color:var(--txt); overflow:hidden; }

    .app{ height:100%; display:grid; grid-template-rows:56px 1fr 110px; }

    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      padding:0 var(--pad);
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, #0a0a0a, #000);
    }
    .brand{
      letter-spacing:.14em; font-weight:700; text-transform:uppercase;
      font-size:12px; color:var(--muted);
    }
    .actions{ display:flex; gap:10px; align-items:center; }
    .pill{
      border:1px solid var(--line2); color:var(--muted);
      padding:6px 10px; font-size:12px; letter-spacing:.08em; text-transform:uppercase;
    }
    .btn{
      border:1px solid var(--line2);
      background:#0b0b0b; color:var(--txt);
      padding:8px 10px; font-size:12px; letter-spacing:.06em; text-transform:uppercase;
      cursor:pointer; user-select:none;
    }
    .btn:hover{ border-color:#3a3a3a; }
    .btn:active{ transform: translateY(1px); }

    .stageWrap{ position:relative; display:grid; place-items:center; padding:var(--gap); }
    .stage{
      position:relative;
      width:min(980px, calc(100vw - 2*var(--gap)));
      height:min(620px, calc(100vh - 56px - 110px - 2*var(--gap)));
      border:1px solid var(--line);
      background: radial-gradient(1000px 600px at 50% 50%, #0b0b0b 0%, #020202 55%, #000 100%);
      overflow:hidden;
      box-shadow: 0 0 0 1px #000 inset;
    }
    video{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      filter: contrast(1.06) brightness(0.98);
      transform: scaleX(-1);
    }
    canvas#aura{
      position:absolute; inset:0;
      width:100%; height:100%;
      transform: scaleX(-1);
      pointer-events:none;
    }
    .frameLines{
      position:absolute; inset:0; pointer-events:none;
      background:
        linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00)),
        linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));
      mix-blend-mode: screen; opacity:.20;
    }

    .hud{
      position:absolute; left:var(--pad); top:var(--pad); right:var(--pad);
      display:flex; justify-content:space-between; gap:12px;
      pointer-events:none;
    }
    .hudBlock{
      pointer-events:auto;
      border:1px solid var(--line2);
      background: rgba(0,0,0,0.42);
      backdrop-filter: blur(6px);
      padding:10px 12px;
      max-width: 420px;
    }
    .hudTitle{
      margin:0 0 8px 0;
      font-size:12px; letter-spacing:.14em; text-transform:uppercase; color:var(--muted);
    }
    .hudRow{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-size:12px; color:var(--muted);
      line-height:1.45;
    }
    .slider{ width:170px; accent-color:#666; }

    .swatches{
      position:absolute; left:var(--pad); right:var(--pad); bottom:var(--pad);
      display:flex; justify-content:space-between; gap:10px;
      pointer-events:none;
    }
    .swatchStrip{
      pointer-events:auto;
      border:1px solid var(--line2);
      background: rgba(0,0,0,0.42);
      backdrop-filter: blur(6px);
      padding:10px 12px;
      min-width: 420px;
      display:flex; flex-direction:column; gap:8px;
    }
    .small{
      font-size:11px; letter-spacing:.10em; text-transform:uppercase; color:var(--muted2);
    }
    .swatchRow{ display:flex; gap:8px; align-items:center; }
    .sw{ width:22px; height:22px; border:1px solid var(--line2); background:#111; }

    .bottom{
      border-top:1px solid var(--line);
      background: linear-gradient(180deg, #000, #080808);
      padding: 10px var(--pad);
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: var(--gap);
      overflow:hidden;
    }
    .box{
      border:1px solid var(--line2);
      background: rgba(0,0,0,0.45);
      padding:10px 12px;
      overflow:auto;
    }
    .box h3{
      margin:0 0 8px 0;
      font-size:12px; letter-spacing:.14em; text-transform:uppercase; color:var(--muted);
    }
    .box p{
      margin:0;
      font-size:12px;
      line-height:1.45;
      color:var(--muted);
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="brand">TEMPLE // AURA GENERATOR (LITE)</div>
      <div class="actions">
        <div class="pill" id="status">idle</div>
        <button class="btn" id="btnStart">start camera</button>
        <button class="btn" id="btnSnap">snapshot</button>
        <button class="btn" id="btnExport">export png</button>
      </div>
    </div>

    <div class="stageWrap">
      <div class="stage" id="stage">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="aura"></canvas>
        <div class="frameLines"></div>

        <div class="hud">
          <div class="hudBlock">
            <div class="hudTitle">aura engine</div>
            <div class="hudRow">
              <span>intensity</span>
              <input class="slider" type="range" id="intensity" min="0" max="100" value="74" />
              <span id="intensityV">74</span>
            </div>
            <div class="hudRow">
              <span>complexity</span>
              <input class="slider" type="range" id="complexity" min="0" max="100" value="68" />
              <span id="complexityV">68</span>
            </div>
            <div class="hudRow">
              <span>saturation</span>
              <input class="slider" type="range" id="saturation" min="0" max="100" value="86" />
              <span id="saturationV">86</span>
            </div>
          </div>

          <div class="hudBlock">
            <div class="hudTitle">performance</div>
            <div class="hudRow"><span>analysis rate</span><span id="arate">~650ms</span></div>
            <div class="hudRow"><span>render rate</span><span id="rrate">~60fps</span></div>
            <div class="hudRow"><span>canvas scale</span><span id="cscale">0.75x</span></div>
          </div>
        </div>

        <div class="swatches">
          <div class="swatchStrip">
            <div class="small">color story (auto)</div>
            <div class="swatchRow" id="swatchRow"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="bottom">
      <div class="box">
        <h3>notes</h3>
        <p>- photobooth input (video)\n- aura = gradients + flowlines (lightweight)\n- analysis runs periodically, not every frame</p>
      </div>
      <div class="box">
        <h3>palette</h3>
        <p id="paletteText">-</p>
      </div>
      <div class="box">
        <h3>export packet</h3>
        <p id="packet">- png: video + aura\n- parameters + palette</p>
      </div>
    </div>
  </div>

<script>
(() => {
  const video = document.getElementById('video');
  const canvas = document.getElementById('aura');
  const ctx = canvas.getContext('2d', { alpha:true });

  const statusEl = document.getElementById('status');
  const btnStart = document.getElementById('btnStart');
  const btnSnap = document.getElementById('btnSnap');
  const btnExport = document.getElementById('btnExport');

  const intensity = document.getElementById('intensity');
  const complexity = document.getElementById('complexity');
  const saturation = document.getElementById('saturation');
  const intensityV = document.getElementById('intensityV');
  const complexityV = document.getElementById('complexityV');
  const saturationV = document.getElementById('saturationV');

  const swatchRow = document.getElementById('swatchRow');
  const paletteText = document.getElementById('paletteText');
  const packet = document.getElementById('packet');

  const cscaleEl = document.getElementById('cscale');
  const arateEl = document.getElementById('arate');

  let stream = null;
  let running = false;

  // PERFORMANCE LEVERS (tuned)
  let canvasScale = 0.75;            // render at 75% res (big win)
  let analysisIntervalMs = 650;      // palette refresh + structure analysis
  let maxDpr = 1.35;                 // cap DPR to prevent retina overload

  // analysis buffers
  const aW = 160, aH = 120;
  const aC = document.createElement('canvas');
  aC.width = aW; aC.height = aH;
  const aCtx = aC.getContext('2d', { willReadFrequently:true });

  // simple structure map: gradient magnitude (cheap)
  const sC = document.createElement('canvas');
  sC.width = aW; sC.height = aH;
  const sCtx = sC.getContext('2d', { willReadFrequently:true });

  let palette = ["#ff3b3b","#ffb84d","#ffe84d","#4dffb5","#4da3ff","#b84dff","#ff4df2","#ff4d8a"];
  let struct = null; // Uint8Array alpha-ish energy map (aW*aH)
  let lastAnalysisAt = 0;

  // flowlines
  let lines = [];
  let lineCount = 110;              // lightweight sophistication
  let lineLen = 22;                 // short segments per frame

  function setStatus(t){ statusEl.textContent = t; }
  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

  function rgbToHex(r,g,b){
    const to = v => v.toString(16).padStart(2,'0');
    return "#" + to(r) + to(g) + to(b);
  }
  function rgbToHsl(r,g,b){
    r/=255; g/=255; b/=255;
    const max = Math.max(r,g,b), min = Math.min(r,g,b);
    let h=0, s=0, l=(max+min)/2;
    const d = max-min;
    if(d !== 0){
      s = d / (1 - Math.abs(2*l - 1));
      switch(max){
        case r: h = ((g-b)/d) % 6; break;
        case g: h = (b-r)/d + 2; break;
        case b: h = (r-g)/d + 4; break;
      }
      h *= 60; if(h < 0) h += 360;
    }
    return {h,s,l};
  }
  function hslToRgb(h,s,l){
    const c=(1-Math.abs(2*l-1))*s;
    const x=c*(1-Math.abs(((h/60)%2)-1));
    const m=l-c/2;
    let r=0,g=0,b=0;
    if(h<60){r=c;g=x;}
    else if(h<120){r=x;g=c;}
    else if(h<180){g=c;b=x;}
    else if(h<240){g=x;b=c;}
    else if(h<300){r=x;b=c;}
    else {r=c;b=x;}
    return { r:Math.round((r+m)*255), g:Math.round((g+m)*255), b:Math.round((b+m)*255) };
  }
  function boostColor(hex, satBoost=1.15, lightShift=-0.03){
    const r=parseInt(hex.slice(1,3),16);
    const g=parseInt(hex.slice(3,5),16);
    const b=parseInt(hex.slice(5,7),16);
    const hsl=rgbToHsl(r,g,b);
    hsl.s = clamp(hsl.s*satBoost,0,1);
    hsl.l = clamp(hsl.l+lightShift,0,1);
    const rgb=hslToRgb(hsl.h,hsl.s,hsl.l);
    return rgbToHex(rgb.r,rgb.g,rgb.b);
  }

  function renderSwatches(list){
    swatchRow.innerHTML = "";
    list.slice(0,10).forEach(c=>{
      const d=document.createElement('div');
      d.className="sw"; d.style.background=c;
      swatchRow.appendChild(d);
    });
    paletteText.textContent = "- " + list.join(" ");
  }

  function quantizePalette(imgData, k=8){
    const data=imgData.data;
    const bins=new Map();
    const step=6; // heavier stride = faster
    for(let i=0;i<data.length;i+=4*step){
      const r=data[i], g=data[i+1], b=data[i+2];
      const lum=0.2126*r + 0.7152*g + 0.0722*b;
      if(lum < 26) continue;
      const rb=r>>3, gb=g>>3, bb=b>>3;
      const key=(rb<<10)|(gb<<5)|bb;
      bins.set(key,(bins.get(key)||0)+1);
    }
    const sorted = Array.from(bins.entries()).sort((a,b)=>b[1]-a[1]).slice(0, k*6);

    const picked=[];
    for(const [key] of sorted){
      const rb=(key>>10)&31, gb=(key>>5)&31, bb=key&31;
      const r=(rb<<3)+4, g=(gb<<3)+4, b=(bb<<3)+4;
      const hsl=rgbToHsl(r,g,b);
      if(hsl.s < 0.18) continue;
      if(picked.some(p => Math.abs(p.h - hsl.h) < 18 || Math.abs(p.h - (hsl.h+360)) < 18 || Math.abs((p.h+360) - hsl.h) < 18)) continue;
      picked.push({hex:rgbToHex(r,g,b), h:hsl.h});
      if(picked.length >= k) break;
    }
    let out = picked.map(p=>p.hex);
    if(out.length < 5) out = palette.slice(0,k);

    const sat = parseFloat(saturation.value)/100;
    const satBoost = 1.0 + sat*0.45;
    const lightShift = -0.08 + sat*0.03;
    out = out.map(c => boostColor(c, satBoost, lightShift));

    if(!out.some(c => c.toLowerCase().includes("ff"))) out.push("#ff3b3b");
    return out.slice(0,k);
  }

  function computeStructure(imgData){
    // CHEAP gradient magnitude on grayscale (no sobel kernels)
    const d=imgData.data;
    const g=new Uint8Array(aW*aH);
    for(let i=0, p=0; i<d.length; i+=4, p++){
      g[p] = (0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2])|0;
    }
    const out = new Uint8Array(aW*aH);
    for(let y=1;y<aH-1;y++){
      for(let x=1;x<aW-1;x++){
        const i=y*aW+x;
        const gx = g[i+1]-g[i-1];
        const gy = g[i+aW]-g[i-aW];
        const mag = Math.abs(gx) + Math.abs(gy);
        out[i] = mag > 22 ? clamp((mag-22)*4,0,255) : 0;
      }
    }
    return out;
  }

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.min(maxDpr, window.devicePixelRatio || 1);
    const w = Math.max(1, Math.floor(rect.width * canvasScale * dpr));
    const h = Math.max(1, Math.floor(rect.height * canvasScale * dpr));
    canvas.width = w;
    canvas.height = h;

    // draw in CSS pixels (scaled canvas)
    ctx.setTransform(w/rect.width, 0, 0, h/rect.height, 0, 0);
    cscaleEl.textContent = canvasScale.toFixed(2) + "x";
    arateEl.textContent = "~" + analysisIntervalMs + "ms";
  }

  window.addEventListener('resize', resizeCanvas);

  function initLines(){
    lines = [];
    const W = canvas.clientWidth, H = canvas.clientHeight;
    for(let i=0;i<lineCount;i++){
      lines.push({
        x: Math.random()*W,
        y: Math.random()*H,
        vx: 0,
        vy: 0,
        seed: Math.random()*1000,
        c: palette[i % palette.length]
      });
    }
  }

  function fieldAngle(x,y,t,comp){
    // same vibe, reduced cost (2-layer trig)
    const a = Math.sin(x*0.004 + t*0.0009) + Math.cos(y*0.004 - t*0.0011);
    return a * (1.2 + comp*1.4) * Math.PI;
  }

  function structAt(x,y){
    if(!struct) return 0;
    const W = canvas.clientWidth, H = canvas.clientHeight;
    const sx = clamp(Math.floor((x/W)*aW), 0, aW-1);
    const sy = clamp(Math.floor((y/H)*aH), 0, aH-1);
    return struct[sy*aW + sx] / 255;
  }

  function drawAura(t){
    const W = canvas.clientWidth, H = canvas.clientHeight;
    const inten = parseFloat(intensity.value)/100;
    const comp  = parseFloat(complexity.value)/100;

    // breathe: gentle trails
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = `rgba(0,0,0,${0.12 - comp*0.04})`;
    ctx.fillRect(0,0,W,H);

    // gradients: fewer, smarter (sophisticated without expensive particle soup)
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.globalAlpha = 0.10 + inten*0.20;

    const cx=W*0.50, cy=H*0.44;
    const baseR=Math.min(W,H)*(0.34 + inten*0.16);

    const gCount = 4 + Math.floor(comp*3); // 4..7
    for(let i=0;i<gCount;i++){
      const col = palette[(i*2) % palette.length];
      const ang = (t*0.00022 + i*1.1);
      const ox = Math.cos(ang) * (14 + i*10) * (0.4 + comp);
      const oy = Math.sin(ang) * (12 + i*9)  * (0.4 + comp);
      const r  = baseR * (0.70 + i*0.06);

      const gr = ctx.createRadialGradient(cx+ox, cy+oy, r*0.10, cx+ox, cy+oy, r);
      gr.addColorStop(0, col + "ff");
      gr.addColorStop(0.55, col + "44");
      gr.addColorStop(1, "#00000000");

      ctx.shadowColor = col;
      ctx.shadowBlur = 18 + inten*34;
      ctx.fillStyle = gr;
      ctx.beginPath();
      ctx.arc(cx+ox, cy+oy, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // flowlines: lower count, edge-biased energy
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    const speed = 0.55 + inten*1.05;
    const jitter = 0.08 + comp*0.22;
    const targetCount = Math.floor(80 + comp*120); // 80..200
    if(Math.abs(targetCount - lineCount) > 20){
      lineCount = targetCount;
      initLines();
    }

    // update line colors occasionally (cheap sophistication)
    for(let i=0;i<lines.length;i++){
      lines[i].c = palette[i % palette.length];
    }

    for(let i=0;i<lines.length;i++){
      const p = lines[i];
      const edge = structAt(p.x, p.y);   // 0..1
      const edgeBoost = 1 + edge*(1.1 + inten*1.0);

      const ang = fieldAngle(p.x, p.y, t + p.seed*10, comp);
      const ax = Math.cos(ang) * speed * edgeBoost;
      const ay = Math.sin(ang) * speed * edgeBoost;

      p.vx = p.vx*0.86 + ax*0.14;
      p.vy = p.vy*0.86 + ay*0.14;

      const x0 = p.x, y0 = p.y;
      p.x += p.vx + (Math.random()-0.5)*jitter;
      p.y += p.vy + (Math.random()-0.5)*jitter;

      // wrap / respawn near center band
      if(p.x < -10 || p.x > W+10 || p.y < -10 || p.y > H+10){
        p.x = W*0.50 + (Math.random()-0.5)*baseR*1.1;
        p.y = H*0.45 + (Math.random()-0.5)*baseR*1.1;
        p.vx = p.vy = 0;
      }

      const col = p.c;
      ctx.strokeStyle = col;
      ctx.lineWidth = 1;
      ctx.shadowColor = col;
      ctx.shadowBlur = 10 + inten*16;

      ctx.globalAlpha = (0.05 + inten*0.10) * (0.55 + edge*0.9);

      ctx.beginPath();
      ctx.moveTo(x0, y0);
      // short polyline for richness without loops
      const seg = 2 + (i % 2); // 2-3 segments
      let xx=x0, yy=y0;
      for(let s=0;s<seg;s++){
        const a2 = fieldAngle(xx, yy, t + p.seed*30 + s*40, comp);
        xx += Math.cos(a2) * (lineLen * (0.35 + edge*0.5));
        yy += Math.sin(a2) * (lineLen * (0.35 + edge*0.5));
        ctx.lineTo(xx, yy);
      }
      ctx.stroke();
    }
    ctx.restore();

    // gentle chroma separation (single pass)
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.globalAlpha = 0.08 + inten*0.08;
    ctx.translate(1.0, 0.0);
    ctx.drawImage(canvas, 0, 0);
    ctx.restore();

    packet.textContent =
`- png: stage composite
- palette: ${palette.join(" ")}
- parameters: intensity=${Math.round(inten*100)} complexity=${Math.round(comp*100)} saturation=${Math.round(parseFloat(saturation.value))}`;
  }

  function analysisTick(){
    try{
      aCtx.drawImage(video, 0, 0, aW, aH);
      const img = aCtx.getImageData(0,0,aW,aH);
      palette = quantizePalette(img, 8);
      struct = computeStructure(img);
      renderSwatches(palette);
      // keep line colors coherent
      for(let i=0;i<lines.length;i++) lines[i].c = palette[i % palette.length];
    }catch(e){}
  }

  function compositeToPNG(){
    const rect = canvas.getBoundingClientRect();
    const out = document.createElement('canvas');
    out.width = Math.floor(rect.width);
    out.height = Math.floor(rect.height);
    const o = out.getContext('2d');

    // mirror like booth
    o.save();
    o.translate(out.width, 0);
    o.scale(-1, 1);
    o.drawImage(video, 0, 0, out.width, out.height);

    // draw aura by sampling display canvas (it is mirrored already)
    // We draw it without mirroring again so it stays aligned.
    o.setTransform(1,0,0,1,0,0);
    o.drawImage(canvas, 0, 0, out.width, out.height);
    o.restore();

    return out.toDataURL('image/png');
  }

  function tick(t){
    if(!running) return;

    intensityV.textContent = intensity.value;
    complexityV.textContent = complexity.value;
    saturationV.textContent = saturation.value;

    if(t - lastAnalysisAt > analysisIntervalMs){
      analysisTick();
      lastAnalysisAt = t;
    }

    drawAura(t);
    requestAnimationFrame(tick);
  }

  async function startCamera(){
    if(stream) return;
    setStatus("requesting camera");
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video: { width:{ideal:1280}, height:{ideal:720}, facingMode:"user" },
        audio: false
      });
      video.srcObject = stream;
      await new Promise(res => video.onloadedmetadata = () => res());

      resizeCanvas();
      initLines();
      renderSwatches(palette);

      running = true;
      setStatus("running");
      requestAnimationFrame(tick);
    }catch(err){
      console.error(err);
      setStatus("blocked");
      alert("Camera access failed. Use https or localhost and allow camera permissions.");
    }
  }

  function snapshot(){
    analysisTick(); // instant refresh
    setStatus("snapshot");
    setTimeout(()=> setStatus("running"), 450);
  }

  function exportPNG(){
    const url = compositeToPNG();
    const a = document.createElement('a');
    a.href = url;
    a.download = `ketadata_aura_${Date.now()}.png`;
    a.click();
    setStatus("exported");
    setTimeout(()=> setStatus("running"), 600);
  }

  // Controls
  btnStart.addEventListener('click', startCamera);
  btnSnap.addEventListener('click', snapshot);
  btnExport.addEventListener('click', exportPNG);

  // Optional: quick performance toggles via keys (kept invisible)
  window.addEventListener('keydown', (e) => {
    if(e.key === '1'){ canvasScale = 0.65; resizeCanvas(); }
    if(e.key === '2'){ canvasScale = 0.75; resizeCanvas(); }
    if(e.key === '3'){ canvasScale = 0.90; resizeCanvas(); }
    if(e.key === '['){ analysisIntervalMs = Math.max(320, analysisIntervalMs - 80); arateEl.textContent = "~"+analysisIntervalMs+"ms"; }
    if(e.key === ']'){ analysisIntervalMs = Math.min(1400, analysisIntervalMs + 80); arateEl.textContent = "~"+analysisIntervalMs+"ms"; }
  });

})();
</script>
</body>
</html>
