<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Connected Fractal Bloom</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      cursor: none;
    }
    canvas {
      display: block;
      filter: contrast(1.25) saturate(1.35);
    }
  </style>
</head>
<body>
  <canvas id="bloom"></canvas>

  <script>
    const canvas = document.getElementById("bloom");
    const ctx = canvas.getContext("2d");

    let time = 0;
    let speed = 0.019;

    function resize() {
      canvas.width = innerWidth;
      canvas.height = innerHeight;
    }

    resize();
    addEventListener("resize", resize);

    function hsla(h, s, l, a) {
      return `hsla(${h}, ${s}%, ${l}%, ${a})`;
    }

    function getC() {
      return { x: canvas.width / 2, y: canvas.height / 2 };
    }

    // --- MAIN MANDALA DRAW ---

    const symmetry = 22;
    const base = 140;

    function drawBackground(c) {
      const r = Math.hypot(canvas.width, canvas.height) * 0.6;
      const t = time * 0.3;
      const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, r);
      g.addColorStop(0, hsla((t * 35) % 360, 90, 55, 1));
      g.addColorStop(0.5, hsla((t * 35 + 120) % 360, 75, 20, 1));
      g.addColorStop(1, hsla((t * 35 + 240) % 360, 65, 5, 1));
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // ---- CONNECTED PETAL RING (no gaps)
    function petalRing(r, layers, phase) {
      const petals = 48;

      for (let L = 0; L < layers; L++) {
        const R = r + L * 16;
        ctx.beginPath();

        for (let i = 0; i <= petals; i++) {
          const t = i / petals;
          const ang = t * Math.PI * 2;

          const n =
            Math.sin(ang * 3 + phase + L * 0.4) * 20 +
            Math.cos(ang * 6 - phase * 0.6 + L) * 12 +
            Math.sin(ang * 9 + phase * 1.3 + L) * 8;

          const rr = R + n;

          const x = Math.cos(ang) * rr;
          const y = Math.sin(ang) * rr;

          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }

        ctx.closePath();
        ctx.strokeStyle = hsla((phase * 30 + L * 20) % 360, 90, 70, 0.5);
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    // --- OUTER RING TO CONNECT LOOSE LINES INTO
    function outerBackbone(r, phase) {
      const pts = 160;
      ctx.beginPath();
      for (let i = 0; i <= pts; i++) {
        const a = (i / pts) * Math.PI * 2;
        const wob =
          Math.sin(a * 5 + phase * 2) * 10 +
          Math.cos(a * 7 - phase * 1.5) * 6;

        const rr = r + wob;
        const x = Math.cos(a) * rr;
        const y = Math.sin(a) * rr;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.strokeStyle = hsla((phase * 40) % 360, 85, 55, 0.55);
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // --- CONNECTED RADIAL FRACTALS (now snap into the outer ring)
    function radialFractals(inner, outer, branches, phase) {
      for (let i = 0; i < branches; i++) {
        const a =
          (i / branches) * Math.PI * 2 +
          phase * 0.6 +
          Math.sin(time * 2 + i) * 0.1;

        const steps = 6;
        ctx.beginPath();
        ctx.moveTo(0, 0);

        for (let s = 1; s <= steps; s++) {
          const t = s / steps;
          const rr = inner + (outer - inner) * t;

          const wob =
            Math.sin(time * 4 + i * 0.7 + s) * 6 +
            Math.cos(time * 3.1 + i * 1.3) * 3;

          const x = Math.cos(a + wob * 0.002) * (rr + wob);
          const y = Math.sin(a + wob * 0.002) * (rr + wob);

          ctx.lineTo(x, y);
        }

        ctx.strokeStyle = hsla((phase * 25 + i * 5) % 360, 90, 75, 0.4);
        ctx.lineWidth = 1.4;
        ctx.stroke();
      }
    }

    // --- ARC RINGS (each one connects to outer backbone)
    function spiralArcs(innerR, outerR, bands, phase) {
      for (let b = 0; b < bands; b++) {
        const r = innerR + (outerR - innerR) * (b / bands);

        const segs = 28;
        for (let i = 0; i < segs; i++) {
          const a1 =
            (Math.PI * 2 * i) / segs +
            phase * 0.8 +
            b * 0.15;
          const a2 = a1 + Math.PI / 10;

          const x1 = Math.cos(a1) * r;
          const y1 = Math.sin(a1) * r;
          const x2 = Math.cos(a2) * (r + 30);
          const y2 = Math.sin(a2) * (r + 30);

          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);

          ctx.strokeStyle = hsla((phase * 35 + b * 30) % 360, 90, 70, 0.35);
          ctx.lineWidth = 5;
          ctx.stroke();
        }
      }
    }

    // --- CORE GLOW
    function core() {
      const g = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
      g.addColorStop(0, "rgba(255,255,255,0.95)");
      g.addColorStop(0.5, "rgba(255,220,200,0.6)");
      g.addColorStop(1, "rgba(255,200,150,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(0, 0, 50, 0, Math.PI * 2);
      ctx.fill();
    }

    function draw() {
      const c = getC();
      drawBackground(c);

      ctx.save();
      ctx.translate(c.x, c.y);

      const phase = time * 1.4;

      // LAYERS IN ORDER
      outerBackbone(base * 2.1, phase);
      spiralArcs(base * 1.2, base * 2.1, 5, phase);
      radialFractals(base * 0.9, base * 2.1, symmetry, phase);
      petalRing(base, 4, phase);
      core();

      ctx.restore();

      time += speed;
      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>
