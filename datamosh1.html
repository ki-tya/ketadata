<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KETADATA // DATAMOSH (SINGLE FILE) v2</title>
<style>
  :root{
    --bg:#000;
    --fg:rgba(255,255,255,.86);
    --muted:rgba(255,255,255,.52);
    --line:rgba(255,255,255,.14);
    --line2:rgba(255,255,255,.26);
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    --sans: Arial, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;

    --top:44px;
    --bot:34px;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0}
  body{background:var(--bg); color:var(--fg); font-family:var(--sans); overflow:hidden}
  #root{position:fixed; inset:0; background:var(--bg)}
  #top{
    position:fixed; left:0; right:0; top:0; height:var(--top);
    display:flex; align-items:center; gap:10px;
    padding:0 10px;
    border-bottom:1px solid var(--line);
    background:rgba(0,0,0,.72);
    backdrop-filter: blur(8px);
    font-family:var(--mono);
    user-select:none;
    z-index:50;
  }
  #top .brand{letter-spacing:.14em; opacity:.92; white-space:nowrap}
  #top .pill{
    display:inline-flex; align-items:center; gap:8px;
    padding:6px 8px;
    border:1px solid var(--line);
    background:rgba(255,255,255,.03);
    white-space:nowrap;
  }
  #top button, #bot button{
    font:inherit;
    color:var(--fg);
    background:transparent;
    border:1px solid var(--line);
    padding:6px 8px;
    cursor:pointer;
  }
  #top button:hover, #bot button:hover{border-color:var(--line2)}
  #top input[type="file"]{display:none}
  .muted{color:var(--muted)}
  .sep{opacity:.35}

  #bot{
    position:fixed; left:0; right:0; bottom:0; height:var(--bot);
    display:flex; align-items:center; justify-content:space-between;
    padding:0 10px;
    border-top:1px solid var(--line);
    background:rgba(0,0,0,.72);
    backdrop-filter: blur(8px);
    font-family:var(--mono);
    user-select:none;
    z-index:50;
  }
  #sig{opacity:.78}

  #view{
    position:fixed;
    left:0; right:0;
    top:var(--top);
    bottom:var(--bot);
  }
  canvas{width:100%; height:100%; display:block}

  #drawer{
    position:fixed;
    left:10px;
    top:calc(var(--top) + 10px);
    width:min(520px, calc(100vw - 20px));
    border:1px solid var(--line);
    background:rgba(0,0,0,.78);
    backdrop-filter: blur(10px);
    padding:10px;
    font-family:var(--mono);
    z-index:60;
    display:none;
  }
  #drawer.open{display:block}
  .row{display:flex; align-items:center; gap:10px; margin:8px 0}
  .row label{min-width:130px; opacity:.85}
  .row input[type="range"]{flex:1}
  .row .val{min-width:70px; text-align:right; opacity:.85}

  #root.invert{filter:invert(1)}
  #root.null #top, #root.null #bot, #root.null #drawer{display:none !important;}
  #root.null #view{top:0; bottom:0;}
</style>
</head>
<body>
<div id="root">
  <div id="top">
    <div class="brand">KETADATA // DATAMOSH</div>
    <div class="sep">|</div>

    <label class="pill" for="file">
      <span>LOAD VIDEO</span>
      <span class="muted" id="fileName">none</span>
    </label>
    <input id="file" type="file" accept="video/*"/>

    <button id="playBtn">PLAY</button>
    <button id="pauseBtn">PAUSE</button>
    <button id="moshBtn">MOSH: <span id="moshLabel">ON</span></button>
    <button id="drawerBtn">SYSTEM</button>
    <button id="fsBtn">FULL</button>
    <button id="nullBtn">NULL</button>
  </div>

  <div id="drawer">
    <div class="row">
      <label>KEYFRAME Hz</label>
      <input id="keyHz" type="range" min="0" max="2.5" step="0.01"/>
      <div class="val" id="keyHzV"></div>
    </div>
    <div class="row">
      <label>FEEDBACK</label>
      <input id="feedback" type="range" min="0.80" max="0.999" step="0.001"/>
      <div class="val" id="feedbackV"></div>
    </div>
    <div class="row">
      <label>DISP px</label>
      <input id="disp" type="range" min="0" max="80" step="1"/>
      <div class="val" id="dispV"></div>
    </div>
    <div class="row">
      <label>GLITCH RATE</label>
      <input id="glitch" type="range" min="0" max="1" step="0.01"/>
      <div class="val" id="glitchV"></div>
    </div>
    <div class="row">
      <label>INJECT</label>
      <input id="inject" type="range" min="0" max="1" step="0.01"/>
      <div class="val" id="injectV"></div>
    </div>
    <div class="row">
      <label>SCAN</label>
      <input id="scan" type="range" min="0" max="1" step="0.01"/>
      <div class="val" id="scanV"></div>
    </div>
    <div class="row">
      <label>INVERT</label>
      <button id="invBtn">TOGGLE</button>
      <div class="val muted">SHIFT+I</div>
    </div>
    <div class="row">
      <label>KEYFRAME NOW</label>
      <button id="resetBtn">PUNCH</button>
      <div class="val muted">K</div>
    </div>
    <div class="row muted" style="line-height:1.35">
      If it looks “too clean”: increase FEEDBACK + DISP + GLITCH, lower KEYFRAME Hz, lower INJECT.
      If it looks “too smeary”: raise KEYFRAME Hz or raise INJECT.
    </div>
  </div>

  <div id="view"><canvas id="c"></canvas></div>

  <div id="bot">
    <div class="muted">SPACE play/pause · D system · SHIFT+F full · SHIFT+N null · K keyframe</div>
    <div id="sig"></div>
  </div>

  <video id="v" playsinline muted loop style="display:none"></video>
</div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);

  const root = $("root");
  const canvas = $("c");
  const ctx = canvas.getContext("2d", { alpha:false, desynchronized:true });

  const v = $("v");
  const file = $("file");

  const STATE = {
    ui:{
      drawer:false,
      null:false,
      invert:false,
      mosh:true,

      keyHz: 0.35,
      feedback: 0.985,
      disp: 22,
      glitch: 0.45,
      inject: 0.22,
      scan: 0.10
    },
    internal:{
      lastKeyAt: 0,
      ready:false
    }
  };

  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const now = ()=>performance.now();

  function fitCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
  }

  function drawVideoCover(){
    const W = canvas.width, H = canvas.height;
    const vw = v.videoWidth || 1;
    const vh = v.videoHeight || 1;
    const s = Math.max(W/vw, H/vh);
    const dw = vw*s, dh = vh*s;
    const dx = (W - dw)/2, dy = (H - dh)/2;
    ctx.drawImage(v, dx, dy, dw, dh);
  }

  function drawClean(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    if (STATE.internal.ready) drawVideoCover();
  }

  function keyframeNow(){
    STATE.internal.lastKeyAt = now();
    drawClean();
  }

  function updateSig(){
    const d = new Date();
    const iso = d.toISOString().slice(0,19).replace("T"," ");
    $("sig").textContent =
      `AE/EE/WB :: FILE_ID=KETADATA_DATAMOSH_02 • ROOM_ID=BASE_SURFACE • VERSION=2 • UPDATED_AT=${iso}Z • CHANGELOG=fix_mosh_pipeline_no_state_clobber`;
  }

  function render(){
    root.classList.toggle("invert", !!STATE.ui.invert);
    root.classList.toggle("null", !!STATE.ui.null);
    $("drawer").classList.toggle("open", !!STATE.ui.drawer);
    $("moshLabel").textContent = STATE.ui.mosh ? "ON":"OFF";

    $("keyHz").value = STATE.ui.keyHz;
    $("feedback").value = STATE.ui.feedback;
    $("disp").value = STATE.ui.disp;
    $("glitch").value = STATE.ui.glitch;
    $("inject").value = STATE.ui.inject;
    $("scan").value = STATE.ui.scan;

    $("keyHzV").textContent = STATE.ui.keyHz.toFixed(2);
    $("feedbackV").textContent = STATE.ui.feedback.toFixed(3);
    $("dispV").textContent = String(STATE.ui.disp|0);
    $("glitchV").textContent = STATE.ui.glitch.toFixed(2);
    $("injectV").textContent = STATE.ui.inject.toFixed(2);
    $("scanV").textContent = STATE.ui.scan.toFixed(2);

    updateSig();
  }

  function toggleFullscreen(){
    if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
  }

  function tick(){
    fitCanvas();

    if (!STATE.internal.ready){
      ctx.setTransform(1,0,0,1,0,0);
      ctx.globalCompositeOperation="source-over";
      ctx.globalAlpha=1;
      ctx.fillStyle="#000";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.globalAlpha=1;
      ctx.fillStyle="rgba(255,255,255,0.72)";
      ctx.font="14px " + getComputedStyle(document.documentElement).getPropertyValue("--mono");
      ctx.fillText("LOAD A VIDEO TO MOSH", 14, 22);
      requestAnimationFrame(tick);
      return;
    }

    const hz = clamp(STATE.ui.keyHz, 0, 10);
    const interval = hz<=0 ? Infinity : (1000/hz);
    if (now() - STATE.internal.lastKeyAt > interval) keyframeNow();

    if (!STATE.ui.mosh){
      drawClean();
      requestAnimationFrame(tick);
      return;
    }

    const W = canvas.width, H = canvas.height;

    /* 1) feedback smear: redraw canvas onto itself */
    const fb = clamp(STATE.ui.feedback, 0, 0.9999);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.globalCompositeOperation="source-over";
    ctx.globalAlpha = fb;
    ctx.drawImage(canvas,0,0);

    /* 2) block displacement */
    const g = clamp(STATE.ui.glitch,0,1);
    const maxDisp = Math.max(0, STATE.ui.disp|0);
    if (Math.random() < g){
      const blocks = 14 + Math.floor(Math.random()*44);
      for (let i=0;i<blocks;i++){
        const bw = 24 + Math.floor(Math.random()*Math.min(320, W*0.40));
        const bh = 12 + Math.floor(Math.random()*Math.min(220, H*0.30));
        const sx = Math.floor(Math.random()*Math.max(1, W-bw));
        const sy = Math.floor(Math.random()*Math.max(1, H-bh));
        const dx = sx + Math.floor((Math.random()*2-1)*maxDisp);
        const dy = sy + Math.floor((Math.random()*2-1)*maxDisp);
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation="source-over";
        ctx.drawImage(canvas, sx,sy,bw,bh, dx,dy,bw,bh);
      }
    }

    /* 3) partial “new frame injection” (THIS is the key) */
    const inj = clamp(STATE.ui.inject, 0, 1);
    // lower injection => stronger “held motion”
    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = clamp(inj, 0.0, 1.0);
    drawVideoCover();

    /* 4) scan/tear */
    const scan = clamp(STATE.ui.scan,0,1);
    if (scan>0){
      ctx.globalCompositeOperation="source-over";
      const lines = 6 + Math.floor(scan*50);
      for (let i=0;i<lines;i++){
        const y = Math.floor(Math.random()*H);
        const h = 1 + Math.floor(Math.random()*(2 + scan*8));
        const a = 0.03 + Math.random()*0.12*scan;
        ctx.globalAlpha = a;
        ctx.fillStyle="rgba(255,255,255,1)";
        ctx.fillRect(0,y,W,h);

        if (Math.random() < scan*0.6){
          const sh = 8 + Math.floor(Math.random()*50);
          const sy = Math.floor(Math.random()*Math.max(1,H-sh));
          const dx = Math.floor((Math.random()*2-1)*(8 + scan*60));
          ctx.globalAlpha = 0.18*scan;
          ctx.drawImage(canvas, 0,sy,W,sh, dx,sy,W,sh);
        }
      }
      ctx.globalAlpha=1;
    }

    requestAnimationFrame(tick);
  }

  /* UI wires */
  $("drawerBtn").onclick = () => { STATE.ui.drawer = !STATE.ui.drawer; render(); };
  $("moshBtn").onclick = () => { STATE.ui.mosh = !STATE.ui.mosh; render(); };
  $("fsBtn").onclick = () => toggleFullscreen();
  $("nullBtn").onclick = () => { STATE.ui.null = !STATE.ui.null; render(); };
  $("invBtn").onclick = () => { STATE.ui.invert = !STATE.ui.invert; render(); };
  $("resetBtn").onclick = () => keyframeNow();

  $("playBtn").onclick = async () => { try{ v.muted=false; await v.play(); }catch(e){} };
  $("pauseBtn").onclick = () => v.pause();

  function bindRange(id, key, parseFn){
    const el = $(id);
    el.addEventListener("input", () => { STATE.ui[key] = parseFn(el.value); render(); });
  }
  bindRange("keyHz","keyHz",(x)=>+x);
  bindRange("feedback","feedback",(x)=>+x);
  bindRange("disp","disp",(x)=>parseInt(x,10));
  bindRange("glitch","glitch",(x)=>+x);
  bindRange("inject","inject",(x)=>+x);
  bindRange("scan","scan",(x)=>+x);

  file.addEventListener("change", async () => {
    const f = file.files && file.files[0];
    if (!f) return;
    $("fileName").textContent = f.name;

    const url = URL.createObjectURL(f);
    v.src = url;
    v.loop = true;
    v.playsInline = true;

    await new Promise((res)=>{
      const on=()=>{ v.removeEventListener("loadeddata", on); res(); };
      v.addEventListener("loadeddata", on);
    });

    STATE.internal.ready = true;
    keyframeNow();
    try{ await v.play(); }catch(e){}
  });

  window.addEventListener("keydown",(e)=>{
    const k = e.key.toLowerCase();
    const shift = e.shiftKey;
    if (k===" "){ e.preventDefault(); (v.paused? v.play(): v.pause()); return; }
    if (shift && k==="f"){ e.preventDefault(); toggleFullscreen(); return; }
    if (shift && k==="n"){ e.preventDefault(); STATE.ui.null=!STATE.ui.null; render(); return; }
    if (shift && k==="i"){ e.preventDefault(); STATE.ui.invert=!STATE.ui.invert; render(); return; }
    if (k==="d"){ e.preventDefault(); STATE.ui.drawer=!STATE.ui.drawer; render(); return; }
    if (k==="k"){ e.preventDefault(); keyframeNow(); return; }
  });

  window.addEventListener("resize", fitCanvas);

  /* init */
  render();
  fitCanvas();
  requestAnimationFrame(tick);
})();
</script>

<!--
AE/EE/WB :: FILE_ID=KETADATA_DATAMOSH_02
ROOM_ID=BASE_SURFACE
VERSION=2
UPDATED_AT=2026-01-10
CHANGELOG=fix_mosh_pipeline_drawVideoCover_no_alpha_composite_clobber
-->
</body>
</html>
