<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TEMPLE // AURA PHOTOBOOTH (MIN)</title>
  <style>
    :root{
      --bg:#000;
      --line:#1f1f1f;
      --line2:#2a2a2a;
      --txt:#eaeaea;
      --muted:#9a9a9a;
      --pad:14px;
    }
    *{ box-sizing:border-box; font-family: Arial, Helvetica, sans-serif; }
    html,body{ height:100%; }
    body{ margin:0; background:var(--bg); color:var(--txt); overflow:hidden; }

    .app{ height:100%; display:grid; grid-template-rows:56px 1fr 72px; }
    .top{
      display:flex; align-items:center; justify-content:space-between;
      padding:0 var(--pad);
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg,#0a0a0a,#000);
    }
    .brand{ font-size:12px; letter-spacing:.14em; text-transform:uppercase; color:var(--muted); font-weight:700; }
    .right{ display:flex; gap:10px; align-items:center; }
    .pill{
      border:1px solid var(--line2);
      color:var(--muted);
      padding:6px 10px;
      font-size:12px;
      letter-spacing:.10em;
      text-transform:uppercase;
    }
    .btn{
      border:1px solid var(--line2);
      background:#0b0b0b;
      color:var(--txt);
      padding:10px 12px;
      font-size:12px;
      letter-spacing:.10em;
      text-transform:uppercase;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{ border-color:#3a3a3a; }
    .btn:active{ transform: translateY(1px); }
    .btn[disabled]{ opacity:.45; cursor:not-allowed; }

    .stageWrap{ display:grid; place-items:center; padding:16px; }
    .stage{
      position:relative;
      width:min(860px, calc(100vw - 32px));
      height:min(560px, calc(100vh - 56px - 72px - 32px));
      border:1px solid var(--line);
      background:#000;
      overflow:hidden;
    }
    video, canvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      transform: scaleX(-1);
    }
    canvas{ pointer-events:none; }

    .overlayText{
      position:absolute; left:14px; bottom:14px;
      font-size:12px; letter-spacing:.12em; text-transform:uppercase;
      color:rgba(234,234,234,.55);
      mix-blend-mode:screen;
      pointer-events:none;
    }

    .bottom{
      border-top:1px solid var(--line);
      padding:10px var(--pad);
      display:flex; align-items:center; justify-content:space-between;
      background: linear-gradient(180deg,#000,#080808);
      gap:12px;
    }
    .hint{
      font-size:12px; color:var(--muted);
      letter-spacing:.02em;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      max-width: 70vw;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="top">
      <div class="brand">TEMPLE // AURA PHOTOBOOTH (MIN)</div>
      <div class="right">
        <div class="pill" id="status">idle</div>
        <button class="btn" id="start">start</button>
        <button class="btn" id="capture" disabled>capture</button>
        <button class="btn" id="save" disabled>save</button>
        <button class="btn" id="reset" disabled>reset</button>
      </div>
    </div>

    <div class="stageWrap">
      <div class="stage" id="stage">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="fx"></canvas>
        <div class="overlayText" id="overlayText">center → capture → aura</div>
      </div>
    </div>

    <div class="bottom">
      <div class="hint" id="hint">Start camera. Capture freezes frame. Aura animates briefly, then final image locks.</div>
      <div class="pill" id="mode">live</div>
    </div>
  </div>

  <script>
  (() => {
    const video = document.getElementById('video');
    const canvas = document.getElementById('fx');
    const ctx = canvas.getContext('2d', { alpha:true });

    const startBtn = document.getElementById('start');
    const capBtn = document.getElementById('capture');
    const saveBtn = document.getElementById('save');
    const resetBtn = document.getElementById('reset');

    const statusEl = document.getElementById('status');
    const modeEl = document.getElementById('mode');
    const hintEl = document.getElementById('hint');
    const overlayText = document.getElementById('overlayText');

    // hidden capture buffer
    const cap = document.createElement('canvas');
    const capCtx = cap.getContext('2d', { willReadFrequently:true });

    let stream = null;
    let raf = 0;

    let state = "idle"; // idle | live | animating | final
    let capturedImageData = null; // ImageData from cap buffer
    let finalAura = null; // ImageData of final aura pass

    function setStatus(s){ statusEl.textContent = s; }
    function setMode(m){ modeEl.textContent = m; }
    function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

    function resize(){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.min(1.35, window.devicePixelRatio || 1);
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);

      cap.width = 320; cap.height = 240; // fixed small analysis buffer for speed
    }
    window.addEventListener('resize', resize);

    // ---------- COLOR STORY (FAST) ----------
    function rgbToHsl(r,g,b){
      r/=255; g/=255; b/=255;
      const max = Math.max(r,g,b), min = Math.min(r,g,b);
      let h=0, s=0, l=(max+min)/2;
      const d=max-min;
      if(d){
        s = d/(1-Math.abs(2*l-1));
        switch(max){
          case r: h=((g-b)/d)%6; break;
          case g: h=(b-r)/d+2; break;
          case b: h=(r-g)/d+4; break;
        }
        h*=60; if(h<0) h+=360;
      }
      return {h,s,l};
    }
    function hslToRgb(h,s,l){
      const c=(1-Math.abs(2*l-1))*s;
      const x=c*(1-Math.abs(((h/60)%2)-1));
      const m=l-c/2;
      let r=0,g=0,b=0;
      if(h<60){r=c;g=x;}
      else if(h<120){r=x;g=c;}
      else if(h<180){g=c;b=x;}
      else if(h<240){g=x;b=c;}
      else if(h<300){r=x;b=c;}
      else {r=c;b=x;}
      return {r:Math.round((r+m)*255), g:Math.round((g+m)*255), b:Math.round((b+m)*255)};
    }
    function toHex(v){ return v.toString(16).padStart(2,'0'); }
    function rgbToHex(r,g,b){ return "#"+toHex(r)+toHex(g)+toHex(b); }

    function paletteFromCapture(){
      capCtx.drawImage(video, 0, 0, cap.width, cap.height);
      const img = capCtx.getImageData(0,0,cap.width, cap.height);
      const d = img.data;

      const bins = new Map();
      const step = 10; // stride for speed
      for(let i=0;i<d.length;i+=4*step){
        const r=d[i], g=d[i+1], b=d[i+2];
        const lum=0.2126*r+0.7152*g+0.0722*b;
        if(lum < 22) continue;
        const rb=r>>3, gb=g>>3, bb=b>>3;
        const key=(rb<<10)|(gb<<5)|bb;
        bins.set(key,(bins.get(key)||0)+1);
      }
      const sorted = Array.from(bins.entries()).sort((a,b)=>b[1]-a[1]).slice(0,48);

      const picked=[];
      for(const [key] of sorted){
        const rb=(key>>10)&31, gb=(key>>5)&31, bb=key&31;
        const r=(rb<<3)+4, g=(gb<<3)+4, b=(bb<<3)+4;
        const hsl=rgbToHsl(r,g,b);
        if(hsl.s < 0.18) continue;
        if(picked.some(p => Math.abs(p.h - hsl.h) < 16)) continue;
        // push toward dense bold (Ketadata: industrial luxury, not pastel)
        hsl.s = clamp(hsl.s*1.2, 0, 1);
        hsl.l = clamp(hsl.l-0.04, 0, 1);
        const rgb=hslToRgb(hsl.h,hsl.s,hsl.l);
        picked.push({hex:rgbToHex(rgb.r,rgb.g,rgb.b), h:hsl.h});
        if(picked.length >= 7) break;
      }

      // fallback if capture is too flat
      if(picked.length < 5){
        return ["#ff3b3b","#ffb84d","#ffe84d","#4da3ff","#b84dff","#ff4df2","#4dffb5"];
      }
      return picked.map(p=>p.hex);
    }

    // ---------- AURA RENDER (LIGHT BUT SOPHISTICATED) ----------
    function drawFinalAura(palette){
      // aura is produced ONCE as an ImageData so we can lock it
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;

      const a = document.createElement('canvas');
      a.width = Math.floor(W);
      a.height = Math.floor(H);
      const aCtx = a.getContext('2d');

      // base dark wash
      aCtx.fillStyle = "#000";
      aCtx.fillRect(0,0,W,H);

      // layered radial gradients (few, high quality)
      aCtx.globalCompositeOperation = "lighter";
      aCtx.globalAlpha = 0.9;

      const cx=W*0.5, cy=H*0.44;
      const baseR = Math.min(W,H)*0.46;

      for(let i=0;i<palette.length;i++){
        const col = palette[i];
        const ang = (i/palette.length) * Math.PI*2;
        const ox = Math.cos(ang) * baseR * 0.10;
        const oy = Math.sin(ang) * baseR * 0.08;

        const r0 = baseR * (0.10 + i*0.015);
        const r1 = baseR * (0.70 + i*0.05);

        const g = aCtx.createRadialGradient(cx+ox, cy+oy, r0, cx+ox, cy+oy, r1);
        g.addColorStop(0.00, col + "ff");
        g.addColorStop(0.45, col + "55");
        g.addColorStop(1.00, "#00000000");

        aCtx.fillStyle = g;
        aCtx.beginPath();
        aCtx.arc(cx+ox, cy+oy, r1, 0, Math.PI*2);
        aCtx.fill();
      }

      // subtle flow texture (very cheap): jittered lines in palette, low alpha
      aCtx.globalAlpha = 0.12;
      aCtx.lineWidth = 1;
      for(let i=0;i<140;i++){
        const col = palette[i % palette.length];
        aCtx.strokeStyle = col;
        const x0 = Math.random()*W;
        const y0 = Math.random()*H;
        const dx = (Math.random()-0.5) * baseR * 0.35;
        const dy = (Math.random()-0.5) * baseR * 0.28;
        aCtx.beginPath();
        aCtx.moveTo(x0,y0);
        aCtx.lineTo(x0+dx, y0+dy);
        aCtx.stroke();
      }

      // gentle vignette
      aCtx.globalCompositeOperation = "source-over";
      aCtx.globalAlpha = 1;
      const vg = aCtx.createRadialGradient(cx, cy, baseR*0.15, cx, cy, baseR*1.15);
      vg.addColorStop(0, "#00000000");
      vg.addColorStop(1, "#000000cc");
      aCtx.fillStyle = vg;
      aCtx.fillRect(0,0,W,H);

      return aCtx.getImageData(0,0,W,H);
    }

    function compositeFinalFrame(){
      // draw frozen capture + finalAura to the visible canvas
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;
      ctx.clearRect(0,0,W,H);

      // draw frozen capture (mirrored)
      ctx.save();
      ctx.translate(W,0);
      ctx.scale(-1,1);
      ctx.drawImage(cap, 0, 0, W, H);
      ctx.restore();

      // draw aura (not mirrored; aura should align with mirrored view)
      if(finalAura){
        const temp = document.createElement('canvas');
        temp.width = finalAura.width;
        temp.height = finalAura.height;
        temp.getContext('2d').putImageData(finalAura, 0, 0);

        ctx.globalCompositeOperation = "screen";
        ctx.globalAlpha = 0.95;
        ctx.drawImage(temp, 0, 0, W, H);

        ctx.globalAlpha = 0.10;
        ctx.globalCompositeOperation = "screen";
        ctx.drawImage(temp, 1.5, 0); // micro chroma/echo
      }

      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = "source-over";
    }

    // minimal movement phase: animate aura “coming into focus” for ~1.8s
    function animateAuraIn(finalAuraData, palette){
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;

      // prepare aura bitmap once
      const auraCanvas = document.createElement('canvas');
      auraCanvas.width = finalAuraData.width;
      auraCanvas.height = finalAuraData.height;
      auraCanvas.getContext('2d').putImageData(finalAuraData, 0, 0);

      const start = performance.now();
      const dur = 1850;

      function frame(t){
        if(state !== "animating") return;

        const p = clamp((t-start)/dur, 0, 1);
        const ease = p < 0.5 ? 2*p*p : 1 - Math.pow(-2*p+2,2)/2; // smooth

        // base: frozen capture
        ctx.clearRect(0,0,W,H);
        ctx.save();
        ctx.translate(W,0); ctx.scale(-1,1);
        ctx.drawImage(cap, 0, 0, W, H);
        ctx.restore();

        // aura: starts blurred + offset and stabilizes
        ctx.globalCompositeOperation = "screen";

        // cheap blur illusion: draw multiple offset copies early, converge to 0
        const blurN = Math.floor(6 - ease*5); // 6 -> 1
        const maxOff = (1 - ease) * 18;

        ctx.globalAlpha = 0.10 + ease*0.85;

        for(let i=0;i<blurN;i++){
          const ox = (Math.random()-0.5)*maxOff;
          const oy = (Math.random()-0.5)*maxOff;
          ctx.drawImage(auraCanvas, ox, oy, W, H);
        }

        // subtle pulsing ring (minimal)
        const cx=W*0.5, cy=H*0.44, r=Math.min(W,H)*(0.22 + ease*0.06);
        ctx.globalAlpha = 0.10 * (1 - ease) + 0.06;
        ctx.beginPath();
        ctx.arc(cx, cy, r + Math.sin(t*0.008)*6*(1-ease), 0, Math.PI*2);
        ctx.strokeStyle = palette[0] || "#ffffff";
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";

        if(p < 1){
          raf = requestAnimationFrame(frame);
        }else{
          // lock final
          state = "final";
          setStatus("final");
          setMode("final");
          hintEl.textContent = "Final aura locked. Save or reset.";
          overlayText.textContent = "aura locked";
          compositeFinalFrame();
          saveBtn.disabled = false;
          resetBtn.disabled = false;
          capBtn.disabled = true;
        }
      }
      raf = requestAnimationFrame(frame);
    }

    // ---------- FLOW ----------
    async function start(){
      if(stream) return;
      try{
        setStatus("requesting");
        stream = await navigator.mediaDevices.getUserMedia({
          video:{ width:{ideal:1280}, height:{ideal:720}, facingMode:"user" },
          audio:false
        });
        video.srcObject = stream;
        await new Promise(res => video.onloadedmetadata = () => res());
        resize();
        setStatus("live");
        setMode("live");
        hintEl.textContent = "Frame yourself. Click capture.";
        overlayText.textContent = "center → capture";
        capBtn.disabled = false;
        resetBtn.disabled = true;
        saveBtn.disabled = true;
      } catch(e){
        console.error(e);
        setStatus("blocked");
        alert("Camera access failed. Use https or localhost and allow camera permissions.");
      }
    }

    function capture(){
      if(!stream) return;

      // freeze a small but crisp capture for booth feel
      // draw current frame into cap buffer (mirrored already by video CSS? no; we draw raw)
      capCtx.save();
      capCtx.translate(cap.width,0);
      capCtx.scale(-1,1);
      capCtx.drawImage(video, 0, 0, cap.width, cap.height);
      capCtx.restore();

      // also draw to visible stage immediately (freeze)
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0,0,rect.width,rect.height);
      ctx.drawImage(cap, 0, 0, rect.width, rect.height);

      setStatus("captured");
      setMode("captured");
      hintEl.textContent = "Generating aura…";
      overlayText.textContent = "generating aura";

      // compute palette + final aura once
      const pal = paletteFromCapture();
      finalAura = drawFinalAura(pal);

      state = "animating";
      setStatus("aura");
      setMode("aura");
      capBtn.disabled = true;
      resetBtn.disabled = true;
      saveBtn.disabled = true;

      animateAuraIn(finalAura, pal);
    }

    function save(){
      // export composite as PNG (frozen + aura)
      const rect = canvas.getBoundingClientRect();
      const out = document.createElement('canvas');
      out.width = Math.floor(rect.width);
      out.height = Math.floor(rect.height);
      const o = out.getContext('2d');

      // draw frozen capture
      o.drawImage(cap, 0, 0, out.width, out.height);

      // aura (final)
      const auraCanvas = document.createElement('canvas');
      auraCanvas.width = finalAura.width;
      auraCanvas.height = finalAura.height;
      auraCanvas.getContext('2d').putImageData(finalAura, 0, 0);

      o.globalCompositeOperation = "screen";
      o.globalAlpha = 0.95;
      o.drawImage(auraCanvas, 0, 0, out.width, out.height);

      const url = out.toDataURL("image/png");
      const a = document.createElement('a');
      a.href = url;
      a.download = `ketadata_aura_${Date.now()}.png`;
      a.click();

      setStatus("saved");
      setTimeout(()=> setStatus("final"), 650);
    }

    function reset(){
      cancelAnimationFrame(raf);
      state = "live";
      setStatus("live");
      setMode("live");
      hintEl.textContent = "Ready. Click capture.";
      overlayText.textContent = "center → capture";
      finalAura = null;
      ctx.clearRect(0,0,canvas.getBoundingClientRect().width, canvas.getBoundingClientRect().height);
      capBtn.disabled = false;
      saveBtn.disabled = true;
      resetBtn.disabled = true;
    }

    startBtn.addEventListener('click', start);
    capBtn.addEventListener('click', capture);
    saveBtn.addEventListener('click', save);
    resetBtn.addEventListener('click', reset);

    // allow spacebar capture (booth)
    window.addEventListener('keydown', (e) => {
      if(e.code === "Space"){
        e.preventDefault();
        if(!stream) start();
        else if(state === "live") capture();
      }
      if(e.key === "Escape" && stream) reset();
    });

  })();
  </script>
</body>
</html>
