<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA LINK SET ARRANGER</title>
  <style>
    :root{
      --bg:#0a0a0a;
      --fg:#f2f2f2;
      --mut:#bdbdbd;
      --dim:#7a7a7a;
      --line:rgba(255,255,255,0.22);
      --line2:rgba(255,255,255,0.12);
      --panel:rgba(0,0,0,0.55);
      --glass:rgba(0,0,0,0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --ui: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --fs:12px; /* SAME SIZE LAW */
      --lh:1.25;
      --pad:10px;
      --gap:10px;
      --r:0px;
      --shadow: 0 10px 35px rgba(0,0,0,0.45);
      --accent: rgba(255,255,255,0.85);
      --ok: rgba(255,255,255,0.12);
      --bad: rgba(255,255,255,0.08);
      --warn: rgba(255,255,255,0.18);
    }

    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family:var(--ui);
      font-size:var(--fs);
      line-height:var(--lh);
      letter-spacing:0.02em;
      overflow:hidden;
    }

    *{ box-sizing:border-box; }
    button, input, textarea, select{
      font: inherit;
      font-size:var(--fs);
      line-height:var(--lh);
      letter-spacing:0.02em;
      color:var(--fg);
      background:#000;
      border:1px solid var(--line2);
      border-radius:var(--r);
      padding:6px 8px;
      outline:none;
    }
    button{ cursor:pointer; background:rgba(0,0,0,0.35); }
    button:hover{ border-color:var(--line); }
    button:active{ transform: translateY(1px); }
    input[type="range"]{ padding:0; height:20px; }
    a{ color:var(--fg); text-decoration:none; border-bottom:1px solid transparent; }
    a:hover{ border-bottom:1px solid var(--line); }
    .mono{ font-family:var(--mono); }

    .topbar{
      position:fixed;
      left:0; right:0; top:0;
      height:44px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 12px;
      border-bottom:1px solid var(--line2);
      background:linear-gradient(to bottom, rgba(0,0,0,0.70), rgba(0,0,0,0.35));
      backdrop-filter: blur(10px);
      z-index:50;
    }
    .topbar .left, .topbar .right{
      display:flex;
      align-items:center;
      gap:8px;
      min-width: 180px;
    }
    .topbar .center{
      display:flex;
      align-items:center;
      gap:10px;
      justify-content:center;
      flex:1;
      text-align:center;
      user-select:none;
      pointer-events:none;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 8px;
      border:1px solid var(--line2);
      background:rgba(0,0,0,0.25);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
    }
    .badge .k{ color:var(--mut); }
    .badge .v{ color:var(--fg); font-family:var(--mono); }

    .main{
      position:fixed;
      left:0; right:0;
      top:44px; bottom:0;
      display:grid;
      grid-template-columns: 420px 1fr 420px;
      gap:0;
    }

    .panel{
      border-right:1px solid var(--line2);
      background:rgba(0,0,0,0.25);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-width: 340px;
    }
    .panel.right{
      border-right:none;
      border-left:1px solid var(--line2);
    }
    .panelHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:10px 10px;
      border-bottom:1px solid var(--line2);
      background:rgba(0,0,0,0.35);
      user-select:none;
    }
    .panelHead .title{
      font-weight:800;
      letter-spacing:0.12em;
      text-transform:uppercase;
    }
    .panelHead .sub{
      color:var(--dim);
      font-family:var(--mono);
      letter-spacing:0.08em;
      text-transform:uppercase;
    }
    .panelBody{
      padding:10px;
      overflow:auto;
      height:100%;
    }

    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .row + .row{ margin-top:8px; }
    .sep{ height:1px; background:var(--line2); margin:10px 0; }

    textarea{
      width:100%;
      min-height: 220px;
      resize:vertical;
      background:#000;
    }

    .hint{
      color:var(--dim);
      font-family:var(--mono);
      letter-spacing:0.06em;
      text-transform:uppercase;
    }
    .hint .kbd{
      display:inline-flex;
      padding:2px 6px;
      border:1px solid var(--line2);
      background:rgba(0,0,0,0.35);
      margin:0 4px;
    }

    .centerStage{
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-width: 520px;
    }

    .lanesBar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px;
      border-bottom:1px solid var(--line2);
      background:rgba(0,0,0,0.25);
    }
    .lanesBar .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }

    .lanes{
      height:100%;
      overflow:auto;
      padding:10px;
      display:grid;
      grid-auto-flow:column;
      grid-auto-columns: minmax(320px, 1fr);
      gap:10px;
      align-items:start;
    }

    .lane{
      border:1px solid var(--line2);
      background:rgba(0,0,0,0.25);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
      min-height: 200px;
      display:flex;
      flex-direction:column;
    }
    .laneHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:10px;
      border-bottom:1px solid var(--line2);
      background:rgba(0,0,0,0.35);
      user-select:none;
    }
    .laneHead .name{
      font-weight:900;
      letter-spacing:0.14em;
      text-transform:uppercase;
    }
    .laneHead .meta{
      color:var(--dim);
      font-family:var(--mono);
    }
    .laneDrop{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height: 220px;
    }

    .card{
      border:1px solid var(--line2);
      background:rgba(0,0,0,0.35);
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:6px;
      cursor:grab;
    }
    .card:active{ cursor:grabbing; }
    .card .top{
      display:flex;
      justify-content:space-between;
      gap:8px;
      align-items:flex-start;
    }
    .card .lbl{
      font-weight:800;
      letter-spacing:0.08em;
      text-transform:uppercase;
      word-break:break-word;
    }
    .card .path{
      color:var(--dim);
      font-family:var(--mono);
      word-break:break-all;
      margin-top:2px;
    }
    .card .note{
      color:var(--mut);
      font-family:var(--mono);
      word-break:break-word;
    }
    .pillRow{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:3px 6px;
      border:1px solid var(--line2);
      background:rgba(0,0,0,0.25);
      color:var(--mut);
      font-family:var(--mono);
      text-transform:uppercase;
      letter-spacing:0.08em;
    }
    .pill.ok{ color:var(--fg); border-color:var(--line); }
    .pill.bad{ opacity:0.7; }
    .pill.btn{ cursor:pointer; user-select:none; }
    .pill.btn:hover{ border-color:var(--line); color:var(--fg); }
    .pill.btn:active{ transform: translateY(1px); }

    .selected{
      outline:1px solid rgba(255,255,255,0.35);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.08) inset;
    }

    .dropHint{
      border:1px dashed var(--line2);
      background:rgba(0,0,0,0.20);
      padding:8px;
      color:var(--dim);
      font-family:var(--mono);
      text-transform:uppercase;
      letter-spacing:0.08em;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
    }

    .small{ color:var(--dim); font-family:var(--mono); }
    .danger{ border-color: rgba(255,255,255,0.28); }
    .okline{ border-color: rgba(255,255,255,0.22); }
    .ghost{ opacity:0.75; }

    .modalShade{
      position:fixed; inset:0;
      background: rgba(0,0,0,0.6);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:80;
    }
    .modal{
      width:min(860px, calc(100vw - 40px));
      max-height: min(720px, calc(100vh - 60px));
      overflow:auto;
      border:1px solid var(--line);
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
    }
    .modalHead{
      position:sticky; top:0;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:10px;
      border-bottom:1px solid var(--line2);
      background: rgba(0,0,0,0.55);
    }
    .modalBody{ padding:10px; }
    .monoBox{
      width:100%;
      min-height: 240px;
      font-family:var(--mono);
      white-space: pre;
      overflow:auto;
      border:1px solid var(--line2);
      padding:10px;
      background:#000;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="left">
      <div class="badge">
        <span class="k">APP</span>
        <span class="v">KETADATA_LINK_SET_ARRANGER</span>
      </div>
    </div>

    <div class="center">
      <div class="badge">
        <span class="k">ACTIVE</span>
        <span class="v" id="activeSummary">NO STATE LOADED</span>
      </div>
    </div>

    <div class="right">
      <button id="btnSaveLocal" title="Save to localStorage">SAVE</button>
      <button id="btnLoadLocal" title="Load from localStorage">LOAD</button>
      <button id="btnExport" title="Download JSON">EXPORT</button>
      <button id="btnImport" title="Import JSON file">IMPORT</button>
      <input id="filePick" type="file" accept="application/json" style="display:none" />
    </div>
  </div>

  <div class="main">
    <!-- INPUT + CLEANUP -->
    <div class="panel">
      <div class="panelHead">
        <div>
          <div class="title">INPUT</div>
          <div class="sub">PASTE LINK TRIAGE JSON</div>
        </div>
        <div class="row">
          <button id="btnParse">PARSE</button>
          <button id="btnClean">CLEAN</button>
        </div>
      </div>
      <div class="panelBody">
        <div class="row">
          <div class="hint">
            PASTE YOUR LINK TRIAGE EXPORT (LIKE <span class="kbd">KETADATA_LINK_TRIAGE_GRID_v2</span>) THEN <span class="kbd">PARSE</span>.
            <br/>CLEAN WILL NORMALIZE NOTES/LABELS AND CREATE SAFE DEFAULTS FOR UNLABELED ITEMS.
          </div>
        </div>
        <div class="sep"></div>
        <textarea id="inputArea" class="mono" spellcheck="false" placeholder='PASTE JSON HERE'></textarea>
        <div class="sep"></div>
        <div class="row">
          <button id="btnHydrateFromInput">USE INPUT AS STATE</button>
          <button id="btnOpenPreview">VIEW OUTPUT JSON</button>
        </div>
        <div class="sep"></div>
        <div class="row">
          <div class="badge">
            <span class="k">LOCAL KEY</span>
            <span class="v" id="localKeyLabel"></span>
          </div>
        </div>
        <div class="row">
          <button id="btnReset" class="danger">RESET APP STATE</button>
        </div>
      </div>
    </div>

    <!-- LANES / PROTO-SETS -->
    <div class="centerStage">
      <div class="lanesBar">
        <div class="controls">
          <span class="pill">PROTO-SETS</span>
          <span class="pill ok" id="pillDrag">DRAG</span>
          <span class="pill" id="pillFilter">FILTER: <span id="filterLabel">ACTIVE</span></span>
          <span class="pill btn" id="btnToggleFilter">TOGGLE FILTER</span>
          <span class="pill btn" id="btnNewLane">+ LANE</span>
          <span class="pill btn" id="btnRenameLanes">RENAME LANES</span>
        </div>
        <div class="controls">
          <input id="searchBox" placeholder="SEARCH (PATH / NOTE / URL)" class="mono" />
          <span class="pill" id="countLabel">0 LINKS</span>
        </div>
      </div>

      <div class="lanes" id="lanes"></div>
    </div>

    <!-- EDITOR -->
    <div class="panel right">
      <div class="panelHead">
        <div>
          <div class="title">EDIT</div>
          <div class="sub">SELECT A CARD</div>
        </div>
        <div class="row">
          <button id="btnOpenLink" disabled>OPEN</button>
          <button id="btnCopyUrl" disabled>COPY URL</button>
        </div>
      </div>

      <div class="panelBody">
        <div class="row">
          <div class="badge">
            <span class="k">ID</span>
            <span class="v" id="edId">—</span>
          </div>
          <div class="badge">
            <span class="k">LANE</span>
            <span class="v" id="edLane">—</span>
          </div>
        </div>

        <div class="sep"></div>

        <div class="row">
          <div class="small">LABEL (DISPLAY NAME)</div>
        </div>
        <div class="row">
          <input id="edLabel" placeholder="LABEL" class="mono" disabled />
        </div>

        <div class="row">
          <div class="small">NOTE (SHORT DESCRIPTOR)</div>
        </div>
        <div class="row">
          <input id="edNote" placeholder="NOTE" class="mono" disabled />
        </div>

        <div class="row">
          <div class="small">PATH</div>
        </div>
        <div class="row">
          <input id="edPath" placeholder="PATH" class="mono" disabled />
        </div>

        <div class="row">
          <div class="small">URL</div>
        </div>
        <div class="row">
          <input id="edUrl" placeholder="URL" class="mono" disabled />
        </div>

        <div class="sep"></div>

        <div class="grid2">
          <div>
            <div class="small">STATUS</div>
            <select id="edStatus" disabled>
              <option value="active">active</option>
              <option value="deprecated">deprecated</option>
            </select>
          </div>
          <div>
            <div class="small">VERSION (OPTIONAL)</div>
            <input id="edVersion" placeholder="VERSION" class="mono" disabled />
          </div>
        </div>

        <div class="row">
          <div class="small">TAGS (RAW STRING, OPTIONAL)</div>
        </div>
        <div class="row">
          <input id="edTags" placeholder="TAGS" class="mono" disabled />
        </div>

        <div class="sep"></div>

        <div class="row">
          <button id="btnDelete" class="danger" disabled>DELETE LINK</button>
          <button id="btnDup" disabled>DUPLICATE</button>
        </div>

        <div class="sep"></div>

        <div class="hint">
          DRAG CARDS BETWEEN LANES TO REARRANGE PROTO-SETS.
          <br/>CLICK A CARD TO EDIT ITS LABEL/NOTE/STATUS.
          <br/>EXPORT CREATES A REAL FILE DOWNLOAD.
        </div>
      </div>
    </div>
  </div>

  <!-- MODAL: JSON PREVIEW -->
  <div class="modalShade" id="modalShade" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modalHead">
        <div class="badge">
          <span class="k">OUTPUT</span>
          <span class="v">JSON</span>
        </div>
        <div class="row">
          <button id="btnModalCopy">COPY</button>
          <button id="btnModalClose">CLOSE</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="monoBox" id="jsonPreview"></div>
      </div>
    </div>
  </div>

  <script>
    /* =========================================================
       EE/WB ▸ STATE MODEL
       - takes Link Triage export (lanes + links map)
       - cleans + normalizes
       - provides apparatus for lane/set editing (drag + edit)
       ========================================================= */

    const FILE_ID = "KETADATA_LINK_SET_ARRANGER";
    const ROOM_ID = "BASE_TOOL";
    const VERSION_ID = "v1_proto_sets_drag_edit_export";
    const STORAGE_KEY = `KDT::STATE::${FILE_ID}::${ROOM_ID}::${VERSION_ID}`;

    const $ = (id)=>document.getElementById(id);

    const UI = {
      lanes: $("lanes"),
      inputArea: $("inputArea"),
      searchBox: $("searchBox"),
      activeSummary: $("activeSummary"),
      localKeyLabel: $("localKeyLabel"),
      countLabel: $("countLabel"),
      filterLabel: $("filterLabel"),
      modalShade: $("modalShade"),
      jsonPreview: $("jsonPreview"),
      ed: {
        id: $("edId"),
        lane: $("edLane"),
        label: $("edLabel"),
        note: $("edNote"),
        path: $("edPath"),
        url: $("edUrl"),
        status: $("edStatus"),
        version: $("edVersion"),
        tags: $("edTags"),
      },
      btn: {
        parse: $("btnParse"),
        clean: $("btnClean"),
        hydrateFromInput: $("btnHydrateFromInput"),
        reset: $("btnReset"),
        openPreview: $("btnOpenPreview"),
        saveLocal: $("btnSaveLocal"),
        loadLocal: $("btnLoadLocal"),
        export: $("btnExport"),
        import: $("btnImport"),
        filePick: $("filePick"),
        openLink: $("btnOpenLink"),
        copyUrl: $("btnCopyUrl"),
        delete: $("btnDelete"),
        dup: $("btnDup"),
        toggleFilter: $("btnToggleFilter"),
        newLane: $("btnNewLane"),
        renameLanes: $("btnRenameLanes"),
        modalClose: $("btnModalClose"),
        modalCopy: $("btnModalCopy"),
      }
    };

    UI.localKeyLabel.textContent = STORAGE_KEY;

    const DEFAULT = () => ({
      version: "KETADATA_LINK_SET_ARRANGER_v1",
      updatedAt: new Date().toISOString(),
      sourceMeta: {
        importedFrom: "",
        importedAt: "",
        originalVersion: ""
      },
      ui: {
        filterStatus: "active", /* active | deprecated | all */
        search: ""
      },
      lanes: [
        { id:"L0", name:"INBOX", deprecated:false },
        { id:"L1", name:"CORE", deprecated:false },
        { id:"L2", name:"EXPERIMENTS", deprecated:false },
        { id:"L3", name:"DEPRECATED", deprecated:true }
      ],
      links: {
        /* id -> link */
        /* { id, path, url, laneId, tags, version, status, note, missing } */
      },
      order: {
        /* laneId -> [linkId, ...] */
      }
    });

    let STATE = DEFAULT();
    let SELECTED_ID = null;
    let DRAG_ID = null;

    function nowISO(){
      return new Date().toISOString();
    }

    function safeStr(x){
      return (x === null || x === undefined) ? "" : String(x);
    }

    function inferLabelFromPath(path){
      const p = safeStr(path).trim();
      if(!p) return "[UNLABELED]";
      const base = p.split("/").pop();
      return `[${base.toUpperCase()}]`;
    }

    function normalizeLink(id, obj){
      const path = safeStr(obj.path || id).trim();
      const url = safeStr(obj.url).trim();
      let note = safeStr(obj.note).trim();
      let tags = safeStr(obj.tags).trim();
      let version = safeStr(obj.version).trim();
      let laneId = safeStr(obj.laneId || "L0").trim();
      let status = safeStr(obj.status || "active").trim().toLowerCase();
      const missing = !!obj.missing;

      if(status !== "active" && status !== "deprecated") status = "active";
      if(!laneId) laneId = "L0";

      // If lane is deprecated, default status deprecated (unless explicitly active)
      const lane = STATE.lanes.find(l=>l.id===laneId);
      if(lane && lane.deprecated && status === "active") status = "deprecated";

      // If url missing but path exists and we can infer pagesBase from input, that happens in import pass.

      // "label" is derived from note if it looks like a label; otherwise we keep note as note.
      // We keep display label as card line 1: prefer note if it looks like a title, else infer.
      const displayLabel = note ? note : inferLabelFromPath(path);

      return {
        id,
        path,
        url,
        laneId,
        tags,
        version,
        status,
        note,
        displayLabel,
        missing
      };
    }

    function ensureOrderArrays(){
      if(!STATE.order) STATE.order = {};
      for(const lane of STATE.lanes){
        if(!Array.isArray(STATE.order[lane.id])) STATE.order[lane.id] = [];
      }
      // Ensure every link is present in its lane order exactly once
      const seen = new Set();
      for(const lane of STATE.lanes){
        const arr = STATE.order[lane.id];
        for(let i=arr.length-1;i>=0;i--){
          const id = arr[i];
          if(!STATE.links[id] || seen.has(id)) arr.splice(i,1);
          else seen.add(id);
        }
      }
      for(const id of Object.keys(STATE.links)){
        if(seen.has(id)) continue;
        const laneId = STATE.links[id].laneId || "L0";
        if(!STATE.order[laneId]) STATE.order[laneId] = [];
        STATE.order[laneId].push(id);
        seen.add(id);
      }
    }

    function computeCounts(){
      const all = Object.keys(STATE.links).length;
      let visible = 0;
      for(const id of Object.keys(STATE.links)){
        const L = STATE.links[id];
        if(passesFilters(L)) visible++;
      }
      UI.countLabel.textContent = `${visible}/${all} LINKS`;
      UI.activeSummary.textContent = `${visible}/${all} VISIBLE`;
    }

    function passesFilters(link){
      const f = STATE.ui.filterStatus;
      if(f === "active" && link.status !== "active") return false;
      if(f === "deprecated" && link.status !== "deprecated") return false;

      const q = safeStr(STATE.ui.search).trim().toLowerCase();
      if(q){
        const hay = [
          link.id, link.path, link.url, link.note, link.tags, link.version,
          (STATE.lanes.find(l=>l.id===link.laneId)?.name || "")
        ].join(" ").toLowerCase();
        if(!hay.includes(q)) return false;
      }
      return true;
    }

    function render(){
      ensureOrderArrays();
      UI.lanes.innerHTML = "";

      for(const lane of STATE.lanes){
        const laneEl = document.createElement("div");
        laneEl.className = "lane";
        laneEl.dataset.laneId = lane.id;

        const head = document.createElement("div");
        head.className = "laneHead";
        head.innerHTML = `
          <div>
            <div class="name">${escapeHtml(lane.name)}</div>
          </div>
          <div class="meta mono">${lane.id} · ${lane.deprecated ? "deprecated" : "active"}</div>
        `;
        laneEl.appendChild(head);

        const drop = document.createElement("div");
        drop.className = "laneDrop";
        drop.dataset.laneId = lane.id;

        const ids = (STATE.order[lane.id] || []).slice();
        let any = false;
        for(const id of ids){
          const link = STATE.links[id];
          if(!link) continue;
          if(!passesFilters(link)) continue;
          any = true;
          drop.appendChild(renderCard(link));
        }
        if(!any){
          const hint = document.createElement("div");
          hint.className = "dropHint";
          hint.textContent = "DROP LINKS HERE";
          drop.appendChild(hint);
        }

        // Drop handlers
        drop.addEventListener("dragover", (e)=>{ e.preventDefault(); });
        drop.addEventListener("drop", (e)=>{
          e.preventDefault();
          if(!DRAG_ID) return;
          moveLinkToLane(DRAG_ID, lane.id);
          DRAG_ID = null;
        });

        laneEl.appendChild(drop);
        UI.lanes.appendChild(laneEl);
      }

      computeCounts();
      updateEditor();
    }

    function renderCard(link){
      const card = document.createElement("div");
      card.className = "card";
      card.draggable = true;
      card.dataset.id = link.id;

      if(SELECTED_ID === link.id) card.classList.add("selected");

      const laneName = STATE.lanes.find(l=>l.id===link.laneId)?.name || link.laneId;

      const statusPill = link.status === "active"
        ? `<span class="pill ok">active</span>`
        : `<span class="pill bad">deprecated</span>`;

      const missingPill = link.missing ? `<span class="pill bad">missing</span>` : ``;

      const noteLine = link.note ? escapeHtml(link.note) : "";
      const displayLine = escapeHtml(link.displayLabel || inferLabelFromPath(link.path));

      card.innerHTML = `
        <div class="top">
          <div style="min-width:0">
            <div class="lbl">${displayLine}</div>
            <div class="path">${escapeHtml(link.path)}</div>
          </div>
          <div class="pillRow" style="justify-content:flex-end">
            ${statusPill}
            ${missingPill}
          </div>
        </div>
        <div class="note">${noteLine ? noteLine : `<span class="ghost mono">NO NOTE</span>`}</div>
        <div class="pillRow">
          <span class="pill">${escapeHtml(laneName)}</span>
          ${link.version ? `<span class="pill mono">${escapeHtml(link.version)}</span>` : `<span class="pill mono ghost">NO VERSION</span>`}
        </div>
      `;

      card.addEventListener("click", ()=>{
        SELECTED_ID = link.id;
        render();
      });

      card.addEventListener("dragstart", ()=>{
        DRAG_ID = link.id;
      });

      card.addEventListener("dragend", ()=>{
        DRAG_ID = null;
      });

      return card;
    }

    function escapeHtml(s){
      return safeStr(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function moveLinkToLane(id, laneId){
      const link = STATE.links[id];
      if(!link) return;

      // Remove from previous order array
      const prev = link.laneId || "L0";
      if(Array.isArray(STATE.order[prev])){
        STATE.order[prev] = STATE.order[prev].filter(x=>x!==id);
      }

      link.laneId = laneId;

      // If lane is deprecated, force deprecated status (can still manually override in editor)
      const lane = STATE.lanes.find(l=>l.id===laneId);
      if(lane && lane.deprecated) link.status = "deprecated";

      if(!Array.isArray(STATE.order[laneId])) STATE.order[laneId] = [];
      STATE.order[laneId].unshift(id);

      STATE.updatedAt = nowISO();
      render();
    }

    function setFilterMode(){
      const f = STATE.ui.filterStatus;
      UI.filterLabel.textContent = f.toUpperCase();
    }

    function updateEditor(){
      const has = !!(SELECTED_ID && STATE.links[SELECTED_ID]);
      const link = has ? STATE.links[SELECTED_ID] : null;

      UI.btn.openLink.disabled = !has || !safeStr(link.url);
      UI.btn.copyUrl.disabled = !has || !safeStr(link.url);
      UI.btn.delete.disabled = !has;
      UI.btn.dup.disabled = !has;

      for(const k of ["label","note","path","url","status","version","tags"]){
        UI.ed[k].disabled = !has;
      }

      if(!has){
        UI.ed.id.textContent = "—";
        UI.ed.lane.textContent = "—";
        UI.ed.label.value = "";
        UI.ed.note.value = "";
        UI.ed.path.value = "";
        UI.ed.url.value = "";
        UI.ed.status.value = "active";
        UI.ed.version.value = "";
        UI.ed.tags.value = "";
        return;
      }

      UI.ed.id.textContent = link.id;
      UI.ed.lane.textContent = link.laneId;

      // Label editing writes to note by default? No. We keep both:
      // - displayLabel is derived: prefer note else inferred.
      // Here we let user set a real display label by writing into note if they want.
      // But user asked "unlabelled will fix" — simplest: we use NOTE as the label surface.
      UI.ed.label.value = link.displayLabel || inferLabelFromPath(link.path);
      UI.ed.note.value = safeStr(link.note);
      UI.ed.path.value = safeStr(link.path);
      UI.ed.url.value = safeStr(link.url);
      UI.ed.status.value = link.status || "active";
      UI.ed.version.value = safeStr(link.version);
      UI.ed.tags.value = safeStr(link.tags);

      // Update editor binding
      bindEditor(link);
    }

    let EDIT_BIND_GUARD = false;
    function bindEditor(link){
      if(EDIT_BIND_GUARD) return;
      EDIT_BIND_GUARD = true;

      // Remove and re-add listeners by cloning nodes (simple, reliable)
      const repl = (el)=>{
        const n = el.cloneNode(true);
        el.parentNode.replaceChild(n, el);
        return n;
      };

      UI.ed.label = repl(UI.ed.label);
      UI.ed.note = repl(UI.ed.note);
      UI.ed.path = repl(UI.ed.path);
      UI.ed.url = repl(UI.ed.url);
      UI.ed.status = repl(UI.ed.status);
      UI.ed.version = repl(UI.ed.version);
      UI.ed.tags = repl(UI.ed.tags);

      UI.ed.label.addEventListener("input", ()=>{
        // We store this as "note" if note is empty, otherwise we store as "displayLabelOverride" via tags? No.
        // Minimal: treat label input as "note" when note empty; otherwise treat as displayLabel by writing note.
        // This keeps one field of truth: "note".
        const v = UI.ed.label.value.trim();
        if(!UI.ed.note.value.trim()){
          link.note = v === "[UNLABELED]" ? "" : v;
          UI.ed.note.value = link.note;
        }else{
          link.note = v;
          UI.ed.note.value = link.note;
        }
        link.displayLabel = link.note ? link.note : inferLabelFromPath(link.path);
        STATE.updatedAt = nowISO();
        render();
      });

      UI.ed.note.addEventListener("input", ()=>{
        link.note = UI.ed.note.value;
        link.displayLabel = link.note ? link.note : inferLabelFromPath(link.path);
        STATE.updatedAt = nowISO();
        render();
      });

      UI.ed.path.addEventListener("input", ()=>{
        link.path = UI.ed.path.value.trim();
        if(!link.url && link.path){
          // If triage had repo.pagesBase, it is stored in sourceMeta.importedFrom as pagesBase
          const base = STATE.sourceMeta.importedFrom || "";
          if(base) link.url = base + link.path;
        }
        if(!link.note) link.displayLabel = inferLabelFromPath(link.path);
        STATE.updatedAt = nowISO();
        render();
      });

      UI.ed.url.addEventListener("input", ()=>{
        link.url = UI.ed.url.value.trim();
        STATE.updatedAt = nowISO();
        render();
      });

      UI.ed.status.addEventListener("change", ()=>{
        link.status = UI.ed.status.value;
        STATE.updatedAt = nowISO();
        render();
      });

      UI.ed.version.addEventListener("input", ()=>{
        link.version = UI.ed.version.value.trim();
        STATE.updatedAt = nowISO();
        render();
      });

      UI.ed.tags.addEventListener("input", ()=>{
        link.tags = UI.ed.tags.value.trim();
        STATE.updatedAt = nowISO();
        render();
      });

      EDIT_BIND_GUARD = false;
    }

    function parseInputJson(){
      const raw = UI.inputArea.value.trim();
      if(!raw) throw new Error("EMPTY INPUT");
      return JSON.parse(raw);
    }

    function ingestTriageExport(obj){
      const next = DEFAULT();
      next.sourceMeta.importedAt = nowISO();
      next.sourceMeta.originalVersion = safeStr(obj.version || "");
      // pagesBase (repo.pagesBase) is the cleanest source of URL composition
      const pagesBase = safeStr(obj?.repo?.pagesBase || "");
      next.sourceMeta.importedFrom = pagesBase;

      // lanes
      if(Array.isArray(obj.lanes) && obj.lanes.length){
        next.lanes = obj.lanes.map(l=>({
          id: safeStr(l.id || "").trim() || crypto.randomUUID().slice(0,6).toUpperCase(),
          name: safeStr(l.name || "LANE").trim() || "LANE",
          deprecated: !!l.deprecated
        }));
      }

      // ui defaults
      const triUI = obj.ui || {};
      next.ui.filterStatus = safeStr(triUI.filterStatus || "active").trim() || "active";
      next.ui.search = safeStr(triUI.filterSearch || "").trim();

      // links map
      const links = obj.links || {};
      for(const key of Object.keys(links)){
        const raw = links[key] || {};
        const id = safeStr(key);
        const laneId = safeStr(raw.laneId || "L0");
        const draft = { ...raw, laneId };

        // if url missing but we have pagesBase, infer
        if(!draft.url && pagesBase && draft.path) draft.url = pagesBase + draft.path;

        next.links[id] = normalizeLink(id, draft);
      }

      // order from triage (if present)
      // triage doesn't store order in the snippet; we create deterministic order by lane + path
      next.order = {};
      for(const lane of next.lanes){
        next.order[lane.id] = [];
      }
      const ids = Object.keys(next.links);
      ids.sort((a,b)=>{
        const A = next.links[a], B = next.links[b];
        if(A.laneId !== B.laneId) return (A.laneId||"").localeCompare(B.laneId||"");
        return (A.path||"").localeCompare(B.path||"");
      });
      for(const id of ids){
        const laneId = next.links[id].laneId || "L0";
        if(!Array.isArray(next.order[laneId])) next.order[laneId] = [];
        next.order[laneId].push(id);
      }

      next.updatedAt = nowISO();
      return next;
    }

    function cleanState(){
      // Normalize every link, ensure url inference, ensure lane/status coherence
      const pagesBase = STATE.sourceMeta.importedFrom || "";
      for(const id of Object.keys(STATE.links)){
        const L = STATE.links[id];
        if(!L.url && pagesBase && L.path) L.url = pagesBase + L.path;
        L.path = safeStr(L.path || id).trim();
        L.url = safeStr(L.url).trim();
        L.tags = safeStr(L.tags).trim();
        L.version = safeStr(L.version).trim();
        L.note = safeStr(L.note).trim();

        // "displayLabel" derived from note else inferred
        L.displayLabel = L.note ? L.note : inferLabelFromPath(L.path);

        // Status normalization
        const lane = STATE.lanes.find(x=>x.id===L.laneId);
        if(lane && lane.deprecated) L.status = "deprecated";
        if(L.status !== "active" && L.status !== "deprecated") L.status = "active";
      }

      // Ensure lanes exist referenced by links
      const laneIds = new Set(STATE.lanes.map(l=>l.id));
      for(const id of Object.keys(STATE.links)){
        const L = STATE.links[id];
        if(!laneIds.has(L.laneId)){
          // send to INBOX if unknown
          L.laneId = "L0";
        }
      }

      ensureOrderArrays();
      STATE.updatedAt = nowISO();
      render();
    }

    function openModal(){
      UI.modalShade.style.display = "flex";
      UI.jsonPreview.textContent = JSON.stringify(exportState(), null, 2);
    }
    function closeModal(){
      UI.modalShade.style.display = "none";
    }

    function exportState(){
      // Export without derived-only fields to keep it clean and compatible with triage-ish schemas.
      // We still keep order for lanes, because rearrangement matters.
      const out = {
        version: STATE.version,
        updatedAt: nowISO(),
        sourceMeta: { ...STATE.sourceMeta },
        ui: { ...STATE.ui },
        lanes: STATE.lanes.map(l=>({ id:l.id, name:l.name, deprecated:!!l.deprecated })),
        order: JSON.parse(JSON.stringify(STATE.order || {})),
        links: {}
      };
      for(const id of Object.keys(STATE.links)){
        const L = STATE.links[id];
        out.links[id] = {
          path: L.path,
          url: L.url,
          laneId: L.laneId,
          tags: L.tags,
          version: L.version,
          status: L.status,
          note: L.note,
          missing: !!L.missing
        };
      }
      return out;
    }

    function downloadJson(filename, data){
      const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 250);
    }

    function saveLocal(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(exportState()));
      UI.activeSummary.textContent = `SAVED · ${Object.keys(STATE.links).length} LINKS`;
    }

    function loadLocal(){
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const obj = JSON.parse(raw);
      // Treat it as an arranger export, not raw triage
      const next = ingestArrangerExport(obj);
      STATE = next;
      SELECTED_ID = null;
      render();
    }

    function ingestArrangerExport(obj){
      const next = DEFAULT();
      next.version = safeStr(obj.version || next.version);
      next.sourceMeta = { ...next.sourceMeta, ...(obj.sourceMeta || {}) };
      next.ui = { ...next.ui, ...(obj.ui || {}) };

      if(Array.isArray(obj.lanes) && obj.lanes.length){
        next.lanes = obj.lanes.map(l=>({
          id: safeStr(l.id||"").trim() || crypto.randomUUID().slice(0,6).toUpperCase(),
          name: safeStr(l.name||"LANE").trim() || "LANE",
          deprecated: !!l.deprecated
        }));
      }

      const pagesBase = next.sourceMeta.importedFrom || "";

      const links = obj.links || {};
      for(const key of Object.keys(links)){
        const id = safeStr(key);
        const raw = links[key] || {};
        const draft = { ...raw };
        if(!draft.url && pagesBase && draft.path) draft.url = pagesBase + draft.path;
        next.links[id] = normalizeLink(id, draft);
      }

      next.order = obj.order && typeof obj.order === "object" ? obj.order : {};
      next.updatedAt = nowISO();
      // ensure order correctness
      STATE = next;
      ensureOrderArrays();
      // restore global STATE reference
      return STATE;
    }

    function copyText(t){
      try{
        navigator.clipboard.writeText(t);
      }catch(e){
        const ta = document.createElement("textarea");
        ta.value = t;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
      }
    }

    function newLane(){
      // Minimal: create a lane id and name; order array created in ensureOrderArrays()
      const id = `L${Math.floor(Math.random()*9000+1000)}`;
      STATE.lanes.push({ id, name:"NEW SET", deprecated:false });
      ensureOrderArrays();
      STATE.updatedAt = nowISO();
      render();
    }

    function renameLanes(){
      // Quick inline prompt approach (no fancy UI)
      // Format: L1=CORE\nL2=EXPERIMENTS\n...
      const lines = STATE.lanes.map(l=>`${l.id}=${l.name}`).join("\n");
      const next = prompt("RENAME LANES (FORMAT: L1=NAME)", lines);
      if(next === null) return;
      const map = {};
      for(const line of next.split("\n")){
        const s = line.trim();
        if(!s) continue;
        const idx = s.indexOf("=");
        if(idx<=0) continue;
        const k = s.slice(0,idx).trim();
        const v = s.slice(idx+1).trim();
        map[k] = v || map[k];
      }
      for(const lane of STATE.lanes){
        if(map[lane.id]) lane.name = map[lane.id];
      }
      STATE.updatedAt = nowISO();
      render();
    }

    function toggleFilter(){
      const f = STATE.ui.filterStatus;
      STATE.ui.filterStatus = (f === "active") ? "deprecated" : (f === "deprecated") ? "all" : "active";
      setFilterMode();
      render();
    }

    function deleteSelected(){
      if(!SELECTED_ID || !STATE.links[SELECTED_ID]) return;
      const id = SELECTED_ID;
      const laneId = STATE.links[id].laneId || "L0";
      delete STATE.links[id];
      if(Array.isArray(STATE.order[laneId])){
        STATE.order[laneId] = STATE.order[laneId].filter(x=>x!==id);
      }
      SELECTED_ID = null;
      STATE.updatedAt = nowISO();
      render();
    }

    function duplicateSelected(){
      if(!SELECTED_ID || !STATE.links[SELECTED_ID]) return;
      const src = STATE.links[SELECTED_ID];
      const id = `${src.id}__COPY__${Math.floor(Math.random()*9999)}`;
      STATE.links[id] = normalizeLink(id, {
        path: src.path,
        url: src.url,
        laneId: src.laneId,
        tags: src.tags,
        version: src.version,
        status: src.status,
        note: src.note,
        missing: src.missing
      });
      if(!Array.isArray(STATE.order[src.laneId])) STATE.order[src.laneId] = [];
      STATE.order[src.laneId].unshift(id);
      STATE.updatedAt = nowISO();
      render();
    }

    function openSelected(){
      if(!SELECTED_ID || !STATE.links[SELECTED_ID]) return;
      const url = STATE.links[SELECTED_ID].url;
      if(!url) return;
      window.open(url, "_blank", "noopener,noreferrer");
    }

    function onSearch(){
      STATE.ui.search = UI.searchBox.value;
      render();
    }

    function wire(){
      UI.btn.parse.addEventListener("click", ()=>{
        try{
          const obj = parseInputJson();
          // Detect triage export by version prefix
          if(safeStr(obj.version).includes("KETADATA_LINK_TRIAGE")){
            const next = ingestTriageExport(obj);
            STATE = next;
          }else{
            // Attempt to ingest as arranger export
            STATE = ingestArrangerExport(obj);
          }
          SELECTED_ID = null;
          setFilterMode();
          render();
        }catch(e){
          alert("PARSE FAILED: " + e.message);
        }
      });

      UI.btn.clean.addEventListener("click", ()=> cleanState());

      UI.btn.hydrateFromInput.addEventListener("click", ()=>{
        try{
          const obj = parseInputJson();
          if(safeStr(obj.version).includes("KETADATA_LINK_TRIAGE")){
            STATE = ingestTriageExport(obj);
          }else{
            STATE = ingestArrangerExport(obj);
          }
          SELECTED_ID = null;
          setFilterMode();
          render();
        }catch(e){
          alert("INPUT FAILED: " + e.message);
        }
      });

      UI.btn.openPreview.addEventListener("click", ()=> openModal());

      UI.btn.modalClose.addEventListener("click", ()=> closeModal());
      UI.modalShade.addEventListener("click", (e)=>{
        if(e.target === UI.modalShade) closeModal();
      });

      UI.btn.modalCopy.addEventListener("click", ()=>{
        copyText(UI.jsonPreview.textContent || "");
      });

      UI.btn.saveLocal.addEventListener("click", ()=> saveLocal());
      UI.btn.loadLocal.addEventListener("click", ()=> loadLocal());

      UI.btn.export.addEventListener("click", ()=>{
        const out = exportState();
        const fname = `KETADATA_LINK_SETS_${new Date().toISOString().slice(0,19).replaceAll(":","-")}.json`;
        downloadJson(fname, out);
      });

      UI.btn.import.addEventListener("click", ()=>{
        UI.btn.filePick.value = "";
        UI.btn.filePick.click();
      });

      UI.btn.filePick.addEventListener("change", async ()=>{
        const f = UI.btn.filePick.files && UI.btn.filePick.files[0];
        if(!f) return;
        const text = await f.text();
        UI.inputArea.value = text;
        UI.btn.parse.click();
      });

      UI.btn.reset.addEventListener("click", ()=>{
        if(!confirm("RESET APP STATE?")) return;
        STATE = DEFAULT();
        SELECTED_ID = null;
        UI.inputArea.value = "";
        UI.searchBox.value = "";
        setFilterMode();
        render();
      });

      UI.btn.openLink.addEventListener("click", ()=> openSelected());
      UI.btn.copyUrl.addEventListener("click", ()=>{
        if(!SELECTED_ID || !STATE.links[SELECTED_ID]) return;
        copyText(STATE.links[SELECTED_ID].url || "");
      });

      UI.btn.delete.addEventListener("click", ()=>{
        if(!confirm("DELETE THIS LINK?")) return;
        deleteSelected();
      });

      UI.btn.dup.addEventListener("click", ()=> duplicateSelected());

      UI.btn.toggleFilter.addEventListener("click", ()=> toggleFilter());
      UI.btn.newLane.addEventListener("click", ()=> newLane());
      UI.btn.renameLanes.addEventListener("click", ()=> renameLanes());

      UI.searchBox.addEventListener("input", ()=> onSearch());

      // Keyboard: Esc closes modal, Ctrl/Cmd+S saves, Ctrl/Cmd+E exports
      window.addEventListener("keydown", (e)=>{
        if(e.key === "Escape"){
          if(UI.modalShade.style.display === "flex") closeModal();
        }
        const mod = e.ctrlKey || e.metaKey;
        if(mod && e.key.toLowerCase() === "s"){
          e.preventDefault();
          saveLocal();
        }
        if(mod && e.key.toLowerCase() === "e"){
          e.preventDefault();
          UI.btn.export.click();
        }
      });
    }

    // Init
    function init(){
      setFilterMode();
      render();
      wire();
      // Attempt auto-load to resume session
      try{ loadLocal(); }catch(_){}
    }
    init();
  </script>

  <!-- ============================================================
    KETADATA HTML SERIALIZATION STAMP
    AE/EE/WB: WB
    FILE_ID: KETADATA_LINK_SET_ARRANGER
    ROOM_ID: BASE_TOOL
    VERSION: v1_proto_sets_drag_edit_export
    UPDATED_AT: 2025-12-29T00:00:00-05:00
    CHANGELOG:
    - INPUT: PASTE TRIAGE JSON → PARSE → CLEAN → EDIT
    - PROTO-SETS: LANES ARE SETS; DRAG LINKS BETWEEN LANES
    - EDIT: LABEL/NOTE/PATH/URL/STATUS/VERSION/TAGS
    - FILTER: ACTIVE / DEPRECATED / ALL + SEARCH
    - STATE IO: SAVE/LOAD (localStorage) + EXPORT/IMPORT (REAL FILE DOWNLOAD/UPLOAD)
    - ORDER: LANE ORDER PERSISTS VIA order[laneId] ARRAYS
    ============================================================ -->
</body>
</html>
