<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA PHOTOBOOTH // CRUNCH</title>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;

      --stroke:rgba(255,255,255,0.18);
      --stroke2:rgba(255,255,255,0.12);

      --glass:rgba(255,255,255,0.06);
      --panel:rgba(0,0,0,0.88);
      --shadow:rgba(0,0,0,0.78);

      --muted:rgba(255,255,255,0.62);
      --muted2:rgba(255,255,255,0.45);

      --node:rgba(255,255,255,0.22);
      --nodeOn:rgba(255,255,255,0.55);
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Arial, Helvetica, sans-serif;}
    body{overflow:hidden;}

    /* STAGE */
    #stage{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:#000;
    }

    /* photobooth frame (single visible object) */
    #frame{
      position:relative;
      width:min(92vw, 980px);
      height:min(86vh, 720px);
      border:1px solid var(--stroke);
      background:#000;
      box-shadow:0 24px 90px var(--shadow);
      overflow:hidden;
    }

    video, canvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      image-rendering:pixelated;
      transform:translateZ(0);
    }

    /* scanline / lo-fi veil */
    #overlay{
      pointer-events:none;
      position:absolute; inset:0;
      mix-blend-mode:screen;
      opacity:0.18;
      background:
        repeating-linear-gradient(0deg,
          rgba(255,255,255,0.05) 0px,
          rgba(255,255,255,0.05) 1px,
          rgba(0,0,0,0) 2px,
          rgba(0,0,0,0) 4px);
    }

    /* micro brand */
    #brand{
      position:absolute; left:12px; top:10px;
      display:flex; align-items:center; gap:8px;
      letter-spacing:0.18em; text-transform:uppercase;
      font-size:11px;
      color:rgba(255,255,255,0.78);
      user-select:none;
      pointer-events:none;
    }
    .note{
      width:8px; height:8px; background:#fff;
      display:inline-block;
    }
    #status{
      margin-left:6px;
      letter-spacing:0.12em;
      font-size:10px;
      color:rgba(255,255,255,0.40);
      white-space:nowrap;
    }

    /* COMMAND/CONTROL BUTTON (the only obvious UI control) */
    #ccBtn{
      position:absolute; right:10px; top:10px;
      width:28px; height:28px;
      border:1px solid rgba(255,255,255,0.24);
      background:rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      cursor:pointer;
      display:grid;
      place-items:center;
      padding:0;
      z-index:5;
    }
    #ccBtn:hover{ background:rgba(255,255,255,0.06); border-color:rgba(255,255,255,0.38); }
    #ccGlyph{
      width:10px; height:10px;
      border:1px solid rgba(255,255,255,0.55);
      background:transparent;
      box-shadow:0 0 0 1px rgba(0,0,0,0.5) inset;
      opacity:0.85;
    }

    /* MESSAGE */
    #msg{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      color:rgba(255,255,255,0.74);
      font-size:11px;
      letter-spacing:0.20em;
      text-transform:uppercase;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,0.20);
      background:rgba(0,0,0,0.70);
      display:none;
      text-align:center;
      max-width:84%;
      z-index:6;
    }

    /* MINIMAL HOTKEY NODES (nearly invisible) */
    #nodes{
      position:absolute;
      inset:0;
      pointer-events:auto; /* allow click to select param */
      z-index:4;
    }
    .node{
      position:absolute;
      width:6px; height:6px;
      border-radius:999px;
      background:var(--node);
      opacity:0.35;
      border:1px solid rgba(255,255,255,0.08);
      cursor:default;
      transition:opacity 120ms linear, transform 120ms linear, background 120ms linear;
    }
    .node:hover{ opacity:0.75; }
    .node.on{
      opacity:0.95;
      background:var(--nodeOn);
      transform:scale(1.15);
      border-color:rgba(255,255,255,0.25);
    }
    /* place nodes in a tiny vertical rail near bottom-right */
    .n1{ right:12px; bottom:112px; }
    .n2{ right:12px; bottom:96px; }
    .n3{ right:12px; bottom:80px; }
    .n4{ right:12px; bottom:64px; }
    .n5{ right:12px; bottom:48px; }

    /* subtle bottom strip */
    #strip{
      position:absolute; left:12px; bottom:10px;
      display:flex; align-items:center; gap:10px;
      font-size:10px;
      letter-spacing:0.16em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.35);
      user-select:none;
      pointer-events:none;
    }

    /* OFF-SCREEN CONTROL DRAWER (outside photobooth) */
    #drawer{
      position:fixed;
      top:0; right:0;
      height:100vh;
      width:min(380px, 92vw);
      transform:translateX(100%);
      transition:transform 180ms ease;
      z-index:20;

      background:var(--panel);
      border-left:1px solid var(--stroke);
      box-shadow:-18px 0 70px rgba(0,0,0,0.72);

      display:flex;
      flex-direction:column;
    }
    #drawer.open{ transform:translateX(0); }

    #drawerHeader{
      padding:14px 14px 10px 14px;
      border-bottom:1px solid var(--stroke2);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      user-select:none;
    }
    #drawerHeader .title{
      display:flex; align-items:center; gap:10px;
      margin:0;
      font-size:12px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.82);
    }
    #closeDrawer{
      width:32px; height:28px;
      border:1px solid rgba(255,255,255,0.20);
      background:transparent;
      cursor:pointer;
      color:rgba(255,255,255,0.7);
      letter-spacing:0.12em;
      text-transform:uppercase;
      font-size:11px;
    }
    #closeDrawer:hover{ background:rgba(255,255,255,0.06); border-color:rgba(255,255,255,0.34); }

    #drawerBody{
      padding:14px;
      display:grid;
      gap:12px;
      overflow:auto;
    }

    .section{
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(255,255,255,0.04);
      padding:12px;
    }
    .sectionTitle{
      margin:0 0 10px 0;
      font-size:11px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.72);
    }

    .row{
      display:grid;
      grid-template-columns: 1fr auto;
      align-items:center;
      gap:12px;
      margin:10px 0;
    }
    label{
      font-size:11px;
      letter-spacing:0.12em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.60);
    }
    input[type="range"]{ width:170px; }

    .chips{ display:flex; flex-wrap:wrap; gap:8px; }
    .chip{
      border:1px solid rgba(255,255,255,0.18);
      background:transparent;
      color:rgba(255,255,255,0.82);
      padding:7px 10px;
      font-size:11px;
      letter-spacing:0.14em;
      text-transform:uppercase;
      cursor:pointer;
    }
    .chip:hover{ background:rgba(255,255,255,0.06); border-color:rgba(255,255,255,0.34); }
    .chip.on{ background:rgba(255,255,255,0.08); border-color:rgba(255,255,255,0.38); }

    .hint{
      margin-top:10px;
      font-size:11px;
      line-height:1.35;
      color:rgba(255,255,255,0.52);
      letter-spacing:0.06em;
    }
    .keys{
      margin-top:10px;
      font-size:11px;
      color:rgba(255,255,255,0.55);
      letter-spacing:0.08em;
      line-height:1.45;
    }
    kbd{
      display:inline-block;
      padding:2px 6px;
      border:1px solid rgba(255,255,255,0.22);
      background:rgba(255,255,255,0.06);
      font-family:Arial, Helvetica, sans-serif;
      font-size:11px;
      letter-spacing:0.14em;
      text-transform:uppercase;
      margin-right:6px;
    }

    /* tiny focus indicator when a parameter is selected */
    #paramHUD{
      position:absolute;
      right:12px; bottom:12px;
      padding:7px 9px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(0,0,0,0.55);
      color:rgba(255,255,255,0.50);
      font-size:10px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      user-select:none;
      z-index:5;
      opacity:0.0;
      transition:opacity 140ms linear;
      pointer-events:none;
    }
    #paramHUD.on{ opacity:1.0; }

    /* accessibility: hide outline for mouse users, keep for keyboard */
    :focus{ outline:none; }
    :focus-visible{ outline:1px solid rgba(255,255,255,0.35); outline-offset:2px; }
  </style>
</head>

<body>
  <div id="stage">
    <div id="frame" aria-label="Photobooth">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="out"></canvas>
      <div id="overlay"></div>

      <div id="brand">
        <span class="note" aria-hidden="true"></span>
        <span>KETADATA PHOTOBOOTH</span>
        <span id="status">CRUNCH ON // INVERT OFF</span>
      </div>

      <!-- only visible control on the booth -->
      <button id="ccBtn" type="button" aria-label="Command / Control">
        <span id="ccGlyph" aria-hidden="true"></span>
      </button>

      <!-- nearly invisible hotkey nodes -->
      <div id="nodes" aria-label="Hotkey nodes">
        <div class="node n1" data-key="1" title="1 (Pixel)"></div>
        <div class="node n2" data-key="2" title="2 (Posterize)"></div>
        <div class="node n3" data-key="3" title="3 (Noise)"></div>
        <div class="node n4" data-key="4" title="4 (Crisp)"></div>
        <div class="node n5" data-key="5" title="5 (Chroma)"></div>
      </div>

      <div id="paramHUD" aria-hidden="true"></div>
      <div id="strip"><span>BLACK ONLY</span><span>NO GRADIENTS</span><span>CRUNCH PRESET</span></div>

      <div id="msg"></div>
    </div>
  </div>

  <!-- OFF-SCREEN DRAWER -->
  <aside id="drawer" aria-label="Controls drawer">
    <div id="drawerHeader">
      <p class="title"><span class="note" aria-hidden="true"></span> COMMAND / CONTROL</p>
      <button id="closeDrawer" type="button">X</button>
    </div>

    <div id="drawerBody">
      <div class="section">
        <p class="sectionTitle">Modes</p>
        <div class="chips">
          <button class="chip on" id="crunchBtn" type="button">Crunch</button>
          <button class="chip" id="invertBtn" type="button">Invert [I]</button>
        </div>
        <div class="hint">
          Drawer is the only “visible UI.” On the booth: operate via nodes/hotkeys + mouse intensity.
        </div>
      </div>

      <div class="section">
        <p class="sectionTitle">Fry Controls</p>

        <div class="row">
          <label for="pixel">Pixel</label>
          <input id="pixel" type="range" min="2" max="16" step="1" value="8" />
        </div>

        <div class="row">
          <label for="poster">Posterize</label>
          <input id="poster" type="range" min="2" max="12" step="1" value="5" />
        </div>

        <div class="row">
          <label for="noise">Noise</label>
          <input id="noise" type="range" min="0" max="1" step="0.01" value="0.28" />
        </div>

        <div class="row">
          <label for="sharpen">Crisp</label>
          <input id="sharpen" type="range" min="0" max="2" step="0.01" value="1.10" />
        </div>

        <div class="row">
          <label for="bleed">Chroma</label>
          <input id="bleed" type="range" min="0" max="8" step="1" value="4" />
        </div>
      </div>

      <div class="section">
        <p class="sectionTitle">Actions</p>
        <div class="chips">
          <button class="chip" id="snapBtn" type="button">Snap [Space]</button>
          <button class="chip" id="saveBtn" type="button">Save PNG</button>
          <button class="chip" id="resetBtn" type="button">Reset [R]</button>
        </div>

        <div class="keys">
          <div><kbd>Space</kbd> snap</div>
          <div><kbd>I</kbd> invert</div>
          <div><kbd>R</kbd> reset preset</div>
          <div><kbd>1–5</kbd> select parameter (nodes mirror these)</div>
          <div>Mouse X adjusts selected parameter. Press same key to deselect.</div>
        </div>
      </div>
    </div>
  </aside>

  <script>
    // ====== KETADATA PHOTOBOOTH (minimal booth surface / off-screen controls) ======
    const video = document.getElementById('video');
    const out = document.getElementById('out');
    const octx = out.getContext('2d', { willReadFrequently: true });

    const drawer = document.getElementById('drawer');
    const ccBtn = document.getElementById('ccBtn');
    const closeDrawer = document.getElementById('closeDrawer');

    const crunchBtn = document.getElementById('crunchBtn');
    const invertBtn = document.getElementById('invertBtn');

    const pixel = document.getElementById('pixel');
    const poster = document.getElementById('poster');
    const noise = document.getElementById('noise');
    const sharpen = document.getElementById('sharpen');
    const bleed = document.getElementById('bleed');

    const snapBtn = document.getElementById('snapBtn');
    const saveBtn = document.getElementById('saveBtn');
    const resetBtn = document.getElementById('resetBtn');

    const statusEl = document.getElementById('status');
    const msgEl = document.getElementById('msg');
    const nodes = [...document.querySelectorAll('.node')];
    const hud = document.getElementById('paramHUD');

    // offscreen buffers
    const buf2 = document.createElement('canvas');
    const b2 = buf2.getContext('2d', { willReadFrequently: true });

    let invertOn = false;
    let crunchOn = true;

    // hotkey-selected param + mouse intensity modulation
    let activeKey = null; // "1".."5"
    let lastMouseX = 0;

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function showMsg(text, ms = 700){
      msgEl.textContent = text;
      msgEl.style.display = 'block';
      clearTimeout(showMsg._t);
      showMsg._t = setTimeout(()=>{ msgEl.style.display = 'none'; }, ms);
    }

    function setHUD(text){
      if(!text){
        hud.classList.remove('on');
        hud.textContent = '';
        return;
      }
      hud.textContent = text;
      hud.classList.add('on');
    }

    function updateNodes(){
      nodes.forEach(n => n.classList.toggle('on', n.dataset.key === activeKey));
    }

    function updateStatus(){
      statusEl.textContent = `CRUNCH ${crunchOn ? 'ON' : 'OFF'} // INVERT ${invertOn ? 'ON' : 'OFF'}`;
      invertBtn.classList.toggle('on', invertOn);
      crunchBtn.classList.toggle('on', crunchOn);

      // If a param is selected, keep HUD minimal
      if(activeKey){
        const map = { "1":"PIXEL", "2":"POSTER", "3":"NOISE", "4":"CRISP", "5":"CHROMA" };
        const val =
          activeKey==="1" ? pixel.value :
          activeKey==="2" ? poster.value :
          activeKey==="3" ? Number(noise.value).toFixed(2) :
          activeKey==="4" ? Number(sharpen.value).toFixed(2) :
          bleed.value;
        setHUD(`${map[activeKey]} ${val}`);
      } else {
        setHUD('');
      }
    }

    function toggleDrawer(force){
      const willOpen = typeof force === 'boolean' ? force : !drawer.classList.contains('open');
      drawer.classList.toggle('open', willOpen);
    }

    ccBtn.addEventListener('click', ()=> toggleDrawer());
    closeDrawer.addEventListener('click', ()=> toggleDrawer(false));

    // close drawer on ESC
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape' && drawer.classList.contains('open')) toggleDrawer(false);
    });

    // ===== Crunch processing =====
    function posterizeChannel(v, levels){
      const step = 255 / (levels - 1);
      return Math.round(v / step) * step;
    }

    function addNoiseInvertPoster(img, levels, nAmt, doInvert){
      const d = img.data;
      for(let i=0; i<d.length; i+=4){
        let r=d[i], g=d[i+1], b=d[i+2];

        if(nAmt > 0){
          const n = (Math.random()*2 - 1) * 255 * nAmt;
          r = clamp(r + n, 0, 255);
          g = clamp(g + n, 0, 255);
          b = clamp(b + n, 0, 255);
        }

        if(doInvert){
          r = 255 - r; g = 255 - g; b = 255 - b;
        }

        r = posterizeChannel(r, levels);
        g = posterizeChannel(g, levels);
        b = posterizeChannel(b, levels);

        d[i]=r; d[i+1]=g; d[i+2]=b;
      }
    }

    function chromaShift(data, w, h, shift){
      if(shift <= 0) return;
      const src = new Uint8ClampedArray(data);
      const idx = (x,y)=> (y*w + x) * 4;
      for(let y=0; y<h; y++){
        for(let x=0; x<w; x++){
          const i = idx(x,y);
          const xr = clamp(x + shift, 0, w-1);
          const xb = clamp(x - shift, 0, w-1);
          data[i+0] = src[idx(xr,y)+0]; // R
          data[i+2] = src[idx(xb,y)+2]; // B
        }
      }
    }

    function applySharpen(data, w, h, amount){
      if(amount <= 0) return;
      const src = new Uint8ClampedArray(data);
      const a = amount;
      const idx = (x,y)=> (y*w + x) * 4;
      for(let y=1; y<h-1; y++){
        for(let x=1; x<w-1; x++){
          const i = idx(x,y);
          for(let c=0; c<3; c++){
            const center = src[i+c];
            const up = src[idx(x,y-1)+c];
            const dn = src[idx(x,y+1)+c];
            const lf = src[idx(x-1,y)+c];
            const rt = src[idx(x+1,y)+c];
            const v = center*(1+4*a) - (up+dn+lf+rt)*a;
            data[i+c] = clamp(v, 0, 255);
          }
        }
      }
    }

    function pixelateInto(destCtx, srcCanvas, w, h, px){
      buf2.width = Math.max(1, Math.floor(w / px));
      buf2.height = Math.max(1, Math.floor(h / px));
      b2.imageSmoothingEnabled = false;
      destCtx.imageSmoothingEnabled = false;

      b2.clearRect(0,0,buf2.width,buf2.height);
      b2.drawImage(srcCanvas, 0,0, w,h, 0,0, buf2.width,buf2.height);

      destCtx.clearRect(0,0,w,h);
      destCtx.drawImage(buf2, 0,0, buf2.width,buf2.height, 0,0, w,h);
    }

    // working buffer = just reuse out itself as source snapshot per frame
    const work = document.createElement('canvas');
    const wctx = work.getContext('2d', { willReadFrequently: true });

    function resize(){
      const rect = out.getBoundingClientRect();
      out.width = Math.max(2, Math.floor(rect.width));
      out.height = Math.max(2, Math.floor(rect.height));
      work.width = out.width;
      work.height = out.height;
      updateStatus();
    }
    window.addEventListener('resize', resize);

    async function startCamera(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user" },
          audio: false
        });
        video.srcObject = stream;
        await video.play();
        showMsg('CAMERA ON', 900);
      }catch(err){
        showMsg('CAMERA DENIED', 1600);
        console.error(err);
      }
    }

    function render(){
      const w = out.width, h = out.height;
      if(video.readyState >= 2 && w && h){
        // draw raw video to work canvas
        wctx.imageSmoothingEnabled = true;
        wctx.clearRect(0,0,w,h);
        wctx.drawImage(video, 0,0, w,h);

        if(crunchOn){
          const px = Number(pixel.value);
          pixelateInto(octx, work, w, h, px);

          const img = octx.getImageData(0,0,w,h);
          chromaShift(img.data, w, h, Number(bleed.value));
          addNoiseInvertPoster(img, Number(poster.value), Number(noise.value), invertOn);
          applySharpen(img.data, w, h, Number(sharpen.value));
          octx.putImageData(img, 0,0);
        } else {
          octx.imageSmoothingEnabled = true;
          octx.clearRect(0,0,w,h);
          octx.drawImage(work, 0,0);

          if(invertOn){
            const img = octx.getImageData(0,0,w,h);
            addNoiseInvertPoster(img, 12, 0, true);
            octx.putImageData(img, 0,0);
          }
        }
      }
      requestAnimationFrame(render);
    }

    // ===== Actions =====
    function snapshot(){ showMsg('SNAP', 450); }

    function savePng(){
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = `ketadata-photobooth-${ts}.png`;
      a.href = out.toDataURL('image/png');
      a.click();
      showMsg('SAVED', 650);
    }

    snapBtn.addEventListener('click', snapshot);
    saveBtn.addEventListener('click', savePng);

    function resetPreset(){
      crunchOn = true;
      invertOn = false;
      pixel.value = 8;
      poster.value = 5;
      noise.value = 0.28;
      sharpen.value = 1.10;
      bleed.value = 4;
      activeKey = null;
      updateNodes();
      updateStatus();
      showMsg('RESET', 550);
    }
    resetBtn.addEventListener('click', resetPreset);

    // mode toggles in drawer
    crunchBtn.addEventListener('click', ()=>{
      crunchOn = !crunchOn;
      updateStatus();
    });
    invertBtn.addEventListener('click', ()=>{
      invertOn = !invertOn;
      updateStatus();
      showMsg(invertOn ? 'INVERT ON' : 'INVERT OFF', 500);
    });

    // sliders update HUD value
    [pixel, poster, noise, sharpen, bleed].forEach(el => el.addEventListener('input', updateStatus));

    // ===== Hotkeys + node selection =====
    function selectKey(k){
      if(activeKey === k){
        activeKey = null;
        updateNodes();
        updateStatus();
        showMsg('DESELECT', 350);
        return;
      }
      activeKey = k;
      updateNodes();
      updateStatus();
      const map = { "1":"PIXEL", "2":"POSTER", "3":"NOISE", "4":"CRISP", "5":"CHROMA" };
      showMsg(`SELECT ${map[k]}`, 450);
    }

    nodes.forEach(n=>{
      n.addEventListener('click', (e)=>{
        e.preventDefault();
        selectKey(n.dataset.key);
      });
    });

    function adjustByMouse(x){
      if(!activeKey) return;
      const dx = x - lastMouseX;
      lastMouseX = x;

      const step = dx / 240; // subtle
      if(activeKey === "1"){
        pixel.value = clamp(Math.round(Number(pixel.value) + step*10), 2, 16);
      } else if(activeKey === "2"){
        poster.value = clamp(Math.round(Number(poster.value) + step*8), 2, 12);
      } else if(activeKey === "3"){
        noise.value = clamp(Number(noise.value) + step*0.35, 0, 1).toFixed(2);
      } else if(activeKey === "4"){
        sharpen.value = clamp(Number(sharpen.value) + step*0.8, 0, 2).toFixed(2);
      } else if(activeKey === "5"){
        bleed.value = clamp(Math.round(Number(bleed.value) + step*12), 0, 8);
      }
      updateStatus();
    }

    window.addEventListener('mousedown', (e)=>{ lastMouseX = e.clientX; });
    window.addEventListener('mousemove', (e)=> adjustByMouse(e.clientX));

    window.addEventListener('keydown', (e)=>{
      const k = e.key;
      const kl = k.toLowerCase();

      if(kl === ' '){
        e.preventDefault();
        snapshot();
        return;
      }
      if(kl === 'i'){
        e.preventDefault();
        invertOn = !invertOn;
        updateStatus();
        showMsg(invertOn ? 'INVERT ON' : 'INVERT OFF', 500);
        return;
      }
      if(kl === 'r'){
        e.preventDefault();
        resetPreset();
        return;
      }
      if(['1','2','3','4','5'].includes(k)){
        e.preventDefault();
        selectKey(k);
        return;
      }
      // Optional: keep "h" as stealth drawer toggle (not shown on UI)
      if(kl === 'h'){
        e.preventDefault();
        toggleDrawer();
        return;
      }
    });

    // ===== INIT =====
    updateNodes();
    updateStatus();
    resize();
    startCamera().then(()=>{
      resize();
      render();
    });
  </script>
</body>
</html>
