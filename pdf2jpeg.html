<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KETADATA // PDF → JPEG CONVERTER</title>

  <!-- KETADATA: Minimal, sharp, functional. No kitsch. -->
  <style>
    :root{
      --bg:#ffffff;
      --fg:#000000;
      --muted:rgba(0,0,0,.6);
      --line:rgba(0,0,0,.14);
      --line2:rgba(0,0,0,.08);
      --panel:#ffffff;
      --shadow: 0 6px 20px rgba(0,0,0,.08);
      --radius: 10px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: Arial, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, sans-serif;
    }

    *{ box-sizing:border-box; }
    html, body { height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family:var(--sans);
      letter-spacing:.2px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .app{
      min-height:100%;
      display:flex;
      flex-direction:column;
    }

    header{
      border-bottom:1px solid var(--line);
      padding:14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      position:sticky;
      top:0;
      background:rgba(255,255,255,.92);
      backdrop-filter: blur(8px);
      z-index:50;
    }

    .brand{
      display:flex;
      flex-direction:column;
      line-height:1.05;
      user-select:none;
    }
    .brand .k{
      font-weight:700;
      font-size:14px;
      letter-spacing:1.4px;
    }
    .brand .s{
      font-size:12px;
      color:var(--muted);
      font-family:var(--mono);
    }

    .header-actions{
      display:flex;
      align-items:center;
      gap:10px;
    }

    .btn{
      appearance:none;
      border:1px solid var(--fg);
      background:transparent;
      color:var(--fg);
      padding:9px 10px;
      border-radius:999px;
      font-size:12px;
      font-family:var(--mono);
      cursor:pointer;
      transition: background .12s ease, color .12s ease, transform .08s ease;
      user-select:none;
    }
    .btn:hover{ background:var(--fg); color:var(--bg); }
    .btn:active{ transform: translateY(1px); }

    .btn.secondary{
      border-color: var(--line);
    }
    .btn.secondary:hover{
      background:rgba(0,0,0,.06);
      color:var(--fg);
      border-color:rgba(0,0,0,.22);
    }

    .noteBtn{
      width:30px; height:30px;
      border-radius:6px;
      border:1px solid var(--fg);
      background:var(--bg);
      display:grid;
      place-items:center;
      cursor:pointer;
      user-select:none;
    }
    .noteBtn:before{
      content:"";
      width:12px; height:12px;
      background:var(--fg);
      display:block;
    }
    .noteBtn:hover{ background:rgba(0,0,0,.06); }

    main{
      flex:1;
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:0;
    }

    /* Left workspace */
    .work{
      padding:16px;
      border-right:1px solid var(--line);
      display:flex;
      flex-direction:column;
      gap:12px;
      min-width:0;
    }

    .row{
      display:flex;
      gap:12px;
      align-items:stretch;
      flex-wrap:wrap;
    }

    .card{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: var(--panel);
      box-shadow: none;
      overflow:hidden;
    }
    .card .head{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--line2);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .card .head .title{
      font-family:var(--mono);
      font-size:12px;
      letter-spacing:.8px;
      text-transform:uppercase;
    }
    .card .head .sub{
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
      font-family:var(--mono);
      letter-spacing:.2px;
      text-transform:none;
    }
    .card .body{
      padding:12px;
    }

    details.keta{
      border:1px solid var(--line);
      border-radius: var(--radius);
      overflow:hidden;
      background: var(--panel);
    }
    details.keta > summary{
      list-style:none;
      cursor:pointer;
      user-select:none;
      padding:12px;
      border-bottom:1px solid var(--line2);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      font-family:var(--mono);
      font-size:12px;
      letter-spacing:.7px;
      text-transform:uppercase;
    }
    details.keta > summary::-webkit-details-marker{ display:none; }
    details.keta .content{
      padding:12px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      .work{ border-right:none; border-bottom:1px solid var(--line); }
    }
    @media (max-width: 720px){
      .grid2{ grid-template-columns:1fr; }
    }

    label{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size:12px;
      color:var(--muted);
      font-family:var(--mono);
    }

    input[type="file"]{
      width:100%;
      border:1px solid var(--line);
      border-radius:8px;
      padding:10px;
      font-family:var(--mono);
      font-size:12px;
      background:#fff;
    }

    input[type="range"]{ width:100%; }
    input[type="number"], select{
      width:100%;
      border:1px solid var(--line);
      border-radius:8px;
      padding:10px;
      font-family:var(--mono);
      font-size:12px;
      background:#fff;
      color:#000;
    }

    .inline{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      font-family:var(--mono);
      font-size:12px;
      color:var(--muted);
    }
    .inline strong{ color:#000; font-weight:700; }
    .inline .pill{
      border:1px solid var(--line);
      border-radius:999px;
      padding:6px 10px;
      color:#000;
      background:#fff;
    }

    .checkbox{
      display:flex;
      align-items:center;
      gap:8px;
      font-family:var(--mono);
      font-size:12px;
      color:#000;
      user-select:none;
    }

    .status{
      border-top:1px solid var(--line2);
      padding:10px 12px;
      font-family:var(--mono);
      font-size:12px;
      color:var(--muted);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }

    .progress{
      width:220px;
      height:10px;
      border:1px solid var(--line);
      border-radius:999px;
      overflow:hidden;
      background:#fff;
    }
    .progress > div{
      height:100%;
      width:0%;
      background:#000;
      transition: width .12s linear;
    }

    /* Preview */
    .previewWrap{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height: 260px;
    }

    .previewStage{
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:12px;
      display:grid;
      place-items:center;
      min-height: 360px;
      background:#fff;
    }

    canvas{
      max-width:100%;
      height:auto;
      display:block;
      background:#fff;
    }

    .thumbRow{
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:10px;
      display:flex;
      gap:10px;
      overflow:auto;
      background:#fff;
      align-items:center;
    }
    .thumb{
      width:56px; height:56px;
      border:1px solid var(--line);
      border-radius:10px;
      overflow:hidden;
      flex: 0 0 auto;
      display:grid;
      place-items:center;
      background:#fff;
      cursor:pointer;
      user-select:none;
    }
    .thumb.selected{
      outline:2px solid #000;
      outline-offset:2px;
    }
    .thumb canvas{
      width:56px; height:56px;
      object-fit:contain;
    }

    /* Right rail: notes & export */
    .rail{
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
      background:#fff;
      min-width:0;
    }

    .notePanel{
      border:1px solid var(--fg);
      border-radius: var(--radius);
      overflow:hidden;
      background:#fff;
    }
    .notePanel .nh{
      padding:12px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .notePanel .nh .t{
      font-family:var(--mono);
      font-size:12px;
      letter-spacing:.8px;
      text-transform:uppercase;
    }
    .notePanel .nb{
      padding:12px;
    }
    textarea{
      width:100%;
      min-height:160px;
      resize:vertical;
      border:1px solid var(--line);
      border-radius:8px;
      padding:10px;
      font-family:var(--mono);
      font-size:12px;
      line-height:1.35;
      outline:none;
    }

    .small{
      font-size:11px;
      color:var(--muted);
      font-family:var(--mono);
      line-height:1.35;
    }

    .danger{
      border-color: rgba(0,0,0,.25);
    }

    .kbd{
      font-family:var(--mono);
      border:1px solid var(--line);
      border-bottom-width:2px;
      border-radius:6px;
      padding:2px 6px;
      color:#000;
      background:#fff;
      font-size:11px;
    }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <div class="brand">
        <div class="k">KETADATA</div>
        <div class="s">PDF → JPEG CONVERTER // IN-HOUSE</div>
      </div>

      <div class="header-actions">
        <button class="btn secondary" id="btnClear" title="Clear current session">CLEAR</button>
        <button class="btn" id="btnConvert" title="Convert loaded PDFs into JPEGs and download a ZIP">CONVERT → ZIP</button>
        <div class="noteBtn" id="toggleNotes" title="KETA NOTE (toggle)"></div>
      </div>
    </header>

    <main>
      <!-- LEFT: WORK -->
      <section class="work">
        <details class="keta" open>
          <summary>
            <span>INPUT</span>
            <span class="small">PDF(s) in, JPEG zip out</span>
          </summary>
          <div class="content">
            <div class="grid2">
              <label>
                PDF FILE(S)
                <input id="pdfInput" type="file" accept="application/pdf" multiple />
                <div class="small">
                  This runs fully in-browser. No upload. If a PDF is huge, the browser may choke; reduce scale or split the file.
                </div>
              </label>

              <div class="card">
                <div class="head">
                  <div>
                    <div class="title">SESSION</div>
                    <div class="sub" id="sessionInfo">No files loaded.</div>
                  </div>
                </div>
                <div class="body">
                  <div class="inline">
                    <span class="pill"><strong id="countPDF">0</strong> PDF</span>
                    <span class="pill"><strong id="countPages">0</strong> pages</span>
                    <span class="pill"><strong id="countReady">0</strong> ready</span>
                  </div>
                  <div style="height:10px"></div>
                  <div class="small">
                    Preview uses page rasterization. Conversion uses the same render pipeline.
                  </div>
                </div>
                <div class="status">
                  <div class="inline">
                    <span>Progress</span>
                    <span class="kbd" id="progLabel">0%</span>
                  </div>
                  <div class="progress"><div id="progBar"></div></div>
                </div>
              </div>
            </div>
          </div>
        </details>

        <details class="keta" open>
          <summary>
            <span>OUTPUT CONTROLS</span>
            <span class="small">naming, scale, quality, inversion</span>
          </summary>
          <div class="content">
            <div class="grid2">
              <label>
                OUTPUT FORMAT
                <select id="outFormat">
                  <option value="jpeg" selected>JPEG (.jpg)</option>
                  <option value="png">PNG (.png) [larger files]</option>
                </select>
              </label>

              <label>
                FOLDER NAMING
                <select id="nameMode">
                  <option value="pdfName" selected>Folder per PDF (PDF filename)</option>
                  <option value="timestamp">Folder per PDF (timestamp)</option>
                </select>
              </label>

              <label>
                RENDER SCALE (DETAIL)
                <input id="scale" type="range" min="1" max="3" step="0.25" value="2" />
                <div class="inline">
                  <span>Scale:</span> <span class="pill"><strong id="scaleVal">2.00</strong>x</span>
                </div>
                <div class="small">2.0x is usually the best balance for handwriting scans.</div>
              </label>

              <label id="qWrap">
                JPEG QUALITY
                <input id="quality" type="range" min="0.4" max="1" step="0.05" value="0.92" />
                <div class="inline">
                  <span>Quality:</span> <span class="pill"><strong id="qualityVal">0.92</strong></span>
                </div>
                <div class="small">Higher = sharper lines, larger zip.</div>
              </label>

              <div class="card">
                <div class="head">
                  <div>
                    <div class="title">INVERSION</div>
                    <div class="sub">Black page / white writing aesthetic</div>
                  </div>
                </div>
                <div class="body">
                  <div class="checkbox">
                    <input type="checkbox" id="invert" checked />
                    <label for="invert" style="gap:0; font-family:var(--mono); color:#000;">
                      INVERT OUTPUT (DEFAULT: ON)
                      <div class="small">For Black Book scans, keep this ON. This bakes inversion into the exported images.</div>
                    </label>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </details>

        <details class="keta" open>
          <summary>
            <span>PREVIEW</span>
            <span class="small">finder-gallery style selection</span>
          </summary>
          <div class="content">
            <div class="previewWrap">
              <div class="previewStage">
                <canvas id="previewCanvas"></canvas>
              </div>
              <div class="thumbRow" id="thumbRow" aria-label="Page thumbnails"></div>
              <div class="small">
                Controls: <span class="kbd">←</span> <span class="kbd">→</span> page, <span class="kbd">I</span> invert, <span class="kbd">C</span> convert.
              </div>
            </div>
          </div>
        </details>
      </section>

      <!-- RIGHT: NOTES -->
      <aside class="rail" id="rail" style="display:block;">
        <div class="notePanel">
          <div class="nh">
            <div class="t">KETA NOTE</div>
            <button class="btn secondary" id="btnNoteExport">EXPORT NOTE JSON</button>
          </div>
          <div class="nb">
            <div class="small">
              This page is a converter, but the system rules still apply: one page-level note that can be collapsed/expanded and exported.
              You can paste specs, decisions, and constraints here.
            </div>
            <div style="height:10px"></div>
            <textarea id="noteText" placeholder="SYSTEM NOTE // decisions, constraints, next actions"></textarea>
            <div style="height:10px"></div>
            <div class="small" id="noteMeta"></div>
          </div>
        </div>

        <details class="keta" open>
          <summary>
            <span>EXPORT MANIFEST</span>
            <span class="small">zip structure + filenames</span>
          </summary>
          <div class="content">
            <div class="small">
              ZIP layout:
              <div style="height:6px"></div>
              <div style="font-family:var(--mono); font-size:12px; color:#000;">
                /<span id="manifestFolder">PDF_NAME</span>/<br/>
                &nbsp;&nbsp;page-001.jpg<br/>
                &nbsp;&nbsp;page-002.jpg<br/>
                &nbsp;&nbsp;...<br/>
              </div>
              <div style="height:10px"></div>
              Page numbering is fixed-width to preserve ordering.
            </div>
          </div>
        </details>

        <details class="keta">
          <summary>
            <span>HARD LIMITS</span>
            <span class="small">performance reality</span>
          </summary>
          <div class="content">
            <div class="small">
              Browser conversion is CPU + RAM bound. If you feed it 8 books at once, it will die.
              Convert per book (per PDF). If a PDF has 200 pages at 3x scale, expect heavy load.
              Reduce scale or split PDFs if needed.
            </div>
          </div>
        </details>
      </aside>
    </main>
  </div>

  <!-- Libraries (CDN). If you want fully offline, download these into your repo and change the script src. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.6.82/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <script>
    // ----------------------------
    // PDF.js setup
    // ----------------------------
    // pdfjsLib is global from CDN
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.6.82/pdf.worker.min.js";
    }

    // ----------------------------
    // State
    // ----------------------------
    const state = {
      files: [],
      docs: [],            // {file, doc, numPages, pages: []}
      totalPages: 0,
      selected: { docIndex: 0, pageIndex: 0 },
      thumbs: [],          // thumbnails canvases (small)
      busy: false,
    };

    // ----------------------------
    // Elements
    // ----------------------------
    const el = {
      pdfInput: document.getElementById("pdfInput"),
      btnConvert: document.getElementById("btnConvert"),
      btnClear: document.getElementById("btnClear"),
      outFormat: document.getElementById("outFormat"),
      nameMode: document.getElementById("nameMode"),
      scale: document.getElementById("scale"),
      scaleVal: document.getElementById("scaleVal"),
      quality: document.getElementById("quality"),
      qualityVal: document.getElementById("qualityVal"),
      qWrap: document.getElementById("qWrap"),
      invert: document.getElementById("invert"),

      sessionInfo: document.getElementById("sessionInfo"),
      countPDF: document.getElementById("countPDF"),
      countPages: document.getElementById("countPages"),
      countReady: document.getElementById("countReady"),

      progBar: document.getElementById("progBar"),
      progLabel: document.getElementById("progLabel"),

      previewCanvas: document.getElementById("previewCanvas"),
      thumbRow: document.getElementById("thumbRow"),

      toggleNotes: document.getElementById("toggleNotes"),
      rail: document.getElementById("rail"),

      noteText: document.getElementById("noteText"),
      noteMeta: document.getElementById("noteMeta"),
      btnNoteExport: document.getElementById("btnNoteExport"),

      manifestFolder: document.getElementById("manifestFolder"),
    };

    // ----------------------------
    // Utilities
    // ----------------------------
    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
    function pad3(n){ return String(n).padStart(3, "0"); }
    function safeName(name){
      return (name || "PDF").replace(/\.pdf$/i,"").replace(/[^\w\-]+/g,"_").replace(/_+/g,"_").slice(0,80);
    }
    function setProgress(p){
      const pct = Math.round(clamp(p, 0, 1) * 100);
      el.progBar.style.width = pct + "%";
      el.progLabel.textContent = pct + "%";
    }
    function setCounts(){
      el.countPDF.textContent = state.docs.length;
      el.countPages.textContent = state.totalPages;
      el.countReady.textContent = state.docs.length ? "YES" : "0";
      if (!state.docs.length){
        el.sessionInfo.textContent = "No files loaded.";
      } else {
        const names = state.docs.map(d => d.file.name).join(" · ");
        el.sessionInfo.textContent = `${state.docs.length} PDF loaded: ${names}`;
      }
    }
    function updateQualityVisibility(){
      if (el.outFormat.value === "jpeg") {
        el.qWrap.style.display = "block";
      } else {
        el.qWrap.style.display = "none";
      }
    }
    function invertCanvas(ctx, w, h){
      const img = ctx.getImageData(0,0,w,h);
      const d = img.data;
      for (let i=0; i<d.length; i+=4){
        d[i]   = 255 - d[i];     // R
        d[i+1] = 255 - d[i+1];   // G
        d[i+2] = 255 - d[i+2];   // B
        // alpha unchanged
      }
      ctx.putImageData(img, 0, 0);
    }

    function selectedDoc(){
      return state.docs[state.selected.docIndex] || null;
    }

    function setManifestFolder(){
      const d = selectedDoc();
      if (!d) { el.manifestFolder.textContent = "PDF_NAME"; return; }
      el.manifestFolder.textContent = safeName(d.file.name);
    }

    // ----------------------------
    // Loading PDFs
    // ----------------------------
    async function loadFiles(fileList){
      clearSession();
      const files = Array.from(fileList || []).filter(f => f.type === "application/pdf" || /\.pdf$/i.test(f.name));
      if (!files.length) return;

      state.busy = true;
      setProgress(0);
      el.btnConvert.textContent = "LOADING…";
      el.btnConvert.disabled = true;

      try{
        state.files = files;
        for (let i=0; i<files.length; i++){
          const file = files[i];
          const data = new Uint8Array(await file.arrayBuffer());
          const doc = await pdfjsLib.getDocument({ data }).promise;
          const numPages = doc.numPages;
          state.docs.push({ file, doc, numPages });
          state.totalPages += numPages;

          setProgress((i+1)/files.length * 0.25); // loading weight
        }

        state.selected = { docIndex: 0, pageIndex: 0 };
        setCounts();
        setManifestFolder();

        await buildThumbsForSelectedDoc();
        await renderPreview();

      } catch(err){
        console.error(err);
        alert("PDF load failed. See console. Try a smaller PDF or refresh.");
      } finally{
        state.busy = false;
        el.btnConvert.textContent = "CONVERT → ZIP";
        el.btnConvert.disabled = !state.docs.length;
        setProgress(0);
      }
    }

    function clearSession(){
      state.files = [];
      state.docs = [];
      state.totalPages = 0;
      state.selected = { docIndex:0, pageIndex:0 };
      state.thumbs = [];
      el.thumbRow.innerHTML = "";
      const ctx = el.previewCanvas.getContext("2d");
      ctx.clearRect(0,0,el.previewCanvas.width, el.previewCanvas.height);
      setCounts();
      setManifestFolder();
      setProgress(0);
    }

    // ----------------------------
    // Thumbnails: finder-ish strip
    // ----------------------------
    async function buildThumbsForSelectedDoc(){
      el.thumbRow.innerHTML = "";
      state.thumbs = [];
      const d = selectedDoc();
      if (!d) return;

      // Limit thumb generation to reasonable bound for UI responsiveness.
      // For very long PDFs, we still show strip but generate around the current window, then expand on demand.
      const maxThumbsHard = 120; // beyond this, generate around selection only
      const num = d.numPages;

      const useWindow = num > maxThumbsHard;
      const windowSize = 60; // pages around selection
      const start = useWindow ? Math.max(1, state.selected.pageIndex + 1 - Math.floor(windowSize/2)) : 1;
      const end   = useWindow ? Math.min(num, start + windowSize - 1) : num;

      const info = useWindow
        ? `Loaded ${d.file.name} (${num} pages). Showing thumbs ${start}-${end}.`
        : `Loaded ${d.file.name} (${num} pages).`;

      el.sessionInfo.textContent = info;

      // Render small thumbs
      for (let p = start; p <= end; p++){
        const thumb = document.createElement("div");
        thumb.className = "thumb";
        thumb.dataset.page = String(p);
        const c = document.createElement("canvas");
        c.width = 56; c.height = 56;
        thumb.appendChild(c);

        thumb.addEventListener("click", async () => {
          state.selected.pageIndex = p - 1;
          await renderPreview();
          highlightThumbs();
        });

        el.thumbRow.appendChild(thumb);
        state.thumbs.push({ pageNumber: p, el: thumb, canvas: c });

        // Lazy render thumbnails (still sequential but lightweight)
        renderThumbPage(d.doc, p, c).catch(console.error);
      }

      highlightThumbs();
    }

    async function renderThumbPage(doc, pageNumber, canvas){
      const page = await doc.getPage(pageNumber);
      const viewport = page.getViewport({ scale: 0.18 }); // small
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      // Fit into 56x56 while preserving aspect
      const target = 56;
      const scale = Math.min(target / viewport.width, target / viewport.height);
      const vp2 = page.getViewport({ scale: 0.18 * scale * 5 }); // nudge up for legibility

      canvas.width = target;
      canvas.height = target;

      // Clear to white
      ctx.fillStyle = "#fff";
      ctx.fillRect(0,0,target,target);

      // Render to offscreen at page size, then draw fit into thumb
      const off = document.createElement("canvas");
      const offCtx = off.getContext("2d", { willReadFrequently: true });
      off.width = Math.ceil(vp2.width);
      off.height = Math.ceil(vp2.height);

      await page.render({ canvasContext: offCtx, viewport: vp2 }).promise;

      if (el.invert.checked){
        invertCanvas(offCtx, off.width, off.height);
      }

      // draw centered contain
      const dw = off.width, dh = off.height;
      const s = Math.min(target/dw, target/dh);
      const rw = dw*s, rh = dh*s;
      const dx = (target - rw)/2;
      const dy = (target - rh)/2;

      ctx.drawImage(off, dx, dy, rw, rh);
    }

    function highlightThumbs(){
      const d = selectedDoc();
      if (!d) return;

      const selectedPage = state.selected.pageIndex + 1;
      for (const t of state.thumbs){
        if (t.pageNumber === selectedPage) t.el.classList.add("selected");
        else t.el.classList.remove("selected");
      }

      // “selected item squared center” behavior in the strip: scroll it into view.
      const match = state.thumbs.find(t => t.pageNumber === selectedPage);
      if (match){
        match.el.scrollIntoView({ behavior:"smooth", inline:"center", block:"nearest" });
      }
    }

    // ----------------------------
    // Main Preview Render
    // ----------------------------
    async function renderPreview(){
      const d = selectedDoc();
      if (!d) return;

      const pageNumber = state.selected.pageIndex + 1;
      const page = await d.doc.getPage(pageNumber);

      const scale = parseFloat(el.scale.value || "2");
      const viewport = page.getViewport({ scale });

      const canvas = el.previewCanvas;
      const ctx = canvas.getContext("2d", { willReadFrequently: true });

      canvas.width = Math.ceil(viewport.width);
      canvas.height = Math.ceil(viewport.height);

      // Render
      await page.render({ canvasContext: ctx, viewport }).promise;

      // Invert if selected
      if (el.invert.checked){
        invertCanvas(ctx, canvas.width, canvas.height);
      }

      // Keep preview visually uniform: stage centers canvas; canvas uses max-width 100% in CSS.
      setManifestFolder();
      highlightThumbs();
      updateNoteMeta();
    }

    // ----------------------------
    // Conversion (PDF(s) -> ZIP of images)
    // ----------------------------
    async function convertAllToZip(){
      if (state.busy) return;
      if (!state.docs.length){
        alert("Load a PDF first.");
        return;
      }

      state.busy = true;
      el.btnConvert.textContent = "CONVERTING…";
      el.btnConvert.disabled = true;
      setProgress(0);

      const zip = new JSZip();
      const format = el.outFormat.value; // "jpeg" or "png"
      const jpegQuality = parseFloat(el.quality.value || "0.92");
      const scale = parseFloat(el.scale.value || "2");
      const invertOn = !!el.invert.checked;

      let donePages = 0;
      const total = state.totalPages;

      try{
        for (let di=0; di<state.docs.length; di++){
          const d = state.docs[di];
          const folderName = (el.nameMode.value === "timestamp")
            ? `${Date.now()}_${safeName(d.file.name)}`
            : safeName(d.file.name);

          const folder = zip.folder(folderName);

          for (let p=1; p<=d.numPages; p++){
            const page = await d.doc.getPage(p);
            const viewport = page.getViewport({ scale });

            const c = document.createElement("canvas");
            const ctx = c.getContext("2d", { willReadFrequently: true });

            c.width = Math.ceil(viewport.width);
            c.height = Math.ceil(viewport.height);

            await page.render({ canvasContext: ctx, viewport }).promise;

            if (invertOn){
              invertCanvas(ctx, c.width, c.height);
            }

            const filename = `page-${pad3(p)}.${format === "jpeg" ? "jpg" : "png"}`;

            const dataUrl = (format === "jpeg")
              ? c.toDataURL("image/jpeg", jpegQuality)
              : c.toDataURL("image/png");

            // DataURL -> binary
            const blob = dataURLToBlob(dataUrl);
            folder.file(filename, blob);

            donePages++;
            setProgress(donePages / total);
          }
        }

        // Add a manifest
        zip.file("KETADATA_MANIFEST.txt", buildManifestText());

        const blob = await zip.generateAsync({ type:"blob" }, (meta) => {
          // meta.percent is zip build progress (separate from render progress)
          // keep render progress; do not fight the user with two systems.
        });

        saveAs(blob, `KETADATA_PDF_TO_JPEG_${Date.now()}.zip`);

      } catch(err){
        console.error(err);
        alert("Conversion failed. See console. Reduce scale, convert one PDF at a time, or split the PDF.");
      } finally{
        state.busy = false;
        el.btnConvert.textContent = "CONVERT → ZIP";
        el.btnConvert.disabled = !state.docs.length;
        setProgress(0);
      }
    }

    function dataURLToBlob(dataURL){
      const parts = dataURL.split(",");
      const mime = parts[0].match(/:(.*?);/)[1];
      const bstr = atob(parts[1]);
      let n = bstr.length;
      const u8arr = new Uint8Array(n);
      while(n--) u8arr[n] = bstr.charCodeAt(n);
      return new Blob([u8arr], { type: mime });
    }

    function buildManifestText(){
      const lines = [];
      lines.push("KETADATA // PDF → JPEG CONVERTER");
      lines.push(`Generated: ${new Date().toISOString()}`);
      lines.push(`Format: ${el.outFormat.value}`);
      lines.push(`Scale: ${parseFloat(el.scale.value).toFixed(2)}x`);
      lines.push(`Invert: ${el.invert.checked ? "ON" : "OFF"}`);
      if (el.outFormat.value === "jpeg"){
        lines.push(`JPEG Quality: ${parseFloat(el.quality.value).toFixed(2)}`);
      }
      lines.push("");
      lines.push("Files:");
      for (const d of state.docs){
        lines.push(`- ${d.file.name} (${d.numPages} pages)`);
      }
      lines.push("");
      lines.push("Naming:");
      lines.push("- Folder per PDF");
      lines.push("- Pages: page-001, page-002, ...");
      return lines.join("\n");
    }

    // ----------------------------
    // Notes (page-level)
    // ----------------------------
    function updateNoteMeta(){
      const d = selectedDoc();
      const pageNumber = d ? (state.selected.pageIndex + 1) : 0;

      const meta = {
        page: "KETADATA_PDF_TO_JPEG_CONVERTER",
        room: "STUDIO/TOOLS",
        clearance: "INTERNAL",
        polarity: "MIND (ANGULAR)",
        timestamp: new Date().toISOString(),
        selection: d ? { pdf: d.file.name, page: pageNumber } : null,
      };

      el.noteMeta.textContent = `META: ${JSON.stringify(meta)}`;
    }

    function exportNoteJSON(){
      const d = selectedDoc();
      const pageNumber = d ? (state.selected.pageIndex + 1) : 0;

      const payload = {
        id: `note_${Date.now()}`,
        room: "STUDIO/TOOLS",
        clearance: "INTERNAL",
        type: "spec/decision",
        polarity: "mind",
        timestamp: new Date().toISOString(),
        source: "KETADATA PDF→JPEG Converter",
        selection: d ? { pdf: d.file.name, page: pageNumber } : null,
        note: el.noteText.value || "",
      };

      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      saveAs(blob, `KETA_NOTE_${Date.now()}.json`);
    }

    // ----------------------------
    // Events
    // ----------------------------
    el.pdfInput.addEventListener("change", (e) => loadFiles(e.target.files));

    el.btnConvert.addEventListener("click", convertAllToZip);
    el.btnClear.addEventListener("click", () => {
      if (state.busy) return;
      clearSession();
      el.pdfInput.value = "";
    });

    el.outFormat.addEventListener("change", () => {
      updateQualityVisibility();
    });

    el.scale.addEventListener("input", async () => {
      el.scaleVal.textContent = parseFloat(el.scale.value).toFixed(2);
      if (state.docs.length && !state.busy) await renderPreview();
    });

    el.quality.addEventListener("input", () => {
      el.qualityVal.textContent = parseFloat(el.quality.value).toFixed(2);
    });

    el.invert.addEventListener("change", async () => {
      if (state.docs.length && !state.busy){
        // Re-render preview and thumbs quickly
        await renderPreview();
        // re-render thumbs (fast but still async)
        await buildThumbsForSelectedDoc();
      }
    });

    el.toggleNotes.addEventListener("click", () => {
      const isHidden = el.rail.style.display === "none";
      el.rail.style.display = isHidden ? "block" : "none";
    });

    el.btnNoteExport.addEventListener("click", exportNoteJSON);

    // Keyboard shortcuts
    document.addEventListener("keydown", async (e) => {
      if (state.busy) return;
      const d = selectedDoc();
      if (!d) return;

      if (e.key === "ArrowRight"){
        e.preventDefault();
        state.selected.pageIndex = Math.min(d.numPages - 1, state.selected.pageIndex + 1);
        await renderPreview();
      }
      if (e.key === "ArrowLeft"){
        e.preventDefault();
        state.selected.pageIndex = Math.max(0, state.selected.pageIndex - 1);
        await renderPreview();
      }
      if (e.key.toLowerCase() === "i"){
        el.invert.checked = !el.invert.checked;
        await renderPreview();
        await buildThumbsForSelectedDoc();
      }
      if (e.key.toLowerCase() === "c"){
        await convertAllToZip();
      }
    });

    // Init
    el.scaleVal.textContent = parseFloat(el.scale.value).toFixed(2);
    el.qualityVal.textContent = parseFloat(el.quality.value).toFixed(2);
    updateQualityVisibility();
    updateNoteMeta();
    setCounts();
    setProgress(0);
  </script>
</body>
</html>
