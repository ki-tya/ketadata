<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KETADATA // MATCHBOOK</title>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --muted:rgba(255,255,255,.58);
      --hair:rgba(255,255,255,.14);
      --panel:rgba(0,0,0,.42);
      --panel2:rgba(0,0,0,.62);
      --motion:1;

      --flame:0.38;   /* flame height/intensity */
      --smoke:0.62;   /* smoke density */
      --char:0.34;    /* burn/char progression */
      --wind:0.18;    /* drift */
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:var(--bg);
      color:var(--fg);
      font:12px/1.25 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      overflow:hidden;
      user-select:none;
    }

    body.invert{ filter: invert(1) hue-rotate(180deg); background:#fff; }
    body.nullmode .chrome{display:none}
    body.nullmode #hud{opacity:0; pointer-events:none}

    #field{
      position:absolute; inset:0;
      background:
        radial-gradient(1400px 1000px at 55% 40%, rgba(255,255,255,.07), rgba(0,0,0,0) 66%),
        radial-gradient(1100px 900px at 22% 78%, rgba(255,255,255,.03), rgba(0,0,0,0) 62%),
        linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,0) 44%),
        linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.46));
    }
    canvas{position:absolute; inset:0; width:100%; height:100%}

    .chrome{position:absolute; inset:0; pointer-events:none}
    #frame{position:absolute; inset:8px; border:1px solid rgba(255,255,255,.08); pointer-events:none}

    #hud{
      position:absolute;
      top:10px; left:10px;
      width:360px;
      border:1px solid var(--hair);
      background:var(--panel);
      backdrop-filter: blur(6px);
      pointer-events:auto;
    }
    #hud .bar{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 8px;
      border-bottom:1px solid var(--hair);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,0));
    }
    #hud .bar .title{opacity:.92}
    #hud .bar .meta{opacity:.58}
    #hud .body{padding:8px; display:grid; gap:8px}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .btn, .pill, input[type="range"]{font:inherit; color:inherit}
    .btn{
      border:1px solid var(--hair);
      background:rgba(255,255,255,.04);
      padding:6px 8px;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{background:rgba(255,255,255,.07)}
    .btn:active{transform: translateY(1px)}
    .pill{
      border:1px solid var(--hair);
      padding:6px 8px;
      background:rgba(0,0,0,.18);
      opacity:.85;
    }
    input[type="range"]{width:140px; accent-color: var(--fg)}
    .label{opacity:.72}
    .mini{opacity:.58}
    .sep{height:1px;background:var(--hair);margin:2px 0}

    #note{
      position:absolute;
      right:10px; top:10px;
      width:360px; height:220px;
      border:1px solid var(--hair);
      background:var(--panel2);
      pointer-events:auto;
      display:none;
    }
    #note.open{display:block}
    #note .bar{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 8px;
      border-bottom:1px solid var(--hair);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,0));
      cursor:move;
      user-select:none;
    }
    #note textarea{
      width:100%; height: calc(100% - 34px);
      border:0; outline:none; resize:none;
      background:transparent;
      color:var(--fg);
      font:inherit;
      padding:8px;
      user-select:text;
    }

    #cornerDots{position:absolute; left:10px; bottom:10px; display:flex; gap:6px; pointer-events:none; opacity:.6}
    .dot{width:10px; height:10px; border-radius:50%; border:1px solid var(--hair); background:rgba(255,255,255,.06)}

    #statusLine{
      position:absolute; right:10px; bottom:10px;
      border:1px solid var(--hair);
      background:rgba(0,0,0,.25);
      padding:6px 8px;
      opacity:.78;
      pointer-events:none;
      max-width:60vw;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
  </style>
</head>
<body>
  <div id="field"><canvas id="c"></canvas></div>

  <div class="chrome">
    <div id="frame"></div>

    <div id="hud">
      <div class="bar">
        <div class="title">KETADATA // MATCHBOOK</div>
        <div class="meta" id="meta">INVERT 0 · NULL 0</div>
      </div>

      <div class="body">
        <div class="row">
          <div class="pill"><span class="label">HOTKEYS</span> <span class="mini">SHIFT+I INVERT · SHIFT+N NULL · SHIFT+F FULLSCREEN · SHIFT+K NOTE · SPACE STRIKE</span></div>
        </div>

        <div class="sep"></div>

        <div class="row">
          <button class="btn" id="btnNote">NOTE</button>
          <button class="btn" id="btnInvert">INVERT</button>
          <button class="btn" id="btnNull">NULL</button>
          <button class="btn" id="btnFull">FULL</button>
          <span class="label">MOTION</span>
          <button class="btn" id="btnMotion">ON</button>
        </div>

        <div class="row">
          <span class="label">FLAME</span>
          <input type="range" id="rngFlame" min="0" max="100" step="1" value="38" />
          <span class="label">SMOKE</span>
          <input type="range" id="rngSmoke" min="0" max="100" step="1" value="62" />
          <span class="label">CHAR</span>
          <input type="range" id="rngChar" min="0" max="100" step="1" value="34" />
        </div>

        <div class="row">
          <span class="label">WIND</span>
          <input type="range" id="rngWind" min="0" max="100" step="1" value="18" />
          <span class="label">RESET</span>
          <button class="btn" id="btnReset">GO</button>
        </div>
      </div>
    </div>

    <div id="note">
      <div class="bar">
        <div>KETA_NOTE</div>
        <div class="mini">SHIFT+K TO TOGGLE</div>
      </div>
      <textarea id="noteText" spellcheck="false" placeholder="KETA_NOTE — optional, movable, non-interfering."></textarea>
    </div>

    <div id="cornerDots" aria-hidden="true">
      <div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div>
    </div>

    <div id="statusLine">READY</div>
  </div>

<script>
/* EE: local-first state */
const FILE_ID = "KETADATA_MATCHBOOK_MONO_V1";
const LS_KEY = "KETADATA::" + FILE_ID + "::STATE";
const $ = (id)=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

const state = {
  invert:false, nullMode:false, fullscreen:false, motion:true,
  flame:0.38, smoke:0.62, char:0.34, wind:0.18,
  noteOpen:false, notePos:{x:null,y:null}, noteText:"",
  lit:false,          // is match burning
  burn:0.0,           // 0..1 progression
  seed:(Math.random()*1e9)>>>0
};

function loadState(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(!s || typeof s!=="object") return;
    Object.assign(state, s);
  }catch(_){}
}
function saveState(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(_){ } }
function status(t){ $("statusLine").textContent = t; }

function applyState(){
  document.body.classList.toggle("invert", !!state.invert);
  document.body.classList.toggle("nullmode", !!state.nullMode);

  $("rngFlame").value = String(Math.round(state.flame*100));
  $("rngSmoke").value = String(Math.round(state.smoke*100));
  $("rngChar").value  = String(Math.round(state.char*100));
  $("rngWind").value  = String(Math.round(state.wind*100));
  $("btnMotion").textContent = state.motion ? "ON" : "OFF";
  $("meta").textContent = `INVERT ${state.invert?1:0} · NULL ${state.nullMode?1:0}`;

  $("noteText").value = state.noteText || "";
  $("note").classList.toggle("open", !!state.noteOpen);
  if(state.notePos && state.notePos.x!=null && state.notePos.y!=null){
    $("note").style.left = state.notePos.x + "px";
    $("note").style.top = state.notePos.y + "px";
    $("note").style.right = "auto";
  }

  status(`${state.lit ? "LIT" : "COLD"} · BURN ${Math.round(state.burn*100)} · FLAME ${Math.round(state.flame*100)} · SMOKE ${Math.round(state.smoke*100)} · CHAR ${Math.round(state.char*100)}`);
}

/* canvas */
const canvas = $("c");
const ctx = canvas.getContext("2d", { alpha:true });
let W=0,H=0,DPR=1;

function resize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  W = Math.floor(window.innerWidth * DPR);
  H = Math.floor(window.innerHeight * DPR);
  canvas.width = W;
  canvas.height = H;
}
addEventListener("resize", resize);

function inv(){ return document.body.classList.contains("invert"); }
function col(a){ return inv() ? `rgba(10,12,15,${a})` : `rgba(255,255,255,${a})`; }

function rand(){
  state.seed = (state.seed * 1664525 + 1013904223) >>> 0;
  return (state.seed >>> 8) / 16777216;
}

/* smoke particles */
const smoke = [];
function spawnSmoke(x,y,n){
  for(let i=0;i<n;i++){
    smoke.push({
      x, y,
      vx: (rand()*2-1) * 0.18*DPR,
      vy: -(0.35 + rand()*0.65) * DPR,
      r: (3 + rand()*12) * DPR,
      a: 0.08 + rand()*0.18,
      w: 0.002 + rand()*0.006,
      ph: rand()*Math.PI*2,
      life: 0,
      max: 140 + rand()*260
    });
  }
}
function drawSmoke(p){
  const fade = 1 - (p.life / p.max);
  const aa = p.a * fade;
  ctx.fillStyle = inv() ? `rgba(10,12,15,${aa})` : `rgba(255,255,255,${aa})`;
  ctx.beginPath();
  ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
  ctx.fill();
}

/* char flecks */
const flecks = [];
function shedFleck(x,y,n){
  for(let i=0;i<n;i++){
    flecks.push({
      x: x + (rand()*2-1)*6*DPR,
      y: y + (rand()*2-1)*4*DPR,
      vx: (rand()*2-1)*0.10*DPR,
      vy: (0.10 + rand()*0.22)*DPR,
      r: (0.6 + rand()*1.6)*DPR,
      a: 0.10 + rand()*0.24,
      life: 0,
      max: 120 + rand()*220
    });
  }
}

/* geometry helpers */
function roundedRect(x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.lineTo(x+w-rr, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
  ctx.lineTo(x+w, y+h-rr);
  ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
  ctx.lineTo(x+rr, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
  ctx.lineTo(x, y+rr);
  ctx.quadraticCurveTo(x, y, x+rr, y);
  ctx.closePath();
}

function draw(t){
  const alpha = state.motion ? 0.22 : 1.0;
  ctx.fillStyle = `rgba(0,0,0,${alpha})`;
  ctx.fillRect(0,0,W,H);

  // faint horizontal paper grain
  ctx.strokeStyle = col(0.012);
  ctx.lineWidth = 1*DPR;
  const g = 88*DPR;
  const oy = ((t*0.004*DPR) % g);
  for(let y=oy; y < H; y += g){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  // stage
  const cx = W*0.52;
  const cy = H*0.62;

  // matchbook body (angular)
  const bw = Math.min(W,H)*0.34;
  const bh = bw*0.22;
  const x0 = cx - bw*0.52;
  const y0 = cy + bh*0.05;

  // shadow
  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.beginPath();
  ctx.ellipse(cx, cy + bh*0.55, bw*0.56, bh*0.42, 0, 0, Math.PI*2);
  ctx.fill();

  // book base
  ctx.fillStyle = "rgba(255,255,255,.02)";
  ctx.strokeStyle = col(0.16);
  ctx.lineWidth = 2*DPR;
  roundedRect(x0, y0, bw, bh, 8*DPR);
  ctx.fill(); ctx.stroke();

  // inner flap line
  ctx.strokeStyle = col(0.10);
  ctx.lineWidth = 1*DPR;
  ctx.beginPath();
  ctx.moveTo(x0 + bw*0.06, y0 + bh*0.58);
  ctx.lineTo(x0 + bw*0.94, y0 + bh*0.58);
  ctx.stroke();

  // striker strip (rough)
  ctx.fillStyle = col(0.03);
  roundedRect(x0 + bw*0.72, y0 + bh*0.10, bw*0.22, bh*0.38, 6*DPR);
  ctx.fill();
  ctx.strokeStyle = col(0.08);
  ctx.lineWidth = 1*DPR;
  for(let i=0;i<20;i++){
    const xx = x0 + bw*0.72 + rand()*bw*0.22;
    const yy = y0 + bh*0.10 + rand()*bh*0.38;
    ctx.beginPath();
    ctx.moveTo(xx, yy);
    ctx.lineTo(xx + (rand()*2-1)*10*DPR, yy + (rand()*2-1)*6*DPR);
    ctx.stroke();
  }

  // matchstick placement (rests diagonally)
  const mLen = bw*0.62;
  const mW = bw*0.022;
  const ang = -0.55; // tilt
  const mx = cx - bw*0.15;
  const my = cy - bh*0.40;

  // burn/char progression
  const burn = clamp(state.burn, 0, 1);
  const headR = mW*2.1;

  // IMPORTANT: head is at local x=0 so it can sit near striker area visually
  // We'll draw stick from head outward.
  const headX = mx;
  const headY = my;

  ctx.save();
  ctx.translate(headX, headY);
  ctx.rotate(ang);

  // wood stick
  const stickLen = mLen*(0.90 - 0.70*burn);
  ctx.fillStyle = col(0.05);
  ctx.strokeStyle = col(0.14);
  ctx.lineWidth = 2*DPR;
  roundedRect(0, -mW/2, stickLen, mW, 6*DPR);
  ctx.fill(); ctx.stroke();

  // char band near head
  ctx.fillStyle = col(0.08 + 0.12*(0.2 + burn));
  ctx.beginPath();
  ctx.rect(-mW*0.10, -mW*0.60, mW*0.38, mW*1.20);
  ctx.fill();

  // match head (monochrome)
  const ch = clamp(state.char, 0, 1);
  ctx.fillStyle = col(0.06 + 0.18*ch);
  ctx.strokeStyle = col(0.18);
  ctx.lineWidth = 2*DPR;
  ctx.beginPath();
  ctx.arc(0, 0, headR, 0, Math.PI*2);
  ctx.fill(); ctx.stroke();

  // micro-texture on head
  ctx.strokeStyle = col(0.08);
  ctx.lineWidth = 1*DPR;
  for(let i=0;i<12;i++){
    const a = (i/12)*Math.PI*2;
    ctx.beginPath();
    ctx.moveTo(Math.cos(a)*headR*0.2, Math.sin(a)*headR*0.2);
    ctx.lineTo(Math.cos(a)*headR*0.95, Math.sin(a)*headR*0.95);
    ctx.stroke();
  }

  // flame (still monochrome): layered soft shapes with jitter, only if lit
  const flame = clamp(state.flame, 0, 1) * (state.lit ? 1 : 0);
  const wind = clamp(state.wind, 0, 1);
  if(flame > 0.001){
    const pulse = 0.55 + 0.45*Math.sin(t*0.006 + burn*4);
    const h = (headR*8.0) * flame * (0.55 + 0.45*pulse);
    const lean = (wind*0.55 + 0.06*Math.sin(t*0.003)) * headR*2.0;

    // outer glow
    ctx.fillStyle = col((0.05 + 0.22*flame)*pulse);
    ctx.beginPath();
    ctx.ellipse(0 + lean*0.55, -h*0.55, headR*2.6, h*0.55, -0.22, 0, Math.PI*2);
    ctx.fill();

    // mid body
    ctx.fillStyle = col((0.08 + 0.26*flame)*pulse);
    ctx.beginPath();
    ctx.ellipse(0 + lean*0.35, -h*0.42, headR*1.9, h*0.42, -0.20, 0, Math.PI*2);
    ctx.fill();

    // core
    ctx.fillStyle = col((0.10 + 0.30*flame)*pulse);
    ctx.beginPath();
    ctx.ellipse(0 + lean*0.18, -h*0.30, headR*1.25, h*0.28, -0.16, 0, Math.PI*2);
    ctx.fill();

    // bright tip
    ctx.fillStyle = col((0.10 + 0.32*flame)*pulse);
    ctx.beginPath();
    ctx.ellipse(0 + lean*0.20, -h*0.72, headR*0.85, h*0.20, -0.25, 0, Math.PI*2);
    ctx.fill();
  }

  ctx.restore();

  // smoke emission from head when lit, plus residual wisp when cooling
  const smokeD = clamp(state.smoke, 0, 1);
  const baseEmit = (state.motion ? 1 : 0) * (0.10 + 1.05*smokeD) * (0.25 + 0.85*(state.lit ? state.flame : 0.10));
  if(Math.random() < baseEmit*0.35){
    spawnSmoke(headX + (rand()*2-1)*6*DPR, headY - headR*2.2, 1 + (Math.random()<0.25?1:0));
  }

  for(let i=smoke.length-1;i>=0;i--){
    const p = smoke[i];
    p.life++;
    p.ph += p.w;
    const w = clamp(state.wind, 0, 1);
    p.x += p.vx + Math.sin(p.ph)*0.18*DPR + (w*0.35)*DPR;
    p.y += p.vy + Math.cos(p.ph*0.7)*0.14*DPR;
    p.r *= 1.0028;
    drawSmoke(p);
    if(p.life > p.max || p.y < -80*DPR) smoke.splice(i,1);
  }

  // flecks fall (char debris)
  for(let i=flecks.length-1;i>=0;i--){
    const f = flecks[i];
    f.life++;
    f.x += f.vx;
    f.y += f.vy;
    f.vy *= 0.997;
    ctx.fillStyle = col(f.a * (1 - f.life/f.max));
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
    ctx.fill();
    if(f.life > f.max || f.y > H + 60*DPR) flecks.splice(i,1);
  }

  // progression: burn only when lit
  if(state.motion && state.lit){
    const flame = clamp(state.flame,0,1);
    const burnRate = (0.00010 + 0.00038*flame) * (0.75 + 0.70*clamp(state.char,0,1));
    state.burn = clamp(state.burn + burnRate, 0, 1);

    // occasional debris shedding
    if(Math.random() < (0.010 + 0.030*state.char) * (0.35 + 0.65*state.burn)){
      shedFleck(headX, headY, 2 + (Math.random()<0.35?2:0));
    }

    // self-extinguish when consumed
    if(state.burn >= 1){
      state.lit = false;
    }
  } else if(state.motion && !state.lit){
    // slow cool-down smoke tail
    if(state.burn > 0 && Math.random() < 0.0035*state.smoke){
      spawnSmoke(headX, headY - headR*2.0, 1);
    }
  }

  // subtle border
  ctx.strokeStyle = col(0.06);
  ctx.lineWidth = 1*DPR;
  ctx.strokeRect(10*DPR, 10*DPR, W-20*DPR, H-20*DPR);
}

let lastSave = 0;
function loop(){
  const t = performance.now();
  draw(t);
  const now = t;
  if(now - lastSave > 900){
    lastSave = now;
    saveState();
    status(`${state.lit ? "LIT" : "COLD"} · BURN ${Math.round(state.burn*100)} · FLAME ${Math.round(state.flame*100)} · SMOKE ${Math.round(state.smoke*100)} · CHAR ${Math.round(state.char*100)}`);
  }
  requestAnimationFrame(loop);
}

/* NOTE drag */
(function noteDrag(){
  const el = $("note");
  const bar = el.querySelector(".bar");
  let dragging=false, ox=0, oy=0;

  bar.addEventListener("mousedown",(e)=>{
    dragging=true;
    const r = el.getBoundingClientRect();
    ox = e.clientX - r.left;
    oy = e.clientY - r.top;
    e.preventDefault();
  });
  window.addEventListener("mousemove",(e)=>{
    if(!dragging) return;
    const x = Math.max(10, Math.min(window.innerWidth - 10 - el.offsetWidth, e.clientX - ox));
    const y = Math.max(10, Math.min(window.innerHeight - 10 - el.offsetHeight, e.clientY - oy));
    el.style.left = x + "px";
    el.style.top = y + "px";
    el.style.right = "auto";
    state.notePos = { x, y };
  });
  window.addEventListener("mouseup",()=>{
    if(!dragging) return;
    dragging=false;
    saveState();
  });
})();

/* controls */
function toggleNote(){ state.noteOpen=!state.noteOpen; saveState(); applyState(); }
function toggleInvert(){ state.invert=!state.invert; saveState(); applyState(); }
function toggleNull(){ state.nullMode=!state.nullMode; saveState(); applyState(); }
async function toggleFullscreen(){
  try{
    if(!document.fullscreenElement){ await document.documentElement.requestFullscreen(); state.fullscreen=true; }
    else { await document.exitFullscreen(); state.fullscreen=false; }
  }catch(_){}
  saveState(); applyState();
}

function strike(){
  // ignite if not lit; if lit, "gust" -> shed flecks + smoke burst
  const wasLit = state.lit;
  state.lit = true;
  if(!wasLit && state.burn <= 0.02){
    state.burn = Math.max(state.burn, 0.03);
  }
  // burst
  for(let i=0;i<6;i++){
    const hx = W*0.52 - Math.min(W,H)*0.34*0.15;
    const hy = H*0.62 - (Math.min(W,H)*0.34*0.22)*0.40;
    spawnSmoke(hx + (Math.random()*2-1)*8*DPR, hy - 18*DPR, 1);
    shedFleck(hx, hy, 1);
  }
  saveState(); applyState();
}

function resetSim(){
  state.lit = false;
  state.burn = 0;
  smoke.length = 0;
  flecks.length = 0;
  state.seed = (Math.random()*1e9)>>>0;
  saveState(); applyState();
}

$("btnNote").addEventListener("click", toggleNote);
$("btnInvert").addEventListener("click", toggleInvert);
$("btnNull").addEventListener("click", toggleNull);
$("btnFull").addEventListener("click", toggleFullscreen);
$("btnMotion").addEventListener("click",()=>{ state.motion=!state.motion; saveState(); applyState(); });
$("btnReset").addEventListener("click", resetSim);

$("rngFlame").addEventListener("input",(e)=>{ state.flame = clamp((parseInt(e.target.value,10)||38)/100, 0, 1); saveState(); applyState(); });
$("rngSmoke").addEventListener("input",(e)=>{ state.smoke = clamp((parseInt(e.target.value,10)||62)/100, 0, 1); saveState(); applyState(); });
$("rngChar").addEventListener("input",(e)=>{ state.char  = clamp((parseInt(e.target.value,10)||34)/100, 0, 1); saveState(); applyState(); });
$("rngWind").addEventListener("input",(e)=>{ state.wind  = clamp((parseInt(e.target.value,10)||18)/100, 0, 1); saveState(); applyState(); });

$("noteText").addEventListener("input",(e)=>{ state.noteText = e.target.value || ""; saveState(); });

function isTypingTarget(t){
  if(!t) return false;
  const tag = (t.tagName||"").toLowerCase();
  return tag==="textarea" || tag==="input" || t.isContentEditable;
}
window.addEventListener("keydown",(e)=>{
  const typing = isTypingTarget(e.target);

  if(e.shiftKey && e.key.toLowerCase()==="i"){ e.preventDefault(); toggleInvert(); return; }
  if(e.shiftKey && e.key.toLowerCase()==="n"){ e.preventDefault(); toggleNull(); return; }
  if(e.shiftKey && e.key.toLowerCase()==="f"){ e.preventDefault(); toggleFullscreen(); return; }
  if(e.shiftKey && e.key.toLowerCase()==="k"){ e.preventDefault(); toggleNote(); return; }

  if(e.code==="Space" && !typing){
    e.preventDefault();
    strike();
    return;
  }
}, { passive:false });

/* boot */
loadState();
resize();
applyState();
requestAnimationFrame(loop);
</script>

<!--
AE: VISUAL (MONOCHROME MATCHBOOK + MATCHSTICK, FLAME SHAPES, SMOKE PARTICLES, CHAR FLECKS, PAPER GRAIN)
EE: ENGINE (LOCAL-FIRST STATE, STRIKE ACTION, BURN PROGRESSION, HOTKEYS, NOTE, FULLSCREEN/INVERT/NULL)
WB: WIRING BRIDGE (APPLY STATE TO DOM, CONTROLS)

FILE_ID: "KETADATA_MATCHBOOK_MONO_V1"
ROOM_ID: "K_MATCHBOOK"
VERSION: "V1"
UPDATED_AT: "2026-01-06T00:00:00.000-05:00"
CHANGELOG:
- V1: Sensitive monochrome still-life: matchbook + match, strike-to-ignite, smoke drift, char debris; local-first persistence.
-->
</body>
</html>
